var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
(function() {
  "use strict";
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t2, _u, _v, _w, _x, _y, _z, _A;
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  var jsxRuntime = { exports: {} };
  var reactJsxRuntime_production = {};
  /**
   * @license React
   * react-jsx-runtime.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReactJsxRuntime_production;
  function requireReactJsxRuntime_production() {
    if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
    hasRequiredReactJsxRuntime_production = 1;
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    function jsxProd(type, config, maybeKey) {
      var key2 = null;
      void 0 !== maybeKey && (key2 = "" + maybeKey);
      void 0 !== config.key && (key2 = "" + config.key);
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config)
          "key" !== propName && (maybeKey[propName] = config[propName]);
      } else maybeKey = config;
      config = maybeKey.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key: key2,
        ref: void 0 !== config ? config : null,
        props: maybeKey
      };
    }
    reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
    reactJsxRuntime_production.jsx = jsxProd;
    reactJsxRuntime_production.jsxs = jsxProd;
    return reactJsxRuntime_production;
  }
  var hasRequiredJsxRuntime;
  function requireJsxRuntime() {
    if (hasRequiredJsxRuntime) return jsxRuntime.exports;
    hasRequiredJsxRuntime = 1;
    {
      jsxRuntime.exports = requireReactJsxRuntime_production();
    }
    return jsxRuntime.exports;
  }
  var jsxRuntimeExports = requireJsxRuntime();
  var react = { exports: {} };
  var react_production = {};
  var hasRequiredReact_production;
  function requireReact_production() {
    if (hasRequiredReact_production) return react_production;
    hasRequiredReact_production = 1;
    var define_process_default2 = { env: {} };
    /**
     * @license React
     * react.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    var ReactNoopUpdateQueue = {
      isMounted: function() {
        return false;
      },
      enqueueForceUpdate: function() {
      },
      enqueueReplaceState: function() {
      },
      enqueueSetState: function() {
      }
    }, assign2 = Object.assign, emptyObject = {};
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function(partialState, callback) {
      if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    function ComponentDummy() {
    }
    ComponentDummy.prototype = Component.prototype;
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent;
    assign2(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true;
    var isArrayImpl = Array.isArray, ReactSharedInternals = { H: null, A: null, T: null, S: null, V: null }, hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function ReactElement(type, key2, self2, source, owner, props) {
      self2 = props.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key: key2,
        ref: void 0 !== self2 ? self2 : null,
        props
      };
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      return ReactElement(
        oldElement.type,
        newKey,
        void 0,
        void 0,
        void 0,
        oldElement.props
      );
    }
    function isValidElement(object) {
      return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function escape2(key2) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return "$" + key2.replace(/[=:]/g, function(match) {
        return escaperLookup[match];
      });
    }
    var userProvidedKeyEscapeRegex = /\/+/g;
    function getElementKey(element, index) {
      return "object" === typeof element && null !== element && null != element.key ? escape2("" + element.key) : index.toString(36);
    }
    function noop$12() {
    }
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch ("string" === typeof thenable.status ? thenable.then(noop$12, noop$12) : (thenable.status = "pending", thenable.then(
            function(fulfilledValue) {
              "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
            },
            function(error) {
              "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
            }
          )), thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if ("undefined" === type || "boolean" === type) children = null;
      var invokeCallback = false;
      if (null === children) invokeCallback = true;
      else
        switch (type) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = true;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
                break;
              case REACT_LAZY_TYPE:
                return invokeCallback = children._init, mapIntoArray(
                  invokeCallback(children._payload),
                  array,
                  escapedPrefix,
                  nameSoFar,
                  callback
                );
            }
        }
      if (invokeCallback)
        return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
          return c;
        })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
          callback,
          escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
            userProvidedKeyEscapeRegex,
            "$&/"
          ) + "/") + invokeCallback
        )), array.push(callback)), 1;
      invokeCallback = 0;
      var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i2 = 0; i2 < children.length; i2++)
          nameSoFar = children[i2], type = nextNamePrefix + getElementKey(nameSoFar, i2), invokeCallback += mapIntoArray(
            nameSoFar,
            array,
            escapedPrefix,
            type,
            callback
          );
      else if (i2 = getIteratorFn(children), "function" === typeof i2)
        for (children = i2.call(children), i2 = 0; !(nameSoFar = children.next()).done; )
          nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i2++), invokeCallback += mapIntoArray(
            nameSoFar,
            array,
            escapedPrefix,
            type,
            callback
          );
      else if ("object" === type) {
        if ("function" === typeof children.then)
          return mapIntoArray(
            resolveThenable(children),
            array,
            escapedPrefix,
            nameSoFar,
            callback
          );
        array = String(children);
        throw Error(
          "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
        );
      }
      return invokeCallback;
    }
    function mapChildren2(children, func, context) {
      if (null == children) return children;
      var result = [], count = 0;
      mapIntoArray(children, result, "", "", function(child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (-1 === payload._status) {
        var ctor = payload._result;
        ctor = ctor();
        ctor.then(
          function(moduleObject) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 1, payload._result = moduleObject;
          },
          function(error) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 2, payload._result = error;
          }
        );
        -1 === payload._status && (payload._status = 0, payload._result = ctor);
      }
      if (1 === payload._status) return payload._result.default;
      throw payload._result;
    }
    var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event)) return;
      } else if ("object" === typeof define_process_default2 && "function" === typeof define_process_default2.emit) {
        define_process_default2.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    };
    function noop2() {
    }
    react_production.Children = {
      map: mapChildren2,
      forEach: function(children, forEachFunc, forEachContext) {
        mapChildren2(
          children,
          function() {
            forEachFunc.apply(this, arguments);
          },
          forEachContext
        );
      },
      count: function(children) {
        var n = 0;
        mapChildren2(children, function() {
          n++;
        });
        return n;
      },
      toArray: function(children) {
        return mapChildren2(children, function(child) {
          return child;
        }) || [];
      },
      only: function(children) {
        if (!isValidElement(children))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return children;
      }
    };
    react_production.Component = Component;
    react_production.Fragment = REACT_FRAGMENT_TYPE;
    react_production.Profiler = REACT_PROFILER_TYPE;
    react_production.PureComponent = PureComponent;
    react_production.StrictMode = REACT_STRICT_MODE_TYPE;
    react_production.Suspense = REACT_SUSPENSE_TYPE;
    react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    react_production.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function(size) {
        return ReactSharedInternals.H.useMemoCache(size);
      }
    };
    react_production.cache = function(fn) {
      return function() {
        return fn.apply(null, arguments);
      };
    };
    react_production.cloneElement = function(element, config, children) {
      if (null === element || void 0 === element)
        throw Error(
          "The argument must be a React element, but you passed " + element + "."
        );
      var props = assign2({}, element.props), key2 = element.key, owner = void 0;
      if (null != config)
        for (propName in void 0 !== config.ref && (owner = void 0), void 0 !== config.key && (key2 = "" + config.key), config)
          !hasOwnProperty2.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
      var propName = arguments.length - 2;
      if (1 === propName) props.children = children;
      else if (1 < propName) {
        for (var childArray = Array(propName), i2 = 0; i2 < propName; i2++)
          childArray[i2] = arguments[i2 + 2];
        props.children = childArray;
      }
      return ReactElement(element.type, key2, void 0, void 0, owner, props);
    };
    react_production.createContext = function(defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      return defaultValue;
    };
    react_production.createElement = function(type, config, children) {
      var propName, props = {}, key2 = null;
      if (null != config)
        for (propName in void 0 !== config.key && (key2 = "" + config.key), config)
          hasOwnProperty2.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
      var childrenLength = arguments.length - 2;
      if (1 === childrenLength) props.children = children;
      else if (1 < childrenLength) {
        for (var childArray = Array(childrenLength), i2 = 0; i2 < childrenLength; i2++)
          childArray[i2] = arguments[i2 + 2];
        props.children = childArray;
      }
      if (type && type.defaultProps)
        for (propName in childrenLength = type.defaultProps, childrenLength)
          void 0 === props[propName] && (props[propName] = childrenLength[propName]);
      return ReactElement(type, key2, void 0, void 0, null, props);
    };
    react_production.createRef = function() {
      return { current: null };
    };
    react_production.forwardRef = function(render) {
      return { $$typeof: REACT_FORWARD_REF_TYPE, render };
    };
    react_production.isValidElement = isValidElement;
    react_production.lazy = function(ctor) {
      return {
        $$typeof: REACT_LAZY_TYPE,
        _payload: { _status: -1, _result: ctor },
        _init: lazyInitializer
      };
    };
    react_production.memo = function(type, compare) {
      return {
        $$typeof: REACT_MEMO_TYPE,
        type,
        compare: void 0 === compare ? null : compare
      };
    };
    react_production.startTransition = function(scope) {
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop2, reportGlobalError);
      } catch (error) {
        reportGlobalError(error);
      } finally {
        ReactSharedInternals.T = prevTransition;
      }
    };
    react_production.unstable_useCacheRefresh = function() {
      return ReactSharedInternals.H.useCacheRefresh();
    };
    react_production.use = function(usable) {
      return ReactSharedInternals.H.use(usable);
    };
    react_production.useActionState = function(action, initialState, permalink) {
      return ReactSharedInternals.H.useActionState(action, initialState, permalink);
    };
    react_production.useCallback = function(callback, deps) {
      return ReactSharedInternals.H.useCallback(callback, deps);
    };
    react_production.useContext = function(Context) {
      return ReactSharedInternals.H.useContext(Context);
    };
    react_production.useDebugValue = function() {
    };
    react_production.useDeferredValue = function(value, initialValue) {
      return ReactSharedInternals.H.useDeferredValue(value, initialValue);
    };
    react_production.useEffect = function(create2, createDeps, update) {
      var dispatcher = ReactSharedInternals.H;
      if ("function" === typeof update)
        throw Error(
          "useEffect CRUD overload is not enabled in this build of React."
        );
      return dispatcher.useEffect(create2, createDeps);
    };
    react_production.useId = function() {
      return ReactSharedInternals.H.useId();
    };
    react_production.useImperativeHandle = function(ref, create2, deps) {
      return ReactSharedInternals.H.useImperativeHandle(ref, create2, deps);
    };
    react_production.useInsertionEffect = function(create2, deps) {
      return ReactSharedInternals.H.useInsertionEffect(create2, deps);
    };
    react_production.useLayoutEffect = function(create2, deps) {
      return ReactSharedInternals.H.useLayoutEffect(create2, deps);
    };
    react_production.useMemo = function(create2, deps) {
      return ReactSharedInternals.H.useMemo(create2, deps);
    };
    react_production.useOptimistic = function(passthrough, reducer) {
      return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
    };
    react_production.useReducer = function(reducer, initialArg, init2) {
      return ReactSharedInternals.H.useReducer(reducer, initialArg, init2);
    };
    react_production.useRef = function(initialValue) {
      return ReactSharedInternals.H.useRef(initialValue);
    };
    react_production.useState = function(initialState) {
      return ReactSharedInternals.H.useState(initialState);
    };
    react_production.useSyncExternalStore = function(subscribe2, getSnapshot, getServerSnapshot) {
      return ReactSharedInternals.H.useSyncExternalStore(
        subscribe2,
        getSnapshot,
        getServerSnapshot
      );
    };
    react_production.useTransition = function() {
      return ReactSharedInternals.H.useTransition();
    };
    react_production.version = "19.1.0";
    return react_production;
  }
  var hasRequiredReact;
  function requireReact() {
    if (hasRequiredReact) return react.exports;
    hasRequiredReact = 1;
    {
      react.exports = requireReact_production();
    }
    return react.exports;
  }
  var reactExports = requireReact();
  const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
  var client = { exports: {} };
  var reactDomClient_production = {};
  var scheduler = { exports: {} };
  var scheduler_production = {};
  /**
   * @license React
   * scheduler.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredScheduler_production;
  function requireScheduler_production() {
    if (hasRequiredScheduler_production) return scheduler_production;
    hasRequiredScheduler_production = 1;
    (function(exports) {
      function push(heap, node) {
        var index = heap.length;
        heap.push(node);
        a: for (; 0 < index; ) {
          var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
          if (0 < compare(parent, node))
            heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
          else break a;
        }
      }
      function peek(heap) {
        return 0 === heap.length ? null : heap[0];
      }
      function pop(heap) {
        if (0 === heap.length) return null;
        var first = heap[0], last2 = heap.pop();
        if (last2 !== first) {
          heap[0] = last2;
          a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
            var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
            if (0 > compare(left, last2))
              rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last2, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last2, index = leftIndex);
            else if (rightIndex < length && 0 > compare(right, last2))
              heap[index] = right, heap[rightIndex] = last2, index = rightIndex;
            else break a;
          }
        }
        return first;
      }
      function compare(a, b2) {
        var diff = a.sortIndex - b2.sortIndex;
        return 0 !== diff ? diff : a.id - b2.id;
      }
      exports.unstable_now = void 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var localPerformance = performance;
        exports.unstable_now = function() {
          return localPerformance.now();
        };
      } else {
        var localDate = Date, initialTime = localDate.now();
        exports.unstable_now = function() {
          return localDate.now() - initialTime;
        };
      }
      var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
      function advanceTimers(currentTime) {
        for (var timer = peek(timerQueue); null !== timer; ) {
          if (null === timer.callback) pop(timerQueue);
          else if (timer.startTime <= currentTime)
            pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
          else break;
          timer = peek(timerQueue);
        }
      }
      function handleTimeout(currentTime) {
        isHostTimeoutScheduled = false;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled)
          if (null !== peek(taskQueue))
            isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
          else {
            var firstTimer = peek(timerQueue);
            null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
          }
      }
      var isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
      function shouldYieldToHost() {
        return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
      }
      function performWorkUntilDeadline() {
        needsPaint = false;
        if (isMessageLoopRunning) {
          var currentTime = exports.unstable_now();
          startTime = currentTime;
          var hasMoreWork = true;
          try {
            a: {
              isHostCallbackScheduled = false;
              isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
              isPerformingWork = true;
              var previousPriorityLevel = currentPriorityLevel;
              try {
                b: {
                  advanceTimers(currentTime);
                  for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                    var callback = currentTask.callback;
                    if ("function" === typeof callback) {
                      currentTask.callback = null;
                      currentPriorityLevel = currentTask.priorityLevel;
                      var continuationCallback = callback(
                        currentTask.expirationTime <= currentTime
                      );
                      currentTime = exports.unstable_now();
                      if ("function" === typeof continuationCallback) {
                        currentTask.callback = continuationCallback;
                        advanceTimers(currentTime);
                        hasMoreWork = true;
                        break b;
                      }
                      currentTask === peek(taskQueue) && pop(taskQueue);
                      advanceTimers(currentTime);
                    } else pop(taskQueue);
                    currentTask = peek(taskQueue);
                  }
                  if (null !== currentTask) hasMoreWork = true;
                  else {
                    var firstTimer = peek(timerQueue);
                    null !== firstTimer && requestHostTimeout(
                      handleTimeout,
                      firstTimer.startTime - currentTime
                    );
                    hasMoreWork = false;
                  }
                }
                break a;
              } finally {
                currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
              }
              hasMoreWork = void 0;
            }
          } finally {
            hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
          }
        }
      }
      var schedulePerformWorkUntilDeadline;
      if ("function" === typeof localSetImmediate)
        schedulePerformWorkUntilDeadline = function() {
          localSetImmediate(performWorkUntilDeadline);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function() {
          port.postMessage(null);
        };
      } else
        schedulePerformWorkUntilDeadline = function() {
          localSetTimeout(performWorkUntilDeadline, 0);
        };
      function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
          callback(exports.unstable_now());
        }, ms);
      }
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(task) {
        task.callback = null;
      };
      exports.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel;
      };
      exports.unstable_next = function(eventHandler) {
        switch (currentPriorityLevel) {
          case 1:
          case 2:
          case 3:
            var priorityLevel = 3;
            break;
          default:
            priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_requestPaint = function() {
        needsPaint = true;
      };
      exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
        var currentTime = exports.unstable_now();
        "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
        switch (priorityLevel) {
          case 1:
            var timeout = -1;
            break;
          case 2:
            timeout = 250;
            break;
          case 5:
            timeout = 1073741823;
            break;
          case 4:
            timeout = 1e4;
            break;
          default:
            timeout = 5e3;
        }
        timeout = options + timeout;
        priorityLevel = {
          id: taskIdCounter++,
          callback,
          priorityLevel,
          startTime: options,
          expirationTime: timeout,
          sortIndex: -1
        };
        options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
        return priorityLevel;
      };
      exports.unstable_shouldYield = shouldYieldToHost;
      exports.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      };
    })(scheduler_production);
    return scheduler_production;
  }
  var hasRequiredScheduler;
  function requireScheduler() {
    if (hasRequiredScheduler) return scheduler.exports;
    hasRequiredScheduler = 1;
    {
      scheduler.exports = requireScheduler_production();
    }
    return scheduler.exports;
  }
  var reactDom$1 = { exports: {} };
  var reactDom_production = {};
  /**
   * @license React
   * react-dom.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReactDom_production;
  function requireReactDom_production() {
    if (hasRequiredReactDom_production) return reactDom_production;
    hasRequiredReactDom_production = 1;
    var React2 = requireReact();
    function formatProdErrorMessage(code2) {
      var url = "https://react.dev/errors/" + code2;
      if (1 < arguments.length) {
        url += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var i2 = 2; i2 < arguments.length; i2++)
          url += "&args[]=" + encodeURIComponent(arguments[i2]);
      }
      return "Minified React error #" + code2 + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function noop2() {
    }
    var Internals = {
      d: {
        f: noop2,
        r: function() {
          throw Error(formatProdErrorMessage(522));
        },
        D: noop2,
        C: noop2,
        L: noop2,
        m: noop2,
        X: noop2,
        S: noop2,
        M: noop2
      },
      p: 0,
      findDOMNode: null
    }, REACT_PORTAL_TYPE = Symbol.for("react.portal");
    function createPortal$1(children, containerInfo, implementation) {
      var key2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: null == key2 ? null : "" + key2,
        children,
        containerInfo,
        implementation
      };
    }
    var ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function getCrossOriginStringAs(as, input) {
      if ("font" === as) return "";
      if ("string" === typeof input)
        return "use-credentials" === input ? input : "";
    }
    reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
    reactDom_production.createPortal = function(children, container) {
      var key2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
        throw Error(formatProdErrorMessage(299));
      return createPortal$1(children, container, null, key2);
    };
    reactDom_production.flushSync = function(fn) {
      var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
      try {
        if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
      } finally {
        ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
      }
    };
    reactDom_production.preconnect = function(href, options) {
      "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
    };
    reactDom_production.prefetchDNS = function(href) {
      "string" === typeof href && Internals.d.D(href);
    };
    reactDom_production.preinit = function(href, options) {
      if ("string" === typeof href && options && "string" === typeof options.as) {
        var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
        "style" === as ? Internals.d.S(
          href,
          "string" === typeof options.precedence ? options.precedence : void 0,
          {
            crossOrigin,
            integrity,
            fetchPriority
          }
        ) : "script" === as && Internals.d.X(href, {
          crossOrigin,
          integrity,
          fetchPriority,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
      }
    };
    reactDom_production.preinitModule = function(href, options) {
      if ("string" === typeof href)
        if ("object" === typeof options && null !== options) {
          if (null == options.as || "script" === options.as) {
            var crossOrigin = getCrossOriginStringAs(
              options.as,
              options.crossOrigin
            );
            Internals.d.M(href, {
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
          }
        } else null == options && Internals.d.M(href);
    };
    reactDom_production.preload = function(href, options) {
      if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
        var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
        Internals.d.L(href, as, {
          crossOrigin,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0,
          type: "string" === typeof options.type ? options.type : void 0,
          fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
          referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
          imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
          imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
          media: "string" === typeof options.media ? options.media : void 0
        });
      }
    };
    reactDom_production.preloadModule = function(href, options) {
      if ("string" === typeof href)
        if (options) {
          var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
          Internals.d.m(href, {
            as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0
          });
        } else Internals.d.m(href);
    };
    reactDom_production.requestFormReset = function(form) {
      Internals.d.r(form);
    };
    reactDom_production.unstable_batchedUpdates = function(fn, a) {
      return fn(a);
    };
    reactDom_production.useFormState = function(action, initialState, permalink) {
      return ReactSharedInternals.H.useFormState(action, initialState, permalink);
    };
    reactDom_production.useFormStatus = function() {
      return ReactSharedInternals.H.useHostTransitionStatus();
    };
    reactDom_production.version = "19.1.0";
    return reactDom_production;
  }
  var hasRequiredReactDom;
  function requireReactDom() {
    if (hasRequiredReactDom) return reactDom$1.exports;
    hasRequiredReactDom = 1;
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err2) {
        console.error(err2);
      }
    }
    {
      checkDCE();
      reactDom$1.exports = requireReactDom_production();
    }
    return reactDom$1.exports;
  }
  var hasRequiredReactDomClient_production;
  function requireReactDomClient_production() {
    if (hasRequiredReactDomClient_production) return reactDomClient_production;
    hasRequiredReactDomClient_production = 1;
    var define_process_default2 = { env: {} };
    /**
     * @license React
     * react-dom-client.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var Scheduler = requireScheduler(), React2 = requireReact(), ReactDOM2 = requireReactDom();
    function formatProdErrorMessage(code2) {
      var url = "https://react.dev/errors/" + code2;
      if (1 < arguments.length) {
        url += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var i2 = 2; i2 < arguments.length; i2++)
          url += "&args[]=" + encodeURIComponent(arguments[i2]);
      }
      return "Minified React error #" + code2 + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function isValidContainer(node) {
      return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
    }
    function getNearestMountedFiber(fiber) {
      var node = fiber, nearestMounted = fiber;
      if (fiber.alternate) for (; node.return; ) node = node.return;
      else {
        fiber = node;
        do
          node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
        while (fiber);
      }
      return 3 === node.tag ? nearestMounted : null;
    }
    function getSuspenseInstanceFromFiber(fiber) {
      if (13 === fiber.tag) {
        var suspenseState = fiber.memoizedState;
        null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
        if (null !== suspenseState) return suspenseState.dehydrated;
      }
      return null;
    }
    function assertIsMounted(fiber) {
      if (getNearestMountedFiber(fiber) !== fiber)
        throw Error(formatProdErrorMessage(188));
    }
    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate;
      if (!alternate) {
        alternate = getNearestMountedFiber(fiber);
        if (null === alternate) throw Error(formatProdErrorMessage(188));
        return alternate !== fiber ? null : fiber;
      }
      for (var a = fiber, b2 = alternate; ; ) {
        var parentA = a.return;
        if (null === parentA) break;
        var parentB = parentA.alternate;
        if (null === parentB) {
          b2 = parentA.return;
          if (null !== b2) {
            a = b2;
            continue;
          }
          break;
        }
        if (parentA.child === parentB.child) {
          for (parentB = parentA.child; parentB; ) {
            if (parentB === a) return assertIsMounted(parentA), fiber;
            if (parentB === b2) return assertIsMounted(parentA), alternate;
            parentB = parentB.sibling;
          }
          throw Error(formatProdErrorMessage(188));
        }
        if (a.return !== b2.return) a = parentA, b2 = parentB;
        else {
          for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
            if (child$0 === a) {
              didFindChild = true;
              a = parentA;
              b2 = parentB;
              break;
            }
            if (child$0 === b2) {
              didFindChild = true;
              b2 = parentA;
              a = parentB;
              break;
            }
            child$0 = child$0.sibling;
          }
          if (!didFindChild) {
            for (child$0 = parentB.child; child$0; ) {
              if (child$0 === a) {
                didFindChild = true;
                a = parentB;
                b2 = parentA;
                break;
              }
              if (child$0 === b2) {
                didFindChild = true;
                b2 = parentB;
                a = parentA;
                break;
              }
              child$0 = child$0.sibling;
            }
            if (!didFindChild) throw Error(formatProdErrorMessage(189));
          }
        }
        if (a.alternate !== b2) throw Error(formatProdErrorMessage(190));
      }
      if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
      return a.stateNode.current === a ? fiber : alternate;
    }
    function findCurrentHostFiberImpl(node) {
      var tag = node.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
      for (node = node.child; null !== node; ) {
        tag = findCurrentHostFiberImpl(node);
        if (null !== tag) return tag;
        node = node.sibling;
      }
      return null;
    }
    var assign2 = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
    var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type)
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type)
        switch (type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return (type.displayName || "Context") + ".Provider";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x2) {
            }
        }
      return null;
    }
    var isArrayImpl = Array.isArray, ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {
      pending: false,
      data: null,
      method: null,
      action: null
    }, valueStack = [], index = -1;
    function createCursor(defaultValue) {
      return { current: defaultValue };
    }
    function pop(cursor) {
      0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
    }
    function push(cursor, value) {
      index++;
      valueStack[index] = cursor.current;
      cursor.current = value;
    }
    var contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null);
    function pushHostContainer(fiber, nextRootInstance) {
      push(rootInstanceStackCursor, nextRootInstance);
      push(contextFiberStackCursor, fiber);
      push(contextStackCursor, null);
      switch (nextRootInstance.nodeType) {
        case 9:
        case 11:
          fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
          break;
        default:
          if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
            nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
          else
            switch (fiber) {
              case "svg":
                fiber = 1;
                break;
              case "math":
                fiber = 2;
                break;
              default:
                fiber = 0;
            }
      }
      pop(contextStackCursor);
      push(contextStackCursor, fiber);
    }
    function popHostContainer() {
      pop(contextStackCursor);
      pop(contextFiberStackCursor);
      pop(rootInstanceStackCursor);
    }
    function pushHostContext(fiber) {
      null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
      var context = contextStackCursor.current;
      var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
      context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
    }
    function popHostContext(fiber) {
      contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
      hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
    }
    var hasOwnProperty2 = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null;
    function setIsStrictModeForDevtools(newIsStrictMode) {
      "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
      if (injectedHook && "function" === typeof injectedHook.setStrictMode)
        try {
          injectedHook.setStrictMode(rendererID, newIsStrictMode);
        } catch (err2) {
        }
    }
    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2;
    function clz32Fallback(x2) {
      x2 >>>= 0;
      return 0 === x2 ? 32 : 31 - (log(x2) / LN2 | 0) | 0;
    }
    var nextTransitionLane = 256, nextRetryLane = 4194304;
    function getHighestPriorityLanes(lanes) {
      var pendingSyncLanes = lanes & 42;
      if (0 !== pendingSyncLanes) return pendingSyncLanes;
      switch (lanes & -lanes) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return lanes & 4194048;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return lanes & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return lanes;
      }
    }
    function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
      var pendingLanes = root2.pendingLanes;
      if (0 === pendingLanes) return 0;
      var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
      root2 = root2.warmLanes;
      var nonIdlePendingLanes = pendingLanes & 134217727;
      0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
      return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
    }
    function checkIfRootIsPrerendering(root2, renderLanes2) {
      return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
    }
    function computeExpirationTime(lane, currentTime) {
      switch (lane) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return currentTime + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return currentTime + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function claimNextTransitionLane() {
      var lane = nextTransitionLane;
      nextTransitionLane <<= 1;
      0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
      return lane;
    }
    function claimNextRetryLane() {
      var lane = nextRetryLane;
      nextRetryLane <<= 1;
      0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
      return lane;
    }
    function createLaneMap(initial) {
      for (var laneMap = [], i2 = 0; 31 > i2; i2++) laneMap.push(initial);
      return laneMap;
    }
    function markRootUpdated$1(root2, updateLane) {
      root2.pendingLanes |= updateLane;
      268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
    }
    function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
      var previouslyPendingLanes = root2.pendingLanes;
      root2.pendingLanes = remainingLanes;
      root2.suspendedLanes = 0;
      root2.pingedLanes = 0;
      root2.warmLanes = 0;
      root2.expiredLanes &= remainingLanes;
      root2.entangledLanes &= remainingLanes;
      root2.errorRecoveryDisabledLanes &= remainingLanes;
      root2.shellSuspendCounter = 0;
      var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
      for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
        var index$5 = 31 - clz32(remainingLanes), lane = 1 << index$5;
        entanglements[index$5] = 0;
        expirationTimes[index$5] = -1;
        var hiddenUpdatesForLane = hiddenUpdates[index$5];
        if (null !== hiddenUpdatesForLane)
          for (hiddenUpdates[index$5] = null, index$5 = 0; index$5 < hiddenUpdatesForLane.length; index$5++) {
            var update = hiddenUpdatesForLane[index$5];
            null !== update && (update.lane &= -536870913);
          }
        remainingLanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
      0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
    }
    function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
      root2.pendingLanes |= spawnedLane;
      root2.suspendedLanes &= ~spawnedLane;
      var spawnedLaneIndex = 31 - clz32(spawnedLane);
      root2.entangledLanes |= spawnedLane;
      root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194090;
    }
    function markRootEntangled(root2, entangledLanes) {
      var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
      for (root2 = root2.entanglements; rootEntangledLanes; ) {
        var index$6 = 31 - clz32(rootEntangledLanes), lane = 1 << index$6;
        lane & entangledLanes | root2[index$6] & entangledLanes && (root2[index$6] |= entangledLanes);
        rootEntangledLanes &= ~lane;
      }
    }
    function getBumpedLaneForHydrationByLane(lane) {
      switch (lane) {
        case 2:
          lane = 1;
          break;
        case 8:
          lane = 4;
          break;
        case 32:
          lane = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          lane = 128;
          break;
        case 268435456:
          lane = 134217728;
          break;
        default:
          lane = 0;
      }
      return lane;
    }
    function lanesToEventPriority(lanes) {
      lanes &= -lanes;
      return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
    }
    function resolveUpdatePriority() {
      var updatePriority = ReactDOMSharedInternals.p;
      if (0 !== updatePriority) return updatePriority;
      updatePriority = window.event;
      return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
    }
    function runWithPriority(priority, fn) {
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        return ReactDOMSharedInternals.p = priority, fn();
      } finally {
        ReactDOMSharedInternals.p = previousPriority;
      }
    }
    var randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey;
    function detachDeletedInstance(node) {
      delete node[internalInstanceKey];
      delete node[internalPropsKey];
      delete node[internalEventHandlersKey];
      delete node[internalEventHandlerListenersKey];
      delete node[internalEventHandlesSetKey];
    }
    function getClosestInstanceFromNode(targetNode) {
      var targetInst = targetNode[internalInstanceKey];
      if (targetInst) return targetInst;
      for (var parentNode2 = targetNode.parentNode; parentNode2; ) {
        if (targetInst = parentNode2[internalContainerInstanceKey] || parentNode2[internalInstanceKey]) {
          parentNode2 = targetInst.alternate;
          if (null !== targetInst.child || null !== parentNode2 && null !== parentNode2.child)
            for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode; ) {
              if (parentNode2 = targetNode[internalInstanceKey]) return parentNode2;
              targetNode = getParentSuspenseInstance(targetNode);
            }
          return targetInst;
        }
        targetNode = parentNode2;
        parentNode2 = targetNode.parentNode;
      }
      return null;
    }
    function getInstanceFromNode(node) {
      if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
        var tag = node.tag;
        if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag)
          return node;
      }
      return null;
    }
    function getNodeFromInstance(inst) {
      var tag = inst.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
      throw Error(formatProdErrorMessage(33));
    }
    function getResourcesFromRoot(root2) {
      var resources = root2[internalRootNodeResourcesKey];
      resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
      return resources;
    }
    function markNodeAsHoistable(node) {
      node[internalHoistableMarker] = true;
    }
    var allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {};
    function registerTwoPhaseEvent(registrationName, dependencies) {
      registerDirectEvent(registrationName, dependencies);
      registerDirectEvent(registrationName + "Capture", dependencies);
    }
    function registerDirectEvent(registrationName, dependencies) {
      registrationNameDependencies[registrationName] = dependencies;
      for (registrationName = 0; registrationName < dependencies.length; registrationName++)
        allNativeEvents.add(dependencies[registrationName]);
    }
    var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
    function isAttributeNameSafe(attributeName) {
      if (hasOwnProperty2.call(validatedAttributeNameCache, attributeName))
        return true;
      if (hasOwnProperty2.call(illegalAttributeNameCache, attributeName)) return false;
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
        return validatedAttributeNameCache[attributeName] = true;
      illegalAttributeNameCache[attributeName] = true;
      return false;
    }
    function setValueForAttribute(node, name, value) {
      if (isAttributeNameSafe(name))
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
              node.removeAttribute(name);
              return;
            case "boolean":
              var prefix$8 = name.toLowerCase().slice(0, 5);
              if ("data-" !== prefix$8 && "aria-" !== prefix$8) {
                node.removeAttribute(name);
                return;
              }
          }
          node.setAttribute(name, "" + value);
        }
    }
    function setValueForKnownAttribute(node, name, value) {
      if (null === value) node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        node.setAttribute(name, "" + value);
      }
    }
    function setValueForNamespacedAttribute(node, namespace, name, value) {
      if (null === value) node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        node.setAttributeNS(namespace, name, "" + value);
      }
    }
    var prefix2, suffix;
    function describeBuiltInComponentFrame(name) {
      if (void 0 === prefix2)
        try {
          throw Error();
        } catch (x2) {
          var match = x2.stack.trim().match(/\n( *(at )?)/);
          prefix2 = match && match[1] || "";
          suffix = -1 < x2.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x2.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return "\n" + prefix2 + name + suffix;
    }
    var reentry = false;
    function describeNativeComponentFrame(fn, construct2) {
      if (!fn || reentry) return "";
      reentry = true;
      var previousPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function() {
            try {
              if (construct2) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if ("object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x2) {
                    var control = x2;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$9) {
                    control = x$9;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$10) {
                  control = x$10;
                }
                (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                });
              }
            } catch (sample) {
              if (sample && control && "string" === typeof sample.stack)
                return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name"
        );
        namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
          for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
            RunInRootFrame++;
          for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
            "DetermineComponentFrameRoot"
          ); )
            namePropDescriptor++;
          if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
            for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
              namePropDescriptor--;
          for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
            if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
              if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                do
                  if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                    var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                    fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
                    return frame;
                  }
                while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
              }
              break;
            }
        }
      } finally {
        reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
      }
      return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
    }
    function describeFiber(fiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return describeBuiltInComponentFrame(fiber.type);
        case 16:
          return describeBuiltInComponentFrame("Lazy");
        case 13:
          return describeBuiltInComponentFrame("Suspense");
        case 19:
          return describeBuiltInComponentFrame("SuspenseList");
        case 0:
        case 15:
          return describeNativeComponentFrame(fiber.type, false);
        case 11:
          return describeNativeComponentFrame(fiber.type.render, false);
        case 1:
          return describeNativeComponentFrame(fiber.type, true);
        case 31:
          return describeBuiltInComponentFrame("Activity");
        default:
          return "";
      }
    }
    function getStackByFiberInDevAndProd(workInProgress2) {
      try {
        var info = "";
        do
          info += describeFiber(workInProgress2), workInProgress2 = workInProgress2.return;
        while (workInProgress2);
        return info;
      } catch (x2) {
        return "\nError generating stack: " + x2.message + "\n" + x2.stack;
      }
    }
    function getToStringValue(value) {
      switch (typeof value) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return value;
        case "object":
          return value;
        default:
          return "";
      }
    }
    function isCheckable(elem) {
      var type = elem.type;
      return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
    }
    function trackValueOnNode(node) {
      var valueField = isCheckable(node) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(
        node.constructor.prototype,
        valueField
      ), currentValue = "" + node[valueField];
      if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
        var get2 = descriptor.get, set2 = descriptor.set;
        Object.defineProperty(node, valueField, {
          configurable: true,
          get: function() {
            return get2.call(this);
          },
          set: function(value) {
            currentValue = "" + value;
            set2.call(this, value);
          }
        });
        Object.defineProperty(node, valueField, {
          enumerable: descriptor.enumerable
        });
        return {
          getValue: function() {
            return currentValue;
          },
          setValue: function(value) {
            currentValue = "" + value;
          },
          stopTracking: function() {
            node._valueTracker = null;
            delete node[valueField];
          }
        };
      }
    }
    function track(node) {
      node._valueTracker || (node._valueTracker = trackValueOnNode(node));
    }
    function updateValueIfChanged(node) {
      if (!node) return false;
      var tracker = node._valueTracker;
      if (!tracker) return true;
      var lastValue = tracker.getValue();
      var value = "";
      node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
      node = value;
      return node !== lastValue ? (tracker.setValue(node), true) : false;
    }
    function getActiveElement(doc2) {
      doc2 = doc2 || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof doc2) return null;
      try {
        return doc2.activeElement || doc2.body;
      } catch (e) {
        return doc2.body;
      }
    }
    var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
    function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
      return value.replace(
        escapeSelectorAttributeValueInsideDoubleQuotesRegex,
        function(ch) {
          return "\\" + ch.charCodeAt(0).toString(16) + " ";
        }
      );
    }
    function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
      element.name = "";
      null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
      if (null != value)
        if ("number" === type) {
          if (0 === value && "" === element.value || element.value != value)
            element.value = "" + getToStringValue(value);
        } else
          element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
      else
        "submit" !== type && "reset" !== type || element.removeAttribute("value");
      null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
      null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
      null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
      null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
    }
    function initInput2(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
      null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
      if (null != value || null != defaultValue) {
        if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value))
          return;
        defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        value = null != value ? "" + getToStringValue(value) : defaultValue;
        isHydrating2 || value === element.value || (element.value = value);
        element.defaultValue = value;
      }
      checked = null != checked ? checked : defaultChecked;
      checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
      element.checked = isHydrating2 ? element.checked : !!checked;
      element.defaultChecked = !!checked;
      null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
    }
    function setDefaultValue(node, type, value) {
      "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
    }
    function updateOptions(node, multiple, propValue, setDefaultSelected) {
      node = node.options;
      if (multiple) {
        multiple = {};
        for (var i2 = 0; i2 < propValue.length; i2++)
          multiple["$" + propValue[i2]] = true;
        for (propValue = 0; propValue < node.length; propValue++)
          i2 = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i2 && (node[propValue].selected = i2), i2 && setDefaultSelected && (node[propValue].defaultSelected = true);
      } else {
        propValue = "" + getToStringValue(propValue);
        multiple = null;
        for (i2 = 0; i2 < node.length; i2++) {
          if (node[i2].value === propValue) {
            node[i2].selected = true;
            setDefaultSelected && (node[i2].defaultSelected = true);
            return;
          }
          null !== multiple || node[i2].disabled || (multiple = node[i2]);
        }
        null !== multiple && (multiple.selected = true);
      }
    }
    function updateTextarea(element, value, defaultValue) {
      if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
        element.defaultValue !== value && (element.defaultValue = value);
        return;
      }
      element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
    }
    function initTextarea(element, value, defaultValue, children) {
      if (null == value) {
        if (null != children) {
          if (null != defaultValue) throw Error(formatProdErrorMessage(92));
          if (isArrayImpl(children)) {
            if (1 < children.length) throw Error(formatProdErrorMessage(93));
            children = children[0];
          }
          defaultValue = children;
        }
        null == defaultValue && (defaultValue = "");
        value = defaultValue;
      }
      defaultValue = getToStringValue(value);
      element.defaultValue = defaultValue;
      children = element.textContent;
      children === defaultValue && "" !== children && null !== children && (element.value = children);
    }
    function setTextContent(node, text2) {
      if (text2) {
        var firstChild = node.firstChild;
        if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
          firstChild.nodeValue = text2;
          return;
        }
      }
      node.textContent = text2;
    }
    var unitlessNumbers = new Set(
      "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
        " "
      )
    );
    function setValueForStyle(style2, styleName, value) {
      var isCustomProperty = 0 === styleName.indexOf("--");
      null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : style2[styleName] = ("" + value).trim() : style2[styleName] = value + "px";
    }
    function setValueForStyles(node, styles2, prevStyles) {
      if (null != styles2 && "object" !== typeof styles2)
        throw Error(formatProdErrorMessage(62));
      node = node.style;
      if (null != prevStyles) {
        for (var styleName in prevStyles)
          !prevStyles.hasOwnProperty(styleName) || null != styles2 && styles2.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
        for (var styleName$16 in styles2)
          styleName = styles2[styleName$16], styles2.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
      } else
        for (var styleName$17 in styles2)
          styles2.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles2[styleName$17]);
    }
    function isCustomElement(tagName) {
      if (-1 === tagName.indexOf("-")) return false;
      switch (tagName) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var aliases = /* @__PURE__ */ new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function sanitizeURL(url) {
      return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
    }
    var currentReplayingEvent = null;
    function getEventTarget(nativeEvent) {
      nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
      nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
      return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
    }
    var restoreTarget = null, restoreQueue = null;
    function restoreStateOfTarget(target) {
      var internalInstance = getInstanceFromNode(target);
      if (internalInstance && (target = internalInstance.stateNode)) {
        var props = target[internalPropsKey] || null;
        a: switch (target = internalInstance.stateNode, internalInstance.type) {
          case "input":
            updateInput(
              target,
              props.value,
              props.defaultValue,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name
            );
            internalInstance = props.name;
            if ("radio" === props.type && null != internalInstance) {
              for (props = target; props.parentNode; ) props = props.parentNode;
              props = props.querySelectorAll(
                'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                  "" + internalInstance
                ) + '"][type="radio"]'
              );
              for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                var otherNode = props[internalInstance];
                if (otherNode !== target && otherNode.form === target.form) {
                  var otherProps = otherNode[internalPropsKey] || null;
                  if (!otherProps) throw Error(formatProdErrorMessage(90));
                  updateInput(
                    otherNode,
                    otherProps.value,
                    otherProps.defaultValue,
                    otherProps.defaultValue,
                    otherProps.checked,
                    otherProps.defaultChecked,
                    otherProps.type,
                    otherProps.name
                  );
                }
              }
              for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
            }
            break a;
          case "textarea":
            updateTextarea(target, props.value, props.defaultValue);
            break a;
          case "select":
            internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
        }
      }
    }
    var isInsideEventHandler = false;
    function batchedUpdates$1(fn, a, b2) {
      if (isInsideEventHandler) return fn(a, b2);
      isInsideEventHandler = true;
      try {
        var JSCompiler_inline_result = fn(a);
        return JSCompiler_inline_result;
      } finally {
        if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
          if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
            for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
        }
      }
    }
    function getListener(inst, registrationName) {
      var stateNode = inst.stateNode;
      if (null === stateNode) return null;
      var props = stateNode[internalPropsKey] || null;
      if (null === props) return null;
      stateNode = props[registrationName];
      a: switch (registrationName) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
          inst = !props;
          break a;
        default:
          inst = false;
      }
      if (inst) return null;
      if (stateNode && "function" !== typeof stateNode)
        throw Error(
          formatProdErrorMessage(231, registrationName, typeof stateNode)
        );
      return stateNode;
    }
    var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
    if (canUseDOM)
      try {
        var options = {};
        Object.defineProperty(options, "passive", {
          get: function() {
            passiveBrowserEventsSupported = true;
          }
        });
        window.addEventListener("test", options, options);
        window.removeEventListener("test", options, options);
      } catch (e) {
        passiveBrowserEventsSupported = false;
      }
    var root = null, startText = null, fallbackText = null;
    function getData() {
      if (fallbackText) return fallbackText;
      var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
      for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
      var minEnd = startLength - start;
      for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
      return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
    }
    function getEventCharCode(nativeEvent) {
      var keyCode = nativeEvent.keyCode;
      "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
      10 === nativeEvent && (nativeEvent = 13);
      return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
    }
    function functionThatReturnsTrue() {
      return true;
    }
    function functionThatReturnsFalse() {
      return false;
    }
    function createSyntheticEvent(Interface) {
      function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
        this._reactName = reactName;
        this._targetInst = targetInst;
        this.type = reactEventType;
        this.nativeEvent = nativeEvent;
        this.target = nativeEventTarget;
        this.currentTarget = null;
        for (var propName in Interface)
          Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
        this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
        this.isPropagationStopped = functionThatReturnsFalse;
        return this;
      }
      assign2(SyntheticBaseEvent.prototype, {
        preventDefault: function() {
          this.defaultPrevented = true;
          var event = this.nativeEvent;
          event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
        },
        stopPropagation: function() {
          var event = this.nativeEvent;
          event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
        },
        persist: function() {
        },
        isPersistent: functionThatReturnsTrue
      });
      return SyntheticBaseEvent;
    }
    var EventInterface = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(event) {
        return event.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign2({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign2({}, UIEventInterface, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: getEventModifierState,
      button: 0,
      buttons: 0,
      relatedTarget: function(event) {
        return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
      },
      movementX: function(event) {
        if ("movementX" in event) return event.movementX;
        event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
        return lastMovementX;
      },
      movementY: function(event) {
        return "movementY" in event ? event.movementY : lastMovementY;
      }
    }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign2({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign2({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign2({}, EventInterface, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign2({}, EventInterface, {
      clipboardData: function(event) {
        return "clipboardData" in event ? event.clipboardData : window.clipboardData;
      }
    }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign2({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), normalizeKey = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, translateToKey = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, modifierKeyToProp = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function modifierStateGetter(keyArg) {
      var nativeEvent = this.nativeEvent;
      return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
    }
    function getEventModifierState() {
      return modifierStateGetter;
    }
    var KeyboardEventInterface = assign2({}, UIEventInterface, {
      key: function(nativeEvent) {
        if (nativeEvent.key) {
          var key2 = normalizeKey[nativeEvent.key] || nativeEvent.key;
          if ("Unidentified" !== key2) return key2;
        }
        return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: getEventModifierState,
      charCode: function(event) {
        return "keypress" === event.type ? getEventCharCode(event) : 0;
      },
      keyCode: function(event) {
        return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
      },
      which: function(event) {
        return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
      }
    }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign2({}, MouseEventInterface, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign2({}, UIEventInterface, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: getEventModifierState
    }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign2({}, EventInterface, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign2({}, MouseEventInterface, {
      deltaX: function(event) {
        return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
      },
      deltaY: function(event) {
        return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign2({}, EventInterface, {
      newState: 0,
      oldState: 0
    }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
    canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
    var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CHAR = String.fromCharCode(32), hasSpaceKeypress = false;
    function isFallbackCompositionEnd(domEventName, nativeEvent) {
      switch (domEventName) {
        case "keyup":
          return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
        case "keydown":
          return 229 !== nativeEvent.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function getDataFromCustomEvent(nativeEvent) {
      nativeEvent = nativeEvent.detail;
      return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
    }
    var isComposing = false;
    function getNativeBeforeInputChars(domEventName, nativeEvent) {
      switch (domEventName) {
        case "compositionend":
          return getDataFromCustomEvent(nativeEvent);
        case "keypress":
          if (32 !== nativeEvent.which) return null;
          hasSpaceKeypress = true;
          return SPACEBAR_CHAR;
        case "textInput":
          return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
        default:
          return null;
      }
    }
    function getFallbackBeforeInputChars(domEventName, nativeEvent) {
      if (isComposing)
        return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
      switch (domEventName) {
        case "paste":
          return null;
        case "keypress":
          if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
            if (nativeEvent.char && 1 < nativeEvent.char.length)
              return nativeEvent.char;
            if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
          }
          return null;
        case "compositionend":
          return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
        default:
          return null;
      }
    }
    var supportedInputTypes = {
      color: true,
      date: true,
      datetime: true,
      "datetime-local": true,
      email: true,
      month: true,
      number: true,
      password: true,
      range: true,
      search: true,
      tel: true,
      text: true,
      time: true,
      url: true,
      week: true
    };
    function isTextInputElement(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
    }
    function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
      restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
      inst = accumulateTwoPhaseListeners(inst, "onChange");
      0 < inst.length && (nativeEvent = new SyntheticEvent(
        "onChange",
        "change",
        null,
        nativeEvent,
        target
      ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
    }
    var activeElement$1 = null, activeElementInst$1 = null;
    function runEventInBatch(dispatchQueue) {
      processDispatchQueue(dispatchQueue, 0);
    }
    function getInstIfValueChanged(targetInst) {
      var targetNode = getNodeFromInstance(targetInst);
      if (updateValueIfChanged(targetNode)) return targetInst;
    }
    function getTargetInstForChangeEvent(domEventName, targetInst) {
      if ("change" === domEventName) return targetInst;
    }
    var isInputEventSupported = false;
    if (canUseDOM) {
      var JSCompiler_inline_result$jscomp$282;
      if (canUseDOM) {
        var isSupported$jscomp$inline_417 = "oninput" in document;
        if (!isSupported$jscomp$inline_417) {
          var element$jscomp$inline_418 = document.createElement("div");
          element$jscomp$inline_418.setAttribute("oninput", "return;");
          isSupported$jscomp$inline_417 = "function" === typeof element$jscomp$inline_418.oninput;
        }
        JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417;
      } else JSCompiler_inline_result$jscomp$282 = false;
      isInputEventSupported = JSCompiler_inline_result$jscomp$282 && (!document.documentMode || 9 < document.documentMode);
    }
    function stopWatchingForValueChange() {
      activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
    }
    function handlePropertyChange(nativeEvent) {
      if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
        var dispatchQueue = [];
        createAndAccumulateChangeEvent(
          dispatchQueue,
          activeElementInst$1,
          nativeEvent,
          getEventTarget(nativeEvent)
        );
        batchedUpdates$1(runEventInBatch, dispatchQueue);
      }
    }
    function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
      "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
    }
    function getTargetInstForInputEventPolyfill(domEventName) {
      if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
        return getInstIfValueChanged(activeElementInst$1);
    }
    function getTargetInstForClickEvent(domEventName, targetInst) {
      if ("click" === domEventName) return getInstIfValueChanged(targetInst);
    }
    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
      if ("input" === domEventName || "change" === domEventName)
        return getInstIfValueChanged(targetInst);
    }
    function is(x2, y) {
      return x2 === y && (0 !== x2 || 1 / x2 === 1 / y) || x2 !== x2 && y !== y;
    }
    var objectIs = "function" === typeof Object.is ? Object.is : is;
    function shallowEqual(objA, objB) {
      if (objectIs(objA, objB)) return true;
      if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
        return false;
      var keysA = Object.keys(objA), keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) return false;
      for (keysB = 0; keysB < keysA.length; keysB++) {
        var currentKey = keysA[keysB];
        if (!hasOwnProperty2.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
          return false;
      }
      return true;
    }
    function getLeafNode(node) {
      for (; node && node.firstChild; ) node = node.firstChild;
      return node;
    }
    function getNodeForCharacterOffset(root2, offset2) {
      var node = getLeafNode(root2);
      root2 = 0;
      for (var nodeEnd; node; ) {
        if (3 === node.nodeType) {
          nodeEnd = root2 + node.textContent.length;
          if (root2 <= offset2 && nodeEnd >= offset2)
            return { node, offset: offset2 - root2 };
          root2 = nodeEnd;
        }
        a: {
          for (; node; ) {
            if (node.nextSibling) {
              node = node.nextSibling;
              break a;
            }
            node = node.parentNode;
          }
          node = void 0;
        }
        node = getLeafNode(node);
      }
    }
    function containsNode(outerNode, innerNode) {
      return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
    }
    function getActiveElementDeep(containerInfo) {
      containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
      for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
        try {
          var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
        } catch (err2) {
          JSCompiler_inline_result = false;
        }
        if (JSCompiler_inline_result) containerInfo = element.contentWindow;
        else break;
        element = getActiveElement(containerInfo.document);
      }
      return element;
    }
    function hasSelectionCapabilities(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
    }
    var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false;
    function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
      var doc2 = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
      mouseDown || null == activeElement || activeElement !== getActiveElement(doc2) || (doc2 = activeElement, "selectionStart" in doc2 && hasSelectionCapabilities(doc2) ? doc2 = { start: doc2.selectionStart, end: doc2.selectionEnd } : (doc2 = (doc2.ownerDocument && doc2.ownerDocument.defaultView || window).getSelection(), doc2 = {
        anchorNode: doc2.anchorNode,
        anchorOffset: doc2.anchorOffset,
        focusNode: doc2.focusNode,
        focusOffset: doc2.focusOffset
      }), lastSelection && shallowEqual(lastSelection, doc2) || (lastSelection = doc2, doc2 = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc2.length && (nativeEvent = new SyntheticEvent(
        "onSelect",
        "select",
        null,
        nativeEvent,
        nativeEventTarget
      ), dispatchQueue.push({ event: nativeEvent, listeners: doc2 }), nativeEvent.target = activeElement)));
    }
    function makePrefixMap(styleProp, eventName) {
      var prefixes = {};
      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
      prefixes["Webkit" + styleProp] = "webkit" + eventName;
      prefixes["Moz" + styleProp] = "moz" + eventName;
      return prefixes;
    }
    var vendorPrefixes = {
      animationend: makePrefixMap("Animation", "AnimationEnd"),
      animationiteration: makePrefixMap("Animation", "AnimationIteration"),
      animationstart: makePrefixMap("Animation", "AnimationStart"),
      transitionrun: makePrefixMap("Transition", "TransitionRun"),
      transitionstart: makePrefixMap("Transition", "TransitionStart"),
      transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
      transitionend: makePrefixMap("Transition", "TransitionEnd")
    }, prefixedEventNames = {}, style = {};
    canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
    function getVendorPrefixedEventName(eventName) {
      if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
      if (!vendorPrefixes[eventName]) return eventName;
      var prefixMap = vendorPrefixes[eventName], styleProp;
      for (styleProp in prefixMap)
        if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
          return prefixedEventNames[eventName] = prefixMap[styleProp];
      return eventName;
    }
    var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
    simpleEventPluginEvents.push("scrollEnd");
    function registerSimpleEvent(domEventName, reactName) {
      topLevelEventsToReactNames.set(domEventName, reactName);
      registerTwoPhaseEvent(reactName, [domEventName]);
    }
    var CapturedStacks = /* @__PURE__ */ new WeakMap();
    function createCapturedValueAtFiber(value, source) {
      if ("object" === typeof value && null !== value) {
        var existing = CapturedStacks.get(value);
        if (void 0 !== existing) return existing;
        source = {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
        CapturedStacks.set(value, source);
        return source;
      }
      return {
        value,
        source,
        stack: getStackByFiberInDevAndProd(source)
      };
    }
    var concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0;
    function finishQueueingConcurrentUpdates() {
      for (var endIndex = concurrentQueuesIndex, i2 = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i2 < endIndex; ) {
        var fiber = concurrentQueues[i2];
        concurrentQueues[i2++] = null;
        var queue = concurrentQueues[i2];
        concurrentQueues[i2++] = null;
        var update = concurrentQueues[i2];
        concurrentQueues[i2++] = null;
        var lane = concurrentQueues[i2];
        concurrentQueues[i2++] = null;
        if (null !== queue && null !== update) {
          var pending = queue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
      }
    }
    function enqueueUpdate$1(fiber, queue, update, lane) {
      concurrentQueues[concurrentQueuesIndex++] = fiber;
      concurrentQueues[concurrentQueuesIndex++] = queue;
      concurrentQueues[concurrentQueuesIndex++] = update;
      concurrentQueues[concurrentQueuesIndex++] = lane;
      concurrentlyUpdatedLanes |= lane;
      fiber.lanes |= lane;
      fiber = fiber.alternate;
      null !== fiber && (fiber.lanes |= lane);
    }
    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
      enqueueUpdate$1(fiber, queue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function enqueueConcurrentRenderForLane(fiber, lane) {
      enqueueUpdate$1(fiber, null, null, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
      sourceFiber.lanes |= lane;
      var alternate = sourceFiber.alternate;
      null !== alternate && (alternate.lanes |= lane);
      for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
        parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
      return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
    }
    function getRootForUpdatedFiber(sourceFiber) {
      if (50 < nestedUpdateCount)
        throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
      for (var parent = sourceFiber.return; null !== parent; )
        sourceFiber = parent, parent = sourceFiber.return;
      return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
    }
    var emptyContextObject = {};
    function FiberNode(tag, pendingProps, key2, mode) {
      this.tag = tag;
      this.key = key2;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.refCleanup = this.ref = null;
      this.pendingProps = pendingProps;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = mode;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function createFiberImplClass(tag, pendingProps, key2, mode) {
      return new FiberNode(tag, pendingProps, key2, mode);
    }
    function shouldConstruct(Component) {
      Component = Component.prototype;
      return !(!Component || !Component.isReactComponent);
    }
    function createWorkInProgress(current, pendingProps) {
      var workInProgress2 = current.alternate;
      null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
        current.tag,
        pendingProps,
        current.key,
        current.mode
      ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
      workInProgress2.flags = current.flags & 65011712;
      workInProgress2.childLanes = current.childLanes;
      workInProgress2.lanes = current.lanes;
      workInProgress2.child = current.child;
      workInProgress2.memoizedProps = current.memoizedProps;
      workInProgress2.memoizedState = current.memoizedState;
      workInProgress2.updateQueue = current.updateQueue;
      pendingProps = current.dependencies;
      workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
      workInProgress2.sibling = current.sibling;
      workInProgress2.index = current.index;
      workInProgress2.ref = current.ref;
      workInProgress2.refCleanup = current.refCleanup;
      return workInProgress2;
    }
    function resetWorkInProgress(workInProgress2, renderLanes2) {
      workInProgress2.flags &= 65011714;
      var current = workInProgress2.alternate;
      null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
        lanes: renderLanes2.lanes,
        firstContext: renderLanes2.firstContext
      });
      return workInProgress2;
    }
    function createFiberFromTypeAndProps(type, key2, pendingProps, owner, mode, lanes) {
      var fiberTag = 0;
      owner = type;
      if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
      else if ("string" === typeof type)
        fiberTag = isHostHoistableType(
          type,
          pendingProps,
          contextStackCursor.current
        ) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
      else
        a: switch (type) {
          case REACT_ACTIVITY_TYPE:
            return type = createFiberImplClass(31, pendingProps, key2, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
          case REACT_FRAGMENT_TYPE:
            return createFiberFromFragment(pendingProps.children, mode, lanes, key2);
          case REACT_STRICT_MODE_TYPE:
            fiberTag = 8;
            mode |= 24;
            break;
          case REACT_PROFILER_TYPE:
            return type = createFiberImplClass(12, pendingProps, key2, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
          case REACT_SUSPENSE_TYPE:
            return type = createFiberImplClass(13, pendingProps, key2, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
          case REACT_SUSPENSE_LIST_TYPE:
            return type = createFiberImplClass(19, pendingProps, key2, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
          default:
            if ("object" === typeof type && null !== type)
              switch (type.$$typeof) {
                case REACT_PROVIDER_TYPE:
                case REACT_CONTEXT_TYPE:
                  fiberTag = 10;
                  break a;
                case REACT_CONSUMER_TYPE:
                  fiberTag = 9;
                  break a;
                case REACT_FORWARD_REF_TYPE:
                  fiberTag = 11;
                  break a;
                case REACT_MEMO_TYPE:
                  fiberTag = 14;
                  break a;
                case REACT_LAZY_TYPE:
                  fiberTag = 16;
                  owner = null;
                  break a;
              }
            fiberTag = 29;
            pendingProps = Error(
              formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
            );
            owner = null;
        }
      key2 = createFiberImplClass(fiberTag, pendingProps, key2, mode);
      key2.elementType = type;
      key2.type = owner;
      key2.lanes = lanes;
      return key2;
    }
    function createFiberFromFragment(elements, mode, lanes, key2) {
      elements = createFiberImplClass(7, elements, key2, mode);
      elements.lanes = lanes;
      return elements;
    }
    function createFiberFromText(content, mode, lanes) {
      content = createFiberImplClass(6, content, null, mode);
      content.lanes = lanes;
      return content;
    }
    function createFiberFromPortal(portal, mode, lanes) {
      mode = createFiberImplClass(
        4,
        null !== portal.children ? portal.children : [],
        portal.key,
        mode
      );
      mode.lanes = lanes;
      mode.stateNode = {
        containerInfo: portal.containerInfo,
        pendingChildren: null,
        implementation: portal.implementation
      };
      return mode;
    }
    var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "";
    function pushTreeFork(workInProgress2, totalChildren) {
      forkStack[forkStackIndex++] = treeForkCount;
      forkStack[forkStackIndex++] = treeForkProvider;
      treeForkProvider = workInProgress2;
      treeForkCount = totalChildren;
    }
    function pushTreeId(workInProgress2, totalChildren, index2) {
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextProvider = workInProgress2;
      var baseIdWithLeadingBit = treeContextId;
      workInProgress2 = treeContextOverflow;
      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
      baseIdWithLeadingBit &= ~(1 << baseLength);
      index2 += 1;
      var length = 32 - clz32(totalChildren) + baseLength;
      if (30 < length) {
        var numberOfOverflowBits = baseLength - baseLength % 5;
        length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
        baseIdWithLeadingBit >>= numberOfOverflowBits;
        baseLength -= numberOfOverflowBits;
        treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index2 << baseLength | baseIdWithLeadingBit;
        treeContextOverflow = length + workInProgress2;
      } else
        treeContextId = 1 << length | index2 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
    }
    function pushMaterializedTreeId(workInProgress2) {
      null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
    }
    function popTreeContext(workInProgress2) {
      for (; workInProgress2 === treeForkProvider; )
        treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
      for (; workInProgress2 === treeContextProvider; )
        treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
    }
    var hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(formatProdErrorMessage(519));
    function throwOnHydrationMismatch(fiber) {
      var error = Error(formatProdErrorMessage(418, ""));
      queueHydrationError(createCapturedValueAtFiber(error, fiber));
      throw HydrationMismatchException;
    }
    function prepareToHydrateHostInstance(fiber) {
      var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
      instance[internalInstanceKey] = fiber;
      instance[internalPropsKey] = props;
      switch (type) {
        case "dialog":
          listenToNonDelegatedEvent("cancel", instance);
          listenToNonDelegatedEvent("close", instance);
          break;
        case "iframe":
        case "object":
        case "embed":
          listenToNonDelegatedEvent("load", instance);
          break;
        case "video":
        case "audio":
          for (type = 0; type < mediaEventTypes.length; type++)
            listenToNonDelegatedEvent(mediaEventTypes[type], instance);
          break;
        case "source":
          listenToNonDelegatedEvent("error", instance);
          break;
        case "img":
        case "image":
        case "link":
          listenToNonDelegatedEvent("error", instance);
          listenToNonDelegatedEvent("load", instance);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", instance);
          break;
        case "input":
          listenToNonDelegatedEvent("invalid", instance);
          initInput2(
            instance,
            props.value,
            props.defaultValue,
            props.checked,
            props.defaultChecked,
            props.type,
            props.name,
            true
          );
          track(instance);
          break;
        case "select":
          listenToNonDelegatedEvent("invalid", instance);
          break;
        case "textarea":
          listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children), track(instance);
      }
      type = props.children;
      "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$12), instance = true) : instance = false;
      instance || throwOnHydrationMismatch(fiber);
    }
    function popToNextHostParent(fiber) {
      for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
        switch (hydrationParentFiber.tag) {
          case 5:
          case 13:
            rootOrSingletonContext = false;
            return;
          case 27:
          case 3:
            rootOrSingletonContext = true;
            return;
          default:
            hydrationParentFiber = hydrationParentFiber.return;
        }
    }
    function popHydrationState(fiber) {
      if (fiber !== hydrationParentFiber) return false;
      if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
      var tag = fiber.tag, JSCompiler_temp;
      if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
        if (JSCompiler_temp = 5 === tag)
          JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
        JSCompiler_temp = !JSCompiler_temp;
      }
      JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
      popToNextHostParent(fiber);
      if (13 === tag) {
        fiber = fiber.memoizedState;
        fiber = null !== fiber ? fiber.dehydrated : null;
        if (!fiber) throw Error(formatProdErrorMessage(317));
        a: {
          fiber = fiber.nextSibling;
          for (tag = 0; fiber; ) {
            if (8 === fiber.nodeType)
              if (JSCompiler_temp = fiber.data, "/$" === JSCompiler_temp) {
                if (0 === tag) {
                  nextHydratableInstance = getNextHydratable(fiber.nextSibling);
                  break a;
                }
                tag--;
              } else
                "$" !== JSCompiler_temp && "$!" !== JSCompiler_temp && "$?" !== JSCompiler_temp || tag++;
            fiber = fiber.nextSibling;
          }
          nextHydratableInstance = null;
        }
      } else
        27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
      return true;
    }
    function resetHydrationState() {
      nextHydratableInstance = hydrationParentFiber = null;
      isHydrating = false;
    }
    function upgradeHydrationErrorsToRecoverable() {
      var queuedErrors = hydrationErrors;
      null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
        workInProgressRootRecoverableErrors,
        queuedErrors
      ), hydrationErrors = null);
      return queuedErrors;
    }
    function queueHydrationError(error) {
      null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
    }
    var valueCursor = createCursor(null), currentlyRenderingFiber$1 = null, lastContextDependency = null;
    function pushProvider(providerFiber, context, nextValue) {
      push(valueCursor, context._currentValue);
      context._currentValue = nextValue;
    }
    function popProvider(context) {
      context._currentValue = valueCursor.current;
      pop(valueCursor);
    }
    function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
      for (; null !== parent; ) {
        var alternate = parent.alternate;
        (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
        if (parent === propagationRoot) break;
        parent = parent.return;
      }
    }
    function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
      var fiber = workInProgress2.child;
      null !== fiber && (fiber.return = workInProgress2);
      for (; null !== fiber; ) {
        var list = fiber.dependencies;
        if (null !== list) {
          var nextFiber = fiber.child;
          list = list.firstContext;
          a: for (; null !== list; ) {
            var dependency = list;
            list = fiber;
            for (var i2 = 0; i2 < contexts.length; i2++)
              if (dependency.context === contexts[i2]) {
                list.lanes |= renderLanes2;
                dependency = list.alternate;
                null !== dependency && (dependency.lanes |= renderLanes2);
                scheduleContextWorkOnParentPath(
                  list.return,
                  renderLanes2,
                  workInProgress2
                );
                forcePropagateEntireTree || (nextFiber = null);
                break a;
              }
            list = dependency.next;
          }
        } else if (18 === fiber.tag) {
          nextFiber = fiber.return;
          if (null === nextFiber) throw Error(formatProdErrorMessage(341));
          nextFiber.lanes |= renderLanes2;
          list = nextFiber.alternate;
          null !== list && (list.lanes |= renderLanes2);
          scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
          nextFiber = null;
        } else nextFiber = fiber.child;
        if (null !== nextFiber) nextFiber.return = fiber;
        else
          for (nextFiber = fiber; null !== nextFiber; ) {
            if (nextFiber === workInProgress2) {
              nextFiber = null;
              break;
            }
            fiber = nextFiber.sibling;
            if (null !== fiber) {
              fiber.return = nextFiber.return;
              nextFiber = fiber;
              break;
            }
            nextFiber = nextFiber.return;
          }
        fiber = nextFiber;
      }
    }
    function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
      current = null;
      for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
        if (!isInsidePropagationBailout) {
          if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
          else if (0 !== (parent.flags & 262144)) break;
        }
        if (10 === parent.tag) {
          var currentParent = parent.alternate;
          if (null === currentParent) throw Error(formatProdErrorMessage(387));
          currentParent = currentParent.memoizedProps;
          if (null !== currentParent) {
            var context = parent.type;
            objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
          }
        } else if (parent === hostTransitionProviderCursor.current) {
          currentParent = parent.alternate;
          if (null === currentParent) throw Error(formatProdErrorMessage(387));
          currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
        }
        parent = parent.return;
      }
      null !== current && propagateContextChanges(
        workInProgress2,
        current,
        renderLanes2,
        forcePropagateEntireTree
      );
      workInProgress2.flags |= 262144;
    }
    function checkIfContextChanged(currentDependencies) {
      for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
        if (!objectIs(
          currentDependencies.context._currentValue,
          currentDependencies.memoizedValue
        ))
          return true;
        currentDependencies = currentDependencies.next;
      }
      return false;
    }
    function prepareToReadContext(workInProgress2) {
      currentlyRenderingFiber$1 = workInProgress2;
      lastContextDependency = null;
      workInProgress2 = workInProgress2.dependencies;
      null !== workInProgress2 && (workInProgress2.firstContext = null);
    }
    function readContext(context) {
      return readContextForConsumer(currentlyRenderingFiber$1, context);
    }
    function readContextDuringReconciliation(consumer, context) {
      null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
      return readContextForConsumer(consumer, context);
    }
    function readContextForConsumer(consumer, context) {
      var value = context._currentValue;
      context = { context, memoizedValue: value, next: null };
      if (null === lastContextDependency) {
        if (null === consumer) throw Error(formatProdErrorMessage(308));
        lastContextDependency = context;
        consumer.dependencies = { lanes: 0, firstContext: context };
        consumer.flags |= 524288;
      } else lastContextDependency = lastContextDependency.next = context;
      return value;
    }
    var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
      var listeners = [], signal = this.signal = {
        aborted: false,
        addEventListener: function(type, listener) {
          listeners.push(listener);
        }
      };
      this.abort = function() {
        signal.aborted = true;
        listeners.forEach(function(listener) {
          return listener();
        });
      };
    }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0
    };
    function createCache() {
      return {
        controller: new AbortControllerLocal(),
        data: /* @__PURE__ */ new Map(),
        refCount: 0
      };
    }
    function releaseCache(cache) {
      cache.refCount--;
      0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
        cache.controller.abort();
      });
    }
    var currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null;
    function entangleAsyncAction(transition, thenable) {
      if (null === currentEntangledListeners) {
        var entangledListeners = currentEntangledListeners = [];
        currentEntangledPendingCount = 0;
        currentEntangledLane = requestTransitionLane();
        currentEntangledActionThenable = {
          status: "pending",
          value: void 0,
          then: function(resolve) {
            entangledListeners.push(resolve);
          }
        };
      }
      currentEntangledPendingCount++;
      thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
      return thenable;
    }
    function pingEngtangledActionScope() {
      if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
        null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
        var listeners = currentEntangledListeners;
        currentEntangledListeners = null;
        currentEntangledLane = 0;
        currentEntangledActionThenable = null;
        for (var i2 = 0; i2 < listeners.length; i2++) (0, listeners[i2])();
      }
    }
    function chainThenableValue(thenable, result) {
      var listeners = [], thenableWithOverride = {
        status: "pending",
        value: null,
        reason: null,
        then: function(resolve) {
          listeners.push(resolve);
        }
      };
      thenable.then(
        function() {
          thenableWithOverride.status = "fulfilled";
          thenableWithOverride.value = result;
          for (var i2 = 0; i2 < listeners.length; i2++) (0, listeners[i2])(result);
        },
        function(error) {
          thenableWithOverride.status = "rejected";
          thenableWithOverride.reason = error;
          for (error = 0; error < listeners.length; error++)
            (0, listeners[error])(void 0);
        }
      );
      return thenableWithOverride;
    }
    var prevOnStartTransitionFinish = ReactSharedInternals.S;
    ReactSharedInternals.S = function(transition, returnValue) {
      "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
      null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
    };
    var resumedCache = createCursor(null);
    function peekCacheFromPool() {
      var cacheResumedFromPreviousRender = resumedCache.current;
      return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
    }
    function pushTransition(offscreenWorkInProgress, prevCachePool) {
      null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
    }
    function getSuspendedCache() {
      var cacheFromPool = peekCacheFromPool();
      return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
    }
    var SuspenseException = Error(formatProdErrorMessage(460)), SuspenseyCommitException = Error(formatProdErrorMessage(474)), SuspenseActionException = Error(formatProdErrorMessage(542)), noopSuspenseyCommitThenable = { then: function() {
    } };
    function isThenableResolved(thenable) {
      thenable = thenable.status;
      return "fulfilled" === thenable || "rejected" === thenable;
    }
    function noop$3() {
    }
    function trackUsedThenable(thenableState2, thenable, index2) {
      index2 = thenableState2[index2];
      void 0 === index2 ? thenableState2.push(thenable) : index2 !== thenable && (thenable.then(noop$3, noop$3), thenable = index2);
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
        default:
          if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);
          else {
            thenableState2 = workInProgressRoot;
            if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
              throw Error(formatProdErrorMessage(482));
            thenableState2 = thenable;
            thenableState2.status = "pending";
            thenableState2.then(
              function(fulfilledValue) {
                if ("pending" === thenable.status) {
                  var fulfilledThenable = thenable;
                  fulfilledThenable.status = "fulfilled";
                  fulfilledThenable.value = fulfilledValue;
                }
              },
              function(error) {
                if ("pending" === thenable.status) {
                  var rejectedThenable = thenable;
                  rejectedThenable.status = "rejected";
                  rejectedThenable.reason = error;
                }
              }
            );
          }
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          }
          suspendedThenable = thenable;
          throw SuspenseException;
      }
    }
    var suspendedThenable = null;
    function getSuspendedThenable() {
      if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
      var thenable = suspendedThenable;
      suspendedThenable = null;
      return thenable;
    }
    function checkIfUseWrappedInAsyncCatch(rejectedReason) {
      if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
        throw Error(formatProdErrorMessage(483));
    }
    var hasForceUpdate = false;
    function initializeUpdateQueue(fiber) {
      fiber.updateQueue = {
        baseState: fiber.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function cloneUpdateQueue(current, workInProgress2) {
      current = current.updateQueue;
      workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
        baseState: current.baseState,
        firstBaseUpdate: current.firstBaseUpdate,
        lastBaseUpdate: current.lastBaseUpdate,
        shared: current.shared,
        callbacks: null
      });
    }
    function createUpdate(lane) {
      return { lane, tag: 0, payload: null, callback: null, next: null };
    }
    function enqueueUpdate(fiber, update, lane) {
      var updateQueue = fiber.updateQueue;
      if (null === updateQueue) return null;
      updateQueue = updateQueue.shared;
      if (0 !== (executionContext & 2)) {
        var pending = updateQueue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        updateQueue.pending = update;
        update = getRootForUpdatedFiber(fiber);
        markUpdateLaneFromFiberToRoot(fiber, null, lane);
        return update;
      }
      enqueueUpdate$1(fiber, updateQueue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function entangleTransitions(root2, fiber, lane) {
      fiber = fiber.updateQueue;
      if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
        var queueLanes = fiber.lanes;
        queueLanes &= root2.pendingLanes;
        lane |= queueLanes;
        fiber.lanes = lane;
        markRootEntangled(root2, lane);
      }
    }
    function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
      var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
      if (null !== current && (current = current.updateQueue, queue === current)) {
        var newFirst = null, newLast = null;
        queue = queue.firstBaseUpdate;
        if (null !== queue) {
          do {
            var clone2 = {
              lane: queue.lane,
              tag: queue.tag,
              payload: queue.payload,
              callback: null,
              next: null
            };
            null === newLast ? newFirst = newLast = clone2 : newLast = newLast.next = clone2;
            queue = queue.next;
          } while (null !== queue);
          null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
        } else newFirst = newLast = capturedUpdate;
        queue = {
          baseState: current.baseState,
          firstBaseUpdate: newFirst,
          lastBaseUpdate: newLast,
          shared: current.shared,
          callbacks: current.callbacks
        };
        workInProgress2.updateQueue = queue;
        return;
      }
      workInProgress2 = queue.lastBaseUpdate;
      null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
      queue.lastBaseUpdate = capturedUpdate;
    }
    var didReadFromEntangledAsyncAction = false;
    function suspendIfUpdateReadFromEntangledAsyncAction() {
      if (didReadFromEntangledAsyncAction) {
        var entangledActionThenable = currentEntangledActionThenable;
        if (null !== entangledActionThenable) throw entangledActionThenable;
      }
    }
    function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
      didReadFromEntangledAsyncAction = false;
      var queue = workInProgress$jscomp$0.updateQueue;
      hasForceUpdate = false;
      var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
      if (null !== pendingQueue) {
        queue.shared.pending = null;
        var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
        lastPendingUpdate.next = null;
        null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
        lastBaseUpdate = lastPendingUpdate;
        var current = workInProgress$jscomp$0.alternate;
        null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
      }
      if (null !== firstBaseUpdate) {
        var newState = queue.baseState;
        lastBaseUpdate = 0;
        current = firstPendingUpdate = lastPendingUpdate = null;
        pendingQueue = firstBaseUpdate;
        do {
          var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
          if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
            0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
            null !== current && (current = current.next = {
              lane: 0,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: null,
              next: null
            });
            a: {
              var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
              updateLane = props;
              var instance = instance$jscomp$0;
              switch (update.tag) {
                case 1:
                  workInProgress2 = update.payload;
                  if ("function" === typeof workInProgress2) {
                    newState = workInProgress2.call(instance, newState, updateLane);
                    break a;
                  }
                  newState = workInProgress2;
                  break a;
                case 3:
                  workInProgress2.flags = workInProgress2.flags & -65537 | 128;
                case 0:
                  workInProgress2 = update.payload;
                  updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
                  if (null === updateLane || void 0 === updateLane) break a;
                  newState = assign2({}, newState, updateLane);
                  break a;
                case 2:
                  hasForceUpdate = true;
              }
            }
            updateLane = pendingQueue.callback;
            null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
          } else
            isHiddenUpdate = {
              lane: updateLane,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: pendingQueue.callback,
              next: null
            }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
          pendingQueue = pendingQueue.next;
          if (null === pendingQueue)
            if (pendingQueue = queue.shared.pending, null === pendingQueue)
              break;
            else
              isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
        } while (1);
        null === current && (lastPendingUpdate = newState);
        queue.baseState = lastPendingUpdate;
        queue.firstBaseUpdate = firstPendingUpdate;
        queue.lastBaseUpdate = current;
        null === firstBaseUpdate && (queue.shared.lanes = 0);
        workInProgressRootSkippedLanes |= lastBaseUpdate;
        workInProgress$jscomp$0.lanes = lastBaseUpdate;
        workInProgress$jscomp$0.memoizedState = newState;
      }
    }
    function callCallback(callback, context) {
      if ("function" !== typeof callback)
        throw Error(formatProdErrorMessage(191, callback));
      callback.call(context);
    }
    function commitCallbacks(updateQueue, context) {
      var callbacks = updateQueue.callbacks;
      if (null !== callbacks)
        for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
          callCallback(callbacks[updateQueue], context);
    }
    var currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0);
    function pushHiddenContext(fiber, context) {
      fiber = entangledRenderLanes;
      push(prevEntangledRenderLanesCursor, fiber);
      push(currentTreeHiddenStackCursor, context);
      entangledRenderLanes = fiber | context.baseLanes;
    }
    function reuseHiddenContextOnStack() {
      push(prevEntangledRenderLanesCursor, entangledRenderLanes);
      push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
    }
    function popHiddenContext() {
      entangledRenderLanes = prevEntangledRenderLanesCursor.current;
      pop(currentTreeHiddenStackCursor);
      pop(prevEntangledRenderLanesCursor);
    }
    var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter$1 = 0, thenableState$1 = null, globalClientIdCounter = 0;
    function throwInvalidHookError() {
      throw Error(formatProdErrorMessage(321));
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
      if (null === prevDeps) return false;
      for (var i2 = 0; i2 < prevDeps.length && i2 < nextDeps.length; i2++)
        if (!objectIs(nextDeps[i2], prevDeps[i2])) return false;
      return true;
    }
    function renderWithHooks(current, workInProgress2, Component, props, secondArg, nextRenderLanes) {
      renderLanes = nextRenderLanes;
      currentlyRenderingFiber = workInProgress2;
      workInProgress2.memoizedState = null;
      workInProgress2.updateQueue = null;
      workInProgress2.lanes = 0;
      ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
      shouldDoubleInvokeUserFnsInHooksDEV = false;
      nextRenderLanes = Component(props, secondArg);
      shouldDoubleInvokeUserFnsInHooksDEV = false;
      didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
        workInProgress2,
        Component,
        props,
        secondArg
      ));
      finishRenderingHooks(current);
      return nextRenderLanes;
    }
    function finishRenderingHooks(current) {
      ReactSharedInternals.H = ContextOnlyDispatcher;
      var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
      renderLanes = 0;
      workInProgressHook = currentHook = currentlyRenderingFiber = null;
      didScheduleRenderPhaseUpdate = false;
      thenableIndexCounter$1 = 0;
      thenableState$1 = null;
      if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
      null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
    }
    function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
      currentlyRenderingFiber = workInProgress2;
      var numberOfReRenders = 0;
      do {
        didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
        thenableIndexCounter$1 = 0;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
        numberOfReRenders += 1;
        workInProgressHook = currentHook = null;
        if (null != workInProgress2.updateQueue) {
          var children = workInProgress2.updateQueue;
          children.lastEffect = null;
          children.events = null;
          children.stores = null;
          null != children.memoCache && (children.memoCache.index = 0);
        }
        ReactSharedInternals.H = HooksDispatcherOnRerender;
        children = Component(props, secondArg);
      } while (didScheduleRenderPhaseUpdateDuringThisPass);
      return children;
    }
    function TransitionAwareHostComponent() {
      var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
      maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
      dispatcher = dispatcher.useState()[0];
      (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
      return maybeThenable;
    }
    function checkDidRenderIdHook() {
      var didRenderIdHook = 0 !== localIdCounter;
      localIdCounter = 0;
      return didRenderIdHook;
    }
    function bailoutHooks(current, workInProgress2, lanes) {
      workInProgress2.updateQueue = current.updateQueue;
      workInProgress2.flags &= -2053;
      current.lanes &= ~lanes;
    }
    function resetHooksOnUnwind(workInProgress2) {
      if (didScheduleRenderPhaseUpdate) {
        for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
          var queue = workInProgress2.queue;
          null !== queue && (queue.pending = null);
          workInProgress2 = workInProgress2.next;
        }
        didScheduleRenderPhaseUpdate = false;
      }
      renderLanes = 0;
      workInProgressHook = currentHook = currentlyRenderingFiber = null;
      didScheduleRenderPhaseUpdateDuringThisPass = false;
      thenableIndexCounter$1 = localIdCounter = 0;
      thenableState$1 = null;
    }
    function mountWorkInProgressHook() {
      var hook = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
      return workInProgressHook;
    }
    function updateWorkInProgressHook() {
      if (null === currentHook) {
        var nextCurrentHook = currentlyRenderingFiber.alternate;
        nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
      } else nextCurrentHook = currentHook.next;
      var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
      if (null !== nextWorkInProgressHook)
        workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
      else {
        if (null === nextCurrentHook) {
          if (null === currentlyRenderingFiber.alternate)
            throw Error(formatProdErrorMessage(467));
          throw Error(formatProdErrorMessage(310));
        }
        currentHook = nextCurrentHook;
        nextCurrentHook = {
          memoizedState: currentHook.memoizedState,
          baseState: currentHook.baseState,
          baseQueue: currentHook.baseQueue,
          queue: currentHook.queue,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
      }
      return workInProgressHook;
    }
    function createFunctionComponentUpdateQueue() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    function useThenable(thenable) {
      var index2 = thenableIndexCounter$1;
      thenableIndexCounter$1 += 1;
      null === thenableState$1 && (thenableState$1 = []);
      thenable = trackUsedThenable(thenableState$1, thenable, index2);
      index2 = currentlyRenderingFiber;
      null === (null === workInProgressHook ? index2.memoizedState : workInProgressHook.next) && (index2 = index2.alternate, ReactSharedInternals.H = null === index2 || null === index2.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
      return thenable;
    }
    function use2(usable) {
      if (null !== usable && "object" === typeof usable) {
        if ("function" === typeof usable.then) return useThenable(usable);
        if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
      }
      throw Error(formatProdErrorMessage(438, String(usable)));
    }
    function useMemoCache(size) {
      var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
      null !== updateQueue && (memoCache = updateQueue.memoCache);
      if (null == memoCache) {
        var current = currentlyRenderingFiber.alternate;
        null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
          data: current.data.map(function(array) {
            return array.slice();
          }),
          index: 0
        })));
      }
      null == memoCache && (memoCache = { data: [], index: 0 });
      null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
      updateQueue.memoCache = memoCache;
      updateQueue = memoCache.data[memoCache.index];
      if (void 0 === updateQueue)
        for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)
          updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
      memoCache.index++;
      return updateQueue;
    }
    function basicStateReducer(state, action) {
      return "function" === typeof action ? action(state) : action;
    }
    function updateReducer(reducer) {
      var hook = updateWorkInProgressHook();
      return updateReducerImpl(hook, currentHook, reducer);
    }
    function updateReducerImpl(hook, current, reducer) {
      var queue = hook.queue;
      if (null === queue) throw Error(formatProdErrorMessage(311));
      queue.lastRenderedReducer = reducer;
      var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
      if (null !== pendingQueue) {
        if (null !== baseQueue) {
          var baseFirst = baseQueue.next;
          baseQueue.next = pendingQueue.next;
          pendingQueue.next = baseFirst;
        }
        current.baseQueue = baseQueue = pendingQueue;
        queue.pending = null;
      }
      pendingQueue = hook.baseState;
      if (null === baseQueue) hook.memoizedState = pendingQueue;
      else {
        current = baseQueue.next;
        var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$32 = false;
        do {
          var updateLane = update.lane & -536870913;
          if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
            var revertLane = update.revertLane;
            if (0 === revertLane)
              null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                lane: 0,
                revertLane: 0,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
            else if ((renderLanes & revertLane) === revertLane) {
              update = update.next;
              revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
              continue;
            } else
              updateLane = {
                lane: 0,
                revertLane: update.revertLane,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
            updateLane = update.action;
            shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
            pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
          } else
            revertLane = {
              lane: updateLane,
              revertLane: update.revertLane,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
          update = update.next;
        } while (null !== update && update !== current);
        null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
        if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$32 && (reducer = currentEntangledActionThenable, null !== reducer)))
          throw reducer;
        hook.memoizedState = pendingQueue;
        hook.baseState = baseFirst;
        hook.baseQueue = newBaseQueueLast;
        queue.lastRenderedState = pendingQueue;
      }
      null === baseQueue && (queue.lanes = 0);
      return [hook.memoizedState, queue.dispatch];
    }
    function rerenderReducer(reducer) {
      var hook = updateWorkInProgressHook(), queue = hook.queue;
      if (null === queue) throw Error(formatProdErrorMessage(311));
      queue.lastRenderedReducer = reducer;
      var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
      if (null !== lastRenderPhaseUpdate) {
        queue.pending = null;
        var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
        do
          newState = reducer(newState, update.action), update = update.next;
        while (update !== lastRenderPhaseUpdate);
        objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
        hook.memoizedState = newState;
        null === hook.baseQueue && (hook.baseState = newState);
        queue.lastRenderedState = newState;
      }
      return [newState, dispatch];
    }
    function updateSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
      if (isHydrating$jscomp$0) {
        if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
        getServerSnapshot = getServerSnapshot();
      } else getServerSnapshot = getSnapshot();
      var snapshotChanged = !objectIs(
        (currentHook || hook).memoizedState,
        getServerSnapshot
      );
      snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
      hook = hook.queue;
      var create2 = subscribeToStore.bind(null, fiber, hook, subscribe2);
      updateEffectImpl(2048, 8, create2, [subscribe2]);
      if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
        fiber.flags |= 2048;
        pushSimpleEffect(
          9,
          createEffectInstance(),
          updateStoreInstance.bind(
            null,
            fiber,
            hook,
            getServerSnapshot,
            getSnapshot
          ),
          null
        );
        if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
        isHydrating$jscomp$0 || 0 !== (renderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      return getServerSnapshot;
    }
    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
      fiber.flags |= 16384;
      fiber = { getSnapshot, value: renderedSnapshot };
      getSnapshot = currentlyRenderingFiber.updateQueue;
      null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
    }
    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
      inst.value = nextSnapshot;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    }
    function subscribeToStore(fiber, inst, subscribe2) {
      return subscribe2(function() {
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      });
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return true;
      }
    }
    function forceStoreRerender(fiber) {
      var root2 = enqueueConcurrentRenderForLane(fiber, 2);
      null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
    }
    function mountStateImpl(initialState) {
      var hook = mountWorkInProgressHook();
      if ("function" === typeof initialState) {
        var initialStateInitializer = initialState;
        initialState = initialStateInitializer();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            initialStateInitializer();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
      }
      hook.memoizedState = hook.baseState = initialState;
      hook.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialState
      };
      return hook;
    }
    function updateOptimisticImpl(hook, current, passthrough, reducer) {
      hook.baseState = passthrough;
      return updateReducerImpl(
        hook,
        currentHook,
        "function" === typeof reducer ? reducer : basicStateReducer
      );
    }
    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
      if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
      fiber = actionQueue.action;
      if (null !== fiber) {
        var actionNode = {
          payload,
          action: fiber,
          next: null,
          isTransition: true,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(listener) {
            actionNode.listeners.push(listener);
          }
        };
        null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
        setState(actionNode);
        setPendingState = actionQueue.pending;
        null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
      }
    }
    function runActionStateAction(actionQueue, node) {
      var action = node.action, payload = node.payload, prevState = actionQueue.state;
      if (node.isTransition) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          handleActionReturnValue(actionQueue, node, returnValue);
        } catch (error) {
          onActionError(actionQueue, node, error);
        } finally {
          ReactSharedInternals.T = prevTransition;
        }
      } else
        try {
          prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
        } catch (error$38) {
          onActionError(actionQueue, node, error$38);
        }
    }
    function handleActionReturnValue(actionQueue, node, returnValue) {
      null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
        function(nextState) {
          onActionSuccess(actionQueue, node, nextState);
        },
        function(error) {
          return onActionError(actionQueue, node, error);
        }
      ) : onActionSuccess(actionQueue, node, returnValue);
    }
    function onActionSuccess(actionQueue, actionNode, nextState) {
      actionNode.status = "fulfilled";
      actionNode.value = nextState;
      notifyActionListeners(actionNode);
      actionQueue.state = nextState;
      actionNode = actionQueue.pending;
      null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
    }
    function onActionError(actionQueue, actionNode, error) {
      var last2 = actionQueue.pending;
      actionQueue.pending = null;
      if (null !== last2) {
        last2 = last2.next;
        do
          actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
        while (actionNode !== last2);
      }
      actionQueue.action = null;
    }
    function notifyActionListeners(actionNode) {
      actionNode = actionNode.listeners;
      for (var i2 = 0; i2 < actionNode.length; i2++) (0, actionNode[i2])();
    }
    function actionStateReducer(oldState, newState) {
      return newState;
    }
    function mountActionState(action, initialStateProp) {
      if (isHydrating) {
        var ssrFormState = workInProgressRoot.formState;
        if (null !== ssrFormState) {
          a: {
            var JSCompiler_inline_result = currentlyRenderingFiber;
            if (isHydrating) {
              if (nextHydratableInstance) {
                b: {
                  var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                  for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                    if (!inRootOrSingleton) {
                      JSCompiler_inline_result$jscomp$0 = null;
                      break b;
                    }
                    JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                      JSCompiler_inline_result$jscomp$0.nextSibling
                    );
                    if (null === JSCompiler_inline_result$jscomp$0) {
                      JSCompiler_inline_result$jscomp$0 = null;
                      break b;
                    }
                  }
                  inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                  JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
                }
                if (JSCompiler_inline_result$jscomp$0) {
                  nextHydratableInstance = getNextHydratable(
                    JSCompiler_inline_result$jscomp$0.nextSibling
                  );
                  JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                  break a;
                }
              }
              throwOnHydrationMismatch(JSCompiler_inline_result);
            }
            JSCompiler_inline_result = false;
          }
          JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
        }
      }
      ssrFormState = mountWorkInProgressHook();
      ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
      JSCompiler_inline_result = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: actionStateReducer,
        lastRenderedState: initialStateProp
      };
      ssrFormState.queue = JSCompiler_inline_result;
      ssrFormState = dispatchSetState.bind(
        null,
        currentlyRenderingFiber,
        JSCompiler_inline_result
      );
      JSCompiler_inline_result.dispatch = ssrFormState;
      JSCompiler_inline_result = mountStateImpl(false);
      inRootOrSingleton = dispatchOptimisticSetState.bind(
        null,
        currentlyRenderingFiber,
        false,
        JSCompiler_inline_result.queue
      );
      JSCompiler_inline_result = mountWorkInProgressHook();
      JSCompiler_inline_result$jscomp$0 = {
        state: initialStateProp,
        dispatch: null,
        action,
        pending: null
      };
      JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
      ssrFormState = dispatchActionState.bind(
        null,
        currentlyRenderingFiber,
        JSCompiler_inline_result$jscomp$0,
        inRootOrSingleton,
        ssrFormState
      );
      JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
      JSCompiler_inline_result.memoizedState = action;
      return [initialStateProp, ssrFormState, false];
    }
    function updateActionState(action) {
      var stateHook = updateWorkInProgressHook();
      return updateActionStateImpl(stateHook, currentHook, action);
    }
    function updateActionStateImpl(stateHook, currentStateHook, action) {
      currentStateHook = updateReducerImpl(
        stateHook,
        currentStateHook,
        actionStateReducer
      )[0];
      stateHook = updateReducer(basicStateReducer)[0];
      if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
        try {
          var state = useThenable(currentStateHook);
        } catch (x2) {
          if (x2 === SuspenseException) throw SuspenseActionException;
          throw x2;
        }
      else state = currentStateHook;
      currentStateHook = updateWorkInProgressHook();
      var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
      action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
        9,
        createEffectInstance(),
        actionStateActionEffect.bind(null, actionQueue, action),
        null
      ));
      return [state, dispatch, stateHook];
    }
    function actionStateActionEffect(actionQueue, action) {
      actionQueue.action = action;
    }
    function rerenderActionState(action) {
      var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
      if (null !== currentStateHook)
        return updateActionStateImpl(stateHook, currentStateHook, action);
      updateWorkInProgressHook();
      stateHook = stateHook.memoizedState;
      currentStateHook = updateWorkInProgressHook();
      var dispatch = currentStateHook.queue.dispatch;
      currentStateHook.memoizedState = action;
      return [stateHook, dispatch, false];
    }
    function pushSimpleEffect(tag, inst, create2, createDeps) {
      tag = { tag, create: create2, deps: createDeps, inst, next: null };
      inst = currentlyRenderingFiber.updateQueue;
      null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
      create2 = inst.lastEffect;
      null === create2 ? inst.lastEffect = tag.next = tag : (createDeps = create2.next, create2.next = tag, tag.next = createDeps, inst.lastEffect = tag);
      return tag;
    }
    function createEffectInstance() {
      return { destroy: void 0, resource: void 0 };
    }
    function updateRef() {
      return updateWorkInProgressHook().memoizedState;
    }
    function mountEffectImpl(fiberFlags, hookFlags, create2, createDeps) {
      var hook = mountWorkInProgressHook();
      createDeps = void 0 === createDeps ? null : createDeps;
      currentlyRenderingFiber.flags |= fiberFlags;
      hook.memoizedState = pushSimpleEffect(
        1 | hookFlags,
        createEffectInstance(),
        create2,
        createDeps
      );
    }
    function updateEffectImpl(fiberFlags, hookFlags, create2, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var inst = hook.memoizedState.inst;
      null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create2, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
        1 | hookFlags,
        inst,
        create2,
        deps
      ));
    }
    function mountEffect(create2, createDeps) {
      mountEffectImpl(8390656, 8, create2, createDeps);
    }
    function updateEffect(create2, createDeps) {
      updateEffectImpl(2048, 8, create2, createDeps);
    }
    function updateInsertionEffect(create2, deps) {
      return updateEffectImpl(4, 2, create2, deps);
    }
    function updateLayoutEffect(create2, deps) {
      return updateEffectImpl(4, 4, create2, deps);
    }
    function imperativeHandleEffect(create2, ref) {
      if ("function" === typeof ref) {
        create2 = create2();
        var refCleanup = ref(create2);
        return function() {
          "function" === typeof refCleanup ? refCleanup() : ref(null);
        };
      }
      if (null !== ref && void 0 !== ref)
        return create2 = create2(), ref.current = create2, function() {
          ref.current = null;
        };
    }
    function updateImperativeHandle(ref, create2, deps) {
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create2, ref), deps);
    }
    function mountDebugValue() {
    }
    function updateCallback(callback, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      hook.memoizedState = [callback, deps];
      return callback;
    }
    function updateMemo(nextCreate, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      prevState = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      hook.memoizedState = [prevState, deps];
      return prevState;
    }
    function mountDeferredValueImpl(hook, value, initialValue) {
      if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
        return hook.memoizedState = value;
      hook.memoizedState = initialValue;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return initialValue;
    }
    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
      if (objectIs(value, prevValue)) return value;
      if (null !== currentTreeHiddenStackCursor.current)
        return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
      if (0 === (renderLanes & 42))
        return didReceiveUpdate = true, hook.memoizedState = value;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return prevValue;
    }
    function startTransition(fiber, queue, pendingState, finishedState, callback) {
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      dispatchOptimisticSetState(fiber, false, queue, pendingState);
      try {
        var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
          var thenableForFinishedState = chainThenableValue(
            returnValue,
            finishedState
          );
          dispatchSetStateInternal(
            fiber,
            queue,
            thenableForFinishedState,
            requestUpdateLane(fiber)
          );
        } else
          dispatchSetStateInternal(
            fiber,
            queue,
            finishedState,
            requestUpdateLane(fiber)
          );
      } catch (error) {
        dispatchSetStateInternal(
          fiber,
          queue,
          { then: function() {
          }, status: "rejected", reason: error },
          requestUpdateLane()
        );
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    function noop$22() {
    }
    function startHostTransition(formFiber, pendingState, action, formData) {
      if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
      var queue = ensureFormComponentIsStateful(formFiber).queue;
      startTransition(
        formFiber,
        queue,
        pendingState,
        sharedNotPendingObject,
        null === action ? noop$22 : function() {
          requestFormReset$1(formFiber);
          return action(formData);
        }
      );
    }
    function ensureFormComponentIsStateful(formFiber) {
      var existingStateHook = formFiber.memoizedState;
      if (null !== existingStateHook) return existingStateHook;
      existingStateHook = {
        memoizedState: sharedNotPendingObject,
        baseState: sharedNotPendingObject,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: sharedNotPendingObject
        },
        next: null
      };
      var initialResetState = {};
      existingStateHook.next = {
        memoizedState: initialResetState,
        baseState: initialResetState,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialResetState
        },
        next: null
      };
      formFiber.memoizedState = existingStateHook;
      formFiber = formFiber.alternate;
      null !== formFiber && (formFiber.memoizedState = existingStateHook);
      return existingStateHook;
    }
    function requestFormReset$1(formFiber) {
      var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
      dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
    }
    function useHostTransitionStatus() {
      return readContext(HostTransitionContext);
    }
    function updateId() {
      return updateWorkInProgressHook().memoizedState;
    }
    function updateRefresh() {
      return updateWorkInProgressHook().memoizedState;
    }
    function refreshCache(fiber) {
      for (var provider = fiber.return; null !== provider; ) {
        switch (provider.tag) {
          case 24:
          case 3:
            var lane = requestUpdateLane();
            fiber = createUpdate(lane);
            var root$41 = enqueueUpdate(provider, fiber, lane);
            null !== root$41 && (scheduleUpdateOnFiber(root$41, provider, lane), entangleTransitions(root$41, provider, lane));
            provider = { cache: createCache() };
            fiber.payload = provider;
            return;
        }
        provider = provider.return;
      }
    }
    function dispatchReducerAction(fiber, queue, action) {
      var lane = requestUpdateLane();
      action = {
        lane,
        revertLane: 0,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
    }
    function dispatchSetState(fiber, queue, action) {
      var lane = requestUpdateLane();
      dispatchSetStateInternal(fiber, queue, action, lane);
    }
    function dispatchSetStateInternal(fiber, queue, action, lane) {
      var update = {
        lane,
        revertLane: 0,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
      else {
        var alternate = fiber.alternate;
        if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
          try {
            var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
            update.hasEagerState = true;
            update.eagerState = eagerState;
            if (objectIs(eagerState, currentState))
              return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
          } catch (error) {
          } finally {
          }
        action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
        if (null !== action)
          return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
      }
      return false;
    }
    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
      action = {
        lane: 2,
        revertLane: requestTransitionLane(),
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) {
        if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
      } else
        throwIfDuringRender = enqueueConcurrentHookUpdate(
          fiber,
          queue,
          action,
          2
        ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
    }
    function isRenderPhaseUpdate(fiber) {
      var alternate = fiber.alternate;
      return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
    }
    function enqueueRenderPhaseUpdate(queue, update) {
      didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
      var pending = queue.pending;
      null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
      queue.pending = update;
    }
    function entangleTransitionUpdate(root2, queue, lane) {
      if (0 !== (lane & 4194048)) {
        var queueLanes = queue.lanes;
        queueLanes &= root2.pendingLanes;
        lane |= queueLanes;
        queue.lanes = lane;
        markRootEntangled(root2, lane);
      }
    }
    var ContextOnlyDispatcher = {
      readContext,
      use: use2,
      useCallback: throwInvalidHookError,
      useContext: throwInvalidHookError,
      useEffect: throwInvalidHookError,
      useImperativeHandle: throwInvalidHookError,
      useLayoutEffect: throwInvalidHookError,
      useInsertionEffect: throwInvalidHookError,
      useMemo: throwInvalidHookError,
      useReducer: throwInvalidHookError,
      useRef: throwInvalidHookError,
      useState: throwInvalidHookError,
      useDebugValue: throwInvalidHookError,
      useDeferredValue: throwInvalidHookError,
      useTransition: throwInvalidHookError,
      useSyncExternalStore: throwInvalidHookError,
      useId: throwInvalidHookError,
      useHostTransitionStatus: throwInvalidHookError,
      useFormState: throwInvalidHookError,
      useActionState: throwInvalidHookError,
      useOptimistic: throwInvalidHookError,
      useMemoCache: throwInvalidHookError,
      useCacheRefresh: throwInvalidHookError
    }, HooksDispatcherOnMount = {
      readContext,
      use: use2,
      useCallback: function(callback, deps) {
        mountWorkInProgressHook().memoizedState = [
          callback,
          void 0 === deps ? null : deps
        ];
        return callback;
      },
      useContext: readContext,
      useEffect: mountEffect,
      useImperativeHandle: function(ref, create2, deps) {
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        mountEffectImpl(
          4194308,
          4,
          imperativeHandleEffect.bind(null, create2, ref),
          deps
        );
      },
      useLayoutEffect: function(create2, deps) {
        return mountEffectImpl(4194308, 4, create2, deps);
      },
      useInsertionEffect: function(create2, deps) {
        mountEffectImpl(4, 2, create2, deps);
      },
      useMemo: function(nextCreate, deps) {
        var hook = mountWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var nextValue = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [nextValue, deps];
        return nextValue;
      },
      useReducer: function(reducer, initialArg, init2) {
        var hook = mountWorkInProgressHook();
        if (void 0 !== init2) {
          var initialState = init2(initialArg);
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              init2(initialArg);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        } else initialState = initialArg;
        hook.memoizedState = hook.baseState = initialState;
        reducer = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: reducer,
          lastRenderedState: initialState
        };
        hook.queue = reducer;
        reducer = reducer.dispatch = dispatchReducerAction.bind(
          null,
          currentlyRenderingFiber,
          reducer
        );
        return [hook.memoizedState, reducer];
      },
      useRef: function(initialValue) {
        var hook = mountWorkInProgressHook();
        initialValue = { current: initialValue };
        return hook.memoizedState = initialValue;
      },
      useState: function(initialState) {
        initialState = mountStateImpl(initialState);
        var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
        queue.dispatch = dispatch;
        return [initialState.memoizedState, dispatch];
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function(value, initialValue) {
        var hook = mountWorkInProgressHook();
        return mountDeferredValueImpl(hook, value, initialValue);
      },
      useTransition: function() {
        var stateHook = mountStateImpl(false);
        stateHook = startTransition.bind(
          null,
          currentlyRenderingFiber,
          stateHook.queue,
          true,
          false
        );
        mountWorkInProgressHook().memoizedState = stateHook;
        return [false, stateHook];
      },
      useSyncExternalStore: function(subscribe2, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
        if (isHydrating) {
          if (void 0 === getServerSnapshot)
            throw Error(formatProdErrorMessage(407));
          getServerSnapshot = getServerSnapshot();
        } else {
          getServerSnapshot = getSnapshot();
          if (null === workInProgressRoot)
            throw Error(formatProdErrorMessage(349));
          0 !== (workInProgressRootRenderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        hook.memoizedState = getServerSnapshot;
        var inst = { value: getServerSnapshot, getSnapshot };
        hook.queue = inst;
        mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe2), [
          subscribe2
        ]);
        fiber.flags |= 2048;
        pushSimpleEffect(
          9,
          createEffectInstance(),
          updateStoreInstance.bind(
            null,
            fiber,
            inst,
            getServerSnapshot,
            getSnapshot
          ),
          null
        );
        return getServerSnapshot;
      },
      useId: function() {
        var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
        if (isHydrating) {
          var JSCompiler_inline_result = treeContextOverflow;
          var idWithLeadingBit = treeContextId;
          JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
          identifierPrefix = "" + identifierPrefix + "R" + JSCompiler_inline_result;
          JSCompiler_inline_result = localIdCounter++;
          0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
          identifierPrefix += "";
        } else
          JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "" + identifierPrefix + "r" + JSCompiler_inline_result.toString(32) + "";
        return hook.memoizedState = identifierPrefix;
      },
      useHostTransitionStatus,
      useFormState: mountActionState,
      useActionState: mountActionState,
      useOptimistic: function(passthrough) {
        var hook = mountWorkInProgressHook();
        hook.memoizedState = hook.baseState = passthrough;
        var queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null
        };
        hook.queue = queue;
        hook = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          true,
          queue
        );
        queue.dispatch = hook;
        return [passthrough, hook];
      },
      useMemoCache,
      useCacheRefresh: function() {
        return mountWorkInProgressHook().memoizedState = refreshCache.bind(
          null,
          currentlyRenderingFiber
        );
      }
    }, HooksDispatcherOnUpdate = {
      readContext,
      use: use2,
      useCallback: updateCallback,
      useContext: readContext,
      useEffect: updateEffect,
      useImperativeHandle: updateImperativeHandle,
      useInsertionEffect: updateInsertionEffect,
      useLayoutEffect: updateLayoutEffect,
      useMemo: updateMemo,
      useReducer: updateReducer,
      useRef: updateRef,
      useState: function() {
        return updateReducer(basicStateReducer);
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function(value, initialValue) {
        var hook = updateWorkInProgressHook();
        return updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue
        );
      },
      useTransition: function() {
        var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
        return [
          "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
          start
        ];
      },
      useSyncExternalStore: updateSyncExternalStore,
      useId: updateId,
      useHostTransitionStatus,
      useFormState: updateActionState,
      useActionState: updateActionState,
      useOptimistic: function(passthrough, reducer) {
        var hook = updateWorkInProgressHook();
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      },
      useMemoCache,
      useCacheRefresh: updateRefresh
    }, HooksDispatcherOnRerender = {
      readContext,
      use: use2,
      useCallback: updateCallback,
      useContext: readContext,
      useEffect: updateEffect,
      useImperativeHandle: updateImperativeHandle,
      useInsertionEffect: updateInsertionEffect,
      useLayoutEffect: updateLayoutEffect,
      useMemo: updateMemo,
      useReducer: rerenderReducer,
      useRef: updateRef,
      useState: function() {
        return rerenderReducer(basicStateReducer);
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function(value, initialValue) {
        var hook = updateWorkInProgressHook();
        return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue
        );
      },
      useTransition: function() {
        var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
        return [
          "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
          start
        ];
      },
      useSyncExternalStore: updateSyncExternalStore,
      useId: updateId,
      useHostTransitionStatus,
      useFormState: rerenderActionState,
      useActionState: rerenderActionState,
      useOptimistic: function(passthrough, reducer) {
        var hook = updateWorkInProgressHook();
        if (null !== currentHook)
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        hook.baseState = passthrough;
        return [passthrough, hook.queue.dispatch];
      },
      useMemoCache,
      useCacheRefresh: updateRefresh
    }, thenableState = null, thenableIndexCounter = 0;
    function unwrapThenable(thenable) {
      var index2 = thenableIndexCounter;
      thenableIndexCounter += 1;
      null === thenableState && (thenableState = []);
      return trackUsedThenable(thenableState, thenable, index2);
    }
    function coerceRef(workInProgress2, element) {
      element = element.props.ref;
      workInProgress2.ref = void 0 !== element ? element : null;
    }
    function throwOnInvalidObjectType(returnFiber, newChild) {
      if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
        throw Error(formatProdErrorMessage(525));
      returnFiber = Object.prototype.toString.call(newChild);
      throw Error(
        formatProdErrorMessage(
          31,
          "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
        )
      );
    }
    function resolveLazy(lazyType2) {
      var init2 = lazyType2._init;
      return init2(lazyType2._payload);
    }
    function createChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (shouldTrackSideEffects) {
          var deletions = returnFiber.deletions;
          null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
        }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects) return null;
        for (; null !== currentFirstChild; )
          deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return null;
      }
      function mapRemainingChildren(currentFirstChild) {
        for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
          null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return existingChildren;
      }
      function useFiber(fiber, pendingProps) {
        fiber = createWorkInProgress(fiber, pendingProps);
        fiber.index = 0;
        fiber.sibling = null;
        return fiber;
      }
      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        newFiber.index = newIndex;
        if (!shouldTrackSideEffects)
          return newFiber.flags |= 1048576, lastPlacedIndex;
        newIndex = newFiber.alternate;
        if (null !== newIndex)
          return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
        newFiber.flags |= 67108866;
        return lastPlacedIndex;
      }
      function placeSingleChild(newFiber) {
        shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
        return newFiber;
      }
      function updateTextNode(returnFiber, current, textContent, lanes) {
        if (null === current || 6 !== current.tag)
          return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
        current = useFiber(current, textContent);
        current.return = returnFiber;
        return current;
      }
      function updateElement(returnFiber, current, element, lanes) {
        var elementType = element.type;
        if (elementType === REACT_FRAGMENT_TYPE)
          return updateFragment(
            returnFiber,
            current,
            element.props.children,
            lanes,
            element.key
          );
        if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
          return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
        current = createFiberFromTypeAndProps(
          element.type,
          element.key,
          element.props,
          null,
          returnFiber.mode,
          lanes
        );
        coerceRef(current, element);
        current.return = returnFiber;
        return current;
      }
      function updatePortal(returnFiber, current, portal, lanes) {
        if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
          return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
        current = useFiber(current, portal.children || []);
        current.return = returnFiber;
        return current;
      }
      function updateFragment(returnFiber, current, fragment, lanes, key2) {
        if (null === current || 7 !== current.tag)
          return current = createFiberFromFragment(
            fragment,
            returnFiber.mode,
            lanes,
            key2
          ), current.return = returnFiber, current;
        current = useFiber(current, fragment);
        current.return = returnFiber;
        return current;
      }
      function createChild(returnFiber, newChild, lanes) {
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
          return newChild = createFiberFromText(
            "" + newChild,
            returnFiber.mode,
            lanes
          ), newChild.return = returnFiber, newChild;
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return lanes = createFiberFromTypeAndProps(
                newChild.type,
                newChild.key,
                newChild.props,
                null,
                returnFiber.mode,
                lanes
              ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
            case REACT_PORTAL_TYPE:
              return newChild = createFiberFromPortal(
                newChild,
                returnFiber.mode,
                lanes
              ), newChild.return = returnFiber, newChild;
            case REACT_LAZY_TYPE:
              var init2 = newChild._init;
              newChild = init2(newChild._payload);
              return createChild(returnFiber, newChild, lanes);
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return newChild = createFiberFromFragment(
              newChild,
              returnFiber.mode,
              lanes,
              null
            ), newChild.return = returnFiber, newChild;
          if ("function" === typeof newChild.then)
            return createChild(returnFiber, unwrapThenable(newChild), lanes);
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return createChild(
              returnFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        return null;
      }
      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
        var key2 = null !== oldFiber ? oldFiber.key : null;
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
          return null !== key2 ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newChild.key === key2 ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
            case REACT_PORTAL_TYPE:
              return newChild.key === key2 ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
            case REACT_LAZY_TYPE:
              return key2 = newChild._init, newChild = key2(newChild._payload), updateSlot(returnFiber, oldFiber, newChild, lanes);
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return null !== key2 ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
          if ("function" === typeof newChild.then)
            return updateSlot(
              returnFiber,
              oldFiber,
              unwrapThenable(newChild),
              lanes
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateSlot(
              returnFiber,
              oldFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        return null;
      }
      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
          return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return existingChildren = existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
            case REACT_PORTAL_TYPE:
              return existingChildren = existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
            case REACT_LAZY_TYPE:
              var init2 = newChild._init;
              newChild = init2(newChild._payload);
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                newChild,
                lanes
              );
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
          if ("function" === typeof newChild.then)
            return updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              unwrapThenable(newChild),
              lanes
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        return null;
      }
      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(
            returnFiber,
            oldFiber,
            newChildren[newIdx],
            lanes
          );
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (newIdx === newChildren.length)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (null === oldFiber) {
          for (; newIdx < newChildren.length; newIdx++)
            oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
              oldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
          nextOldFiber = updateFromMap(
            oldFiber,
            returnFiber,
            newIdx,
            newChildren[newIdx],
            lanes
          ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
            null === nextOldFiber.key ? newIdx : nextOldFiber.key
          ), currentFirstChild = placeChild(
            nextOldFiber,
            currentFirstChild,
            newIdx
          ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
        if (null == newChildren) throw Error(formatProdErrorMessage(151));
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (step.done)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (null === oldFiber) {
          for (; !step.done; newIdx++, step = newChildren.next())
            step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
          step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
        "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              a: {
                for (var key2 = newChild.key; null !== currentFirstChild; ) {
                  if (currentFirstChild.key === key2) {
                    key2 = newChild.type;
                    if (key2 === REACT_FRAGMENT_TYPE) {
                      if (7 === currentFirstChild.tag) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(
                          currentFirstChild,
                          newChild.props.children
                        );
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      }
                    } else if (currentFirstChild.elementType === key2 || "object" === typeof key2 && null !== key2 && key2.$$typeof === REACT_LAZY_TYPE && resolveLazy(key2) === currentFirstChild.type) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(currentFirstChild, newChild.props);
                      coerceRef(lanes, newChild);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    }
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  } else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                  newChild.props.children,
                  returnFiber.mode,
                  lanes,
                  newChild.key
                ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
              }
              return placeSingleChild(returnFiber);
            case REACT_PORTAL_TYPE:
              a: {
                for (key2 = newChild.key; null !== currentFirstChild; ) {
                  if (currentFirstChild.key === key2)
                    if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(currentFirstChild, newChild.children || []);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    } else {
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    }
                  else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                lanes.return = returnFiber;
                returnFiber = lanes;
              }
              return placeSingleChild(returnFiber);
            case REACT_LAZY_TYPE:
              return key2 = newChild._init, newChild = key2(newChild._payload), reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
          }
          if (isArrayImpl(newChild))
            return reconcileChildrenArray(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
          if (getIteratorFn(newChild)) {
            key2 = getIteratorFn(newChild);
            if ("function" !== typeof key2) throw Error(formatProdErrorMessage(150));
            newChild = key2.call(newChild);
            return reconcileChildrenIterator(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
          }
          if ("function" === typeof newChild.then)
            return reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              unwrapThenable(newChild),
              lanes
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
      }
      return function(returnFiber, currentFirstChild, newChild, lanes) {
        try {
          thenableIndexCounter = 0;
          var firstChildFiber = reconcileChildFibersImpl(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes
          );
          thenableState = null;
          return firstChildFiber;
        } catch (x2) {
          if (x2 === SuspenseException || x2 === SuspenseActionException) throw x2;
          var fiber = createFiberImplClass(29, x2, null, returnFiber.mode);
          fiber.lanes = lanes;
          fiber.return = returnFiber;
          return fiber;
        } finally {
        }
      };
    }
    var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null;
    function pushPrimaryTreeSuspenseHandler(handler) {
      var current = handler.alternate;
      push(suspenseStackCursor, suspenseStackCursor.current & 1);
      push(suspenseHandlerStackCursor, handler);
      null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
    }
    function pushOffscreenSuspenseHandler(fiber) {
      if (22 === fiber.tag) {
        if (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary) {
          var current = fiber.alternate;
          null !== current && null !== current.memoizedState && (shellBoundary = fiber);
        }
      } else reuseSuspenseHandlerOnStack();
    }
    function reuseSuspenseHandlerOnStack() {
      push(suspenseStackCursor, suspenseStackCursor.current);
      push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
    }
    function popSuspenseHandler(fiber) {
      pop(suspenseHandlerStackCursor);
      shellBoundary === fiber && (shellBoundary = null);
      pop(suspenseStackCursor);
    }
    var suspenseStackCursor = createCursor(0);
    function findFirstSuspended(row) {
      for (var node = row; null !== node; ) {
        if (13 === node.tag) {
          var state = node.memoizedState;
          if (null !== state && (state = state.dehydrated, null === state || "$?" === state.data || isSuspenseInstanceFallback(state)))
            return node;
        } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
          if (0 !== (node.flags & 128)) return node;
        } else if (null !== node.child) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === row) break;
        for (; null === node.sibling; ) {
          if (null === node.return || node.return === row) return null;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
      return null;
    }
    function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
      ctor = workInProgress2.memoizedState;
      getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
      getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign2({}, ctor, getDerivedStateFromProps);
      workInProgress2.memoizedState = getDerivedStateFromProps;
      0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
    }
    var classComponentUpdater = {
      enqueueSetState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(), update = createUpdate(lane);
        update.payload = payload;
        void 0 !== callback && null !== callback && (update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
      },
      enqueueReplaceState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(), update = createUpdate(lane);
        update.tag = 1;
        update.payload = payload;
        void 0 !== callback && null !== callback && (update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
      },
      enqueueForceUpdate: function(inst, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(), update = createUpdate(lane);
        update.tag = 2;
        void 0 !== callback && null !== callback && (update.callback = callback);
        callback = enqueueUpdate(inst, update, lane);
        null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
      }
    };
    function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
      workInProgress2 = workInProgress2.stateNode;
      return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
    }
    function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
      workInProgress2 = instance.state;
      "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
      "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
      instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
    }
    function resolveClassComponentProps(Component, baseProps) {
      var newProps = baseProps;
      if ("ref" in baseProps) {
        newProps = {};
        for (var propName in baseProps)
          "ref" !== propName && (newProps[propName] = baseProps[propName]);
      }
      if (Component = Component.defaultProps) {
        newProps === baseProps && (newProps = assign2({}, newProps));
        for (var propName$73 in Component)
          void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
      }
      return newProps;
    }
    var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event)) return;
      } else if ("object" === typeof define_process_default2 && "function" === typeof define_process_default2.emit) {
        define_process_default2.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    };
    function defaultOnUncaughtError(error) {
      reportGlobalError(error);
    }
    function defaultOnCaughtError(error) {
      console.error(error);
    }
    function defaultOnRecoverableError(error) {
      reportGlobalError(error);
    }
    function logUncaughtError(root2, errorInfo) {
      try {
        var onUncaughtError = root2.onUncaughtError;
        onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
      } catch (e$74) {
        setTimeout(function() {
          throw e$74;
        });
      }
    }
    function logCaughtError(root2, boundary, errorInfo) {
      try {
        var onCaughtError = root2.onCaughtError;
        onCaughtError(errorInfo.value, {
          componentStack: errorInfo.stack,
          errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
        });
      } catch (e$75) {
        setTimeout(function() {
          throw e$75;
        });
      }
    }
    function createRootErrorUpdate(root2, errorInfo, lane) {
      lane = createUpdate(lane);
      lane.tag = 3;
      lane.payload = { element: null };
      lane.callback = function() {
        logUncaughtError(root2, errorInfo);
      };
      return lane;
    }
    function createClassErrorUpdate(lane) {
      lane = createUpdate(lane);
      lane.tag = 3;
      return lane;
    }
    function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
      var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
      if ("function" === typeof getDerivedStateFromError) {
        var error = errorInfo.value;
        update.payload = function() {
          return getDerivedStateFromError(error);
        };
        update.callback = function() {
          logCaughtError(root2, fiber, errorInfo);
        };
      }
      var inst = fiber.stateNode;
      null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
        logCaughtError(root2, fiber, errorInfo);
        "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
        var stack = errorInfo.stack;
        this.componentDidCatch(errorInfo.value, {
          componentStack: null !== stack ? stack : ""
        });
      });
    }
    function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
      sourceFiber.flags |= 32768;
      if (null !== value && "object" === typeof value && "function" === typeof value.then) {
        returnFiber = sourceFiber.alternate;
        null !== returnFiber && propagateParentContextChanges(
          returnFiber,
          sourceFiber,
          rootRenderLanes,
          true
        );
        sourceFiber = suspenseHandlerStackCursor.current;
        if (null !== sourceFiber) {
          switch (sourceFiber.tag) {
            case 13:
              return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
            case 22:
              return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                transitions: null,
                markerInstances: null,
                retryQueue: /* @__PURE__ */ new Set([value])
              }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
          }
          throw Error(formatProdErrorMessage(435, sourceFiber.tag));
        }
        attachPingListener(root2, value, rootRenderLanes);
        renderDidSuspendDelayIfPossible();
        return false;
      }
      if (isHydrating)
        return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root2 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root2, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
          cause: value
        }), queueHydrationError(
          createCapturedValueAtFiber(returnFiber, sourceFiber)
        )), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
          root2.stateNode,
          value,
          rootRenderLanes
        ), enqueueCapturedUpdate(root2, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
      var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
      wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
      null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
      4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
      if (null === returnFiber) return true;
      value = createCapturedValueAtFiber(value, sourceFiber);
      sourceFiber = returnFiber;
      do {
        switch (sourceFiber.tag) {
          case 3:
            return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(sourceFiber.stateNode, value, root2), enqueueCapturedUpdate(sourceFiber, root2), false;
          case 1:
            if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
              return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                rootRenderLanes,
                root2,
                sourceFiber,
                value
              ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
        }
        sourceFiber = sourceFiber.return;
      } while (null !== sourceFiber);
      return false;
    }
    var SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = false;
    function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
      workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
        workInProgress2,
        current.child,
        nextChildren,
        renderLanes2
      );
    }
    function updateForwardRef(current, workInProgress2, Component, nextProps, renderLanes2) {
      Component = Component.render;
      var ref = workInProgress2.ref;
      if ("ref" in nextProps) {
        var propsWithoutRef = {};
        for (var key2 in nextProps)
          "ref" !== key2 && (propsWithoutRef[key2] = nextProps[key2]);
      } else propsWithoutRef = nextProps;
      prepareToReadContext(workInProgress2);
      nextProps = renderWithHooks(
        current,
        workInProgress2,
        Component,
        propsWithoutRef,
        ref,
        renderLanes2
      );
      key2 = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      isHydrating && key2 && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    function updateMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
      if (null === current) {
        var type = Component.type;
        if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
          return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
            current,
            workInProgress2,
            type,
            nextProps,
            renderLanes2
          );
        current = createFiberFromTypeAndProps(
          Component.type,
          null,
          nextProps,
          workInProgress2,
          workInProgress2.mode,
          renderLanes2
        );
        current.ref = workInProgress2.ref;
        current.return = workInProgress2;
        return workInProgress2.child = current;
      }
      type = current.child;
      if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
        var prevProps = type.memoizedProps;
        Component = Component.compare;
        Component = null !== Component ? Component : shallowEqual;
        if (Component(prevProps, nextProps) && current.ref === workInProgress2.ref)
          return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      workInProgress2.flags |= 1;
      current = createWorkInProgress(type, nextProps);
      current.ref = workInProgress2.ref;
      current.return = workInProgress2;
      return workInProgress2.child = current;
    }
    function updateSimpleMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
      if (null !== current) {
        var prevProps = current.memoizedProps;
        if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
          if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
            0 !== (current.flags & 131072) && (didReceiveUpdate = true);
          else
            return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      return updateFunctionComponent(
        current,
        workInProgress2,
        Component,
        nextProps,
        renderLanes2
      );
    }
    function updateOffscreenComponent(current, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
      if ("hidden" === nextProps.mode) {
        if (0 !== (workInProgress2.flags & 128)) {
          nextProps = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
          if (null !== current) {
            nextChildren = workInProgress2.child = current.child;
            for (prevState = 0; null !== nextChildren; )
              prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
            workInProgress2.childLanes = prevState & ~nextProps;
          } else workInProgress2.childLanes = 0, workInProgress2.child = null;
          return deferHiddenOffscreenComponent(
            current,
            workInProgress2,
            nextProps,
            renderLanes2
          );
        }
        if (0 !== (renderLanes2 & 536870912))
          workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
            workInProgress2,
            null !== prevState ? prevState.cachePool : null
          ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
        else
          return workInProgress2.lanes = workInProgress2.childLanes = 536870912, deferHiddenOffscreenComponent(
            current,
            workInProgress2,
            null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
            renderLanes2
          );
      } else
        null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack());
      reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2) {
      var JSCompiler_inline_result = peekCacheFromPool();
      JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
      workInProgress2.memoizedState = {
        baseLanes: nextBaseLanes,
        cachePool: JSCompiler_inline_result
      };
      null !== current && pushTransition(workInProgress2, null);
      reuseHiddenContextOnStack();
      pushOffscreenSuspenseHandler(workInProgress2);
      null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
      return null;
    }
    function markRef(current, workInProgress2) {
      var ref = workInProgress2.ref;
      if (null === ref)
        null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
      else {
        if ("function" !== typeof ref && "object" !== typeof ref)
          throw Error(formatProdErrorMessage(284));
        if (null === current || current.ref !== ref)
          workInProgress2.flags |= 4194816;
      }
    }
    function updateFunctionComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
      prepareToReadContext(workInProgress2);
      Component = renderWithHooks(
        current,
        workInProgress2,
        Component,
        nextProps,
        void 0,
        renderLanes2
      );
      nextProps = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current, workInProgress2, Component, renderLanes2);
      return workInProgress2.child;
    }
    function replayFunctionComponent(current, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
      prepareToReadContext(workInProgress2);
      workInProgress2.updateQueue = null;
      nextProps = renderWithHooksAgain(
        workInProgress2,
        Component,
        nextProps,
        secondArg
      );
      finishRenderingHooks(current);
      Component = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      isHydrating && Component && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    function updateClassComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
      prepareToReadContext(workInProgress2);
      if (null === workInProgress2.stateNode) {
        var context = emptyContextObject, contextType = Component.contextType;
        "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
        context = new Component(nextProps, context);
        workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
        context.updater = classComponentUpdater;
        workInProgress2.stateNode = context;
        context._reactInternals = workInProgress2;
        context = workInProgress2.stateNode;
        context.props = nextProps;
        context.state = workInProgress2.memoizedState;
        context.refs = {};
        initializeUpdateQueue(workInProgress2);
        contextType = Component.contextType;
        context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
        context.state = workInProgress2.memoizedState;
        contextType = Component.getDerivedStateFromProps;
        "function" === typeof contextType && (applyDerivedStateFromProps(
          workInProgress2,
          Component,
          contextType,
          nextProps
        ), context.state = workInProgress2.memoizedState);
        "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
        "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
        nextProps = true;
      } else if (null === current) {
        context = workInProgress2.stateNode;
        var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
        context.props = oldProps;
        var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
        contextType = emptyContextObject;
        "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
        var getDerivedStateFromProps = Component.getDerivedStateFromProps;
        contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
        unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
        contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
          workInProgress2,
          context,
          nextProps,
          contextType
        );
        hasForceUpdate = false;
        var oldState = workInProgress2.memoizedState;
        context.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        oldContext = workInProgress2.memoizedState;
        unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
          workInProgress2,
          Component,
          getDerivedStateFromProps,
          nextProps
        ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
          workInProgress2,
          Component,
          oldProps,
          nextProps,
          oldState,
          oldContext,
          contextType
        )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
      } else {
        context = workInProgress2.stateNode;
        cloneUpdateQueue(current, workInProgress2);
        contextType = workInProgress2.memoizedProps;
        contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
        context.props = contextType$jscomp$0;
        getDerivedStateFromProps = workInProgress2.pendingProps;
        oldState = context.context;
        oldContext = Component.contextType;
        oldProps = emptyContextObject;
        "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
        unresolvedOldProps = Component.getDerivedStateFromProps;
        (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
          workInProgress2,
          context,
          nextProps,
          oldProps
        );
        hasForceUpdate = false;
        oldState = workInProgress2.memoizedState;
        context.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        var newState = workInProgress2.memoizedState;
        contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
          workInProgress2,
          Component,
          unresolvedOldProps,
          nextProps
        ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
          workInProgress2,
          Component,
          contextType$jscomp$0,
          nextProps,
          oldState,
          newState,
          oldProps
        ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
          nextProps,
          newState,
          oldProps
        )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
      }
      context = nextProps;
      markRef(current, workInProgress2);
      nextProps = 0 !== (workInProgress2.flags & 128);
      context || nextProps ? (context = workInProgress2.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
        workInProgress2,
        current.child,
        null,
        renderLanes2
      ), workInProgress2.child = reconcileChildFibers(
        workInProgress2,
        null,
        Component,
        renderLanes2
      )) : reconcileChildren(current, workInProgress2, Component, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
        current,
        workInProgress2,
        renderLanes2
      );
      return current;
    }
    function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
      resetHydrationState();
      workInProgress2.flags |= 256;
      reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    var SUSPENDED_MARKER = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
    };
    function mountSuspenseOffscreenState(renderLanes2) {
      return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
    }
    function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
      current = null !== current ? current.childLanes & ~renderLanes2 : 0;
      primaryTreeDidDefer && (current |= workInProgressDeferredLane);
      return current;
    }
    function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
      (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
      JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
      JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
      workInProgress2.flags &= -33;
      if (null === current) {
        if (isHydrating) {
          showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack();
          if (isHydrating) {
            var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;
            if (JSCompiler_temp$jscomp$0 = nextInstance) {
              c: {
                JSCompiler_temp$jscomp$0 = nextInstance;
                for (nextInstance = rootOrSingletonContext; 8 !== JSCompiler_temp$jscomp$0.nodeType; ) {
                  if (!nextInstance) {
                    nextInstance = null;
                    break c;
                  }
                  JSCompiler_temp$jscomp$0 = getNextHydratable(
                    JSCompiler_temp$jscomp$0.nextSibling
                  );
                  if (null === JSCompiler_temp$jscomp$0) {
                    nextInstance = null;
                    break c;
                  }
                }
                nextInstance = JSCompiler_temp$jscomp$0;
              }
              null !== nextInstance ? (workInProgress2.memoizedState = {
                dehydrated: nextInstance,
                treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
                retryLane: 536870912,
                hydrationErrors: null
              }, JSCompiler_temp$jscomp$0 = createFiberImplClass(
                18,
                null,
                null,
                0
              ), JSCompiler_temp$jscomp$0.stateNode = nextInstance, JSCompiler_temp$jscomp$0.return = workInProgress2, workInProgress2.child = JSCompiler_temp$jscomp$0, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = true) : JSCompiler_temp$jscomp$0 = false;
            }
            JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress2);
          }
          nextInstance = workInProgress2.memoizedState;
          if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance))
            return isSuspenseInstanceFallback(nextInstance) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912, null;
          popSuspenseHandler(workInProgress2);
        }
        nextInstance = nextProps.children;
        nextProps = nextProps.fallback;
        if (showFallback)
          return reuseSuspenseHandlerOnStack(), showFallback = workInProgress2.mode, nextInstance = mountWorkInProgressOffscreenFiber(
            { mode: "hidden", children: nextInstance },
            showFallback
          ), nextProps = createFiberFromFragment(
            nextProps,
            showFallback,
            renderLanes2,
            null
          ), nextInstance.return = workInProgress2, nextProps.return = workInProgress2, nextInstance.sibling = nextProps, workInProgress2.child = nextInstance, showFallback = workInProgress2.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes2), showFallback.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        return mountSuspensePrimaryChildren(workInProgress2, nextInstance);
      }
      JSCompiler_temp$jscomp$0 = current.memoizedState;
      if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {
        if (didSuspend)
          workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
            { mode: "visible", children: nextProps.children },
            nextInstance
          ), showFallback = createFiberFromFragment(
            showFallback,
            nextInstance,
            renderLanes2,
            null
          ), showFallback.flags |= 2, nextProps.return = workInProgress2, showFallback.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, reconcileChildFibers(
            workInProgress2,
            current.child,
            null,
            renderLanes2
          ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = showFallback);
        else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextInstance)) {
          JSCompiler_temp = nextInstance.nextSibling && nextInstance.nextSibling.dataset;
          if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
          JSCompiler_temp = digest;
          nextProps = Error(formatProdErrorMessage(419));
          nextProps.stack = "";
          nextProps.digest = JSCompiler_temp;
          queueHydrationError({ value: nextProps, source: null, stack: null });
          workInProgress2 = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          );
        } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
          JSCompiler_temp = workInProgressRoot;
          if (null !== JSCompiler_temp && (nextProps = renderLanes2 & -renderLanes2, nextProps = 0 !== (nextProps & 42) ? 1 : getBumpedLaneForHydrationByLane(nextProps), nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes2)) ? 0 : nextProps, 0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane))
            throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
          "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();
          workInProgress2 = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          );
        } else
          "$?" === nextInstance.data ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = JSCompiler_temp$jscomp$0.treeContext, nextHydratableInstance = getNextHydratable(
            nextInstance.nextSibling
          ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && (idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress2), workInProgress2 = mountSuspensePrimaryChildren(
            workInProgress2,
            nextProps.children
          ), workInProgress2.flags |= 4096);
        return workInProgress2;
      }
      if (showFallback)
        return reuseSuspenseHandlerOnStack(), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, JSCompiler_temp$jscomp$0 = current.child, digest = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
          mode: "hidden",
          children: nextProps.children
        }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 65011712, null !== digest ? showFallback = createWorkInProgress(digest, showFallback) : (showFallback = createFiberFromFragment(
          showFallback,
          nextInstance,
          renderLanes2,
          null
        ), showFallback.flags |= 2), showFallback.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, nextProps = showFallback, showFallback = workInProgress2.child, nextInstance = current.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes2) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (digest = CacheContext._currentValue, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== digest ? { parent: digest, pool: digest } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {
          baseLanes: nextInstance.baseLanes | renderLanes2,
          cachePool: JSCompiler_temp$jscomp$0
        }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(
          current,
          JSCompiler_temp,
          renderLanes2
        ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
      pushPrimaryTreeSuspenseHandler(workInProgress2);
      renderLanes2 = current.child;
      current = renderLanes2.sibling;
      renderLanes2 = createWorkInProgress(renderLanes2, {
        mode: "visible",
        children: nextProps.children
      });
      renderLanes2.return = workInProgress2;
      renderLanes2.sibling = null;
      null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
      workInProgress2.child = renderLanes2;
      workInProgress2.memoizedState = null;
      return renderLanes2;
    }
    function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
      primaryChildren = mountWorkInProgressOffscreenFiber(
        { mode: "visible", children: primaryChildren },
        workInProgress2.mode
      );
      primaryChildren.return = workInProgress2;
      return workInProgress2.child = primaryChildren;
    }
    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
      offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
      offscreenProps.lanes = 0;
      offscreenProps.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      };
      return offscreenProps;
    }
    function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
      reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
      current = mountSuspensePrimaryChildren(
        workInProgress2,
        workInProgress2.pendingProps.children
      );
      current.flags |= 2;
      workInProgress2.memoizedState = null;
      return current;
    }
    function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
      fiber.lanes |= renderLanes2;
      var alternate = fiber.alternate;
      null !== alternate && (alternate.lanes |= renderLanes2);
      scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
    }
    function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
      var renderState = workInProgress2.memoizedState;
      null === renderState ? workInProgress2.memoizedState = {
        isBackwards,
        rendering: null,
        renderingStartTime: 0,
        last: lastContentRow,
        tail,
        tailMode
      } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
    }
    function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
      reconcileChildren(current, workInProgress2, nextProps.children, renderLanes2);
      nextProps = suspenseStackCursor.current;
      if (0 !== (nextProps & 2))
        nextProps = nextProps & 1 | 2, workInProgress2.flags |= 128;
      else {
        if (null !== current && 0 !== (current.flags & 128))
          a: for (current = workInProgress2.child; null !== current; ) {
            if (13 === current.tag)
              null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
            else if (19 === current.tag)
              scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
            else if (null !== current.child) {
              current.child.return = current;
              current = current.child;
              continue;
            }
            if (current === workInProgress2) break a;
            for (; null === current.sibling; ) {
              if (null === current.return || current.return === workInProgress2)
                break a;
              current = current.return;
            }
            current.sibling.return = current.return;
            current = current.sibling;
          }
        nextProps &= 1;
      }
      push(suspenseStackCursor, nextProps);
      switch (revealOrder) {
        case "forwards":
          renderLanes2 = workInProgress2.child;
          for (revealOrder = null; null !== renderLanes2; )
            current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
          renderLanes2 = revealOrder;
          null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
          initSuspenseListRenderState(
            workInProgress2,
            false,
            revealOrder,
            renderLanes2,
            tailMode
          );
          break;
        case "backwards":
          renderLanes2 = null;
          revealOrder = workInProgress2.child;
          for (workInProgress2.child = null; null !== revealOrder; ) {
            current = revealOrder.alternate;
            if (null !== current && null === findFirstSuspended(current)) {
              workInProgress2.child = revealOrder;
              break;
            }
            current = revealOrder.sibling;
            revealOrder.sibling = renderLanes2;
            renderLanes2 = revealOrder;
            revealOrder = current;
          }
          initSuspenseListRenderState(
            workInProgress2,
            true,
            renderLanes2,
            null,
            tailMode
          );
          break;
        case "together":
          initSuspenseListRenderState(workInProgress2, false, null, null, void 0);
          break;
        default:
          workInProgress2.memoizedState = null;
      }
      return workInProgress2.child;
    }
    function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
      null !== current && (workInProgress2.dependencies = current.dependencies);
      workInProgressRootSkippedLanes |= workInProgress2.lanes;
      if (0 === (renderLanes2 & workInProgress2.childLanes))
        if (null !== current) {
          if (propagateParentContextChanges(
            current,
            workInProgress2,
            renderLanes2,
            false
          ), 0 === (renderLanes2 & workInProgress2.childLanes))
            return null;
        } else return null;
      if (null !== current && workInProgress2.child !== current.child)
        throw Error(formatProdErrorMessage(153));
      if (null !== workInProgress2.child) {
        current = workInProgress2.child;
        renderLanes2 = createWorkInProgress(current, current.pendingProps);
        workInProgress2.child = renderLanes2;
        for (renderLanes2.return = workInProgress2; null !== current.sibling; )
          current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
      }
      return workInProgress2.child;
    }
    function checkScheduledUpdateOrContext(current, renderLanes2) {
      if (0 !== (current.lanes & renderLanes2)) return true;
      current = current.dependencies;
      return null !== current && checkIfContextChanged(current) ? true : false;
    }
    function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
      switch (workInProgress2.tag) {
        case 3:
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
          resetHydrationState();
          break;
        case 27:
        case 5:
          pushHostContext(workInProgress2);
          break;
        case 4:
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          break;
        case 10:
          pushProvider(
            workInProgress2,
            workInProgress2.type,
            workInProgress2.memoizedProps.value
          );
          break;
        case 13:
          var state = workInProgress2.memoizedState;
          if (null !== state) {
            if (null !== state.dehydrated)
              return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
            if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
              return updateSuspenseComponent(current, workInProgress2, renderLanes2);
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            current = bailoutOnAlreadyFinishedWork(
              current,
              workInProgress2,
              renderLanes2
            );
            return null !== current ? current.sibling : null;
          }
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          break;
        case 19:
          var didSuspendBefore = 0 !== (current.flags & 128);
          state = 0 !== (renderLanes2 & workInProgress2.childLanes);
          state || (propagateParentContextChanges(
            current,
            workInProgress2,
            renderLanes2,
            false
          ), state = 0 !== (renderLanes2 & workInProgress2.childLanes));
          if (didSuspendBefore) {
            if (state)
              return updateSuspenseListComponent(
                current,
                workInProgress2,
                renderLanes2
              );
            workInProgress2.flags |= 128;
          }
          didSuspendBefore = workInProgress2.memoizedState;
          null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
          push(suspenseStackCursor, suspenseStackCursor.current);
          if (state) break;
          else return null;
        case 22:
        case 23:
          return workInProgress2.lanes = 0, updateOffscreenComponent(current, workInProgress2, renderLanes2);
        case 24:
          pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
      }
      return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    }
    function beginWork(current, workInProgress2, renderLanes2) {
      if (null !== current)
        if (current.memoizedProps !== workInProgress2.pendingProps)
          didReceiveUpdate = true;
        else {
          if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
            return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
              current,
              workInProgress2,
              renderLanes2
            );
          didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
        }
      else
        didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
      workInProgress2.lanes = 0;
      switch (workInProgress2.tag) {
        case 16:
          a: {
            current = workInProgress2.pendingProps;
            var lazyComponent = workInProgress2.elementType, init2 = lazyComponent._init;
            lazyComponent = init2(lazyComponent._payload);
            workInProgress2.type = lazyComponent;
            if ("function" === typeof lazyComponent)
              shouldConstruct(lazyComponent) ? (current = resolveClassComponentProps(lazyComponent, current), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
                null,
                workInProgress2,
                lazyComponent,
                current,
                renderLanes2
              )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
                null,
                workInProgress2,
                lazyComponent,
                current,
                renderLanes2
              ));
            else {
              if (void 0 !== lazyComponent && null !== lazyComponent) {
                if (init2 = lazyComponent.$$typeof, init2 === REACT_FORWARD_REF_TYPE) {
                  workInProgress2.tag = 11;
                  workInProgress2 = updateForwardRef(
                    null,
                    workInProgress2,
                    lazyComponent,
                    current,
                    renderLanes2
                  );
                  break a;
                } else if (init2 === REACT_MEMO_TYPE) {
                  workInProgress2.tag = 14;
                  workInProgress2 = updateMemoComponent(
                    null,
                    workInProgress2,
                    lazyComponent,
                    current,
                    renderLanes2
                  );
                  break a;
                }
              }
              workInProgress2 = getComponentNameFromType(lazyComponent) || lazyComponent;
              throw Error(formatProdErrorMessage(306, workInProgress2, ""));
            }
          }
          return workInProgress2;
        case 0:
          return updateFunctionComponent(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 1:
          return lazyComponent = workInProgress2.type, init2 = resolveClassComponentProps(
            lazyComponent,
            workInProgress2.pendingProps
          ), updateClassComponent(
            current,
            workInProgress2,
            lazyComponent,
            init2,
            renderLanes2
          );
        case 3:
          a: {
            pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            );
            if (null === current) throw Error(formatProdErrorMessage(387));
            lazyComponent = workInProgress2.pendingProps;
            var prevState = workInProgress2.memoizedState;
            init2 = prevState.element;
            cloneUpdateQueue(current, workInProgress2);
            processUpdateQueue(workInProgress2, lazyComponent, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            lazyComponent = nextState.cache;
            pushProvider(workInProgress2, CacheContext, lazyComponent);
            lazyComponent !== prevState.cache && propagateContextChanges(
              workInProgress2,
              [CacheContext],
              renderLanes2,
              true
            );
            suspendIfUpdateReadFromEntangledAsyncAction();
            lazyComponent = nextState.element;
            if (prevState.isDehydrated)
              if (prevState = {
                element: lazyComponent,
                isDehydrated: false,
                cache: nextState.cache
              }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                workInProgress2 = mountHostRootWithoutHydrating(
                  current,
                  workInProgress2,
                  lazyComponent,
                  renderLanes2
                );
                break a;
              } else if (lazyComponent !== init2) {
                init2 = createCapturedValueAtFiber(
                  Error(formatProdErrorMessage(424)),
                  workInProgress2
                );
                queueHydrationError(init2);
                workInProgress2 = mountHostRootWithoutHydrating(
                  current,
                  workInProgress2,
                  lazyComponent,
                  renderLanes2
                );
                break a;
              } else {
                current = workInProgress2.stateNode.containerInfo;
                switch (current.nodeType) {
                  case 9:
                    current = current.body;
                    break;
                  default:
                    current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
                }
                nextHydratableInstance = getNextHydratable(current.firstChild);
                hydrationParentFiber = workInProgress2;
                isHydrating = true;
                hydrationErrors = null;
                rootOrSingletonContext = true;
                renderLanes2 = mountChildFibers(
                  workInProgress2,
                  null,
                  lazyComponent,
                  renderLanes2
                );
                for (workInProgress2.child = renderLanes2; renderLanes2; )
                  renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
              }
            else {
              resetHydrationState();
              if (lazyComponent === init2) {
                workInProgress2 = bailoutOnAlreadyFinishedWork(
                  current,
                  workInProgress2,
                  renderLanes2
                );
                break a;
              }
              reconcileChildren(
                current,
                workInProgress2,
                lazyComponent,
                renderLanes2
              );
            }
            workInProgress2 = workInProgress2.child;
          }
          return workInProgress2;
        case 26:
          return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
            workInProgress2.type,
            null,
            workInProgress2.pendingProps,
            null
          )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, lazyComponent = getOwnerDocumentFromRootContainer(
            rootInstanceStackCursor.current
          ).createElement(renderLanes2), lazyComponent[internalInstanceKey] = workInProgress2, lazyComponent[internalPropsKey] = current, setInitialProperties(lazyComponent, renderLanes2, current), markNodeAsHoistable(lazyComponent), workInProgress2.stateNode = lazyComponent) : workInProgress2.memoizedState = getResource(
            workInProgress2.type,
            current.memoizedProps,
            workInProgress2.pendingProps,
            current.memoizedState
          ), null;
        case 27:
          return pushHostContext(workInProgress2), null === current && isHydrating && (lazyComponent = workInProgress2.stateNode = resolveSingletonInstance(
            workInProgress2.type,
            workInProgress2.pendingProps,
            rootInstanceStackCursor.current
          ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, init2 = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = init2, nextHydratableInstance = getNextHydratable(
            lazyComponent.firstChild
          )) : nextHydratableInstance = init2), reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
        case 5:
          if (null === current && isHydrating) {
            if (init2 = lazyComponent = nextHydratableInstance)
              lazyComponent = canHydrateInstance(
                lazyComponent,
                workInProgress2.type,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== lazyComponent ? (workInProgress2.stateNode = lazyComponent, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
                lazyComponent.firstChild
              ), rootOrSingletonContext = false, init2 = true) : init2 = false;
            init2 || throwOnHydrationMismatch(workInProgress2);
          }
          pushHostContext(workInProgress2);
          init2 = workInProgress2.type;
          prevState = workInProgress2.pendingProps;
          nextState = null !== current ? current.memoizedProps : null;
          lazyComponent = prevState.children;
          shouldSetTextContent(init2, prevState) ? lazyComponent = null : null !== nextState && shouldSetTextContent(init2, nextState) && (workInProgress2.flags |= 32);
          null !== workInProgress2.memoizedState && (init2 = renderWithHooks(
            current,
            workInProgress2,
            TransitionAwareHostComponent,
            null,
            null,
            renderLanes2
          ), HostTransitionContext._currentValue = init2);
          markRef(current, workInProgress2);
          reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2);
          return workInProgress2.child;
        case 6:
          if (null === current && isHydrating) {
            if (current = renderLanes2 = nextHydratableInstance)
              renderLanes2 = canHydrateTextInstance(
                renderLanes2,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
            current || throwOnHydrationMismatch(workInProgress2);
          }
          return null;
        case 13:
          return updateSuspenseComponent(current, workInProgress2, renderLanes2);
        case 4:
          return pushHostContainer(
            workInProgress2,
            workInProgress2.stateNode.containerInfo
          ), lazyComponent = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
            workInProgress2,
            null,
            lazyComponent,
            renderLanes2
          ) : reconcileChildren(
            current,
            workInProgress2,
            lazyComponent,
            renderLanes2
          ), workInProgress2.child;
        case 11:
          return updateForwardRef(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 7:
          return reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps,
            renderLanes2
          ), workInProgress2.child;
        case 8:
          return reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), workInProgress2.child;
        case 12:
          return reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), workInProgress2.child;
        case 10:
          return lazyComponent = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, lazyComponent.value), reconcileChildren(
            current,
            workInProgress2,
            lazyComponent.children,
            renderLanes2
          ), workInProgress2.child;
        case 9:
          return init2 = workInProgress2.type._context, lazyComponent = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), init2 = readContext(init2), lazyComponent = lazyComponent(init2), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2), workInProgress2.child;
        case 14:
          return updateMemoComponent(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 15:
          return updateSimpleMemoComponent(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 19:
          return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
        case 31:
          return lazyComponent = workInProgress2.pendingProps, renderLanes2 = workInProgress2.mode, lazyComponent = {
            mode: lazyComponent.mode,
            children: lazyComponent.children
          }, null === current ? (renderLanes2 = mountWorkInProgressOffscreenFiber(
            lazyComponent,
            renderLanes2
          ), renderLanes2.ref = workInProgress2.ref, workInProgress2.child = renderLanes2, renderLanes2.return = workInProgress2, workInProgress2 = renderLanes2) : (renderLanes2 = createWorkInProgress(current.child, lazyComponent), renderLanes2.ref = workInProgress2.ref, workInProgress2.child = renderLanes2, renderLanes2.return = workInProgress2, workInProgress2 = renderLanes2), workInProgress2;
        case 22:
          return updateOffscreenComponent(current, workInProgress2, renderLanes2);
        case 24:
          return prepareToReadContext(workInProgress2), lazyComponent = readContext(CacheContext), null === current ? (init2 = peekCacheFromPool(), null === init2 && (init2 = workInProgressRoot, prevState = createCache(), init2.pooledCache = prevState, prevState.refCount++, null !== prevState && (init2.pooledCacheLanes |= renderLanes2), init2 = prevState), workInProgress2.memoizedState = {
            parent: lazyComponent,
            cache: init2
          }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, init2)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), init2 = current.memoizedState, prevState = workInProgress2.memoizedState, init2.parent !== lazyComponent ? (init2 = { parent: lazyComponent, cache: lazyComponent }, workInProgress2.memoizedState = init2, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = init2), pushProvider(workInProgress2, CacheContext, lazyComponent)) : (lazyComponent = prevState.cache, pushProvider(workInProgress2, CacheContext, lazyComponent), lazyComponent !== init2.cache && propagateContextChanges(
            workInProgress2,
            [CacheContext],
            renderLanes2,
            true
          ))), reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), workInProgress2.child;
        case 29:
          throw workInProgress2.pendingProps;
      }
      throw Error(formatProdErrorMessage(156, workInProgress2.tag));
    }
    function markUpdate(workInProgress2) {
      workInProgress2.flags |= 4;
    }
    function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
      if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
        workInProgress2.flags &= -16777217;
      else if (workInProgress2.flags |= 16777216, !preloadResource(resource)) {
        resource = suspenseHandlerStackCursor.current;
        if (null !== resource && ((workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary))
          throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
        workInProgress2.flags |= 8192;
      }
    }
    function scheduleRetryEffect(workInProgress2, retryQueue) {
      null !== retryQueue && (workInProgress2.flags |= 4);
      workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
    }
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
      if (!isHydrating)
        switch (renderState.tailMode) {
          case "hidden":
            hasRenderedATailFallback = renderState.tail;
            for (var lastTailNode = null; null !== hasRenderedATailFallback; )
              null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
            null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
            break;
          case "collapsed":
            lastTailNode = renderState.tail;
            for (var lastTailNode$113 = null; null !== lastTailNode; )
              null !== lastTailNode.alternate && (lastTailNode$113 = lastTailNode), lastTailNode = lastTailNode.sibling;
            null === lastTailNode$113 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$113.sibling = null;
        }
    }
    function bubbleProperties(completedWork) {
      var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
      if (didBailout)
        for (var child$114 = completedWork.child; null !== child$114; )
          newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags & 65011712, subtreeFlags |= child$114.flags & 65011712, child$114.return = completedWork, child$114 = child$114.sibling;
      else
        for (child$114 = completedWork.child; null !== child$114; )
          newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags, subtreeFlags |= child$114.flags, child$114.return = completedWork, child$114 = child$114.sibling;
      completedWork.subtreeFlags |= subtreeFlags;
      completedWork.childLanes = newChildLanes;
      return didBailout;
    }
    function completeWork(current, workInProgress2, renderLanes2) {
      var newProps = workInProgress2.pendingProps;
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 31:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return bubbleProperties(workInProgress2), null;
        case 1:
          return bubbleProperties(workInProgress2), null;
        case 3:
          renderLanes2 = workInProgress2.stateNode;
          newProps = null;
          null !== current && (newProps = current.memoizedState.cache);
          workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
          popProvider(CacheContext);
          popHostContainer();
          renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
          if (null === current || null === current.child)
            popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
          bubbleProperties(workInProgress2);
          return null;
        case 26:
          return renderLanes2 = workInProgress2.memoizedState, null === current ? (markUpdate(workInProgress2), null !== renderLanes2 ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217)) : renderLanes2 ? renderLanes2 !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current.memoizedProps !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217), null;
        case 27:
          popHostContext(workInProgress2);
          renderLanes2 = rootInstanceStackCursor.current;
          var type = workInProgress2.type;
          if (null !== current && null != workInProgress2.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if (!newProps) {
              if (null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              bubbleProperties(workInProgress2);
              return null;
            }
            current = contextStackCursor.current;
            popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
          }
          bubbleProperties(workInProgress2);
          return null;
        case 5:
          popHostContext(workInProgress2);
          renderLanes2 = workInProgress2.type;
          if (null !== current && null != workInProgress2.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if (!newProps) {
              if (null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              bubbleProperties(workInProgress2);
              return null;
            }
            current = contextStackCursor.current;
            if (popHydrationState(workInProgress2))
              prepareToHydrateHostInstance(workInProgress2);
            else {
              type = getOwnerDocumentFromRootContainer(
                rootInstanceStackCursor.current
              );
              switch (current) {
                case 1:
                  current = type.createElementNS(
                    "http://www.w3.org/2000/svg",
                    renderLanes2
                  );
                  break;
                case 2:
                  current = type.createElementNS(
                    "http://www.w3.org/1998/Math/MathML",
                    renderLanes2
                  );
                  break;
                default:
                  switch (renderLanes2) {
                    case "svg":
                      current = type.createElementNS(
                        "http://www.w3.org/2000/svg",
                        renderLanes2
                      );
                      break;
                    case "math":
                      current = type.createElementNS(
                        "http://www.w3.org/1998/Math/MathML",
                        renderLanes2
                      );
                      break;
                    case "script":
                      current = type.createElement("div");
                      current.innerHTML = "<script><\/script>";
                      current = current.removeChild(current.firstChild);
                      break;
                    case "select":
                      current = "string" === typeof newProps.is ? type.createElement("select", { is: newProps.is }) : type.createElement("select");
                      newProps.multiple ? current.multiple = true : newProps.size && (current.size = newProps.size);
                      break;
                    default:
                      current = "string" === typeof newProps.is ? type.createElement(renderLanes2, { is: newProps.is }) : type.createElement(renderLanes2);
                  }
              }
              current[internalInstanceKey] = workInProgress2;
              current[internalPropsKey] = newProps;
              a: for (type = workInProgress2.child; null !== type; ) {
                if (5 === type.tag || 6 === type.tag)
                  current.appendChild(type.stateNode);
                else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {
                  type.child.return = type;
                  type = type.child;
                  continue;
                }
                if (type === workInProgress2) break a;
                for (; null === type.sibling; ) {
                  if (null === type.return || type.return === workInProgress2)
                    break a;
                  type = type.return;
                }
                type.sibling.return = type.return;
                type = type.sibling;
              }
              workInProgress2.stateNode = current;
              a: switch (setInitialProperties(current, renderLanes2, newProps), renderLanes2) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  current = !!newProps.autoFocus;
                  break a;
                case "img":
                  current = true;
                  break a;
                default:
                  current = false;
              }
              current && markUpdate(workInProgress2);
            }
          }
          bubbleProperties(workInProgress2);
          workInProgress2.flags &= -16777217;
          return null;
        case 6:
          if (current && null != workInProgress2.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if ("string" !== typeof newProps && null === workInProgress2.stateNode)
              throw Error(formatProdErrorMessage(166));
            current = rootInstanceStackCursor.current;
            if (popHydrationState(workInProgress2)) {
              current = workInProgress2.stateNode;
              renderLanes2 = workInProgress2.memoizedProps;
              newProps = null;
              type = hydrationParentFiber;
              if (null !== type)
                switch (type.tag) {
                  case 27:
                  case 5:
                    newProps = type.memoizedProps;
                }
              current[internalInstanceKey] = workInProgress2;
              current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
              current || throwOnHydrationMismatch(workInProgress2);
            } else
              current = getOwnerDocumentFromRootContainer(current).createTextNode(
                newProps
              ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
          }
          bubbleProperties(workInProgress2);
          return null;
        case 13:
          newProps = workInProgress2.memoizedState;
          if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
            type = popHydrationState(workInProgress2);
            if (null !== newProps && null !== newProps.dehydrated) {
              if (null === current) {
                if (!type) throw Error(formatProdErrorMessage(318));
                type = workInProgress2.memoizedState;
                type = null !== type ? type.dehydrated : null;
                if (!type) throw Error(formatProdErrorMessage(317));
                type[internalInstanceKey] = workInProgress2;
              } else
                resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
              bubbleProperties(workInProgress2);
              type = false;
            } else
              type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
            if (!type) {
              if (workInProgress2.flags & 256)
                return popSuspenseHandler(workInProgress2), workInProgress2;
              popSuspenseHandler(workInProgress2);
              return null;
            }
          }
          popSuspenseHandler(workInProgress2);
          if (0 !== (workInProgress2.flags & 128))
            return workInProgress2.lanes = renderLanes2, workInProgress2;
          renderLanes2 = null !== newProps;
          current = null !== current && null !== current.memoizedState;
          if (renderLanes2) {
            newProps = workInProgress2.child;
            type = null;
            null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool);
            var cache$127 = null;
            null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (cache$127 = newProps.memoizedState.cachePool.pool);
            cache$127 !== type && (newProps.flags |= 2048);
          }
          renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
          scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
          bubbleProperties(workInProgress2);
          return null;
        case 4:
          return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
        case 10:
          return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
        case 19:
          pop(suspenseStackCursor);
          type = workInProgress2.memoizedState;
          if (null === type) return bubbleProperties(workInProgress2), null;
          newProps = 0 !== (workInProgress2.flags & 128);
          cache$127 = type.rendering;
          if (null === cache$127)
            if (newProps) cutOffTailIfNeeded(type, false);
            else {
              if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
                for (current = workInProgress2.child; null !== current; ) {
                  cache$127 = findFirstSuspended(current);
                  if (null !== cache$127) {
                    workInProgress2.flags |= 128;
                    cutOffTailIfNeeded(type, false);
                    current = cache$127.updateQueue;
                    workInProgress2.updateQueue = current;
                    scheduleRetryEffect(workInProgress2, current);
                    workInProgress2.subtreeFlags = 0;
                    current = renderLanes2;
                    for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                      resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                    push(
                      suspenseStackCursor,
                      suspenseStackCursor.current & 1 | 2
                    );
                    return workInProgress2.child;
                  }
                  current = current.sibling;
                }
              null !== type.tail && now() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress2.lanes = 4194304);
            }
          else {
            if (!newProps)
              if (current = findFirstSuspended(cache$127), null !== current) {
                if (workInProgress2.flags |= 128, newProps = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(type, true), null === type.tail && "hidden" === type.tailMode && !cache$127.alternate && !isHydrating)
                  return bubbleProperties(workInProgress2), null;
              } else
                2 * now() - type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress2.lanes = 4194304);
            type.isBackwards ? (cache$127.sibling = workInProgress2.child, workInProgress2.child = cache$127) : (current = type.last, null !== current ? current.sibling = cache$127 : workInProgress2.child = cache$127, type.last = cache$127);
          }
          if (null !== type.tail)
            return workInProgress2 = type.tail, type.rendering = workInProgress2, type.tail = workInProgress2.sibling, type.renderingStartTime = now(), workInProgress2.sibling = null, current = suspenseStackCursor.current, push(suspenseStackCursor, newProps ? current & 1 | 2 : current & 1), workInProgress2;
          bubbleProperties(workInProgress2);
          return null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
        case 24:
          return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error(formatProdErrorMessage(156, workInProgress2.tag));
    }
    function unwindWork(current, workInProgress2) {
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 1:
          return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 3:
          return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 26:
        case 27:
        case 5:
          return popHostContext(workInProgress2), null;
        case 13:
          popSuspenseHandler(workInProgress2);
          current = workInProgress2.memoizedState;
          if (null !== current && null !== current.dehydrated) {
            if (null === workInProgress2.alternate)
              throw Error(formatProdErrorMessage(340));
            resetHydrationState();
          }
          current = workInProgress2.flags;
          return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 19:
          return pop(suspenseStackCursor), null;
        case 4:
          return popHostContainer(), null;
        case 10:
          return popProvider(workInProgress2.type), null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 24:
          return popProvider(CacheContext), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function unwindInterruptedWork(current, interruptedWork) {
      popTreeContext(interruptedWork);
      switch (interruptedWork.tag) {
        case 3:
          popProvider(CacheContext);
          popHostContainer();
          break;
        case 26:
        case 27:
        case 5:
          popHostContext(interruptedWork);
          break;
        case 4:
          popHostContainer();
          break;
        case 13:
          popSuspenseHandler(interruptedWork);
          break;
        case 19:
          pop(suspenseStackCursor);
          break;
        case 10:
          popProvider(interruptedWork.type);
          break;
        case 22:
        case 23:
          popSuspenseHandler(interruptedWork);
          popHiddenContext();
          null !== current && pop(resumedCache);
          break;
        case 24:
          popProvider(CacheContext);
      }
    }
    function commitHookEffectListMount(flags, finishedWork) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              lastEffect = void 0;
              var create2 = updateQueue.create, inst = updateQueue.inst;
              lastEffect = create2();
              inst.destroy = lastEffect;
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              var inst = updateQueue.inst, destroy = inst.destroy;
              if (void 0 !== destroy) {
                inst.destroy = void 0;
                lastEffect = finishedWork;
                var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
                try {
                  destroy_();
                } catch (error) {
                  captureCommitPhaseError(
                    lastEffect,
                    nearestMountedAncestor,
                    error
                  );
                }
              }
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitClassCallbacks(finishedWork) {
      var updateQueue = finishedWork.updateQueue;
      if (null !== updateQueue) {
        var instance = finishedWork.stateNode;
        try {
          commitCallbacks(updateQueue, instance);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
      instance.props = resolveClassComponentProps(
        current.type,
        current.memoizedProps
      );
      instance.state = current.memoizedState;
      try {
        instance.componentWillUnmount();
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      }
    }
    function safelyAttachRef(current, nearestMountedAncestor) {
      try {
        var ref = current.ref;
        if (null !== ref) {
          switch (current.tag) {
            case 26:
            case 27:
            case 5:
              var instanceToUse = current.stateNode;
              break;
            case 30:
              instanceToUse = current.stateNode;
              break;
            default:
              instanceToUse = current.stateNode;
          }
          "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
        }
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      }
    }
    function safelyDetachRef(current, nearestMountedAncestor) {
      var ref = current.ref, refCleanup = current.refCleanup;
      if (null !== ref)
        if ("function" === typeof refCleanup)
          try {
            refCleanup();
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          } finally {
            current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
          }
        else if ("function" === typeof ref)
          try {
            ref(null);
          } catch (error$143) {
            captureCommitPhaseError(current, nearestMountedAncestor, error$143);
          }
        else ref.current = null;
    }
    function commitHostMount(finishedWork) {
      var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
      try {
        a: switch (type) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            props.autoFocus && instance.focus();
            break a;
          case "img":
            props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHostUpdate(finishedWork, newProps, oldProps) {
      try {
        var domElement = finishedWork.stateNode;
        updateProperties(domElement, finishedWork.type, oldProps, newProps);
        domElement[internalPropsKey] = newProps;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function isHostParent(fiber) {
      return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
    }
    function getHostSibling(fiber) {
      a: for (; ; ) {
        for (; null === fiber.sibling; ) {
          if (null === fiber.return || isHostParent(fiber.return)) return null;
          fiber = fiber.return;
        }
        fiber.sibling.return = fiber.return;
        for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
          if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
          if (fiber.flags & 2) continue a;
          if (null === fiber.child || 4 === fiber.tag) continue a;
          else fiber.child.return = fiber, fiber = fiber.child;
        }
        if (!(fiber.flags & 2)) return fiber.stateNode;
      }
    }
    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
      var tag = node.tag;
      if (5 === tag || 6 === tag)
        node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$12));
      else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
        for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
          insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
    }
    function insertOrAppendPlacementNode(node, before, parent) {
      var tag = node.tag;
      if (5 === tag || 6 === tag)
        node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
      else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
        for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
          insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
    }
    function commitHostSingletonAcquisition(finishedWork) {
      var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
      try {
        for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length; )
          singleton.removeAttributeNode(attributes[0]);
        setInitialProperties(singleton, type, props);
        singleton[internalInstanceKey] = finishedWork;
        singleton[internalPropsKey] = props;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null;
    function commitBeforeMutationEffects(root2, firstChild) {
      root2 = root2.containerInfo;
      eventsEnabled = _enabled;
      root2 = getActiveElementDeep(root2);
      if (hasSelectionCapabilities(root2)) {
        if ("selectionStart" in root2)
          var JSCompiler_temp = {
            start: root2.selectionStart,
            end: root2.selectionEnd
          };
        else
          a: {
            JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
            var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
            if (selection && 0 !== selection.rangeCount) {
              JSCompiler_temp = selection.anchorNode;
              var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
              selection = selection.focusOffset;
              try {
                JSCompiler_temp.nodeType, focusNode.nodeType;
              } catch (e$20) {
                JSCompiler_temp = null;
                break a;
              }
              var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode2 = null;
              b: for (; ; ) {
                for (var next; ; ) {
                  node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                  node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                  3 === node.nodeType && (length += node.nodeValue.length);
                  if (null === (next = node.firstChild)) break;
                  parentNode2 = node;
                  node = next;
                }
                for (; ; ) {
                  if (node === root2) break b;
                  parentNode2 === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                  parentNode2 === focusNode && ++indexWithinFocus === selection && (end = length);
                  if (null !== (next = node.nextSibling)) break;
                  node = parentNode2;
                  parentNode2 = node.parentNode;
                }
                node = next;
              }
              JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
            } else JSCompiler_temp = null;
          }
        JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
      } else JSCompiler_temp = null;
      selectionInformation = { focusedElem: root2, selectionRange: JSCompiler_temp };
      _enabled = false;
      for (nextEffect = firstChild; null !== nextEffect; )
        if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1024) && null !== root2)
          root2.return = firstChild, nextEffect = root2;
        else
          for (; null !== nextEffect; ) {
            firstChild = nextEffect;
            focusNode = firstChild.alternate;
            root2 = firstChild.flags;
            switch (firstChild.tag) {
              case 0:
                break;
              case 11:
              case 15:
                break;
              case 1:
                if (0 !== (root2 & 1024) && null !== focusNode) {
                  root2 = void 0;
                  JSCompiler_temp = firstChild;
                  anchorOffset = focusNode.memoizedProps;
                  focusNode = focusNode.memoizedState;
                  selection = JSCompiler_temp.stateNode;
                  try {
                    var resolvedPrevProps = resolveClassComponentProps(
                      JSCompiler_temp.type,
                      anchorOffset,
                      JSCompiler_temp.elementType === JSCompiler_temp.type
                    );
                    root2 = selection.getSnapshotBeforeUpdate(
                      resolvedPrevProps,
                      focusNode
                    );
                    selection.__reactInternalSnapshotBeforeUpdate = root2;
                  } catch (error) {
                    captureCommitPhaseError(
                      JSCompiler_temp,
                      JSCompiler_temp.return,
                      error
                    );
                  }
                }
                break;
              case 3:
                if (0 !== (root2 & 1024)) {
                  if (root2 = firstChild.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                    clearContainerSparingly(root2);
                  else if (1 === JSCompiler_temp)
                    switch (root2.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        clearContainerSparingly(root2);
                        break;
                      default:
                        root2.textContent = "";
                    }
                }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if (0 !== (root2 & 1024)) throw Error(formatProdErrorMessage(163));
            }
            root2 = firstChild.sibling;
            if (null !== root2) {
              root2.return = firstChild.return;
              nextEffect = root2;
              break;
            }
            nextEffect = firstChild.return;
          }
    }
    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitHookEffectListMount(5, finishedWork);
          break;
        case 1:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 4)
            if (finishedRoot = finishedWork.stateNode, null === current)
              try {
                finishedRoot.componentDidMount();
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            else {
              var prevProps = resolveClassComponentProps(
                finishedWork.type,
                current.memoizedProps
              );
              current = current.memoizedState;
              try {
                finishedRoot.componentDidUpdate(
                  prevProps,
                  current,
                  finishedRoot.__reactInternalSnapshotBeforeUpdate
                );
              } catch (error$142) {
                captureCommitPhaseError(
                  finishedWork,
                  finishedWork.return,
                  error$142
                );
              }
            }
          flags & 64 && commitClassCallbacks(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 3:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
            current = null;
            if (null !== finishedWork.child)
              switch (finishedWork.child.tag) {
                case 27:
                case 5:
                  current = finishedWork.child.stateNode;
                  break;
                case 1:
                  current = finishedWork.child.stateNode;
              }
            try {
              commitCallbacks(finishedRoot, current);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 27:
          null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          null === current && flags & 4 && commitHostMount(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
            null,
            finishedWork
          ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
          break;
        case 22:
          flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
          if (!flags) {
            current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
            prevProps = offscreenSubtreeIsHidden;
            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = flags;
            (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              0 !== (finishedWork.subtreeFlags & 8772)
            ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            offscreenSubtreeIsHidden = prevProps;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          }
          break;
        case 30:
          break;
        default:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      }
    }
    function detachFiberAfterEffects(fiber) {
      var alternate = fiber.alternate;
      null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
      fiber.child = null;
      fiber.deletions = null;
      fiber.sibling = null;
      5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
      fiber.stateNode = null;
      fiber.return = null;
      fiber.dependencies = null;
      fiber.memoizedProps = null;
      fiber.memoizedState = null;
      fiber.pendingProps = null;
      fiber.stateNode = null;
      fiber.updateQueue = null;
    }
    var hostParent = null, hostParentIsContainer = false;
    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
      for (parent = parent.child; null !== parent; )
        commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
    }
    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
      if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
        try {
          injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
        } catch (err2) {
        }
      switch (deletedFiber.tag) {
        case 26:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
          break;
        case 27:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
          isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          releaseSingletonInstance(deletedFiber.stateNode);
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 5:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        case 6:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = null;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          if (null !== hostParent)
            if (hostParentIsContainer)
              try {
                (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error
                );
              }
            else
              try {
                hostParent.removeChild(deletedFiber.stateNode);
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error
                );
              }
          break;
        case 18:
          null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearSuspenseBoundary(
            9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
            deletedFiber.stateNode
          ), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
          break;
        case 4:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = deletedFiber.stateNode.containerInfo;
          hostParentIsContainer = true;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          offscreenSubtreeWasHidden || commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
          offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 1:
          offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
            deletedFiber,
            nearestMountedAncestor,
            prevHostParent
          ));
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 21:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 22:
          offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          offscreenSubtreeWasHidden = prevHostParent;
          break;
        default:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
      }
    }
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
      if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
        try {
          retryIfBlockedOn(finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
    }
    function getRetryCache(finishedWork) {
      switch (finishedWork.tag) {
        case 13:
        case 19:
          var retryCache = finishedWork.stateNode;
          null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
          return retryCache;
        case 22:
          return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
        default:
          throw Error(formatProdErrorMessage(435, finishedWork.tag));
      }
    }
    function attachSuspenseRetryListeners(finishedWork, wakeables) {
      var retryCache = getRetryCache(finishedWork);
      wakeables.forEach(function(wakeable) {
        var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
        retryCache.has(wakeable) || (retryCache.add(wakeable), wakeable.then(retry, retry));
      });
    }
    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
      var deletions = parentFiber.deletions;
      if (null !== deletions)
        for (var i2 = 0; i2 < deletions.length; i2++) {
          var childToDelete = deletions[i2], root2 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
          a: for (; null !== parent; ) {
            switch (parent.tag) {
              case 27:
                if (isSingletonScope(parent.type)) {
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break a;
                }
                break;
              case 5:
                hostParent = parent.stateNode;
                hostParentIsContainer = false;
                break a;
              case 3:
              case 4:
                hostParent = parent.stateNode.containerInfo;
                hostParentIsContainer = true;
                break a;
            }
            parent = parent.return;
          }
          if (null === hostParent) throw Error(formatProdErrorMessage(160));
          commitDeletionEffectsOnFiber(root2, returnFiber, childToDelete);
          hostParent = null;
          hostParentIsContainer = false;
          root2 = childToDelete.alternate;
          null !== root2 && (root2.return = null);
          childToDelete.return = null;
        }
      if (parentFiber.subtreeFlags & 13878)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
    }
    var currentHoistableRoot = null;
    function commitMutationEffectsOnFiber(finishedWork, root2) {
      var current = finishedWork.alternate, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
          break;
        case 1:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
          break;
        case 26:
          var hoistableRoot = currentHoistableRoot;
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          if (flags & 4) {
            var currentResource = null !== current ? current.memoizedState : null;
            flags = finishedWork.memoizedState;
            if (null === current)
              if (null === flags)
                if (null === finishedWork.stateNode) {
                  a: {
                    flags = finishedWork.type;
                    current = finishedWork.memoizedProps;
                    hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                    b: switch (flags) {
                      case "title":
                        currentResource = hoistableRoot.getElementsByTagName("title")[0];
                        if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                          currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                            currentResource,
                            hoistableRoot.querySelector("head > title")
                          );
                        setInitialProperties(currentResource, flags, current);
                        currentResource[internalInstanceKey] = finishedWork;
                        markNodeAsHoistable(currentResource);
                        flags = currentResource;
                        break a;
                      case "link":
                        var maybeNodes = getHydratableHoistableCache(
                          "link",
                          "href",
                          hoistableRoot
                        ).get(flags + (current.href || ""));
                        if (maybeNodes) {
                          for (var i2 = 0; i2 < maybeNodes.length; i2++)
                            if (currentResource = maybeNodes[i2], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                              maybeNodes.splice(i2, 1);
                              break b;
                            }
                        }
                        currentResource = hoistableRoot.createElement(flags);
                        setInitialProperties(currentResource, flags, current);
                        hoistableRoot.head.appendChild(currentResource);
                        break;
                      case "meta":
                        if (maybeNodes = getHydratableHoistableCache(
                          "meta",
                          "content",
                          hoistableRoot
                        ).get(flags + (current.content || ""))) {
                          for (i2 = 0; i2 < maybeNodes.length; i2++)
                            if (currentResource = maybeNodes[i2], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                              maybeNodes.splice(i2, 1);
                              break b;
                            }
                        }
                        currentResource = hoistableRoot.createElement(flags);
                        setInitialProperties(currentResource, flags, current);
                        hoistableRoot.head.appendChild(currentResource);
                        break;
                      default:
                        throw Error(formatProdErrorMessage(468, flags));
                    }
                    currentResource[internalInstanceKey] = finishedWork;
                    markNodeAsHoistable(currentResource);
                    flags = currentResource;
                  }
                  finishedWork.stateNode = flags;
                } else
                  mountHoistable(
                    hoistableRoot,
                    finishedWork.type,
                    finishedWork.stateNode
                  );
              else
                finishedWork.stateNode = acquireResource(
                  hoistableRoot,
                  flags,
                  finishedWork.memoizedProps
                );
            else
              currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
                hoistableRoot,
                finishedWork.type,
                finishedWork.stateNode
              ) : acquireResource(
                hoistableRoot,
                flags,
                finishedWork.memoizedProps
              )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current.memoizedProps
              );
          }
          break;
        case 27:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          null !== current && flags & 4 && commitHostUpdate(
            finishedWork,
            finishedWork.memoizedProps,
            current.memoizedProps
          );
          break;
        case 5:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          if (finishedWork.flags & 32) {
            hoistableRoot = finishedWork.stateNode;
            try {
              setTextContent(hoistableRoot, "");
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
            finishedWork,
            hoistableRoot,
            null !== current ? current.memoizedProps : hoistableRoot
          ));
          flags & 1024 && (needsFormReset = true);
          break;
        case 6:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          if (flags & 4) {
            if (null === finishedWork.stateNode)
              throw Error(formatProdErrorMessage(162));
            flags = finishedWork.memoizedProps;
            current = finishedWork.stateNode;
            try {
              current.nodeValue = flags;
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 3:
          tagCaches = null;
          hoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(root2.containerInfo);
          recursivelyTraverseMutationEffects(root2, finishedWork);
          currentHoistableRoot = hoistableRoot;
          commitReconciliationEffects(finishedWork);
          if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
            try {
              retryIfBlockedOn(root2.containerInfo);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
          break;
        case 4:
          flags = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(
            finishedWork.stateNode.containerInfo
          );
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          currentHoistableRoot = flags;
          break;
        case 12:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          break;
        case 13:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 22:
          hoistableRoot = null !== finishedWork.memoizedState;
          var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
          recursivelyTraverseMutationEffects(root2, finishedWork);
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
          commitReconciliationEffects(finishedWork);
          if (flags & 8192)
            a: for (root2 = finishedWork.stateNode, root2._visibility = hoistableRoot ? root2._visibility & -2 : root2._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root2 = finishedWork; ; ) {
              if (5 === root2.tag || 26 === root2.tag) {
                if (null === current) {
                  wasHidden = current = root2;
                  try {
                    if (currentResource = wasHidden.stateNode, hoistableRoot)
                      maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
                    else {
                      i2 = wasHidden.stateNode;
                      var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                      i2.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                    }
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if (6 === root2.tag) {
                if (null === current) {
                  wasHidden = root2;
                  try {
                    wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
                root2.child.return = root2;
                root2 = root2.child;
                continue;
              }
              if (root2 === finishedWork) break a;
              for (; null === root2.sibling; ) {
                if (null === root2.return || root2.return === finishedWork) break a;
                current === root2 && (current = null);
                root2 = root2.return;
              }
              current === root2 && (current = null);
              root2.sibling.return = root2.return;
              root2 = root2.sibling;
            }
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
          break;
        case 19:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
      }
    }
    function commitReconciliationEffects(finishedWork) {
      var flags = finishedWork.flags;
      if (flags & 2) {
        try {
          for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
            if (isHostParent(parentFiber)) {
              hostParentFiber = parentFiber;
              break;
            }
            parentFiber = parentFiber.return;
          }
          if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
          switch (hostParentFiber.tag) {
            case 27:
              var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before, parent);
              break;
            case 5:
              var parent$144 = hostParentFiber.stateNode;
              hostParentFiber.flags & 32 && (setTextContent(parent$144, ""), hostParentFiber.flags &= -33);
              var before$145 = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before$145, parent$144);
              break;
            case 3:
            case 4:
              var parent$146 = hostParentFiber.stateNode.containerInfo, before$147 = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(
                finishedWork,
                before$147,
                parent$146
              );
              break;
            default:
              throw Error(formatProdErrorMessage(161));
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        finishedWork.flags &= -3;
      }
      flags & 4096 && (finishedWork.flags &= -4097);
    }
    function recursivelyResetForms(parentFiber) {
      if (parentFiber.subtreeFlags & 1024)
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var fiber = parentFiber;
          recursivelyResetForms(fiber);
          5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
          parentFiber = parentFiber.sibling;
        }
    }
    function recursivelyTraverseLayoutEffects(root2, parentFiber) {
      if (parentFiber.subtreeFlags & 8772)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
    }
    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var finishedWork = parentFiber;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 1:
            safelyDetachRef(finishedWork, finishedWork.return);
            var instance = finishedWork.stateNode;
            "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
              finishedWork,
              finishedWork.return,
              instance
            );
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 27:
            releaseSingletonInstance(finishedWork.stateNode);
          case 26:
          case 5:
            safelyDetachRef(finishedWork, finishedWork.return);
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 22:
            null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 30:
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          default:
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            commitHookEffectListMount(4, finishedWork);
            break;
          case 1:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            current = finishedWork;
            finishedRoot = current.stateNode;
            if ("function" === typeof finishedRoot.componentDidMount)
              try {
                finishedRoot.componentDidMount();
              } catch (error) {
                captureCommitPhaseError(current, current.return, error);
              }
            current = finishedWork;
            finishedRoot = current.updateQueue;
            if (null !== finishedRoot) {
              var instance = current.stateNode;
              try {
                var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                if (null !== hiddenCallbacks)
                  for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                    callCallback(hiddenCallbacks[finishedRoot], instance);
              } catch (error) {
                captureCommitPhaseError(current, current.return, error);
              }
            }
            includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 27:
            commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            break;
          case 13:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 22:
            null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 30:
            break;
          default:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function commitOffscreenPassiveMountEffects(current, finishedWork) {
      var previousCache = null;
      null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
      current = null;
      null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
      current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
    }
    function commitCachePassiveMountEffect(current, finishedWork) {
      current = null;
      null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
      finishedWork = finishedWork.memoizedState.cache;
      finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
    }
    function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitPassiveMountOnFiber(
            root2,
            parentFiber,
            committedLanes,
            committedTransitions
          ), parentFiber = parentFiber.sibling;
    }
    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 && commitHookEffectListMount(9, finishedWork);
          break;
        case 1:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          break;
        case 3:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
          break;
        case 12:
          if (flags & 2048) {
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            finishedRoot = finishedWork.stateNode;
            try {
              var _finishedWork$memoize2 = finishedWork.memoizedProps, id = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
              "function" === typeof onPostCommit && onPostCommit(
                id,
                null === finishedWork.alternate ? "mount" : "update",
                finishedRoot.passiveEffectDuration,
                -0
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
          break;
        case 13:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          break;
        case 23:
          break;
        case 22:
          _finishedWork$memoize2 = finishedWork.stateNode;
          id = finishedWork.alternate;
          null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            0 !== (finishedWork.subtreeFlags & 10256)
          ));
          flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
          break;
        case 24:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
      }
    }
    function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
            commitHookEffectListMount(8, finishedWork);
            break;
          case 23:
            break;
          case 22:
            var instance = finishedWork.stateNode;
            null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ) : recursivelyTraverseAtomicPassiveEffects(
              finishedRoot,
              finishedWork
            ) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ));
            includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
              finishedWork.alternate,
              finishedWork
            );
            break;
          case 24:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 22:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
              flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
              flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          }
          parentFiber = parentFiber.sibling;
        }
    }
    var suspenseyCommitFlag = 8192;
    function recursivelyAccumulateSuspenseyCommit(parentFiber) {
      if (parentFiber.subtreeFlags & suspenseyCommitFlag)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
    }
    function accumulateSuspenseyCommitOnFiber(fiber) {
      switch (fiber.tag) {
        case 26:
          recursivelyAccumulateSuspenseyCommit(fiber);
          fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
            currentHoistableRoot,
            fiber.memoizedState,
            fiber.memoizedProps
          );
          break;
        case 5:
          recursivelyAccumulateSuspenseyCommit(fiber);
          break;
        case 3:
        case 4:
          var previousHoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
          recursivelyAccumulateSuspenseyCommit(fiber);
          currentHoistableRoot = previousHoistableRoot;
          break;
        case 22:
          null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
          break;
        default:
          recursivelyAccumulateSuspenseyCommit(fiber);
      }
    }
    function detachAlternateSiblings(parentFiber) {
      var previousFiber = parentFiber.alternate;
      if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
        previousFiber.child = null;
        do
          previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
        while (null !== parentFiber);
      }
    }
    function recursivelyTraversePassiveUnmountEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i2 = 0; i2 < deletions.length; i2++) {
            var childToDelete = deletions[i2];
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber
            );
          }
        detachAlternateSiblings(parentFiber);
      }
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
    }
    function commitPassiveUnmountOnFiber(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
          break;
        case 3:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        case 12:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        case 22:
          var instance = finishedWork.stateNode;
          null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        default:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
      }
    }
    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i2 = 0; i2 < deletions.length; i2++) {
            var childToDelete = deletions[i2];
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber
            );
          }
        detachAlternateSiblings(parentFiber);
      }
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        deletions = parentFiber;
        switch (deletions.tag) {
          case 0:
          case 11:
          case 15:
            commitHookEffectListUnmount(8, deletions, deletions.return);
            recursivelyTraverseDisconnectPassiveEffects(deletions);
            break;
          case 22:
            i2 = deletions.stateNode;
            i2._visibility & 2 && (i2._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
            break;
          default:
            recursivelyTraverseDisconnectPassiveEffects(deletions);
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
      for (; null !== nextEffect; ) {
        var fiber = nextEffect;
        switch (fiber.tag) {
          case 0:
          case 11:
          case 15:
            commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
            break;
          case 23:
          case 22:
            if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
              var cache = fiber.memoizedState.cachePool.pool;
              null != cache && cache.refCount++;
            }
            break;
          case 24:
            releaseCache(fiber.memoizedState.cache);
        }
        cache = fiber.child;
        if (null !== cache) cache.return = fiber, nextEffect = cache;
        else
          a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
            cache = nextEffect;
            var sibling = cache.sibling, returnFiber = cache.return;
            detachFiberAfterEffects(cache);
            if (cache === fiber) {
              nextEffect = null;
              break a;
            }
            if (null !== sibling) {
              sibling.return = returnFiber;
              nextEffect = sibling;
              break a;
            }
            nextEffect = returnFiber;
          }
      }
    }
    var DefaultAsyncDispatcher = {
      getCacheForType: function(resourceType) {
        var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
        void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
        return cacheForType;
      }
    }, PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, workInProgressRootRenderTargetTime = Infinity, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, nestedUpdateCount = 0, rootWithNestedUpdates = null;
    function requestUpdateLane() {
      if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
        return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
      if (null !== ReactSharedInternals.T) {
        var actionScopeLane = currentEntangledLane;
        return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
      }
      return resolveUpdatePriority();
    }
    function requestDeferredLane() {
      0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
      var suspenseHandler = suspenseHandlerStackCursor.current;
      null !== suspenseHandler && (suspenseHandler.flags |= 32);
      return workInProgressDeferredLane;
    }
    function scheduleUpdateOnFiber(root2, fiber, lane) {
      if (root2 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
        prepareFreshStack(root2, 0), markRootSuspended(
          root2,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        );
      markRootUpdated$1(root2, lane);
      if (0 === (executionContext & 2) || root2 !== workInProgressRoot)
        root2 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
          root2,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        )), ensureRootIsScheduled(root2);
    }
    function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
      if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
      var shouldTimeSlice = !forceSync && 0 === (lanes & 124) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
      do {
        if (0 === exitStatus) {
          workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
          break;
        } else {
          forceSync = root$jscomp$0.current.alternate;
          if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
            exitStatus = renderRootSync(root$jscomp$0, lanes, false);
            renderWasConcurrent = false;
            continue;
          }
          if (2 === exitStatus) {
            renderWasConcurrent = lanes;
            if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
              var JSCompiler_inline_result = 0;
            else
              JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
            if (0 !== JSCompiler_inline_result) {
              lanes = JSCompiler_inline_result;
              a: {
                var root2 = root$jscomp$0;
                exitStatus = workInProgressRootConcurrentErrors;
                var wasRootDehydrated = root2.current.memoizedState.isDehydrated;
                wasRootDehydrated && (prepareFreshStack(root2, JSCompiler_inline_result).flags |= 256);
                JSCompiler_inline_result = renderRootSync(
                  root2,
                  JSCompiler_inline_result,
                  false
                );
                if (2 !== JSCompiler_inline_result) {
                  if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                    root2.errorRecoveryDisabledLanes |= renderWasConcurrent;
                    workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                    exitStatus = 4;
                    break a;
                  }
                  renderWasConcurrent = workInProgressRootRecoverableErrors;
                  workInProgressRootRecoverableErrors = exitStatus;
                  null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
                    workInProgressRootRecoverableErrors,
                    renderWasConcurrent
                  ));
                }
                exitStatus = JSCompiler_inline_result;
              }
              renderWasConcurrent = false;
              if (2 !== exitStatus) continue;
            }
          }
          if (1 === exitStatus) {
            prepareFreshStack(root$jscomp$0, 0);
            markRootSuspended(root$jscomp$0, lanes, 0, true);
            break;
          }
          a: {
            shouldTimeSlice = root$jscomp$0;
            renderWasConcurrent = exitStatus;
            switch (renderWasConcurrent) {
              case 0:
              case 1:
                throw Error(formatProdErrorMessage(345));
              case 4:
                if ((lanes & 4194048) !== lanes) break;
              case 6:
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                break a;
              case 2:
                workInProgressRootRecoverableErrors = null;
                break;
              case 3:
              case 5:
                break;
              default:
                throw Error(formatProdErrorMessage(329));
            }
            if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
              markRootSuspended(
                shouldTimeSlice,
                lanes,
                workInProgressDeferredLane,
                !workInProgressRootDidSkipSuspendedSiblings
              );
              if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
              shouldTimeSlice.timeoutHandle = scheduleTimeout(
                commitRootWhenReady.bind(
                  null,
                  shouldTimeSlice,
                  forceSync,
                  workInProgressRootRecoverableErrors,
                  workInProgressTransitions,
                  workInProgressRootDidIncludeRecursiveRenderUpdate,
                  lanes,
                  workInProgressDeferredLane,
                  workInProgressRootInterleavedUpdatedLanes,
                  workInProgressSuspendedRetryLanes,
                  workInProgressRootDidSkipSuspendedSiblings,
                  renderWasConcurrent,
                  2,
                  -0,
                  0
                ),
                exitStatus
              );
              break a;
            }
            commitRootWhenReady(
              shouldTimeSlice,
              forceSync,
              workInProgressRootRecoverableErrors,
              workInProgressTransitions,
              workInProgressRootDidIncludeRecursiveRenderUpdate,
              lanes,
              workInProgressDeferredLane,
              workInProgressRootInterleavedUpdatedLanes,
              workInProgressSuspendedRetryLanes,
              workInProgressRootDidSkipSuspendedSiblings,
              renderWasConcurrent,
              0,
              -0,
              0
            );
          }
        }
        break;
      } while (1);
      ensureRootIsScheduled(root$jscomp$0);
    }
    function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
      root2.timeoutHandle = -1;
      suspendedCommitReason = finishedWork.subtreeFlags;
      if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
        if (suspendedState = { stylesheets: null, count: 0, unsuspend: noop2 }, accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), null !== suspendedCommitReason) {
          root2.cancelPendingCommit = suspendedCommitReason(
            commitRoot.bind(
              null,
              root2,
              finishedWork,
              lanes,
              recoverableErrors,
              transitions,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes,
              exitStatus,
              1,
              completedRenderStartTime,
              completedRenderEndTime
            )
          );
          markRootSuspended(root2, lanes, spawnedLane, !didSkipSuspendedSiblings);
          return;
        }
      }
      commitRoot(
        root2,
        finishedWork,
        lanes,
        recoverableErrors,
        transitions,
        didIncludeRenderPhaseUpdate,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes
      );
    }
    function isRenderConsistentWithExternalStores(finishedWork) {
      for (var node = finishedWork; ; ) {
        var tag = node.tag;
        if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
          for (var i2 = 0; i2 < tag.length; i2++) {
            var check = tag[i2], getSnapshot = check.getSnapshot;
            check = check.value;
            try {
              if (!objectIs(getSnapshot(), check)) return false;
            } catch (error) {
              return false;
            }
          }
        tag = node.child;
        if (node.subtreeFlags & 16384 && null !== tag)
          tag.return = node, node = tag;
        else {
          if (node === finishedWork) break;
          for (; null === node.sibling; ) {
            if (null === node.return || node.return === finishedWork) return true;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      }
      return true;
    }
    function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
      suspendedLanes &= ~workInProgressRootPingedLanes;
      suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
      root2.suspendedLanes |= suspendedLanes;
      root2.pingedLanes &= ~suspendedLanes;
      didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
      didAttemptEntireTree = root2.expirationTimes;
      for (var lanes = suspendedLanes; 0 < lanes; ) {
        var index$4 = 31 - clz32(lanes), lane = 1 << index$4;
        didAttemptEntireTree[index$4] = -1;
        lanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
    }
    function flushSyncWork$1() {
      return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0), false) : true;
    }
    function resetWorkInProgressStack() {
      if (null !== workInProgress) {
        if (0 === workInProgressSuspendedReason)
          var interruptedWork = workInProgress.return;
        else
          interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState = null, thenableIndexCounter = 0, interruptedWork = workInProgress;
        for (; null !== interruptedWork; )
          unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
        workInProgress = null;
      }
    }
    function prepareFreshStack(root2, lanes) {
      var timeoutHandle = root2.timeoutHandle;
      -1 !== timeoutHandle && (root2.timeoutHandle = -1, cancelTimeout(timeoutHandle));
      timeoutHandle = root2.cancelPendingCommit;
      null !== timeoutHandle && (root2.cancelPendingCommit = null, timeoutHandle());
      resetWorkInProgressStack();
      workInProgressRoot = root2;
      workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
      workInProgressRootRenderLanes = lanes;
      workInProgressSuspendedReason = 0;
      workInProgressThrownValue = null;
      workInProgressRootDidSkipSuspendedSiblings = false;
      workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
      workInProgressRootDidAttachPingListener = false;
      workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
      workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
      workInProgressRootDidIncludeRecursiveRenderUpdate = false;
      0 !== (lanes & 8) && (lanes |= lanes & 32);
      var allEntangledLanes = root2.entangledLanes;
      if (0 !== allEntangledLanes)
        for (root2 = root2.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
          var index$2 = 31 - clz32(allEntangledLanes), lane = 1 << index$2;
          lanes |= root2[index$2];
          allEntangledLanes &= ~lane;
        }
      entangledRenderLanes = lanes;
      finishQueueingConcurrentUpdates();
      return timeoutHandle;
    }
    function handleThrow(root2, thrownValue) {
      currentlyRenderingFiber = null;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
      workInProgressThrownValue = thrownValue;
      null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
        root2,
        createCapturedValueAtFiber(thrownValue, root2.current)
      ));
    }
    function pushDispatcher() {
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
    }
    function pushAsyncDispatcher() {
      var prevAsyncDispatcher = ReactSharedInternals.A;
      ReactSharedInternals.A = DefaultAsyncDispatcher;
      return prevAsyncDispatcher;
    }
    function renderDidSuspendDelayIfPossible() {
      workInProgressRootExitStatus = 4;
      workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
      0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
        workInProgressRoot,
        workInProgressRootRenderLanes,
        workInProgressDeferredLane,
        false
      );
    }
    function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
      var prevExecutionContext = executionContext;
      executionContext |= 2;
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes)
        workInProgressTransitions = null, prepareFreshStack(root2, lanes);
      lanes = false;
      var exitStatus = workInProgressRootExitStatus;
      a: do
        try {
          if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
            var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
            switch (workInProgressSuspendedReason) {
              case 8:
                resetWorkInProgressStack();
                exitStatus = 6;
                break a;
              case 3:
              case 2:
              case 9:
              case 6:
                null === suspenseHandlerStackCursor.current && (lanes = true);
                var reason = workInProgressSuspendedReason;
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                  exitStatus = 0;
                  break a;
                }
                break;
              default:
                reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
            }
          }
          workLoopSync();
          exitStatus = workInProgressRootExitStatus;
          break;
        } catch (thrownValue$167) {
          handleThrow(root2, thrownValue$167);
        }
      while (1);
      lanes && root2.shellSuspendCounter++;
      lastContextDependency = currentlyRenderingFiber$1 = null;
      executionContext = prevExecutionContext;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
      return exitStatus;
    }
    function workLoopSync() {
      for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
    }
    function renderRootConcurrent(root2, lanes) {
      var prevExecutionContext = executionContext;
      executionContext |= 2;
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root2, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
        root2,
        lanes
      );
      a: do
        try {
          if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
            lanes = workInProgress;
            var thrownValue = workInProgressThrownValue;
            b: switch (workInProgressSuspendedReason) {
              case 1:
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root2, lanes, thrownValue, 1);
                break;
              case 2:
              case 9:
                if (isThenableResolved(thrownValue)) {
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  replaySuspendedUnitOfWork(lanes);
                  break;
                }
                lanes = function() {
                  2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root2 || (workInProgressSuspendedReason = 7);
                  ensureRootIsScheduled(root2);
                };
                thrownValue.then(lanes, lanes);
                break a;
              case 3:
                workInProgressSuspendedReason = 7;
                break a;
              case 4:
                workInProgressSuspendedReason = 5;
                break a;
              case 7:
                isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, lanes, thrownValue, 7));
                break;
              case 5:
                var resource = null;
                switch (workInProgress.tag) {
                  case 26:
                    resource = workInProgress.memoizedState;
                  case 5:
                  case 27:
                    var hostFiber = workInProgress;
                    if (resource ? preloadResource(resource) : 1) {
                      workInProgressSuspendedReason = 0;
                      workInProgressThrownValue = null;
                      var sibling = hostFiber.sibling;
                      if (null !== sibling) workInProgress = sibling;
                      else {
                        var returnFiber = hostFiber.return;
                        null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                      }
                      break b;
                    }
                }
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root2, lanes, thrownValue, 5);
                break;
              case 6:
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root2, lanes, thrownValue, 6);
                break;
              case 8:
                resetWorkInProgressStack();
                workInProgressRootExitStatus = 6;
                break a;
              default:
                throw Error(formatProdErrorMessage(462));
            }
          }
          workLoopConcurrentByScheduler();
          break;
        } catch (thrownValue$169) {
          handleThrow(root2, thrownValue$169);
        }
      while (1);
      lastContextDependency = currentlyRenderingFiber$1 = null;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      executionContext = prevExecutionContext;
      if (null !== workInProgress) return 0;
      workInProgressRoot = null;
      workInProgressRootRenderLanes = 0;
      finishQueueingConcurrentUpdates();
      return workInProgressRootExitStatus;
    }
    function workLoopConcurrentByScheduler() {
      for (; null !== workInProgress && !shouldYield(); )
        performUnitOfWork(workInProgress);
    }
    function performUnitOfWork(unitOfWork) {
      var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
    }
    function replaySuspendedUnitOfWork(unitOfWork) {
      var next = unitOfWork;
      var current = next.alternate;
      switch (next.tag) {
        case 15:
        case 0:
          next = replayFunctionComponent(
            current,
            next,
            next.pendingProps,
            next.type,
            void 0,
            workInProgressRootRenderLanes
          );
          break;
        case 11:
          next = replayFunctionComponent(
            current,
            next,
            next.pendingProps,
            next.type.render,
            next.ref,
            workInProgressRootRenderLanes
          );
          break;
        case 5:
          resetHooksOnUnwind(next);
        default:
          unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
      }
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
    }
    function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
      lastContextDependency = currentlyRenderingFiber$1 = null;
      resetHooksOnUnwind(unitOfWork);
      thenableState = null;
      thenableIndexCounter = 0;
      var returnFiber = unitOfWork.return;
      try {
        if (throwException(
          root2,
          returnFiber,
          unitOfWork,
          thrownValue,
          workInProgressRootRenderLanes
        )) {
          workInProgressRootExitStatus = 1;
          logUncaughtError(
            root2,
            createCapturedValueAtFiber(thrownValue, root2.current)
          );
          workInProgress = null;
          return;
        }
      } catch (error) {
        if (null !== returnFiber) throw workInProgress = returnFiber, error;
        workInProgressRootExitStatus = 1;
        logUncaughtError(
          root2,
          createCapturedValueAtFiber(thrownValue, root2.current)
        );
        workInProgress = null;
        return;
      }
      if (unitOfWork.flags & 32768) {
        if (isHydrating || 1 === suspendedReason) root2 = true;
        else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
          root2 = false;
        else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
          suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
        unwindUnitOfWork(unitOfWork, root2);
      } else completeUnitOfWork(unitOfWork);
    }
    function completeUnitOfWork(unitOfWork) {
      var completedWork = unitOfWork;
      do {
        if (0 !== (completedWork.flags & 32768)) {
          unwindUnitOfWork(
            completedWork,
            workInProgressRootDidSkipSuspendedSiblings
          );
          return;
        }
        unitOfWork = completedWork.return;
        var next = completeWork(
          completedWork.alternate,
          completedWork,
          entangledRenderLanes
        );
        if (null !== next) {
          workInProgress = next;
          return;
        }
        completedWork = completedWork.sibling;
        if (null !== completedWork) {
          workInProgress = completedWork;
          return;
        }
        workInProgress = completedWork = unitOfWork;
      } while (null !== completedWork);
      0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
    }
    function unwindUnitOfWork(unitOfWork, skipSiblings) {
      do {
        var next = unwindWork(unitOfWork.alternate, unitOfWork);
        if (null !== next) {
          next.flags &= 32767;
          workInProgress = next;
          return;
        }
        next = unitOfWork.return;
        null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
        if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
          workInProgress = unitOfWork;
          return;
        }
        workInProgress = unitOfWork = next;
      } while (null !== unitOfWork);
      workInProgressRootExitStatus = 6;
      workInProgress = null;
    }
    function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
      root2.cancelPendingCommit = null;
      do
        flushPendingEffects();
      while (0 !== pendingEffectsStatus);
      if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
      if (null !== finishedWork) {
        if (finishedWork === root2.current) throw Error(formatProdErrorMessage(177));
        didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
        didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
        markRootFinished(
          root2,
          lanes,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes
        );
        root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
        pendingFinishedWork = finishedWork;
        pendingEffectsRoot = root2;
        pendingEffectsLanes = lanes;
        pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
        pendingPassiveTransitions = transitions;
        pendingRecoverableErrors = recoverableErrors;
        0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
          flushPassiveEffects();
          return null;
        })) : (root2.callbackNode = null, root2.callbackPriority = 0);
        recoverableErrors = 0 !== (finishedWork.flags & 13878);
        if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
          recoverableErrors = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          transitions = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          spawnedLane = executionContext;
          executionContext |= 4;
          try {
            commitBeforeMutationEffects(root2, finishedWork, lanes);
          } finally {
            executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
          }
        }
        pendingEffectsStatus = 1;
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
      }
    }
    function flushMutationEffects() {
      if (1 === pendingEffectsStatus) {
        pendingEffectsStatus = 0;
        var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
        if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
          rootMutationHasEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          try {
            commitMutationEffectsOnFiber(finishedWork, root2);
            var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
            if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
              priorFocusedElem.ownerDocument.documentElement,
              priorFocusedElem
            )) {
              if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                var start = priorSelectionRange.start, end = priorSelectionRange.end;
                void 0 === end && (end = start);
                if ("selectionStart" in priorFocusedElem)
                  priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                    end,
                    priorFocusedElem.value.length
                  );
                else {
                  var doc2 = priorFocusedElem.ownerDocument || document, win = doc2 && doc2.defaultView || window;
                  if (win.getSelection) {
                    var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                    !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                    var startMarker = getNodeForCharacterOffset(
                      priorFocusedElem,
                      start$jscomp$0
                    ), endMarker = getNodeForCharacterOffset(
                      priorFocusedElem,
                      end$jscomp$0
                    );
                    if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                      var range = doc2.createRange();
                      range.setStart(startMarker.node, startMarker.offset);
                      selection.removeAllRanges();
                      start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                    }
                  }
                }
              }
              doc2 = [];
              for (selection = priorFocusedElem; selection = selection.parentNode; )
                1 === selection.nodeType && doc2.push({
                  element: selection,
                  left: selection.scrollLeft,
                  top: selection.scrollTop
                });
              "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
              for (priorFocusedElem = 0; priorFocusedElem < doc2.length; priorFocusedElem++) {
                var info = doc2[priorFocusedElem];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
            _enabled = !!eventsEnabled;
            selectionInformation = eventsEnabled = null;
          } finally {
            executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
          }
        }
        root2.current = finishedWork;
        pendingEffectsStatus = 2;
      }
    }
    function flushLayoutEffects() {
      if (2 === pendingEffectsStatus) {
        pendingEffectsStatus = 0;
        var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
        if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
          rootHasLayoutEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          try {
            commitLayoutEffectOnFiber(root2, finishedWork.alternate, finishedWork);
          } finally {
            executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
          }
        }
        pendingEffectsStatus = 3;
      }
    }
    function flushSpawnedWork() {
      if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
        pendingEffectsStatus = 0;
        requestPaint();
        var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
        0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root2, root2.pendingLanes));
        var remainingLanes = root2.pendingLanes;
        0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
        lanesToEventPriority(lanes);
        finishedWork = finishedWork.stateNode;
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
          try {
            injectedHook.onCommitFiberRoot(
              rendererID,
              finishedWork,
              void 0,
              128 === (finishedWork.current.flags & 128)
            );
          } catch (err2) {
          }
        if (null !== recoverableErrors) {
          finishedWork = ReactSharedInternals.T;
          remainingLanes = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          ReactSharedInternals.T = null;
          try {
            for (var onRecoverableError = root2.onRecoverableError, i2 = 0; i2 < recoverableErrors.length; i2++) {
              var recoverableError = recoverableErrors[i2];
              onRecoverableError(recoverableError.value, {
                componentStack: recoverableError.stack
              });
            }
          } finally {
            ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
          }
        }
        0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
        ensureRootIsScheduled(root2);
        remainingLanes = root2.pendingLanes;
        0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42) ? root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2) : nestedUpdateCount = 0;
        flushSyncWorkAcrossRoots_impl(0);
      }
    }
    function releaseRootPooledCache(root2, remainingLanes) {
      0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
    }
    function flushPendingEffects(wasDelayedCommit) {
      flushMutationEffects();
      flushLayoutEffects();
      flushSpawnedWork();
      return flushPassiveEffects();
    }
    function flushPassiveEffects() {
      if (5 !== pendingEffectsStatus) return false;
      var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
      pendingEffectsRemainingLanes = 0;
      var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
        ReactSharedInternals.T = null;
        renderPriority = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
        pendingEffectsStatus = 0;
        pendingFinishedWork = pendingEffectsRoot = null;
        pendingEffectsLanes = 0;
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
        var prevExecutionContext = executionContext;
        executionContext |= 4;
        commitPassiveUnmountOnFiber(root$jscomp$0.current);
        commitPassiveMountOnFiber(
          root$jscomp$0,
          root$jscomp$0.current,
          lanes,
          renderPriority
        );
        executionContext = prevExecutionContext;
        flushSyncWorkAcrossRoots_impl(0, false);
        if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
          try {
            injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
          } catch (err2) {
          }
        return true;
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root2, remainingLanes);
      }
    }
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
      sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
      sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
      rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
      null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
    }
    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
      if (3 === sourceFiber.tag)
        captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
      else
        for (; null !== nearestMountedAncestor; ) {
          if (3 === nearestMountedAncestor.tag) {
            captureCommitPhaseErrorOnRoot(
              nearestMountedAncestor,
              sourceFiber,
              error
            );
            break;
          } else if (1 === nearestMountedAncestor.tag) {
            var instance = nearestMountedAncestor.stateNode;
            if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
              sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
              error = createClassErrorUpdate(2);
              instance = enqueueUpdate(nearestMountedAncestor, error, 2);
              null !== instance && (initializeClassErrorUpdate(
                error,
                instance,
                nearestMountedAncestor,
                sourceFiber
              ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
              break;
            }
          }
          nearestMountedAncestor = nearestMountedAncestor.return;
        }
    }
    function attachPingListener(root2, wakeable, lanes) {
      var pingCache = root2.pingCache;
      if (null === pingCache) {
        pingCache = root2.pingCache = new PossiblyWeakMap();
        var threadIDs = /* @__PURE__ */ new Set();
        pingCache.set(wakeable, threadIDs);
      } else
        threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
      threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root2 = pingSuspendedRoot.bind(null, root2, wakeable, lanes), wakeable.then(root2, root2));
    }
    function pingSuspendedRoot(root2, wakeable, pingedLanes) {
      var pingCache = root2.pingCache;
      null !== pingCache && pingCache.delete(wakeable);
      root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
      root2.warmLanes &= ~pingedLanes;
      workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
      ensureRootIsScheduled(root2);
    }
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
      0 === retryLane && (retryLane = claimNextRetryLane());
      boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
      null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
    }
    function retryDehydratedSuspenseBoundary(boundaryFiber) {
      var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
      null !== suspenseState && (retryLane = suspenseState.retryLane);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function resolveRetryWakeable(boundaryFiber, wakeable) {
      var retryLane = 0;
      switch (boundaryFiber.tag) {
        case 13:
          var retryCache = boundaryFiber.stateNode;
          var suspenseState = boundaryFiber.memoizedState;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          break;
        case 19:
          retryCache = boundaryFiber.stateNode;
          break;
        case 22:
          retryCache = boundaryFiber.stateNode._retryCache;
          break;
        default:
          throw Error(formatProdErrorMessage(314));
      }
      null !== retryCache && retryCache.delete(wakeable);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function scheduleCallback$1(priorityLevel, callback) {
      return scheduleCallback$3(priorityLevel, callback);
    }
    var firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0;
    function ensureRootIsScheduled(root2) {
      root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
      mightHavePendingSyncWork = true;
      didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
    }
    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
      if (!isFlushingWork && mightHavePendingSyncWork) {
        isFlushingWork = true;
        do {
          var didPerformSomeWork = false;
          for (var root$174 = firstScheduledRoot; null !== root$174; ) {
            if (0 !== syncTransitionLanes) {
              var pendingLanes = root$174.pendingLanes;
              if (0 === pendingLanes) var JSCompiler_inline_result = 0;
              else {
                var suspendedLanes = root$174.suspendedLanes, pingedLanes = root$174.pingedLanes;
                JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
              }
              0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
            } else
              JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
                root$174,
                root$174 === workInProgressRoot ? JSCompiler_inline_result : 0,
                null !== root$174.cancelPendingCommit || -1 !== root$174.timeoutHandle
              ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$174, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
            root$174 = root$174.next;
          }
        } while (didPerformSomeWork);
        isFlushingWork = false;
      }
    }
    function processRootScheduleInImmediateTask() {
      processRootScheduleInMicrotask();
    }
    function processRootScheduleInMicrotask() {
      mightHavePendingSyncWork = didScheduleMicrotask = false;
      var syncTransitionLanes = 0;
      0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
      for (var currentTime = now(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
        var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
        if (0 === nextLanes)
          root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
        else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
          mightHavePendingSyncWork = true;
        root2 = next;
      }
      flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
    }
    function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
      for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
        var index$3 = 31 - clz32(lanes), lane = 1 << index$3, expirationTime = expirationTimes[index$3];
        if (-1 === expirationTime) {
          if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
            expirationTimes[index$3] = computeExpirationTime(lane, currentTime);
        } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
        lanes &= ~lane;
      }
      currentTime = workInProgressRoot;
      suspendedLanes = workInProgressRootRenderLanes;
      suspendedLanes = getNextLanes(
        root2,
        root2 === currentTime ? suspendedLanes : 0,
        null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
      );
      pingedLanes = root2.callbackNode;
      if (0 === suspendedLanes || root2 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
        return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
      if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
        currentTime = suspendedLanes & -suspendedLanes;
        if (currentTime === root2.callbackPriority) return currentTime;
        null !== pingedLanes && cancelCallback$1(pingedLanes);
        switch (lanesToEventPriority(suspendedLanes)) {
          case 2:
          case 8:
            suspendedLanes = UserBlockingPriority;
            break;
          case 32:
            suspendedLanes = NormalPriority$1;
            break;
          case 268435456:
            suspendedLanes = IdlePriority;
            break;
          default:
            suspendedLanes = NormalPriority$1;
        }
        pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
        suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
        root2.callbackPriority = currentTime;
        root2.callbackNode = suspendedLanes;
        return currentTime;
      }
      null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
      root2.callbackPriority = 2;
      root2.callbackNode = null;
      return 2;
    }
    function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
      if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
        return root2.callbackNode = null, root2.callbackPriority = 0, null;
      var originalCallbackNode = root2.callbackNode;
      if (flushPendingEffects() && root2.callbackNode !== originalCallbackNode)
        return null;
      var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
      workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
        root2,
        root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
        null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
      );
      if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
      performWorkOnRoot(root2, workInProgressRootRenderLanes$jscomp$0, didTimeout);
      scheduleTaskForRootDuringMicrotask(root2, now());
      return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
    }
    function performSyncWorkOnRoot(root2, lanes) {
      if (flushPendingEffects()) return null;
      performWorkOnRoot(root2, lanes, true);
    }
    function scheduleImmediateRootScheduleTask() {
      scheduleMicrotask2(function() {
        0 !== (executionContext & 6) ? scheduleCallback$3(
          ImmediatePriority,
          processRootScheduleInImmediateTask
        ) : processRootScheduleInMicrotask();
      });
    }
    function requestTransitionLane() {
      0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
      return currentEventTransitionLane;
    }
    function coerceFormActionProp(actionProp) {
      return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
    }
    function createFormDataWithSubmitter(form, submitter) {
      var temp = submitter.ownerDocument.createElement("input");
      temp.name = submitter.name;
      temp.value = submitter.value;
      form.id && temp.setAttribute("form", form.id);
      submitter.parentNode.insertBefore(temp, submitter);
      form = new FormData(form);
      temp.parentNode.removeChild(temp);
      return form;
    }
    function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
      if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
        var action = coerceFormActionProp(
          (nativeEventTarget[internalPropsKey] || null).action
        ), submitter = nativeEvent.submitter;
        submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
        var event = new SyntheticEvent(
          "action",
          "action",
          null,
          nativeEvent,
          nativeEventTarget
        );
        dispatchQueue.push({
          event,
          listeners: [
            {
              instance: null,
              listener: function() {
                if (nativeEvent.defaultPrevented) {
                  if (0 !== currentEventTransitionLane) {
                    var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                    startHostTransition(
                      maybeTargetInst,
                      {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      },
                      null,
                      formData
                    );
                  }
                } else
                  "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                    maybeTargetInst,
                    {
                      pending: true,
                      data: formData,
                      method: nativeEventTarget.method,
                      action
                    },
                    action,
                    formData
                  ));
              },
              currentTarget: nativeEventTarget
            }
          ]
        });
      }
    }
    for (var i$jscomp$inline_1528 = 0; i$jscomp$inline_1528 < simpleEventPluginEvents.length; i$jscomp$inline_1528++) {
      var eventName$jscomp$inline_1529 = simpleEventPluginEvents[i$jscomp$inline_1528], domEventName$jscomp$inline_1530 = eventName$jscomp$inline_1529.toLowerCase(), capitalizedEvent$jscomp$inline_1531 = eventName$jscomp$inline_1529[0].toUpperCase() + eventName$jscomp$inline_1529.slice(1);
      registerSimpleEvent(
        domEventName$jscomp$inline_1530,
        "on" + capitalizedEvent$jscomp$inline_1531
      );
    }
    registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
    registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
    registerSimpleEvent(ANIMATION_START, "onAnimationStart");
    registerSimpleEvent("dblclick", "onDoubleClick");
    registerSimpleEvent("focusin", "onFocus");
    registerSimpleEvent("focusout", "onBlur");
    registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
    registerSimpleEvent(TRANSITION_START, "onTransitionStart");
    registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
    registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
    registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
    registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
    registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
    registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
    registerTwoPhaseEvent(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(" ")
    );
    registerTwoPhaseEvent(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    );
    registerTwoPhaseEvent("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]);
    registerTwoPhaseEvent(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    );
    registerTwoPhaseEvent(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    );
    registerTwoPhaseEvent(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
    var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ), nonDelegatedEvents = new Set(
      "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
    );
    function processDispatchQueue(dispatchQueue, eventSystemFlags) {
      eventSystemFlags = 0 !== (eventSystemFlags & 4);
      for (var i2 = 0; i2 < dispatchQueue.length; i2++) {
        var _dispatchQueue$i = dispatchQueue[i2], event = _dispatchQueue$i.event;
        _dispatchQueue$i = _dispatchQueue$i.listeners;
        a: {
          var previousInstance = void 0;
          if (eventSystemFlags)
            for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
              var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              previousInstance = _dispatchListeners$i;
              event.currentTarget = currentTarget;
              try {
                previousInstance(event);
              } catch (error) {
                reportGlobalError(error);
              }
              event.currentTarget = null;
              previousInstance = instance;
            }
          else
            for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
              _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
              instance = _dispatchListeners$i.instance;
              currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              previousInstance = _dispatchListeners$i;
              event.currentTarget = currentTarget;
              try {
                previousInstance(event);
              } catch (error) {
                reportGlobalError(error);
              }
              event.currentTarget = null;
              previousInstance = instance;
            }
        }
      }
    }
    function listenToNonDelegatedEvent(domEventName, targetElement) {
      var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
      void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
      var listenerSetKey = domEventName + "__bubble";
      JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
    }
    function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
      var eventSystemFlags = 0;
      isCapturePhaseListener && (eventSystemFlags |= 4);
      addTrappedEventListener(
        target,
        domEventName,
        eventSystemFlags,
        isCapturePhaseListener
      );
    }
    var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
    function listenToAllSupportedEvents(rootContainerElement) {
      if (!rootContainerElement[listeningMarker]) {
        rootContainerElement[listeningMarker] = true;
        allNativeEvents.forEach(function(domEventName) {
          "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
        });
        var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
        null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
      }
    }
    function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
      switch (getEventPriority(domEventName)) {
        case 2:
          var listenerWrapper = dispatchDiscreteEvent;
          break;
        case 8:
          listenerWrapper = dispatchContinuousEvent;
          break;
        default:
          listenerWrapper = dispatchEvent2;
      }
      eventSystemFlags = listenerWrapper.bind(
        null,
        domEventName,
        eventSystemFlags,
        targetContainer
      );
      listenerWrapper = void 0;
      !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
      isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
        capture: true,
        passive: listenerWrapper
      }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
        passive: listenerWrapper
      }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
    }
    function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
      var ancestorInst = targetInst$jscomp$0;
      if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
        a: for (; ; ) {
          if (null === targetInst$jscomp$0) return;
          var nodeTag = targetInst$jscomp$0.tag;
          if (3 === nodeTag || 4 === nodeTag) {
            var container = targetInst$jscomp$0.stateNode.containerInfo;
            if (container === targetContainer) break;
            if (4 === nodeTag)
              for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                var grandTag = nodeTag.tag;
                if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                  return;
                nodeTag = nodeTag.return;
              }
            for (; null !== container; ) {
              nodeTag = getClosestInstanceFromNode(container);
              if (null === nodeTag) return;
              grandTag = nodeTag.tag;
              if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                targetInst$jscomp$0 = ancestorInst = nodeTag;
                continue a;
              }
              container = container.parentNode;
            }
          }
          targetInst$jscomp$0 = targetInst$jscomp$0.return;
        }
      batchedUpdates$1(function() {
        var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
        a: {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (void 0 !== reactName) {
            var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (0 === getEventCharCode(nativeEvent)) break a;
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (2 === nativeEvent.button) break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
              case "scrollend":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
              case "toggle":
              case "beforetoggle":
                SyntheticEventCtor = SyntheticToggleEvent;
            }
            var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
            inCapturePhase = [];
            for (var instance = targetInst, lastHostComponent; null !== instance; ) {
              var _instance = instance;
              lastHostComponent = _instance.stateNode;
              _instance = _instance.tag;
              5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(
                createDispatchListener(instance, _instance, lastHostComponent)
              ));
              if (accumulateTargetOnly) break;
              instance = instance.return;
            }
            0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
              reactName,
              reactEventType,
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
          }
        }
        if (0 === (eventSystemFlags & 7)) {
          a: {
            reactName = "mouseover" === domEventName || "pointerover" === domEventName;
            SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
            if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
              break a;
            if (SyntheticEventCtor || reactName) {
              reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
              if (SyntheticEventCtor) {
                if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                  reactEventType = null;
              } else SyntheticEventCtor = null, reactEventType = targetInst;
              if (SyntheticEventCtor !== reactEventType) {
                inCapturePhase = SyntheticMouseEvent;
                _instance = "onMouseLeave";
                reactEventName = "onMouseEnter";
                instance = "mouse";
                if ("pointerout" === domEventName || "pointerover" === domEventName)
                  inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                reactName = new inCapturePhase(
                  _instance,
                  instance + "leave",
                  SyntheticEventCtor,
                  nativeEvent,
                  nativeEventTarget
                );
                reactName.target = accumulateTargetOnly;
                reactName.relatedTarget = lastHostComponent;
                _instance = null;
                getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                  reactEventName,
                  instance + "enter",
                  reactEventType,
                  nativeEvent,
                  nativeEventTarget
                ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
                accumulateTargetOnly = _instance;
                if (SyntheticEventCtor && reactEventType)
                  b: {
                    inCapturePhase = SyntheticEventCtor;
                    reactEventName = reactEventType;
                    instance = 0;
                    for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent))
                      instance++;
                    lastHostComponent = 0;
                    for (_instance = reactEventName; _instance; _instance = getParent(_instance))
                      lastHostComponent++;
                    for (; 0 < instance - lastHostComponent; )
                      inCapturePhase = getParent(inCapturePhase), instance--;
                    for (; 0 < lastHostComponent - instance; )
                      reactEventName = getParent(reactEventName), lastHostComponent--;
                    for (; instance--; ) {
                      if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate)
                        break b;
                      inCapturePhase = getParent(inCapturePhase);
                      reactEventName = getParent(reactEventName);
                    }
                    inCapturePhase = null;
                  }
                else inCapturePhase = null;
                null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                  dispatchQueue,
                  reactName,
                  SyntheticEventCtor,
                  inCapturePhase,
                  false
                );
                null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                  dispatchQueue,
                  accumulateTargetOnly,
                  reactEventType,
                  inCapturePhase,
                  true
                );
              }
            }
          }
          a: {
            reactName = targetInst ? getNodeFromInstance(targetInst) : window;
            SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
            if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
              var getTargetInstFunc = getTargetInstForChangeEvent;
            else if (isTextInputElement(reactName))
              if (isInputEventSupported)
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                var handleEventFunc = handleEventsForInputEventPolyfill;
              }
            else
              SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
            if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
              createAndAccumulateChangeEvent(
                dispatchQueue,
                getTargetInstFunc,
                nativeEvent,
                nativeEventTarget
              );
              break a;
            }
            handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
            "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
          }
          handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
          switch (domEventName) {
            case "focusin":
              if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
              break;
            case "focusout":
              lastSelection = activeElementInst = activeElement = null;
              break;
            case "mousedown":
              mouseDown = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = false;
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
              break;
            case "selectionchange":
              if (skipSelectionChangeEvent) break;
            case "keydown":
            case "keyup":
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          }
          var fallbackData;
          if (canUseCompositionEvent)
            b: {
              switch (domEventName) {
                case "compositionstart":
                  var eventType = "onCompositionStart";
                  break b;
                case "compositionend":
                  eventType = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  eventType = "onCompositionUpdate";
                  break b;
              }
              eventType = void 0;
            }
          else
            isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
          eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
            eventType,
            domEventName,
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
          if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
            eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
              "onBeforeInput",
              "beforeinput",
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({
              event: handleEventFunc,
              listeners: eventType
            }), handleEventFunc.data = fallbackData);
          extractEvents$1(
            dispatchQueue,
            domEventName,
            targetInst,
            nativeEvent,
            nativeEventTarget
          );
        }
        processDispatchQueue(dispatchQueue, eventSystemFlags);
      });
    }
    function createDispatchListener(instance, listener, currentTarget) {
      return {
        instance,
        listener,
        currentTarget
      };
    }
    function accumulateTwoPhaseListeners(targetFiber, reactName) {
      for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
        var _instance2 = targetFiber, stateNode = _instance2.stateNode;
        _instance2 = _instance2.tag;
        5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ));
        if (3 === targetFiber.tag) return listeners;
        targetFiber = targetFiber.return;
      }
      return [];
    }
    function getParent(inst) {
      if (null === inst) return null;
      do
        inst = inst.return;
      while (inst && 5 !== inst.tag && 27 !== inst.tag);
      return inst ? inst : null;
    }
    function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
      for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
        var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
        _instance3 = _instance3.tag;
        if (null !== alternate && alternate === common) break;
        5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
          createDispatchListener(target, stateNode, alternate)
        )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
          createDispatchListener(target, stateNode, alternate)
        )));
        target = target.return;
      }
      0 !== listeners.length && dispatchQueue.push({ event, listeners });
    }
    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
    function normalizeMarkupForTextOrAttribute(markup) {
      return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
    }
    function checkForUnmatchedText(serverText, clientText) {
      clientText = normalizeMarkupForTextOrAttribute(clientText);
      return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
    }
    function noop$12() {
    }
    function setProp(domElement, tag, key2, value, props, prevValue) {
      switch (key2) {
        case "children":
          "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
          break;
        case "className":
          setValueForKnownAttribute(domElement, "class", value);
          break;
        case "tabIndex":
          setValueForKnownAttribute(domElement, "tabindex", value);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          setValueForKnownAttribute(domElement, key2, value);
          break;
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "data":
          if ("object" !== tag) {
            setValueForKnownAttribute(domElement, "data", value);
            break;
          }
        case "src":
        case "href":
          if ("" === value && ("a" !== tag || "href" !== key2)) {
            domElement.removeAttribute(key2);
            break;
          }
          if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
            domElement.removeAttribute(key2);
            break;
          }
          value = sanitizeURL("" + value);
          domElement.setAttribute(key2, value);
          break;
        case "action":
        case "formAction":
          if ("function" === typeof value) {
            domElement.setAttribute(
              key2,
              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
            );
            break;
          } else
            "function" === typeof prevValue && ("formAction" === key2 ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
              domElement,
              tag,
              "formEncType",
              props.formEncType,
              props,
              null
            ), setProp(
              domElement,
              tag,
              "formMethod",
              props.formMethod,
              props,
              null
            ), setProp(
              domElement,
              tag,
              "formTarget",
              props.formTarget,
              props,
              null
            )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
          if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
            domElement.removeAttribute(key2);
            break;
          }
          value = sanitizeURL("" + value);
          domElement.setAttribute(key2, value);
          break;
        case "onClick":
          null != value && (domElement.onclick = noop$12);
          break;
        case "onScroll":
          null != value && listenToNonDelegatedEvent("scroll", domElement);
          break;
        case "onScrollEnd":
          null != value && listenToNonDelegatedEvent("scrollend", domElement);
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(formatProdErrorMessage(61));
            key2 = value.__html;
            if (null != key2) {
              if (null != props.children) throw Error(formatProdErrorMessage(60));
              domElement.innerHTML = key2;
            }
          }
          break;
        case "multiple":
          domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "muted":
          domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
            domElement.removeAttribute("xlink:href");
            break;
          }
          key2 = sanitizeURL("" + value);
          domElement.setAttributeNS(
            "http://www.w3.org/1999/xlink",
            "xlink:href",
            key2
          );
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key2, "" + value) : domElement.removeAttribute(key2);
          break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key2, "") : domElement.removeAttribute(key2);
          break;
        case "capture":
        case "download":
          true === value ? domElement.setAttribute(key2, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key2, value) : domElement.removeAttribute(key2);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key2, value) : domElement.removeAttribute(key2);
          break;
        case "rowSpan":
        case "start":
          null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key2) : domElement.setAttribute(key2, value);
          break;
        case "popover":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          setValueForAttribute(domElement, "popover", value);
          break;
        case "xlinkActuate":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:actuate",
            value
          );
          break;
        case "xlinkArcrole":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:arcrole",
            value
          );
          break;
        case "xlinkRole":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:role",
            value
          );
          break;
        case "xlinkShow":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:show",
            value
          );
          break;
        case "xlinkTitle":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:title",
            value
          );
          break;
        case "xlinkType":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:type",
            value
          );
          break;
        case "xmlBase":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:base",
            value
          );
          break;
        case "xmlLang":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:lang",
            value
          );
          break;
        case "xmlSpace":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:space",
            value
          );
          break;
        case "is":
          setValueForAttribute(domElement, "is", value);
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!(2 < key2.length) || "o" !== key2[0] && "O" !== key2[0] || "n" !== key2[1] && "N" !== key2[1])
            key2 = aliases.get(key2) || key2, setValueForAttribute(domElement, key2, value);
      }
    }
    function setPropOnCustomElement(domElement, tag, key2, value, props, prevValue) {
      switch (key2) {
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(formatProdErrorMessage(61));
            key2 = value.__html;
            if (null != key2) {
              if (null != props.children) throw Error(formatProdErrorMessage(60));
              domElement.innerHTML = key2;
            }
          }
          break;
        case "children":
          "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
          break;
        case "onScroll":
          null != value && listenToNonDelegatedEvent("scroll", domElement);
          break;
        case "onScrollEnd":
          null != value && listenToNonDelegatedEvent("scrollend", domElement);
          break;
        case "onClick":
          null != value && (domElement.onclick = noop$12);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!registrationNameDependencies.hasOwnProperty(key2))
            a: {
              if ("o" === key2[0] && "n" === key2[1] && (props = key2.endsWith("Capture"), tag = key2.slice(2, props ? key2.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key2] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                "function" !== typeof prevValue && null !== prevValue && (key2 in domElement ? domElement[key2] = null : domElement.hasAttribute(key2) && domElement.removeAttribute(key2));
                domElement.addEventListener(tag, value, props);
                break a;
              }
              key2 in domElement ? domElement[key2] = value : true === value ? domElement.setAttribute(key2, "") : setValueForAttribute(domElement, key2, value);
            }
      }
    }
    function setInitialProperties(domElement, tag, props) {
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          var hasSrc = false, hasSrcSet = false, propKey;
          for (propKey in props)
            if (props.hasOwnProperty(propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "src":
                    hasSrc = true;
                    break;
                  case "srcSet":
                    hasSrcSet = true;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(formatProdErrorMessage(137, tag));
                  default:
                    setProp(domElement, tag, propKey, propValue, props, null);
                }
            }
          hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
          hasSrc && setProp(domElement, tag, "src", props.src, props, null);
          return;
        case "input":
          listenToNonDelegatedEvent("invalid", domElement);
          var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
          for (hasSrc in props)
            if (props.hasOwnProperty(hasSrc)) {
              var propValue$188 = props[hasSrc];
              if (null != propValue$188)
                switch (hasSrc) {
                  case "name":
                    hasSrcSet = propValue$188;
                    break;
                  case "type":
                    propValue = propValue$188;
                    break;
                  case "checked":
                    checked = propValue$188;
                    break;
                  case "defaultChecked":
                    defaultChecked = propValue$188;
                    break;
                  case "value":
                    propKey = propValue$188;
                    break;
                  case "defaultValue":
                    defaultValue = propValue$188;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propValue$188)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    setProp(domElement, tag, hasSrc, propValue$188, props, null);
                }
            }
          initInput2(
            domElement,
            propKey,
            defaultValue,
            checked,
            defaultChecked,
            propValue,
            hasSrcSet,
            false
          );
          track(domElement);
          return;
        case "select":
          listenToNonDelegatedEvent("invalid", domElement);
          hasSrc = propValue = propKey = null;
          for (hasSrcSet in props)
            if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
              switch (hasSrcSet) {
                case "value":
                  propKey = defaultValue;
                  break;
                case "defaultValue":
                  propValue = defaultValue;
                  break;
                case "multiple":
                  hasSrc = defaultValue;
                default:
                  setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
              }
          tag = propKey;
          props = propValue;
          domElement.multiple = !!hasSrc;
          null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
          return;
        case "textarea":
          listenToNonDelegatedEvent("invalid", domElement);
          propKey = hasSrcSet = hasSrc = null;
          for (propValue in props)
            if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
              switch (propValue) {
                case "value":
                  hasSrc = defaultValue;
                  break;
                case "defaultValue":
                  hasSrcSet = defaultValue;
                  break;
                case "children":
                  propKey = defaultValue;
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != defaultValue) throw Error(formatProdErrorMessage(91));
                  break;
                default:
                  setProp(domElement, tag, propValue, defaultValue, props, null);
              }
          initTextarea(domElement, hasSrc, hasSrcSet, propKey);
          track(domElement);
          return;
        case "option":
          for (checked in props)
            if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
              switch (checked) {
                case "selected":
                  domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                  break;
                default:
                  setProp(domElement, tag, checked, hasSrc, props, null);
              }
          return;
        case "dialog":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          listenToNonDelegatedEvent("cancel", domElement);
          listenToNonDelegatedEvent("close", domElement);
          break;
        case "iframe":
        case "object":
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "video":
        case "audio":
          for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
            listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
          break;
        case "image":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", domElement);
          break;
        case "embed":
        case "source":
        case "link":
          listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (defaultChecked in props)
            if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
              switch (defaultChecked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(formatProdErrorMessage(137, tag));
                default:
                  setProp(domElement, tag, defaultChecked, hasSrc, props, null);
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (propValue$188 in props)
              props.hasOwnProperty(propValue$188) && (hasSrc = props[propValue$188], void 0 !== hasSrc && setPropOnCustomElement(
                domElement,
                tag,
                propValue$188,
                hasSrc,
                props,
                void 0
              ));
            return;
          }
      }
      for (defaultValue in props)
        props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
    }
    function updateProperties(domElement, tag, lastProps, nextProps) {
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
          for (propKey in lastProps) {
            var lastProp = lastProps[propKey];
            if (lastProps.hasOwnProperty(propKey) && null != lastProp)
              switch (propKey) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  lastDefaultValue = lastProp;
                default:
                  nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
              }
          }
          for (var propKey$205 in nextProps) {
            var propKey = nextProps[propKey$205];
            lastProp = lastProps[propKey$205];
            if (nextProps.hasOwnProperty(propKey$205) && (null != propKey || null != lastProp))
              switch (propKey$205) {
                case "type":
                  type = propKey;
                  break;
                case "name":
                  name = propKey;
                  break;
                case "checked":
                  checked = propKey;
                  break;
                case "defaultChecked":
                  defaultChecked = propKey;
                  break;
                case "value":
                  value = propKey;
                  break;
                case "defaultValue":
                  defaultValue = propKey;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propKey)
                    throw Error(formatProdErrorMessage(137, tag));
                  break;
                default:
                  propKey !== lastProp && setProp(
                    domElement,
                    tag,
                    propKey$205,
                    propKey,
                    nextProps,
                    lastProp
                  );
              }
          }
          updateInput(
            domElement,
            value,
            defaultValue,
            lastDefaultValue,
            checked,
            defaultChecked,
            type,
            name
          );
          return;
        case "select":
          propKey = value = defaultValue = propKey$205 = null;
          for (type in lastProps)
            if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
              switch (type) {
                case "value":
                  break;
                case "multiple":
                  propKey = lastDefaultValue;
                default:
                  nextProps.hasOwnProperty(type) || setProp(
                    domElement,
                    tag,
                    type,
                    null,
                    nextProps,
                    lastDefaultValue
                  );
              }
          for (name in nextProps)
            if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
              switch (name) {
                case "value":
                  propKey$205 = type;
                  break;
                case "defaultValue":
                  defaultValue = type;
                  break;
                case "multiple":
                  value = type;
                default:
                  type !== lastDefaultValue && setProp(
                    domElement,
                    tag,
                    name,
                    type,
                    nextProps,
                    lastDefaultValue
                  );
              }
          tag = defaultValue;
          lastProps = value;
          nextProps = propKey;
          null != propKey$205 ? updateOptions(domElement, !!lastProps, propKey$205, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
          return;
        case "textarea":
          propKey = propKey$205 = null;
          for (defaultValue in lastProps)
            if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
              switch (defaultValue) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  setProp(domElement, tag, defaultValue, null, nextProps, name);
              }
          for (value in nextProps)
            if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
              switch (value) {
                case "value":
                  propKey$205 = name;
                  break;
                case "defaultValue":
                  propKey = name;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != name) throw Error(formatProdErrorMessage(91));
                  break;
                default:
                  name !== type && setProp(domElement, tag, value, name, nextProps, type);
              }
          updateTextarea(domElement, propKey$205, propKey);
          return;
        case "option":
          for (var propKey$221 in lastProps)
            if (propKey$205 = lastProps[propKey$221], lastProps.hasOwnProperty(propKey$221) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$221))
              switch (propKey$221) {
                case "selected":
                  domElement.selected = false;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    propKey$221,
                    null,
                    nextProps,
                    propKey$205
                  );
              }
          for (lastDefaultValue in nextProps)
            if (propKey$205 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$205 !== propKey && (null != propKey$205 || null != propKey))
              switch (lastDefaultValue) {
                case "selected":
                  domElement.selected = propKey$205 && "function" !== typeof propKey$205 && "symbol" !== typeof propKey$205;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    lastDefaultValue,
                    propKey$205,
                    nextProps,
                    propKey
                  );
              }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var propKey$226 in lastProps)
            propKey$205 = lastProps[propKey$226], lastProps.hasOwnProperty(propKey$226) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$226) && setProp(domElement, tag, propKey$226, null, nextProps, propKey$205);
          for (checked in nextProps)
            if (propKey$205 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$205 !== propKey && (null != propKey$205 || null != propKey))
              switch (checked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propKey$205)
                    throw Error(formatProdErrorMessage(137, tag));
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    checked,
                    propKey$205,
                    nextProps,
                    propKey
                  );
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (var propKey$231 in lastProps)
              propKey$205 = lastProps[propKey$231], lastProps.hasOwnProperty(propKey$231) && void 0 !== propKey$205 && !nextProps.hasOwnProperty(propKey$231) && setPropOnCustomElement(
                domElement,
                tag,
                propKey$231,
                void 0,
                nextProps,
                propKey$205
              );
            for (defaultChecked in nextProps)
              propKey$205 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$205 === propKey || void 0 === propKey$205 && void 0 === propKey || setPropOnCustomElement(
                domElement,
                tag,
                defaultChecked,
                propKey$205,
                nextProps,
                propKey
              );
            return;
          }
      }
      for (var propKey$236 in lastProps)
        propKey$205 = lastProps[propKey$236], lastProps.hasOwnProperty(propKey$236) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$236) && setProp(domElement, tag, propKey$236, null, nextProps, propKey$205);
      for (lastProp in nextProps)
        propKey$205 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$205 === propKey || null == propKey$205 && null == propKey || setProp(domElement, tag, lastProp, propKey$205, nextProps, propKey);
    }
    var eventsEnabled = null, selectionInformation = null;
    function getOwnerDocumentFromRootContainer(rootContainerElement) {
      return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
    }
    function getOwnHostContext(namespaceURI) {
      switch (namespaceURI) {
        case "http://www.w3.org/2000/svg":
          return 1;
        case "http://www.w3.org/1998/Math/MathML":
          return 2;
        default:
          return 0;
      }
    }
    function getChildHostContextProd(parentNamespace, type) {
      if (0 === parentNamespace)
        switch (type) {
          case "svg":
            return 1;
          case "math":
            return 2;
          default:
            return 0;
        }
      return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
    }
    function shouldSetTextContent(type, props) {
      return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
    }
    var currentPopstateTransitionEvent = null;
    function shouldAttemptEagerTransition() {
      var event = window.event;
      if (event && "popstate" === event.type) {
        if (event === currentPopstateTransitionEvent) return false;
        currentPopstateTransitionEvent = event;
        return true;
      }
      currentPopstateTransitionEvent = null;
      return false;
    }
    var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask2 = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
      return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
    } : scheduleTimeout;
    function handleErrorInNextTick(error) {
      setTimeout(function() {
        throw error;
      });
    }
    function isSingletonScope(type) {
      return "head" === type;
    }
    function clearSuspenseBoundary(parentInstance, suspenseInstance) {
      var node = suspenseInstance, possiblePreambleContribution = 0, depth = 0;
      do {
        var nextNode = node.nextSibling;
        parentInstance.removeChild(node);
        if (nextNode && 8 === nextNode.nodeType)
          if (node = nextNode.data, "/$" === node) {
            if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {
              node = possiblePreambleContribution;
              var ownerDocument = parentInstance.ownerDocument;
              node & 1 && releaseSingletonInstance(ownerDocument.documentElement);
              node & 2 && releaseSingletonInstance(ownerDocument.body);
              if (node & 4)
                for (node = ownerDocument.head, releaseSingletonInstance(node), ownerDocument = node.firstChild; ownerDocument; ) {
                  var nextNode$jscomp$0 = ownerDocument.nextSibling, nodeName = ownerDocument.nodeName;
                  ownerDocument[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === ownerDocument.rel.toLowerCase() || node.removeChild(ownerDocument);
                  ownerDocument = nextNode$jscomp$0;
                }
            }
            if (0 === depth) {
              parentInstance.removeChild(nextNode);
              retryIfBlockedOn(suspenseInstance);
              return;
            }
            depth--;
          } else
            "$" === node || "$?" === node || "$!" === node ? depth++ : possiblePreambleContribution = node.charCodeAt(0) - 48;
        else possiblePreambleContribution = 0;
        node = nextNode;
      } while (node);
      retryIfBlockedOn(suspenseInstance);
    }
    function clearContainerSparingly(container) {
      var nextNode = container.firstChild;
      nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
      for (; nextNode; ) {
        var node = nextNode;
        nextNode = nextNode.nextSibling;
        switch (node.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            clearContainerSparingly(node);
            detachDeletedInstance(node);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if ("stylesheet" === node.rel.toLowerCase()) continue;
        }
        container.removeChild(node);
      }
    }
    function canHydrateInstance(instance, type, props, inRootOrSingleton) {
      for (; 1 === instance.nodeType; ) {
        var anyProps = props;
        if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
          if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
            break;
        } else if (!inRootOrSingleton)
          if ("input" === type && "hidden" === instance.type) {
            var name = null == anyProps.name ? null : "" + anyProps.name;
            if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
              return instance;
          } else return instance;
        else if (!instance[internalHoistableMarker])
          switch (type) {
            case "meta":
              if (!instance.hasAttribute("itemprop")) break;
              return instance;
            case "link":
              name = instance.getAttribute("rel");
              if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                break;
              else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                break;
              return instance;
            case "style":
              if (instance.hasAttribute("data-precedence")) break;
              return instance;
            case "script":
              name = instance.getAttribute("src");
              if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                break;
              return instance;
            default:
              return instance;
          }
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) break;
      }
      return null;
    }
    function canHydrateTextInstance(instance, text2, inRootOrSingleton) {
      if ("" === text2) return null;
      for (; 3 !== instance.nodeType; ) {
        if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
          return null;
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) return null;
      }
      return instance;
    }
    function isSuspenseInstanceFallback(instance) {
      return "$!" === instance.data || "$?" === instance.data && "complete" === instance.ownerDocument.readyState;
    }
    function registerSuspenseInstanceRetry(instance, callback) {
      var ownerDocument = instance.ownerDocument;
      if ("$?" !== instance.data || "complete" === ownerDocument.readyState)
        callback();
      else {
        var listener = function() {
          callback();
          ownerDocument.removeEventListener("DOMContentLoaded", listener);
        };
        ownerDocument.addEventListener("DOMContentLoaded", listener);
        instance._reactRetry = listener;
      }
    }
    function getNextHydratable(node) {
      for (; null != node; node = node.nextSibling) {
        var nodeType = node.nodeType;
        if (1 === nodeType || 3 === nodeType) break;
        if (8 === nodeType) {
          nodeType = node.data;
          if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "F!" === nodeType || "F" === nodeType)
            break;
          if ("/$" === nodeType) return null;
        }
      }
      return node;
    }
    var previousHydratableOnEnteringScopedSingleton = null;
    function getParentSuspenseInstance(targetInstance) {
      targetInstance = targetInstance.previousSibling;
      for (var depth = 0; targetInstance; ) {
        if (8 === targetInstance.nodeType) {
          var data = targetInstance.data;
          if ("$" === data || "$!" === data || "$?" === data) {
            if (0 === depth) return targetInstance;
            depth--;
          } else "/$" === data && depth++;
        }
        targetInstance = targetInstance.previousSibling;
      }
      return null;
    }
    function resolveSingletonInstance(type, props, rootContainerInstance) {
      props = getOwnerDocumentFromRootContainer(rootContainerInstance);
      switch (type) {
        case "html":
          type = props.documentElement;
          if (!type) throw Error(formatProdErrorMessage(452));
          return type;
        case "head":
          type = props.head;
          if (!type) throw Error(formatProdErrorMessage(453));
          return type;
        case "body":
          type = props.body;
          if (!type) throw Error(formatProdErrorMessage(454));
          return type;
        default:
          throw Error(formatProdErrorMessage(451));
      }
    }
    function releaseSingletonInstance(instance) {
      for (var attributes = instance.attributes; attributes.length; )
        instance.removeAttributeNode(attributes[0]);
      detachDeletedInstance(instance);
    }
    var preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set();
    function getHoistableRoot(container) {
      return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
    }
    var previousDispatcher = ReactDOMSharedInternals.d;
    ReactDOMSharedInternals.d = {
      f: flushSyncWork,
      r: requestFormReset,
      D: prefetchDNS,
      C: preconnect,
      L: preload,
      m: preloadModule,
      X: preinitScript,
      S: preinitStyle,
      M: preinitModuleScript
    };
    function flushSyncWork() {
      var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
      return previousWasRendering || wasRendering;
    }
    function requestFormReset(form) {
      var formInst = getInstanceFromNode(form);
      null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
    }
    var globalDocument = "undefined" === typeof document ? null : document;
    function preconnectAs(rel, href, crossOrigin) {
      var ownerDocument = globalDocument;
      if (ownerDocument && "string" === typeof href && href) {
        var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
        limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
        "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
        preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
      }
    }
    function prefetchDNS(href) {
      previousDispatcher.D(href);
      preconnectAs("dns-prefetch", href, null);
    }
    function preconnect(href, crossOrigin) {
      previousDispatcher.C(href, crossOrigin);
      preconnectAs("preconnect", href, crossOrigin);
    }
    function preload(href, as, options2) {
      previousDispatcher.L(href, as, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && href && as) {
        var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
        "image" === as ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
          options2.imageSrcSet
        ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
          options2.imageSizes
        ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
        var key2 = preloadSelector;
        switch (as) {
          case "style":
            key2 = getStyleKey(href);
            break;
          case "script":
            key2 = getScriptKey(href);
        }
        preloadPropsMap.has(key2) || (href = assign2(
          {
            rel: "preload",
            href: "image" === as && options2 && options2.imageSrcSet ? void 0 : href,
            as
          },
          options2
        ), preloadPropsMap.set(key2, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key2)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key2)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
      }
    }
    function preloadModule(href, options2) {
      previousDispatcher.m(href, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && href) {
        var as = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key2 = preloadSelector;
        switch (as) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            key2 = getScriptKey(href);
        }
        if (!preloadPropsMap.has(key2) && (href = assign2({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key2, href), null === ownerDocument.querySelector(preloadSelector))) {
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              if (ownerDocument.querySelector(getScriptSelectorFromKey(key2)))
                return;
          }
          as = ownerDocument.createElement("link");
          setInitialProperties(as, "link", href);
          markNodeAsHoistable(as);
          ownerDocument.head.appendChild(as);
        }
      }
    }
    function preinitStyle(href, precedence, options2) {
      previousDispatcher.S(href, precedence, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && href) {
        var styles2 = getResourcesFromRoot(ownerDocument).hoistableStyles, key2 = getStyleKey(href);
        precedence = precedence || "default";
        var resource = styles2.get(key2);
        if (!resource) {
          var state = { loading: 0, preload: null };
          if (resource = ownerDocument.querySelector(
            getStylesheetSelectorFromKey(key2)
          ))
            state.loading = 5;
          else {
            href = assign2(
              { rel: "stylesheet", href, "data-precedence": precedence },
              options2
            );
            (options2 = preloadPropsMap.get(key2)) && adoptPreloadPropsForStylesheet(href, options2);
            var link = resource = ownerDocument.createElement("link");
            markNodeAsHoistable(link);
            setInitialProperties(link, "link", href);
            link._p = new Promise(function(resolve, reject) {
              link.onload = resolve;
              link.onerror = reject;
            });
            link.addEventListener("load", function() {
              state.loading |= 1;
            });
            link.addEventListener("error", function() {
              state.loading |= 2;
            });
            state.loading |= 4;
            insertStylesheet(resource, precedence, ownerDocument);
          }
          resource = {
            type: "stylesheet",
            instance: resource,
            count: 1,
            state
          };
          styles2.set(key2, resource);
        }
      }
    }
    function preinitScript(src, options2) {
      previousDispatcher.X(src, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && src) {
        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key2 = getScriptKey(src), resource = scripts.get(key2);
        resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key2)), resource || (src = assign2({ src, async: true }, options2), (options2 = preloadPropsMap.get(key2)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
          type: "script",
          instance: resource,
          count: 1,
          state: null
        }, scripts.set(key2, resource));
      }
    }
    function preinitModuleScript(src, options2) {
      previousDispatcher.M(src, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && src) {
        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key2 = getScriptKey(src), resource = scripts.get(key2);
        resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key2)), resource || (src = assign2({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key2)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
          type: "script",
          instance: resource,
          count: 1,
          state: null
        }, scripts.set(key2, resource));
      }
    }
    function getResource(type, currentProps, pendingProps, currentResource) {
      var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
      if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
      switch (type) {
        case "meta":
        case "title":
          return null;
        case "style":
          return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
            type = getStyleKey(pendingProps.href);
            var styles$244 = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableStyles, resource$245 = styles$244.get(type);
            resource$245 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$245 = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: { loading: 0, preload: null }
            }, styles$244.set(type, resource$245), (styles$244 = JSCompiler_inline_result.querySelector(
              getStylesheetSelectorFromKey(type)
            )) && !styles$244._p && (resource$245.instance = styles$244, resource$245.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
              rel: "preload",
              as: "style",
              href: pendingProps.href,
              crossOrigin: pendingProps.crossOrigin,
              integrity: pendingProps.integrity,
              media: pendingProps.media,
              hrefLang: pendingProps.hrefLang,
              referrerPolicy: pendingProps.referrerPolicy
            }, preloadPropsMap.set(type, pendingProps), styles$244 || preloadStylesheet(
              JSCompiler_inline_result,
              type,
              pendingProps,
              resource$245.state
            )));
            if (currentProps && null === currentResource)
              throw Error(formatProdErrorMessage(528, ""));
            return resource$245;
          }
          if (currentProps && null !== currentResource)
            throw Error(formatProdErrorMessage(529, ""));
          return null;
        case "script":
          return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
        default:
          throw Error(formatProdErrorMessage(444, type));
      }
    }
    function getStyleKey(href) {
      return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
    }
    function getStylesheetSelectorFromKey(key2) {
      return 'link[rel="stylesheet"][' + key2 + "]";
    }
    function stylesheetPropsFromRawProps(rawProps) {
      return assign2({}, rawProps, {
        "data-precedence": rawProps.precedence,
        precedence: null
      });
    }
    function preloadStylesheet(ownerDocument, key2, preloadProps, state) {
      ownerDocument.querySelector('link[rel="preload"][as="style"][' + key2 + "]") ? state.loading = 1 : (key2 = ownerDocument.createElement("link"), state.preload = key2, key2.addEventListener("load", function() {
        return state.loading |= 1;
      }), key2.addEventListener("error", function() {
        return state.loading |= 2;
      }), setInitialProperties(key2, "link", preloadProps), markNodeAsHoistable(key2), ownerDocument.head.appendChild(key2));
    }
    function getScriptKey(src) {
      return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
    }
    function getScriptSelectorFromKey(key2) {
      return "script[async]" + key2;
    }
    function acquireResource(hoistableRoot, resource, props) {
      resource.count++;
      if (null === resource.instance)
        switch (resource.type) {
          case "style":
            var instance = hoistableRoot.querySelector(
              'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
            );
            if (instance)
              return resource.instance = instance, markNodeAsHoistable(instance), instance;
            var styleProps = assign2({}, props, {
              "data-href": props.href,
              "data-precedence": props.precedence,
              href: null,
              precedence: null
            });
            instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
              "style"
            );
            markNodeAsHoistable(instance);
            setInitialProperties(instance, "style", styleProps);
            insertStylesheet(instance, props.precedence, hoistableRoot);
            return resource.instance = instance;
          case "stylesheet":
            styleProps = getStyleKey(props.href);
            var instance$250 = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(styleProps)
            );
            if (instance$250)
              return resource.state.loading |= 4, resource.instance = instance$250, markNodeAsHoistable(instance$250), instance$250;
            instance = stylesheetPropsFromRawProps(props);
            (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
            instance$250 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
            markNodeAsHoistable(instance$250);
            var linkInstance = instance$250;
            linkInstance._p = new Promise(function(resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(instance$250, "link", instance);
            resource.state.loading |= 4;
            insertStylesheet(instance$250, props.precedence, hoistableRoot);
            return resource.instance = instance$250;
          case "script":
            instance$250 = getScriptKey(props.src);
            if (styleProps = hoistableRoot.querySelector(
              getScriptSelectorFromKey(instance$250)
            ))
              return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
            instance = props;
            if (styleProps = preloadPropsMap.get(instance$250))
              instance = assign2({}, props), adoptPreloadPropsForScript(instance, styleProps);
            hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
            styleProps = hoistableRoot.createElement("script");
            markNodeAsHoistable(styleProps);
            setInitialProperties(styleProps, "link", instance);
            hoistableRoot.head.appendChild(styleProps);
            return resource.instance = styleProps;
          case "void":
            return null;
          default:
            throw Error(formatProdErrorMessage(443, resource.type));
        }
      else
        "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
      return resource.instance;
    }
    function insertStylesheet(instance, precedence, root2) {
      for (var nodes2 = root2.querySelectorAll(
        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
      ), last2 = nodes2.length ? nodes2[nodes2.length - 1] : null, prior = last2, i2 = 0; i2 < nodes2.length; i2++) {
        var node = nodes2[i2];
        if (node.dataset.precedence === precedence) prior = node;
        else if (prior !== last2) break;
      }
      prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
    }
    function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
      null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
      null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
      null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
    }
    function adoptPreloadPropsForScript(scriptProps, preloadProps) {
      null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
      null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
      null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
    }
    var tagCaches = null;
    function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
      if (null === tagCaches) {
        var cache = /* @__PURE__ */ new Map();
        var caches = tagCaches = /* @__PURE__ */ new Map();
        caches.set(ownerDocument, cache);
      } else
        caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
      if (cache.has(type)) return cache;
      cache.set(type, null);
      ownerDocument = ownerDocument.getElementsByTagName(type);
      for (caches = 0; caches < ownerDocument.length; caches++) {
        var node = ownerDocument[caches];
        if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
          var nodeKey = node.getAttribute(keyAttribute) || "";
          nodeKey = type + nodeKey;
          var existing = cache.get(nodeKey);
          existing ? existing.push(node) : cache.set(nodeKey, [node]);
        }
      }
      return cache;
    }
    function mountHoistable(hoistableRoot, type, instance) {
      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
      hoistableRoot.head.insertBefore(
        instance,
        "title" === type ? hoistableRoot.querySelector("head > title") : null
      );
    }
    function isHostHoistableType(type, props, hostContext) {
      if (1 === hostContext || null != props.itemProp) return false;
      switch (type) {
        case "meta":
        case "title":
          return true;
        case "style":
          if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
            break;
          return true;
        case "link":
          if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
            break;
          switch (props.rel) {
            case "stylesheet":
              return type = props.disabled, "string" === typeof props.precedence && null == type;
            default:
              return true;
          }
        case "script":
          if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
            return true;
      }
      return false;
    }
    function preloadResource(resource) {
      return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
    }
    var suspendedState = null;
    function noop2() {
    }
    function suspendResource(hoistableRoot, resource, props) {
      if (null === suspendedState) throw Error(formatProdErrorMessage(475));
      var state = suspendedState;
      if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
        if (null === resource.instance) {
          var key2 = getStyleKey(props.href), instance = hoistableRoot.querySelector(
            getStylesheetSelectorFromKey(key2)
          );
          if (instance) {
            hoistableRoot = instance._p;
            null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
            resource.state.loading |= 4;
            resource.instance = instance;
            markNodeAsHoistable(instance);
            return;
          }
          instance = hoistableRoot.ownerDocument || hoistableRoot;
          props = stylesheetPropsFromRawProps(props);
          (key2 = preloadPropsMap.get(key2)) && adoptPreloadPropsForStylesheet(props, key2);
          instance = instance.createElement("link");
          markNodeAsHoistable(instance);
          var linkInstance = instance;
          linkInstance._p = new Promise(function(resolve, reject) {
            linkInstance.onload = resolve;
            linkInstance.onerror = reject;
          });
          setInitialProperties(instance, "link", props);
          resource.instance = instance;
        }
        null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
        state.stylesheets.set(resource, hoistableRoot);
        (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
      }
    }
    function waitForCommitToBeReady() {
      if (null === suspendedState) throw Error(formatProdErrorMessage(475));
      var state = suspendedState;
      state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
      return 0 < state.count ? function(commit) {
        var stylesheetTimer = setTimeout(function() {
          state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
          if (state.unsuspend) {
            var unsuspend = state.unsuspend;
            state.unsuspend = null;
            unsuspend();
          }
        }, 6e4);
        state.unsuspend = commit;
        return function() {
          state.unsuspend = null;
          clearTimeout(stylesheetTimer);
        };
      } : null;
    }
    function onUnsuspend() {
      this.count--;
      if (0 === this.count) {
        if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
        else if (this.unsuspend) {
          var unsuspend = this.unsuspend;
          this.unsuspend = null;
          unsuspend();
        }
      }
    }
    var precedencesByRoot = null;
    function insertSuspendedStylesheets(state, resources) {
      state.stylesheets = null;
      null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
    }
    function insertStylesheetIntoRoot(root2, resource) {
      if (!(resource.state.loading & 4)) {
        var precedences = precedencesByRoot.get(root2);
        if (precedences) var last2 = precedences.get(null);
        else {
          precedences = /* @__PURE__ */ new Map();
          precedencesByRoot.set(root2, precedences);
          for (var nodes2 = root2.querySelectorAll(
            "link[data-precedence],style[data-precedence]"
          ), i2 = 0; i2 < nodes2.length; i2++) {
            var node = nodes2[i2];
            if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
              precedences.set(node.dataset.precedence, node), last2 = node;
          }
          last2 && precedences.set(null, last2);
        }
        nodes2 = resource.instance;
        node = nodes2.getAttribute("data-precedence");
        i2 = precedences.get(node) || last2;
        i2 === last2 && precedences.set(null, nodes2);
        precedences.set(node, nodes2);
        this.count++;
        last2 = onUnsuspend.bind(this);
        nodes2.addEventListener("load", last2);
        nodes2.addEventListener("error", last2);
        i2 ? i2.parentNode.insertBefore(nodes2, i2.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes2, root2.firstChild));
        resource.state.loading |= 4;
      }
    }
    var HostTransitionContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Provider: null,
      Consumer: null,
      _currentValue: sharedNotPendingObject,
      _currentValue2: sharedNotPendingObject,
      _threadCount: 0
    };
    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
      this.tag = 1;
      this.containerInfo = containerInfo;
      this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
      this.callbackPriority = 0;
      this.expirationTimes = createLaneMap(-1);
      this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = createLaneMap(0);
      this.hiddenUpdates = createLaneMap(null);
      this.identifierPrefix = identifierPrefix;
      this.onUncaughtError = onUncaughtError;
      this.onCaughtError = onCaughtError;
      this.onRecoverableError = onRecoverableError;
      this.pooledCache = null;
      this.pooledCacheLanes = 0;
      this.formState = formState;
      this.incompleteTransitions = /* @__PURE__ */ new Map();
    }
    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
      containerInfo = new FiberRootNode(
        containerInfo,
        tag,
        hydrate,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        formState
      );
      tag = 1;
      true === isStrictMode && (tag |= 24);
      isStrictMode = createFiberImplClass(3, null, null, tag);
      containerInfo.current = isStrictMode;
      isStrictMode.stateNode = containerInfo;
      tag = createCache();
      tag.refCount++;
      containerInfo.pooledCache = tag;
      tag.refCount++;
      isStrictMode.memoizedState = {
        element: initialChildren,
        isDehydrated: hydrate,
        cache: tag
      };
      initializeUpdateQueue(isStrictMode);
      return containerInfo;
    }
    function getContextForSubtree(parentComponent) {
      if (!parentComponent) return emptyContextObject;
      parentComponent = emptyContextObject;
      return parentComponent;
    }
    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
      parentComponent = getContextForSubtree(parentComponent);
      null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
      container = createUpdate(lane);
      container.payload = { element };
      callback = void 0 === callback ? null : callback;
      null !== callback && (container.callback = callback);
      element = enqueueUpdate(rootFiber, container, lane);
      null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
    }
    function markRetryLaneImpl(fiber, retryLane) {
      fiber = fiber.memoizedState;
      if (null !== fiber && null !== fiber.dehydrated) {
        var a = fiber.retryLane;
        fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
      }
    }
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
      markRetryLaneImpl(fiber, retryLane);
      (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
    }
    function attemptContinuousHydration(fiber) {
      if (13 === fiber.tag) {
        var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
        null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
        markRetryLaneIfNotHydrated(fiber, 67108864);
      }
    }
    var _enabled = true;
    function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 2, dispatchEvent2(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 8, dispatchEvent2(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    function dispatchEvent2(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (_enabled) {
        var blockedOn = findInstanceBlockingEvent(nativeEvent);
        if (null === blockedOn)
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            return_targetInst,
            targetContainer
          ), clearIfContinuousEvent(domEventName, nativeEvent);
        else if (queueIfContinuousEvent(
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        ))
          nativeEvent.stopPropagation();
        else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
          for (; null !== blockedOn; ) {
            var fiber = getInstanceFromNode(blockedOn);
            if (null !== fiber)
              switch (fiber.tag) {
                case 3:
                  fiber = fiber.stateNode;
                  if (fiber.current.memoizedState.isDehydrated) {
                    var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                    if (0 !== lanes) {
                      var root2 = fiber;
                      root2.pendingLanes |= 2;
                      for (root2.entangledLanes |= 2; lanes; ) {
                        var lane = 1 << 31 - clz32(lanes);
                        root2.entanglements[1] |= lane;
                        lanes &= ~lane;
                      }
                      ensureRootIsScheduled(fiber);
                      0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0));
                    }
                  }
                  break;
                case 13:
                  root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
              }
            fiber = findInstanceBlockingEvent(nativeEvent);
            null === fiber && dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              return_targetInst,
              targetContainer
            );
            if (fiber === blockedOn) break;
            blockedOn = fiber;
          }
          null !== blockedOn && nativeEvent.stopPropagation();
        } else
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            null,
            targetContainer
          );
      }
    }
    function findInstanceBlockingEvent(nativeEvent) {
      nativeEvent = getEventTarget(nativeEvent);
      return findInstanceBlockingTarget(nativeEvent);
    }
    var return_targetInst = null;
    function findInstanceBlockingTarget(targetNode) {
      return_targetInst = null;
      targetNode = getClosestInstanceFromNode(targetNode);
      if (null !== targetNode) {
        var nearestMounted = getNearestMountedFiber(targetNode);
        if (null === nearestMounted) targetNode = null;
        else {
          var tag = nearestMounted.tag;
          if (13 === tag) {
            targetNode = getSuspenseInstanceFromFiber(nearestMounted);
            if (null !== targetNode) return targetNode;
            targetNode = null;
          } else if (3 === tag) {
            if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
              return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
            targetNode = null;
          } else nearestMounted !== targetNode && (targetNode = null);
        }
      }
      return_targetInst = targetNode;
      return null;
    }
    function getEventPriority(domEventName) {
      switch (domEventName) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 8;
        case "message":
          switch (getCurrentPriorityLevel()) {
            case ImmediatePriority:
              return 2;
            case UserBlockingPriority:
              return 8;
            case NormalPriority$1:
            case LowPriority:
              return 32;
            case IdlePriority:
              return 268435456;
            default:
              return 32;
          }
        default:
          return 32;
      }
    }
    var hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
      " "
    );
    function clearIfContinuousEvent(domEventName, nativeEvent) {
      switch (domEventName) {
        case "focusin":
        case "focusout":
          queuedFocus = null;
          break;
        case "dragenter":
        case "dragleave":
          queuedDrag = null;
          break;
        case "mouseover":
        case "mouseout":
          queuedMouse = null;
          break;
        case "pointerover":
        case "pointerout":
          queuedPointers.delete(nativeEvent.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          queuedPointerCaptures.delete(nativeEvent.pointerId);
      }
    }
    function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
        return existingQueuedEvent = {
          blockedOn,
          domEventName,
          eventSystemFlags,
          nativeEvent,
          targetContainers: [targetContainer]
        }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
      existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
      blockedOn = existingQueuedEvent.targetContainers;
      null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
      return existingQueuedEvent;
    }
    function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      switch (domEventName) {
        case "focusin":
          return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedFocus,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ), true;
        case "dragenter":
          return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedDrag,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ), true;
        case "mouseover":
          return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedMouse,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ), true;
        case "pointerover":
          var pointerId = nativeEvent.pointerId;
          queuedPointers.set(
            pointerId,
            accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedPointers.get(pointerId) || null,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )
          );
          return true;
        case "gotpointercapture":
          return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
            pointerId,
            accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedPointerCaptures.get(pointerId) || null,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )
          ), true;
      }
      return false;
    }
    function attemptExplicitHydrationTarget(queuedTarget) {
      var targetInst = getClosestInstanceFromNode(queuedTarget.target);
      if (null !== targetInst) {
        var nearestMounted = getNearestMountedFiber(targetInst);
        if (null !== nearestMounted) {
          if (targetInst = nearestMounted.tag, 13 === targetInst) {
            if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
              queuedTarget.blockedOn = targetInst;
              runWithPriority(queuedTarget.priority, function() {
                if (13 === nearestMounted.tag) {
                  var lane = requestUpdateLane();
                  lane = getBumpedLaneForHydrationByLane(lane);
                  var root2 = enqueueConcurrentRenderForLane(nearestMounted, lane);
                  null !== root2 && scheduleUpdateOnFiber(root2, nearestMounted, lane);
                  markRetryLaneIfNotHydrated(nearestMounted, lane);
                }
              });
              return;
            }
          } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
            queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
            return;
          }
        }
      }
      queuedTarget.blockedOn = null;
    }
    function attemptReplayContinuousQueuedEvent(queuedEvent) {
      if (null !== queuedEvent.blockedOn) return false;
      for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
        var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
        if (null === nextBlockedOn) {
          nextBlockedOn = queuedEvent.nativeEvent;
          var nativeEventClone = new nextBlockedOn.constructor(
            nextBlockedOn.type,
            nextBlockedOn
          );
          currentReplayingEvent = nativeEventClone;
          nextBlockedOn.target.dispatchEvent(nativeEventClone);
          currentReplayingEvent = null;
        } else
          return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
        targetContainers.shift();
      }
      return true;
    }
    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key2, map) {
      attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key2);
    }
    function replayUnblockedEvents() {
      hasScheduledReplayAttempt = false;
      null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
      null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
      null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
      queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
      queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
    }
    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
      queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
        Scheduler.unstable_NormalPriority,
        replayUnblockedEvents
      )));
    }
    var lastScheduledReplayQueue = null;
    function scheduleReplayQueueIfNeeded(formReplayingQueue) {
      lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
        Scheduler.unstable_NormalPriority,
        function() {
          lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
          for (var i2 = 0; i2 < formReplayingQueue.length; i2 += 3) {
            var form = formReplayingQueue[i2], submitterOrAction = formReplayingQueue[i2 + 1], formData = formReplayingQueue[i2 + 2];
            if ("function" !== typeof submitterOrAction)
              if (null === findInstanceBlockingTarget(submitterOrAction || form))
                continue;
              else break;
            var formInst = getInstanceFromNode(form);
            null !== formInst && (formReplayingQueue.splice(i2, 3), i2 -= 3, startHostTransition(
              formInst,
              {
                pending: true,
                data: formData,
                method: form.method,
                action: submitterOrAction
              },
              submitterOrAction,
              formData
            ));
          }
        }
      ));
    }
    function retryIfBlockedOn(unblocked) {
      function unblock(queuedEvent) {
        return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
      }
      null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
      null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
      null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
      queuedPointers.forEach(unblock);
      queuedPointerCaptures.forEach(unblock);
      for (var i2 = 0; i2 < queuedExplicitHydrationTargets.length; i2++) {
        var queuedTarget = queuedExplicitHydrationTargets[i2];
        queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
      }
      for (; 0 < queuedExplicitHydrationTargets.length && (i2 = queuedExplicitHydrationTargets[0], null === i2.blockedOn); )
        attemptExplicitHydrationTarget(i2), null === i2.blockedOn && queuedExplicitHydrationTargets.shift();
      i2 = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
      if (null != i2)
        for (queuedTarget = 0; queuedTarget < i2.length; queuedTarget += 3) {
          var form = i2[queuedTarget], submitterOrAction = i2[queuedTarget + 1], formProps = form[internalPropsKey] || null;
          if ("function" === typeof submitterOrAction)
            formProps || scheduleReplayQueueIfNeeded(i2);
          else if (formProps) {
            var action = null;
            if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
              if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                action = formProps.formAction;
              else {
                if (null !== findInstanceBlockingTarget(form)) continue;
              }
            else action = formProps.action;
            "function" === typeof action ? i2[queuedTarget + 1] = action : (i2.splice(queuedTarget, 3), queuedTarget -= 3);
            scheduleReplayQueueIfNeeded(i2);
          }
        }
    }
    function ReactDOMRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
      var root2 = this._internalRoot;
      if (null === root2) throw Error(formatProdErrorMessage(409));
      var current = root2.current, lane = requestUpdateLane();
      updateContainerImpl(current, lane, children, root2, null, null);
    };
    ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
      var root2 = this._internalRoot;
      if (null !== root2) {
        this._internalRoot = null;
        var container = root2.containerInfo;
        updateContainerImpl(root2.current, 2, null, root2, null, null);
        flushSyncWork$1();
        container[internalContainerInstanceKey] = null;
      }
    };
    function ReactDOMHydrationRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
      if (target) {
        var updatePriority = resolveUpdatePriority();
        target = { blockedOn: null, target, priority: updatePriority };
        for (var i2 = 0; i2 < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i2].priority; i2++) ;
        queuedExplicitHydrationTargets.splice(i2, 0, target);
        0 === i2 && attemptExplicitHydrationTarget(target);
      }
    };
    var isomorphicReactPackageVersion$jscomp$inline_1785 = React2.version;
    if ("19.1.0" !== isomorphicReactPackageVersion$jscomp$inline_1785)
      throw Error(
        formatProdErrorMessage(
          527,
          isomorphicReactPackageVersion$jscomp$inline_1785,
          "19.1.0"
        )
      );
    ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
      var fiber = componentOrElement._reactInternals;
      if (void 0 === fiber) {
        if ("function" === typeof componentOrElement.render)
          throw Error(formatProdErrorMessage(188));
        componentOrElement = Object.keys(componentOrElement).join(",");
        throw Error(formatProdErrorMessage(268, componentOrElement));
      }
      componentOrElement = findCurrentFiberUsingSlowPath(fiber);
      componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
      componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
      return componentOrElement;
    };
    var internals$jscomp$inline_2256 = {
      bundleType: 0,
      version: "19.1.0",
      rendererPackageName: "react-dom",
      currentDispatcherRef: ReactSharedInternals,
      reconcilerVersion: "19.1.0"
    };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      var hook$jscomp$inline_2257 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!hook$jscomp$inline_2257.isDisabled && hook$jscomp$inline_2257.supportsFiber)
        try {
          rendererID = hook$jscomp$inline_2257.inject(
            internals$jscomp$inline_2256
          ), injectedHook = hook$jscomp$inline_2257;
        } catch (err2) {
        }
    }
    reactDomClient_production.createRoot = function(container, options2) {
      if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
      var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;
      null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks));
      options2 = createFiberRoot(
        container,
        1,
        false,
        null,
        null,
        isStrictMode,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        transitionCallbacks,
        null
      );
      container[internalContainerInstanceKey] = options2.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMRoot(options2);
    };
    reactDomClient_production.hydrateRoot = function(container, initialChildren, options2) {
      if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
      var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;
      null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks), void 0 !== options2.formState && (formState = options2.formState));
      initialChildren = createFiberRoot(
        container,
        1,
        true,
        initialChildren,
        null != options2 ? options2 : null,
        isStrictMode,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        transitionCallbacks,
        formState
      );
      initialChildren.context = getContextForSubtree(null);
      options2 = initialChildren.current;
      isStrictMode = requestUpdateLane();
      isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
      identifierPrefix = createUpdate(isStrictMode);
      identifierPrefix.callback = null;
      enqueueUpdate(options2, identifierPrefix, isStrictMode);
      options2 = isStrictMode;
      initialChildren.current.lanes = options2;
      markRootUpdated$1(initialChildren, options2);
      ensureRootIsScheduled(initialChildren);
      container[internalContainerInstanceKey] = initialChildren.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMHydrationRoot(initialChildren);
    };
    reactDomClient_production.version = "19.1.0";
    return reactDomClient_production;
  }
  var hasRequiredClient;
  function requireClient() {
    if (hasRequiredClient) return client.exports;
    hasRequiredClient = 1;
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err2) {
        console.error(err2);
      }
    }
    {
      checkDCE();
      client.exports = requireReactDomClient_production();
    }
    return client.exports;
  }
  var clientExports = requireClient();
  const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(clientExports);
  var prefix$3 = "Invariant failed";
  function invariant$1(condition, message) {
    if (condition) {
      return;
    }
    {
      throw new Error(prefix$3);
    }
  }
  function warning(condition, message) {
  }
  const __storeToDerived = /* @__PURE__ */ new WeakMap();
  const __derivedToStore = /* @__PURE__ */ new WeakMap();
  const __depsThatHaveWrittenThisTick = {
    current: []
  };
  let __isFlushing = false;
  let __batchDepth = 0;
  const __pendingUpdates = /* @__PURE__ */ new Set();
  const __initialBatchValues = /* @__PURE__ */ new Map();
  function __flush_internals(relatedVals) {
    const sorted = Array.from(relatedVals).sort((a, b2) => {
      if (a instanceof Derived && a.options.deps.includes(b2)) return 1;
      if (b2 instanceof Derived && b2.options.deps.includes(a)) return -1;
      return 0;
    });
    for (const derived of sorted) {
      if (__depsThatHaveWrittenThisTick.current.includes(derived)) {
        continue;
      }
      __depsThatHaveWrittenThisTick.current.push(derived);
      derived.recompute();
      const stores = __derivedToStore.get(derived);
      if (stores) {
        for (const store of stores) {
          const relatedLinkedDerivedVals = __storeToDerived.get(store);
          if (!relatedLinkedDerivedVals) continue;
          __flush_internals(relatedLinkedDerivedVals);
        }
      }
    }
  }
  function __notifyListeners(store) {
    store.listeners.forEach(
      (listener) => listener({
        prevVal: store.prevState,
        currentVal: store.state
      })
    );
  }
  function __notifyDerivedListeners(derived) {
    derived.listeners.forEach(
      (listener) => listener({
        prevVal: derived.prevState,
        currentVal: derived.state
      })
    );
  }
  function __flush(store) {
    if (__batchDepth > 0 && !__initialBatchValues.has(store)) {
      __initialBatchValues.set(store, store.prevState);
    }
    __pendingUpdates.add(store);
    if (__batchDepth > 0) return;
    if (__isFlushing) return;
    try {
      __isFlushing = true;
      while (__pendingUpdates.size > 0) {
        const stores = Array.from(__pendingUpdates);
        __pendingUpdates.clear();
        for (const store2 of stores) {
          const prevState = __initialBatchValues.get(store2) ?? store2.prevState;
          store2.prevState = prevState;
          __notifyListeners(store2);
        }
        for (const store2 of stores) {
          const derivedVals = __storeToDerived.get(store2);
          if (!derivedVals) continue;
          __depsThatHaveWrittenThisTick.current.push(store2);
          __flush_internals(derivedVals);
        }
        for (const store2 of stores) {
          const derivedVals = __storeToDerived.get(store2);
          if (!derivedVals) continue;
          for (const derived of derivedVals) {
            __notifyDerivedListeners(derived);
          }
        }
      }
    } finally {
      __isFlushing = false;
      __depsThatHaveWrittenThisTick.current = [];
      __initialBatchValues.clear();
    }
  }
  function batch(fn) {
    __batchDepth++;
    try {
      fn();
    } finally {
      __batchDepth--;
      if (__batchDepth === 0) {
        const pendingUpdateToFlush = Array.from(__pendingUpdates)[0];
        if (pendingUpdateToFlush) {
          __flush(pendingUpdateToFlush);
        }
      }
    }
  }
  function isUpdaterFunction(updater) {
    return typeof updater === "function";
  }
  class Store {
    constructor(initialState, options) {
      this.listeners = /* @__PURE__ */ new Set();
      this.subscribe = (listener) => {
        var _a2, _b2;
        this.listeners.add(listener);
        const unsub = (_b2 = (_a2 = this.options) == null ? void 0 : _a2.onSubscribe) == null ? void 0 : _b2.call(_a2, listener, this);
        return () => {
          this.listeners.delete(listener);
          unsub == null ? void 0 : unsub();
        };
      };
      this.prevState = initialState;
      this.state = initialState;
      this.options = options;
    }
    setState(updater) {
      var _a2, _b2, _c2;
      this.prevState = this.state;
      if ((_a2 = this.options) == null ? void 0 : _a2.updateFn) {
        this.state = this.options.updateFn(this.prevState)(updater);
      } else {
        if (isUpdaterFunction(updater)) {
          this.state = updater(this.prevState);
        } else {
          this.state = updater;
        }
      }
      (_c2 = (_b2 = this.options) == null ? void 0 : _b2.onUpdate) == null ? void 0 : _c2.call(_b2);
      __flush(this);
    }
  }
  class Derived {
    constructor(options) {
      this.listeners = /* @__PURE__ */ new Set();
      this._subscriptions = [];
      this.lastSeenDepValues = [];
      this.getDepVals = () => {
        const prevDepVals = [];
        const currDepVals = [];
        for (const dep of this.options.deps) {
          prevDepVals.push(dep.prevState);
          currDepVals.push(dep.state);
        }
        this.lastSeenDepValues = currDepVals;
        return {
          prevDepVals,
          currDepVals,
          prevVal: this.prevState ?? void 0
        };
      };
      this.recompute = () => {
        var _a2, _b2;
        this.prevState = this.state;
        const { prevDepVals, currDepVals, prevVal } = this.getDepVals();
        this.state = this.options.fn({
          prevDepVals,
          currDepVals,
          prevVal
        });
        (_b2 = (_a2 = this.options).onUpdate) == null ? void 0 : _b2.call(_a2);
      };
      this.checkIfRecalculationNeededDeeply = () => {
        for (const dep of this.options.deps) {
          if (dep instanceof Derived) {
            dep.checkIfRecalculationNeededDeeply();
          }
        }
        let shouldRecompute = false;
        const lastSeenDepValues = this.lastSeenDepValues;
        const { currDepVals } = this.getDepVals();
        for (let i2 = 0; i2 < currDepVals.length; i2++) {
          if (currDepVals[i2] !== lastSeenDepValues[i2]) {
            shouldRecompute = true;
            break;
          }
        }
        if (shouldRecompute) {
          this.recompute();
        }
      };
      this.mount = () => {
        this.registerOnGraph();
        this.checkIfRecalculationNeededDeeply();
        return () => {
          this.unregisterFromGraph();
          for (const cleanup of this._subscriptions) {
            cleanup();
          }
        };
      };
      this.subscribe = (listener) => {
        var _a2, _b2;
        this.listeners.add(listener);
        const unsub = (_b2 = (_a2 = this.options).onSubscribe) == null ? void 0 : _b2.call(_a2, listener, this);
        return () => {
          this.listeners.delete(listener);
          unsub == null ? void 0 : unsub();
        };
      };
      this.options = options;
      this.state = options.fn({
        prevDepVals: void 0,
        prevVal: void 0,
        currDepVals: this.getDepVals().currDepVals
      });
    }
    registerOnGraph(deps = this.options.deps) {
      for (const dep of deps) {
        if (dep instanceof Derived) {
          dep.registerOnGraph();
          this.registerOnGraph(dep.options.deps);
        } else if (dep instanceof Store) {
          let relatedLinkedDerivedVals = __storeToDerived.get(dep);
          if (!relatedLinkedDerivedVals) {
            relatedLinkedDerivedVals = /* @__PURE__ */ new Set();
            __storeToDerived.set(dep, relatedLinkedDerivedVals);
          }
          relatedLinkedDerivedVals.add(this);
          let relatedStores = __derivedToStore.get(this);
          if (!relatedStores) {
            relatedStores = /* @__PURE__ */ new Set();
            __derivedToStore.set(this, relatedStores);
          }
          relatedStores.add(dep);
        }
      }
    }
    unregisterFromGraph(deps = this.options.deps) {
      for (const dep of deps) {
        if (dep instanceof Derived) {
          this.unregisterFromGraph(dep.options.deps);
        } else if (dep instanceof Store) {
          const relatedLinkedDerivedVals = __storeToDerived.get(dep);
          if (relatedLinkedDerivedVals) {
            relatedLinkedDerivedVals.delete(this);
          }
          const relatedStores = __derivedToStore.get(this);
          if (relatedStores) {
            relatedStores.delete(dep);
          }
        }
      }
    }
  }
  const stateIndexKey = "__TSR_index";
  const popStateEvent = "popstate";
  const beforeUnloadEvent = "beforeunload";
  function createHistory(opts) {
    let location2 = opts.getLocation();
    const subscribers = /* @__PURE__ */ new Set();
    const notify = (action) => {
      location2 = opts.getLocation();
      subscribers.forEach((subscriber) => subscriber({ location: location2, action }));
    };
    const handleIndexChange = (action) => {
      if (opts.notifyOnIndexChange ?? true) notify(action);
      else location2 = opts.getLocation();
    };
    const tryNavigation = async ({
      task,
      navigateOpts,
      ...actionInfo
    }) => {
      var _a2, _b2;
      const ignoreBlocker = (navigateOpts == null ? void 0 : navigateOpts.ignoreBlocker) ?? false;
      if (ignoreBlocker) {
        task();
        return;
      }
      const blockers = ((_a2 = opts.getBlockers) == null ? void 0 : _a2.call(opts)) ?? [];
      const isPushOrReplace = actionInfo.type === "PUSH" || actionInfo.type === "REPLACE";
      if (typeof document !== "undefined" && blockers.length && isPushOrReplace) {
        for (const blocker of blockers) {
          const nextLocation = parseHref(actionInfo.path, actionInfo.state);
          const isBlocked = await blocker.blockerFn({
            currentLocation: location2,
            nextLocation,
            action: actionInfo.type
          });
          if (isBlocked) {
            (_b2 = opts.onBlocked) == null ? void 0 : _b2.call(opts);
            return;
          }
        }
      }
      task();
    };
    return {
      get location() {
        return location2;
      },
      get length() {
        return opts.getLength();
      },
      subscribers,
      subscribe: (cb) => {
        subscribers.add(cb);
        return () => {
          subscribers.delete(cb);
        };
      },
      push: (path, state, navigateOpts) => {
        const currentIndex = location2.state[stateIndexKey];
        state = assignKeyAndIndex(currentIndex + 1, state);
        tryNavigation({
          task: () => {
            opts.pushState(path, state);
            notify({ type: "PUSH" });
          },
          navigateOpts,
          type: "PUSH",
          path,
          state
        });
      },
      replace: (path, state, navigateOpts) => {
        const currentIndex = location2.state[stateIndexKey];
        state = assignKeyAndIndex(currentIndex, state);
        tryNavigation({
          task: () => {
            opts.replaceState(path, state);
            notify({ type: "REPLACE" });
          },
          navigateOpts,
          type: "REPLACE",
          path,
          state
        });
      },
      go: (index, navigateOpts) => {
        tryNavigation({
          task: () => {
            opts.go(index);
            handleIndexChange({ type: "GO", index });
          },
          navigateOpts,
          type: "GO"
        });
      },
      back: (navigateOpts) => {
        tryNavigation({
          task: () => {
            opts.back((navigateOpts == null ? void 0 : navigateOpts.ignoreBlocker) ?? false);
            handleIndexChange({ type: "BACK" });
          },
          navigateOpts,
          type: "BACK"
        });
      },
      forward: (navigateOpts) => {
        tryNavigation({
          task: () => {
            opts.forward((navigateOpts == null ? void 0 : navigateOpts.ignoreBlocker) ?? false);
            handleIndexChange({ type: "FORWARD" });
          },
          navigateOpts,
          type: "FORWARD"
        });
      },
      canGoBack: () => location2.state[stateIndexKey] !== 0,
      createHref: (str) => opts.createHref(str),
      block: (blocker) => {
        var _a2;
        if (!opts.setBlockers) return () => {
        };
        const blockers = ((_a2 = opts.getBlockers) == null ? void 0 : _a2.call(opts)) ?? [];
        opts.setBlockers([...blockers, blocker]);
        return () => {
          var _a22, _b2;
          const blockers2 = ((_a22 = opts.getBlockers) == null ? void 0 : _a22.call(opts)) ?? [];
          (_b2 = opts.setBlockers) == null ? void 0 : _b2.call(opts, blockers2.filter((b2) => b2 !== blocker));
        };
      },
      flush: () => {
        var _a2;
        return (_a2 = opts.flush) == null ? void 0 : _a2.call(opts);
      },
      destroy: () => {
        var _a2;
        return (_a2 = opts.destroy) == null ? void 0 : _a2.call(opts);
      },
      notify
    };
  }
  function assignKeyAndIndex(index, state) {
    if (!state) {
      state = {};
    }
    const key2 = createRandomKey();
    return {
      ...state,
      key: key2,
      // TODO: Remove in v2 - use __TSR_key instead
      __TSR_key: key2,
      [stateIndexKey]: index
    };
  }
  function createBrowserHistory(opts) {
    var _a2, _b2;
    const win = (opts == null ? void 0 : opts.window) ?? (typeof document !== "undefined" ? window : void 0);
    const originalPushState = win.history.pushState;
    const originalReplaceState = win.history.replaceState;
    let blockers = [];
    const _getBlockers = () => blockers;
    const _setBlockers = (newBlockers) => blockers = newBlockers;
    const createHref = (opts == null ? void 0 : opts.createHref) ?? ((path) => path);
    const parseLocation = (opts == null ? void 0 : opts.parseLocation) ?? (() => parseHref(
      `${win.location.pathname}${win.location.search}${win.location.hash}`,
      win.history.state
    ));
    if (!((_a2 = win.history.state) == null ? void 0 : _a2.__TSR_key) && !((_b2 = win.history.state) == null ? void 0 : _b2.key)) {
      const addedKey = createRandomKey();
      win.history.replaceState(
        {
          [stateIndexKey]: 0,
          key: addedKey,
          // TODO: Remove in v2 - use __TSR_key instead
          __TSR_key: addedKey
        },
        ""
      );
    }
    let currentLocation = parseLocation();
    let rollbackLocation;
    let nextPopIsGo = false;
    let ignoreNextPop = false;
    let skipBlockerNextPop = false;
    let ignoreNextBeforeUnload = false;
    const getLocation = () => currentLocation;
    let next;
    let scheduled;
    const flush = () => {
      if (!next) {
        return;
      }
      history2._ignoreSubscribers = true;
      (next.isPush ? win.history.pushState : win.history.replaceState)(
        next.state,
        "",
        next.href
      );
      history2._ignoreSubscribers = false;
      next = void 0;
      scheduled = void 0;
      rollbackLocation = void 0;
    };
    const queueHistoryAction = (type, destHref, state) => {
      const href = createHref(destHref);
      if (!scheduled) {
        rollbackLocation = currentLocation;
      }
      currentLocation = parseHref(destHref, state);
      next = {
        href,
        state,
        isPush: (next == null ? void 0 : next.isPush) || type === "push"
      };
      if (!scheduled) {
        scheduled = Promise.resolve().then(() => flush());
      }
    };
    const onPushPop = (type) => {
      currentLocation = parseLocation();
      history2.notify({ type });
    };
    const onPushPopEvent = async () => {
      if (ignoreNextPop) {
        ignoreNextPop = false;
        return;
      }
      const nextLocation = parseLocation();
      const delta = nextLocation.state[stateIndexKey] - currentLocation.state[stateIndexKey];
      const isForward = delta === 1;
      const isBack = delta === -1;
      const isGo = !isForward && !isBack || nextPopIsGo;
      nextPopIsGo = false;
      const action = isGo ? "GO" : isBack ? "BACK" : "FORWARD";
      const notify = isGo ? {
        type: "GO",
        index: delta
      } : {
        type: isBack ? "BACK" : "FORWARD"
      };
      if (skipBlockerNextPop) {
        skipBlockerNextPop = false;
      } else {
        const blockers2 = _getBlockers();
        if (typeof document !== "undefined" && blockers2.length) {
          for (const blocker of blockers2) {
            const isBlocked = await blocker.blockerFn({
              currentLocation,
              nextLocation,
              action
            });
            if (isBlocked) {
              ignoreNextPop = true;
              win.history.go(1);
              history2.notify(notify);
              return;
            }
          }
        }
      }
      currentLocation = parseLocation();
      history2.notify(notify);
    };
    const onBeforeUnload = (e) => {
      if (ignoreNextBeforeUnload) {
        ignoreNextBeforeUnload = false;
        return;
      }
      let shouldBlock = false;
      const blockers2 = _getBlockers();
      if (typeof document !== "undefined" && blockers2.length) {
        for (const blocker of blockers2) {
          const shouldHaveBeforeUnload = blocker.enableBeforeUnload ?? true;
          if (shouldHaveBeforeUnload === true) {
            shouldBlock = true;
            break;
          }
          if (typeof shouldHaveBeforeUnload === "function" && shouldHaveBeforeUnload() === true) {
            shouldBlock = true;
            break;
          }
        }
      }
      if (shouldBlock) {
        e.preventDefault();
        return e.returnValue = "";
      }
      return;
    };
    const history2 = createHistory({
      getLocation,
      getLength: () => win.history.length,
      pushState: (href, state) => queueHistoryAction("push", href, state),
      replaceState: (href, state) => queueHistoryAction("replace", href, state),
      back: (ignoreBlocker) => {
        if (ignoreBlocker) skipBlockerNextPop = true;
        ignoreNextBeforeUnload = true;
        return win.history.back();
      },
      forward: (ignoreBlocker) => {
        if (ignoreBlocker) skipBlockerNextPop = true;
        ignoreNextBeforeUnload = true;
        win.history.forward();
      },
      go: (n) => {
        nextPopIsGo = true;
        win.history.go(n);
      },
      createHref: (href) => createHref(href),
      flush,
      destroy: () => {
        win.history.pushState = originalPushState;
        win.history.replaceState = originalReplaceState;
        win.removeEventListener(beforeUnloadEvent, onBeforeUnload, {
          capture: true
        });
        win.removeEventListener(popStateEvent, onPushPopEvent);
      },
      onBlocked: () => {
        if (rollbackLocation && currentLocation !== rollbackLocation) {
          currentLocation = rollbackLocation;
        }
      },
      getBlockers: _getBlockers,
      setBlockers: _setBlockers,
      notifyOnIndexChange: false
    });
    win.addEventListener(beforeUnloadEvent, onBeforeUnload, { capture: true });
    win.addEventListener(popStateEvent, onPushPopEvent);
    win.history.pushState = function(...args) {
      const res = originalPushState.apply(win.history, args);
      if (!history2._ignoreSubscribers) onPushPop("PUSH");
      return res;
    };
    win.history.replaceState = function(...args) {
      const res = originalReplaceState.apply(win.history, args);
      if (!history2._ignoreSubscribers) onPushPop("REPLACE");
      return res;
    };
    return history2;
  }
  function createHashHistory(opts) {
    const win = typeof document !== "undefined" ? window : void 0;
    return createBrowserHistory({
      window: win,
      parseLocation: () => {
        const hashSplit = win.location.hash.split("#").slice(1);
        const pathPart = hashSplit[0] ?? "/";
        const searchPart = win.location.search;
        const hashEntries = hashSplit.slice(1);
        const hashPart = hashEntries.length === 0 ? "" : `#${hashEntries.join("#")}`;
        const hashHref = `${pathPart}${searchPart}${hashPart}`;
        return parseHref(hashHref, win.history.state);
      },
      createHref: (href) => `${win.location.pathname}${win.location.search}#${href}`
    });
  }
  function createMemoryHistory(opts = {
    initialEntries: ["/"]
  }) {
    const entries2 = opts.initialEntries;
    let index = opts.initialIndex ? Math.min(Math.max(opts.initialIndex, 0), entries2.length - 1) : entries2.length - 1;
    const states = entries2.map(
      (_entry, index2) => assignKeyAndIndex(index2, void 0)
    );
    const getLocation = () => parseHref(entries2[index], states[index]);
    return createHistory({
      getLocation,
      getLength: () => entries2.length,
      pushState: (path, state) => {
        if (index < entries2.length - 1) {
          entries2.splice(index + 1);
          states.splice(index + 1);
        }
        states.push(state);
        entries2.push(path);
        index = Math.max(entries2.length - 1, 0);
      },
      replaceState: (path, state) => {
        states[index] = state;
        entries2[index] = path;
      },
      back: () => {
        index = Math.max(index - 1, 0);
      },
      forward: () => {
        index = Math.min(index + 1, entries2.length - 1);
      },
      go: (n) => {
        index = Math.min(Math.max(index + n, 0), entries2.length - 1);
      },
      createHref: (path) => path
    });
  }
  function parseHref(href, state) {
    const hashIndex = href.indexOf("#");
    const searchIndex = href.indexOf("?");
    const addedKey = createRandomKey();
    return {
      href,
      pathname: href.substring(
        0,
        hashIndex > 0 ? searchIndex > 0 ? Math.min(hashIndex, searchIndex) : hashIndex : searchIndex > 0 ? searchIndex : href.length
      ),
      hash: hashIndex > -1 ? href.substring(hashIndex) : "",
      search: searchIndex > -1 ? href.slice(searchIndex, hashIndex === -1 ? void 0 : hashIndex) : "",
      state: state || { [stateIndexKey]: 0, key: addedKey, __TSR_key: addedKey }
    };
  }
  function createRandomKey() {
    return (Math.random() + 1).toString(36).substring(7);
  }
  function last(arr) {
    return arr[arr.length - 1];
  }
  function isFunction$2(d) {
    return typeof d === "function";
  }
  function functionalUpdate$1(updater, previous) {
    if (isFunction$2(updater)) {
      return updater(previous);
    }
    return updater;
  }
  function pick(parent, keys2) {
    return keys2.reduce((obj, key2) => {
      obj[key2] = parent[key2];
      return obj;
    }, {});
  }
  function replaceEqualDeep$1(prev, _next) {
    if (prev === _next) {
      return prev;
    }
    const next = _next;
    const array = isPlainArray$1(prev) && isPlainArray$1(next);
    if (array || isSimplePlainObject(prev) && isSimplePlainObject(next)) {
      const prevItems = array ? prev : Object.keys(prev).concat(
        Object.getOwnPropertySymbols(prev)
      );
      const prevSize = prevItems.length;
      const nextItems = array ? next : Object.keys(next).concat(
        Object.getOwnPropertySymbols(next)
      );
      const nextSize = nextItems.length;
      const copy2 = array ? [] : {};
      let equalItems = 0;
      for (let i2 = 0; i2 < nextSize; i2++) {
        const key2 = array ? i2 : nextItems[i2];
        if ((!array && prevItems.includes(key2) || array) && prev[key2] === void 0 && next[key2] === void 0) {
          copy2[key2] = void 0;
          equalItems++;
        } else {
          copy2[key2] = replaceEqualDeep$1(prev[key2], next[key2]);
          if (copy2[key2] === prev[key2] && prev[key2] !== void 0) {
            equalItems++;
          }
        }
      }
      return prevSize === nextSize && equalItems === prevSize ? prev : copy2;
    }
    return next;
  }
  function isSimplePlainObject(o) {
    return (
      // all the checks from isPlainObject are more likely to hit so we perform them first
      isPlainObject$3(o) && Object.getOwnPropertyNames(o).length === Object.keys(o).length
    );
  }
  function isPlainObject$3(o) {
    if (!hasObjectPrototype$1(o)) {
      return false;
    }
    const ctor = o.constructor;
    if (typeof ctor === "undefined") {
      return true;
    }
    const prot = ctor.prototype;
    if (!hasObjectPrototype$1(prot)) {
      return false;
    }
    if (!prot.hasOwnProperty("isPrototypeOf")) {
      return false;
    }
    return true;
  }
  function hasObjectPrototype$1(o) {
    return Object.prototype.toString.call(o) === "[object Object]";
  }
  function isPlainArray$1(value) {
    return Array.isArray(value) && value.length === Object.keys(value).length;
  }
  function getObjectKeys(obj, ignoreUndefined) {
    let keys2 = Object.keys(obj);
    if (ignoreUndefined) {
      keys2 = keys2.filter((key2) => obj[key2] !== void 0);
    }
    return keys2;
  }
  function deepEqual$1(a, b2, opts) {
    if (a === b2) {
      return true;
    }
    if (typeof a !== typeof b2) {
      return false;
    }
    if (isPlainObject$3(a) && isPlainObject$3(b2)) {
      const ignoreUndefined = (opts == null ? void 0 : opts.ignoreUndefined) ?? true;
      const aKeys = getObjectKeys(a, ignoreUndefined);
      const bKeys = getObjectKeys(b2, ignoreUndefined);
      if (!(opts == null ? void 0 : opts.partial) && aKeys.length !== bKeys.length) {
        return false;
      }
      return bKeys.every((key2) => deepEqual$1(a[key2], b2[key2], opts));
    }
    if (Array.isArray(a) && Array.isArray(b2)) {
      if (a.length !== b2.length) {
        return false;
      }
      return !a.some((item, index) => !deepEqual$1(item, b2[index], opts));
    }
    return false;
  }
  function createControlledPromise(onResolve) {
    let resolveLoadPromise;
    let rejectLoadPromise;
    const controlledPromise = new Promise((resolve, reject) => {
      resolveLoadPromise = resolve;
      rejectLoadPromise = reject;
    });
    controlledPromise.status = "pending";
    controlledPromise.resolve = (value) => {
      controlledPromise.status = "resolved";
      controlledPromise.value = value;
      resolveLoadPromise(value);
      onResolve == null ? void 0 : onResolve(value);
    };
    controlledPromise.reject = (e) => {
      controlledPromise.status = "rejected";
      rejectLoadPromise(e);
    };
    return controlledPromise;
  }
  const SEGMENT_TYPE_PATHNAME = 0;
  const SEGMENT_TYPE_PARAM = 1;
  const SEGMENT_TYPE_WILDCARD = 2;
  const SEGMENT_TYPE_OPTIONAL_PARAM = 3;
  function joinPaths(paths) {
    return cleanPath(
      paths.filter((val) => {
        return val !== void 0;
      }).join("/")
    );
  }
  function cleanPath(path) {
    return path.replace(/\/{2,}/g, "/");
  }
  function trimPathLeft(path) {
    return path === "/" ? path : path.replace(/^\/{1,}/, "");
  }
  function trimPathRight(path) {
    return path === "/" ? path : path.replace(/\/{1,}$/, "");
  }
  function trimPath(path) {
    return trimPathRight(trimPathLeft(path));
  }
  function removeTrailingSlash(value, basepath) {
    if ((value == null ? void 0 : value.endsWith("/")) && value !== "/" && value !== `${basepath}/`) {
      return value.slice(0, -1);
    }
    return value;
  }
  function exactPathTest(pathName1, pathName2, basepath) {
    return removeTrailingSlash(pathName1, basepath) === removeTrailingSlash(pathName2, basepath);
  }
  function segmentToString(segment) {
    const { type, value } = segment;
    if (type === SEGMENT_TYPE_PATHNAME) {
      return value;
    }
    const { prefixSegment, suffixSegment } = segment;
    if (type === SEGMENT_TYPE_PARAM) {
      const param = value.substring(1);
      if (prefixSegment && suffixSegment) {
        return `${prefixSegment}{$${param}}${suffixSegment}`;
      } else if (prefixSegment) {
        return `${prefixSegment}{$${param}}`;
      } else if (suffixSegment) {
        return `{$${param}}${suffixSegment}`;
      }
    }
    if (type === SEGMENT_TYPE_OPTIONAL_PARAM) {
      const param = value.substring(1);
      if (prefixSegment && suffixSegment) {
        return `${prefixSegment}{-$${param}}${suffixSegment}`;
      } else if (prefixSegment) {
        return `${prefixSegment}{-$${param}}`;
      } else if (suffixSegment) {
        return `{-$${param}}${suffixSegment}`;
      }
      return `{-$${param}}`;
    }
    if (type === SEGMENT_TYPE_WILDCARD) {
      if (prefixSegment && suffixSegment) {
        return `${prefixSegment}{$}${suffixSegment}`;
      } else if (prefixSegment) {
        return `${prefixSegment}{$}`;
      } else if (suffixSegment) {
        return `{$}${suffixSegment}`;
      }
    }
    return value;
  }
  function resolvePath({
    basepath,
    base: base2,
    to,
    trailingSlash = "never",
    caseSensitive,
    parseCache
  }) {
    var _a2;
    base2 = removeBasepath(basepath, base2, caseSensitive);
    to = removeBasepath(basepath, to, caseSensitive);
    let baseSegments = parsePathname(base2, parseCache).slice();
    const toSegments = parsePathname(to, parseCache);
    if (baseSegments.length > 1 && ((_a2 = last(baseSegments)) == null ? void 0 : _a2.value) === "/") {
      baseSegments.pop();
    }
    for (let index = 0, length = toSegments.length; index < length; index++) {
      const toSegment = toSegments[index];
      const value = toSegment.value;
      if (value === "/") {
        if (!index) {
          baseSegments = [toSegment];
        } else if (index === length - 1) {
          baseSegments.push(toSegment);
        } else ;
      } else if (value === "..") {
        baseSegments.pop();
      } else if (value === ".") ;
      else {
        baseSegments.push(toSegment);
      }
    }
    if (baseSegments.length > 1) {
      if (last(baseSegments).value === "/") {
        if (trailingSlash === "never") {
          baseSegments.pop();
        }
      } else if (trailingSlash === "always") {
        baseSegments.push({ type: SEGMENT_TYPE_PATHNAME, value: "/" });
      }
    }
    const segmentValues = baseSegments.map(segmentToString);
    const joined = joinPaths([basepath, ...segmentValues]);
    return joined;
  }
  const parsePathname = (pathname, cache) => {
    if (!pathname) return [];
    const cached = cache == null ? void 0 : cache.get(pathname);
    if (cached) return cached;
    const parsed = baseParsePathname(pathname);
    cache == null ? void 0 : cache.set(pathname, parsed);
    return parsed;
  };
  const PARAM_RE = /^\$.{1,}$/;
  const PARAM_W_CURLY_BRACES_RE = /^(.*?)\{(\$[a-zA-Z_$][a-zA-Z0-9_$]*)\}(.*)$/;
  const OPTIONAL_PARAM_W_CURLY_BRACES_RE = /^(.*?)\{-(\$[a-zA-Z_$][a-zA-Z0-9_$]*)\}(.*)$/;
  const WILDCARD_RE = /^\$$/;
  const WILDCARD_W_CURLY_BRACES_RE = /^(.*?)\{\$\}(.*)$/;
  function baseParsePathname(pathname) {
    pathname = cleanPath(pathname);
    const segments = [];
    if (pathname.slice(0, 1) === "/") {
      pathname = pathname.substring(1);
      segments.push({
        type: SEGMENT_TYPE_PATHNAME,
        value: "/"
      });
    }
    if (!pathname) {
      return segments;
    }
    const split2 = pathname.split("/").filter(Boolean);
    segments.push(
      ...split2.map((part) => {
        const wildcardBracesMatch = part.match(WILDCARD_W_CURLY_BRACES_RE);
        if (wildcardBracesMatch) {
          const prefix2 = wildcardBracesMatch[1];
          const suffix = wildcardBracesMatch[2];
          return {
            type: SEGMENT_TYPE_WILDCARD,
            value: "$",
            prefixSegment: prefix2 || void 0,
            suffixSegment: suffix || void 0
          };
        }
        const optionalParamBracesMatch = part.match(
          OPTIONAL_PARAM_W_CURLY_BRACES_RE
        );
        if (optionalParamBracesMatch) {
          const prefix2 = optionalParamBracesMatch[1];
          const paramName = optionalParamBracesMatch[2];
          const suffix = optionalParamBracesMatch[3];
          return {
            type: SEGMENT_TYPE_OPTIONAL_PARAM,
            value: paramName,
            // Now just $paramName (no prefix)
            prefixSegment: prefix2 || void 0,
            suffixSegment: suffix || void 0
          };
        }
        const paramBracesMatch = part.match(PARAM_W_CURLY_BRACES_RE);
        if (paramBracesMatch) {
          const prefix2 = paramBracesMatch[1];
          const paramName = paramBracesMatch[2];
          const suffix = paramBracesMatch[3];
          return {
            type: SEGMENT_TYPE_PARAM,
            value: "" + paramName,
            prefixSegment: prefix2 || void 0,
            suffixSegment: suffix || void 0
          };
        }
        if (PARAM_RE.test(part)) {
          const paramName = part.substring(1);
          return {
            type: SEGMENT_TYPE_PARAM,
            value: "$" + paramName,
            prefixSegment: void 0,
            suffixSegment: void 0
          };
        }
        if (WILDCARD_RE.test(part)) {
          return {
            type: SEGMENT_TYPE_WILDCARD,
            value: "$",
            prefixSegment: void 0,
            suffixSegment: void 0
          };
        }
        return {
          type: SEGMENT_TYPE_PATHNAME,
          value: part.includes("%25") ? part.split("%25").map((segment) => decodeURI(segment)).join("%25") : decodeURI(part)
        };
      })
    );
    if (pathname.slice(-1) === "/") {
      pathname = pathname.substring(1);
      segments.push({
        type: SEGMENT_TYPE_PATHNAME,
        value: "/"
      });
    }
    return segments;
  }
  function interpolatePath({
    path,
    params,
    leaveWildcards,
    leaveParams,
    decodeCharMap,
    parseCache
  }) {
    const interpolatedPathSegments = parsePathname(path, parseCache);
    function encodeParam(key2) {
      const value = params[key2];
      const isValueString = typeof value === "string";
      if (key2 === "*" || key2 === "_splat") {
        return isValueString ? encodeURI(value) : value;
      } else {
        return isValueString ? encodePathParam(value, decodeCharMap) : value;
      }
    }
    let isMissingParams = false;
    const usedParams = {};
    const interpolatedPath = joinPaths(
      interpolatedPathSegments.map((segment) => {
        if (segment.type === SEGMENT_TYPE_PATHNAME) {
          return segment.value;
        }
        if (segment.type === SEGMENT_TYPE_WILDCARD) {
          usedParams._splat = params._splat;
          const segmentPrefix = segment.prefixSegment || "";
          const segmentSuffix = segment.suffixSegment || "";
          if (!("_splat" in params)) {
            isMissingParams = true;
            if (leaveWildcards) {
              return `${segmentPrefix}${segment.value}${segmentSuffix}`;
            }
            if (segmentPrefix || segmentSuffix) {
              return `${segmentPrefix}${segmentSuffix}`;
            }
            return void 0;
          }
          const value = encodeParam("_splat");
          if (leaveWildcards) {
            return `${segmentPrefix}${segment.value}${value ?? ""}${segmentSuffix}`;
          }
          return `${segmentPrefix}${value}${segmentSuffix}`;
        }
        if (segment.type === SEGMENT_TYPE_PARAM) {
          const key2 = segment.value.substring(1);
          if (!isMissingParams && !(key2 in params)) {
            isMissingParams = true;
          }
          usedParams[key2] = params[key2];
          const segmentPrefix = segment.prefixSegment || "";
          const segmentSuffix = segment.suffixSegment || "";
          if (leaveParams) {
            const value = encodeParam(segment.value);
            return `${segmentPrefix}${segment.value}${value ?? ""}${segmentSuffix}`;
          }
          return `${segmentPrefix}${encodeParam(key2) ?? "undefined"}${segmentSuffix}`;
        }
        if (segment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {
          const key2 = segment.value.substring(1);
          const segmentPrefix = segment.prefixSegment || "";
          const segmentSuffix = segment.suffixSegment || "";
          if (!(key2 in params) || params[key2] == null) {
            if (leaveWildcards) {
              return `${segmentPrefix}${key2}${segmentSuffix}`;
            }
            if (segmentPrefix || segmentSuffix) {
              return `${segmentPrefix}${segmentSuffix}`;
            }
            return void 0;
          }
          usedParams[key2] = params[key2];
          if (leaveParams) {
            const value = encodeParam(segment.value);
            return `${segmentPrefix}${segment.value}${value ?? ""}${segmentSuffix}`;
          }
          if (leaveWildcards) {
            return `${segmentPrefix}${key2}${encodeParam(key2) ?? ""}${segmentSuffix}`;
          }
          return `${segmentPrefix}${encodeParam(key2) ?? ""}${segmentSuffix}`;
        }
        return segment.value;
      })
    );
    return { usedParams, interpolatedPath, isMissingParams };
  }
  function encodePathParam(value, decodeCharMap) {
    let encoded = encodeURIComponent(value);
    if (decodeCharMap) {
      for (const [encodedChar, char] of decodeCharMap) {
        encoded = encoded.replaceAll(encodedChar, char);
      }
    }
    return encoded;
  }
  function matchPathname(basepath, currentPathname, matchLocation, parseCache) {
    const pathParams = matchByPath(
      basepath,
      currentPathname,
      matchLocation,
      parseCache
    );
    if (matchLocation.to && !pathParams) {
      return;
    }
    return pathParams ?? {};
  }
  function removeBasepath(basepath, pathname, caseSensitive = false) {
    const normalizedBasepath = caseSensitive ? basepath : basepath.toLowerCase();
    const normalizedPathname = caseSensitive ? pathname : pathname.toLowerCase();
    switch (true) {
      // default behaviour is to serve app from the root - pathname
      // left untouched
      case normalizedBasepath === "/":
        return pathname;
      // shortcut for removing the basepath if it matches the pathname
      case normalizedPathname === normalizedBasepath:
        return "";
      // in case pathname is shorter than basepath - there is
      // nothing to remove
      case pathname.length < basepath.length:
        return pathname;
      // avoid matching partial segments - strict equality handled
      // earlier, otherwise, basepath separated from pathname with
      // separator, therefore lack of separator means partial
      // segment match (`/app` should not match `/application`)
      case normalizedPathname[normalizedBasepath.length] !== "/":
        return pathname;
      // remove the basepath from the pathname if it starts with it
      case normalizedPathname.startsWith(normalizedBasepath):
        return pathname.slice(basepath.length);
      // otherwise, return the pathname as is
      default:
        return pathname;
    }
  }
  function matchByPath(basepath, from, {
    to,
    fuzzy,
    caseSensitive
  }, parseCache) {
    if (basepath !== "/" && !from.startsWith(basepath)) {
      return void 0;
    }
    from = removeBasepath(basepath, from, caseSensitive);
    to = removeBasepath(basepath, `${to ?? "$"}`, caseSensitive);
    const baseSegments = parsePathname(
      from.startsWith("/") ? from : `/${from}`,
      parseCache
    );
    const routeSegments = parsePathname(
      to.startsWith("/") ? to : `/${to}`,
      parseCache
    );
    const params = {};
    const result = isMatch(
      baseSegments,
      routeSegments,
      params,
      fuzzy,
      caseSensitive
    );
    return result ? params : void 0;
  }
  function isMatch(baseSegments, routeSegments, params, fuzzy, caseSensitive) {
    var _a2, _b2, _c2;
    let baseIndex = 0;
    let routeIndex = 0;
    while (baseIndex < baseSegments.length || routeIndex < routeSegments.length) {
      const baseSegment = baseSegments[baseIndex];
      const routeSegment = routeSegments[routeIndex];
      if (routeSegment) {
        if (routeSegment.type === SEGMENT_TYPE_WILDCARD) {
          const remainingBaseSegments = baseSegments.slice(baseIndex);
          let _splat;
          if (routeSegment.prefixSegment || routeSegment.suffixSegment) {
            if (!baseSegment) return false;
            const prefix2 = routeSegment.prefixSegment || "";
            const suffix = routeSegment.suffixSegment || "";
            const baseValue = baseSegment.value;
            if ("prefixSegment" in routeSegment) {
              if (!baseValue.startsWith(prefix2)) {
                return false;
              }
            }
            if ("suffixSegment" in routeSegment) {
              if (!((_a2 = baseSegments[baseSegments.length - 1]) == null ? void 0 : _a2.value.endsWith(suffix))) {
                return false;
              }
            }
            let rejoinedSplat = decodeURI(
              joinPaths(remainingBaseSegments.map((d) => d.value))
            );
            if (prefix2 && rejoinedSplat.startsWith(prefix2)) {
              rejoinedSplat = rejoinedSplat.slice(prefix2.length);
            }
            if (suffix && rejoinedSplat.endsWith(suffix)) {
              rejoinedSplat = rejoinedSplat.slice(
                0,
                rejoinedSplat.length - suffix.length
              );
            }
            _splat = rejoinedSplat;
          } else {
            _splat = decodeURI(
              joinPaths(remainingBaseSegments.map((d) => d.value))
            );
          }
          params["*"] = _splat;
          params["_splat"] = _splat;
          return true;
        }
        if (routeSegment.type === SEGMENT_TYPE_PATHNAME) {
          if (routeSegment.value === "/" && !(baseSegment == null ? void 0 : baseSegment.value)) {
            routeIndex++;
            continue;
          }
          if (baseSegment) {
            if (caseSensitive) {
              if (routeSegment.value !== baseSegment.value) {
                return false;
              }
            } else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()) {
              return false;
            }
            baseIndex++;
            routeIndex++;
            continue;
          } else {
            return false;
          }
        }
        if (routeSegment.type === SEGMENT_TYPE_PARAM) {
          if (!baseSegment) {
            return false;
          }
          if (baseSegment.value === "/") {
            return false;
          }
          let _paramValue = "";
          let matched = false;
          if (routeSegment.prefixSegment || routeSegment.suffixSegment) {
            const prefix2 = routeSegment.prefixSegment || "";
            const suffix = routeSegment.suffixSegment || "";
            const baseValue = baseSegment.value;
            if (prefix2 && !baseValue.startsWith(prefix2)) {
              return false;
            }
            if (suffix && !baseValue.endsWith(suffix)) {
              return false;
            }
            let paramValue = baseValue;
            if (prefix2 && paramValue.startsWith(prefix2)) {
              paramValue = paramValue.slice(prefix2.length);
            }
            if (suffix && paramValue.endsWith(suffix)) {
              paramValue = paramValue.slice(0, paramValue.length - suffix.length);
            }
            _paramValue = decodeURIComponent(paramValue);
            matched = true;
          } else {
            _paramValue = decodeURIComponent(baseSegment.value);
            matched = true;
          }
          if (matched) {
            params[routeSegment.value.substring(1)] = _paramValue;
            baseIndex++;
          }
          routeIndex++;
          continue;
        }
        if (routeSegment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {
          if (!baseSegment) {
            routeIndex++;
            continue;
          }
          if (baseSegment.value === "/") {
            routeIndex++;
            continue;
          }
          let _paramValue = "";
          let matched = false;
          if (routeSegment.prefixSegment || routeSegment.suffixSegment) {
            const prefix2 = routeSegment.prefixSegment || "";
            const suffix = routeSegment.suffixSegment || "";
            const baseValue = baseSegment.value;
            if ((!prefix2 || baseValue.startsWith(prefix2)) && (!suffix || baseValue.endsWith(suffix))) {
              let paramValue = baseValue;
              if (prefix2 && paramValue.startsWith(prefix2)) {
                paramValue = paramValue.slice(prefix2.length);
              }
              if (suffix && paramValue.endsWith(suffix)) {
                paramValue = paramValue.slice(
                  0,
                  paramValue.length - suffix.length
                );
              }
              _paramValue = decodeURIComponent(paramValue);
              matched = true;
            }
          } else {
            let shouldMatchOptional = true;
            for (let lookAhead = routeIndex + 1; lookAhead < routeSegments.length; lookAhead++) {
              const futureRouteSegment = routeSegments[lookAhead];
              if ((futureRouteSegment == null ? void 0 : futureRouteSegment.type) === SEGMENT_TYPE_PATHNAME && futureRouteSegment.value === baseSegment.value) {
                shouldMatchOptional = false;
                break;
              }
              if ((futureRouteSegment == null ? void 0 : futureRouteSegment.type) === SEGMENT_TYPE_PARAM || (futureRouteSegment == null ? void 0 : futureRouteSegment.type) === SEGMENT_TYPE_WILDCARD) {
                break;
              }
            }
            if (shouldMatchOptional) {
              _paramValue = decodeURIComponent(baseSegment.value);
              matched = true;
            }
          }
          if (matched) {
            params[routeSegment.value.substring(1)] = _paramValue;
            baseIndex++;
          }
          routeIndex++;
          continue;
        }
      }
      if (baseIndex < baseSegments.length && routeIndex >= routeSegments.length) {
        params["**"] = joinPaths(
          baseSegments.slice(baseIndex).map((d) => d.value)
        );
        return !!fuzzy && ((_b2 = routeSegments[routeSegments.length - 1]) == null ? void 0 : _b2.value) !== "/";
      }
      if (routeIndex < routeSegments.length && baseIndex >= baseSegments.length) {
        for (let i2 = routeIndex; i2 < routeSegments.length; i2++) {
          if (((_c2 = routeSegments[i2]) == null ? void 0 : _c2.type) !== SEGMENT_TYPE_OPTIONAL_PARAM) {
            return false;
          }
        }
        break;
      }
      break;
    }
    return true;
  }
  function isNotFound(obj) {
    return !!(obj == null ? void 0 : obj.isNotFound);
  }
  function getSafeSessionStorage() {
    try {
      if (typeof window !== "undefined" && typeof window.sessionStorage === "object") {
        return window.sessionStorage;
      }
    } catch {
      return void 0;
    }
    return void 0;
  }
  const storageKey = "tsr-scroll-restoration-v1_3";
  const throttle$1 = (fn, wait2) => {
    let timeout;
    return (...args) => {
      if (!timeout) {
        timeout = setTimeout(() => {
          fn(...args);
          timeout = null;
        }, wait2);
      }
    };
  };
  function createScrollRestorationCache() {
    const safeSessionStorage = getSafeSessionStorage();
    if (!safeSessionStorage) {
      return void 0;
    }
    const persistedState = safeSessionStorage.getItem(storageKey);
    let state = persistedState ? JSON.parse(persistedState) : {};
    return {
      state,
      // This setter is simply to make sure that we set the sessionStorage right
      // after the state is updated. It doesn't necessarily need to be a functional
      // update.
      set: (updater) => (state = functionalUpdate$1(updater, state) || state, safeSessionStorage.setItem(storageKey, JSON.stringify(state)))
    };
  }
  const scrollRestorationCache = createScrollRestorationCache();
  const defaultGetScrollRestorationKey = (location2) => {
    return location2.state.__TSR_key || location2.href;
  };
  function getCssSelector(el) {
    const path = [];
    let parent;
    while (parent = el.parentNode) {
      path.unshift(
        `${el.tagName}:nth-child(${[].indexOf.call(parent.children, el) + 1})`
      );
      el = parent;
    }
    return `${path.join(" > ")}`.toLowerCase();
  }
  let ignoreScroll = false;
  function restoreScroll(storageKey2, key2, behavior, shouldScrollRestoration, scrollToTopSelectors) {
    var _a2;
    let byKey;
    try {
      byKey = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
    } catch (error) {
      console.error(error);
      return;
    }
    const resolvedKey = key2 || ((_a2 = window.history.state) == null ? void 0 : _a2.key);
    const elementEntries = byKey[resolvedKey];
    ignoreScroll = true;
    (() => {
      if (shouldScrollRestoration && elementEntries) {
        for (const elementSelector in elementEntries) {
          const entry = elementEntries[elementSelector];
          if (elementSelector === "window") {
            window.scrollTo({
              top: entry.scrollY,
              left: entry.scrollX,
              behavior
            });
          } else if (elementSelector) {
            const element = document.querySelector(elementSelector);
            if (element) {
              element.scrollLeft = entry.scrollX;
              element.scrollTop = entry.scrollY;
            }
          }
        }
        return;
      }
      const hash = window.location.hash.split("#")[1];
      if (hash) {
        const hashScrollIntoViewOptions = (window.history.state || {}).__hashScrollIntoViewOptions ?? true;
        if (hashScrollIntoViewOptions) {
          const el = document.getElementById(hash);
          if (el) {
            el.scrollIntoView(hashScrollIntoViewOptions);
          }
        }
        return;
      }
      [
        "window",
        ...(scrollToTopSelectors == null ? void 0 : scrollToTopSelectors.filter((d) => d !== "window")) ?? []
      ].forEach((selector2) => {
        const element = selector2 === "window" ? window : typeof selector2 === "function" ? selector2() : document.querySelector(selector2);
        if (element) {
          element.scrollTo({
            top: 0,
            left: 0,
            behavior
          });
        }
      });
    })();
    ignoreScroll = false;
  }
  function setupScrollRestoration(router2, force) {
    if (scrollRestorationCache === void 0) {
      return;
    }
    const shouldScrollRestoration = router2.options.scrollRestoration ?? false;
    if (shouldScrollRestoration) {
      router2.isScrollRestoring = true;
    }
    if (typeof document === "undefined" || router2.isScrollRestorationSetup) {
      return;
    }
    router2.isScrollRestorationSetup = true;
    ignoreScroll = false;
    const getKey = router2.options.getScrollRestorationKey || defaultGetScrollRestorationKey;
    window.history.scrollRestoration = "manual";
    const onScroll = (event) => {
      if (ignoreScroll || !router2.isScrollRestoring) {
        return;
      }
      let elementSelector = "";
      if (event.target === document || event.target === window) {
        elementSelector = "window";
      } else {
        const attrId = event.target.getAttribute(
          "data-scroll-restoration-id"
        );
        if (attrId) {
          elementSelector = `[data-scroll-restoration-id="${attrId}"]`;
        } else {
          elementSelector = getCssSelector(event.target);
        }
      }
      const restoreKey = getKey(router2.state.location);
      scrollRestorationCache.set((state) => {
        const keyEntry = state[restoreKey] = state[restoreKey] || {};
        const elementEntry = keyEntry[elementSelector] = keyEntry[elementSelector] || {};
        if (elementSelector === "window") {
          elementEntry.scrollX = window.scrollX || 0;
          elementEntry.scrollY = window.scrollY || 0;
        } else if (elementSelector) {
          const element = document.querySelector(elementSelector);
          if (element) {
            elementEntry.scrollX = element.scrollLeft || 0;
            elementEntry.scrollY = element.scrollTop || 0;
          }
        }
        return state;
      });
    };
    if (typeof document !== "undefined") {
      document.addEventListener("scroll", throttle$1(onScroll, 100), true);
    }
    router2.subscribe("onRendered", (event) => {
      const cacheKey = getKey(event.toLocation);
      if (!router2.resetNextScroll) {
        router2.resetNextScroll = true;
        return;
      }
      restoreScroll(
        storageKey,
        cacheKey,
        router2.options.scrollRestorationBehavior || void 0,
        router2.isScrollRestoring || void 0,
        router2.options.scrollToTopSelectors || void 0
      );
      if (router2.isScrollRestoring) {
        scrollRestorationCache.set((state) => {
          state[cacheKey] = state[cacheKey] || {};
          return state;
        });
      }
    });
  }
  function handleHashScroll(router2) {
    if (typeof document !== "undefined" && document.querySelector) {
      const hashScrollIntoViewOptions = router2.state.location.state.__hashScrollIntoViewOptions ?? true;
      if (hashScrollIntoViewOptions && router2.state.location.hash !== "") {
        const el = document.getElementById(router2.state.location.hash);
        if (el) {
          el.scrollIntoView(hashScrollIntoViewOptions);
        }
      }
    }
  }
  function encode$2(obj, pfx) {
    const normalizedObject = Object.entries(obj).flatMap(([key2, value]) => {
      if (Array.isArray(value)) {
        return value.map((v) => [key2, String(v)]);
      } else {
        return [[key2, String(value)]];
      }
    });
    const searchParams = new URLSearchParams(normalizedObject);
    return "" + searchParams.toString();
  }
  function toValue$1(str) {
    if (!str) return "";
    if (str === "false") return false;
    if (str === "true") return true;
    return +str * 0 === 0 && +str + "" === str ? +str : str;
  }
  function decode(str, pfx) {
    const searchParamsPart = str;
    const searchParams = new URLSearchParams(searchParamsPart);
    const entries2 = [...searchParams.entries()];
    return entries2.reduce((acc, [key2, value]) => {
      const previousValue = acc[key2];
      if (previousValue == null) {
        acc[key2] = toValue$1(value);
      } else {
        acc[key2] = Array.isArray(previousValue) ? [...previousValue, toValue$1(value)] : [previousValue, toValue$1(value)];
      }
      return acc;
    }, {});
  }
  const defaultParseSearch = parseSearchWith(JSON.parse);
  const defaultStringifySearch = stringifySearchWith(
    JSON.stringify,
    JSON.parse
  );
  function parseSearchWith(parser) {
    return (searchStr) => {
      if (searchStr.substring(0, 1) === "?") {
        searchStr = searchStr.substring(1);
      }
      const query = decode(searchStr);
      for (const key2 in query) {
        const value = query[key2];
        if (typeof value === "string") {
          try {
            query[key2] = parser(value);
          } catch (err2) {
          }
        }
      }
      return query;
    };
  }
  function stringifySearchWith(stringify2, parser) {
    function stringifyValue(val) {
      if (typeof val === "object" && val !== null) {
        try {
          return stringify2(val);
        } catch (err2) {
        }
      } else if (typeof val === "string" && typeof parser === "function") {
        try {
          parser(val);
          return stringify2(val);
        } catch (err2) {
        }
      }
      return val;
    }
    return (search) => {
      search = { ...search };
      Object.keys(search).forEach((key2) => {
        const val = search[key2];
        if (typeof val === "undefined" || val === void 0) {
          delete search[key2];
        } else {
          search[key2] = stringifyValue(val);
        }
      });
      const searchStr = encode$2(search).toString();
      return searchStr ? `?${searchStr}` : "";
    };
  }
  const rootRouteId = "__root__";
  function redirect(opts) {
    opts.statusCode = opts.statusCode || opts.code || 307;
    if (!opts.reloadDocument) {
      try {
        new URL(`${opts.href}`);
        opts.reloadDocument = true;
      } catch {
      }
    }
    const headers = new Headers(opts.headers || {});
    if (opts.href && headers.get("Location") === null) {
      headers.set("Location", opts.href);
    }
    const response = new Response(null, {
      status: opts.statusCode,
      headers
    });
    response.options = opts;
    if (opts.throw) {
      throw response;
    }
    return response;
  }
  function isRedirect(obj) {
    return obj instanceof Response && !!obj.options;
  }
  function createLRUCache(max2) {
    const cache = /* @__PURE__ */ new Map();
    let oldest;
    let newest;
    const touch = (entry) => {
      if (!entry.next) return;
      if (!entry.prev) {
        entry.next.prev = void 0;
        oldest = entry.next;
        entry.next = void 0;
        if (newest) {
          entry.prev = newest;
          newest.next = entry;
        }
      } else {
        entry.prev.next = entry.next;
        entry.next.prev = entry.prev;
        entry.next = void 0;
        if (newest) {
          newest.next = entry;
          entry.prev = newest;
        }
      }
      newest = entry;
    };
    return {
      get(key2) {
        const entry = cache.get(key2);
        if (!entry) return void 0;
        touch(entry);
        return entry.value;
      },
      set(key2, value) {
        if (cache.size >= max2 && oldest) {
          const toDelete = oldest;
          cache.delete(toDelete.key);
          if (toDelete.next) {
            oldest = toDelete.next;
            toDelete.next.prev = void 0;
          }
          if (toDelete === newest) {
            newest = void 0;
          }
        }
        const existing = cache.get(key2);
        if (existing) {
          existing.value = value;
          touch(existing);
        } else {
          const entry = { key: key2, value, prev: newest };
          if (newest) newest.next = entry;
          newest = entry;
          if (!oldest) oldest = entry;
          cache.set(key2, entry);
        }
      }
    };
  }
  function getLocationChangeInfo(routerState) {
    const fromLocation = routerState.resolvedLocation;
    const toLocation = routerState.location;
    const pathChanged = (fromLocation == null ? void 0 : fromLocation.pathname) !== toLocation.pathname;
    const hrefChanged = (fromLocation == null ? void 0 : fromLocation.href) !== toLocation.href;
    const hashChanged = (fromLocation == null ? void 0 : fromLocation.hash) !== toLocation.hash;
    return { fromLocation, toLocation, pathChanged, hrefChanged, hashChanged };
  }
  class RouterCore {
    /**
     * @deprecated Use the `createRouter` function instead
     */
    constructor(options) {
      this.tempLocationKey = `${Math.round(
        Math.random() * 1e7
      )}`;
      this.resetNextScroll = true;
      this.shouldViewTransition = void 0;
      this.isViewTransitionTypesSupported = void 0;
      this.subscribers = /* @__PURE__ */ new Set();
      this.isScrollRestoring = false;
      this.isScrollRestorationSetup = false;
      this.startTransition = (fn) => fn();
      this.update = (newOptions) => {
        var _a2;
        if (newOptions.notFoundRoute) {
          console.warn(
            "The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/framework/react/guide/not-found-errors#migrating-from-notfoundroute for more info."
          );
        }
        const previousOptions = this.options;
        this.options = {
          ...this.options,
          ...newOptions
        };
        this.isServer = this.options.isServer ?? typeof document === "undefined";
        this.pathParamsDecodeCharMap = this.options.pathParamsAllowedCharacters ? new Map(
          this.options.pathParamsAllowedCharacters.map((char) => [
            encodeURIComponent(char),
            char
          ])
        ) : void 0;
        if (!this.basepath || newOptions.basepath && newOptions.basepath !== previousOptions.basepath) {
          if (newOptions.basepath === void 0 || newOptions.basepath === "" || newOptions.basepath === "/") {
            this.basepath = "/";
          } else {
            this.basepath = `/${trimPath(newOptions.basepath)}`;
          }
        }
        if (!this.history || this.options.history && this.options.history !== this.history) {
          this.history = this.options.history ?? (this.isServer ? createMemoryHistory({
            initialEntries: [this.basepath || "/"]
          }) : createBrowserHistory());
          this.latestLocation = this.parseLocation();
        }
        if (this.options.routeTree !== this.routeTree) {
          this.routeTree = this.options.routeTree;
          this.buildRouteTree();
        }
        if (!this.__store) {
          this.__store = new Store(getInitialRouterState(this.latestLocation), {
            onUpdate: () => {
              this.__store.state = {
                ...this.state,
                cachedMatches: this.state.cachedMatches.filter(
                  (d) => !["redirected"].includes(d.status)
                )
              };
            }
          });
          setupScrollRestoration(this);
        }
        if (typeof window !== "undefined" && "CSS" in window && typeof ((_a2 = window.CSS) == null ? void 0 : _a2.supports) === "function") {
          this.isViewTransitionTypesSupported = window.CSS.supports(
            "selector(:active-view-transition-type(a)"
          );
        }
      };
      this.buildRouteTree = () => {
        const { routesById, routesByPath, flatRoutes } = processRouteTree({
          routeTree: this.routeTree,
          initRoute: (route, i2) => {
            route.init({
              originalIndex: i2
            });
          }
        });
        this.routesById = routesById;
        this.routesByPath = routesByPath;
        this.flatRoutes = flatRoutes;
        const notFoundRoute = this.options.notFoundRoute;
        if (notFoundRoute) {
          notFoundRoute.init({
            originalIndex: 99999999999
          });
          this.routesById[notFoundRoute.id] = notFoundRoute;
        }
      };
      this.subscribe = (eventType, fn) => {
        const listener = {
          eventType,
          fn
        };
        this.subscribers.add(listener);
        return () => {
          this.subscribers.delete(listener);
        };
      };
      this.emit = (routerEvent) => {
        this.subscribers.forEach((listener) => {
          if (listener.eventType === routerEvent.type) {
            listener.fn(routerEvent);
          }
        });
      };
      this.parseLocation = (previousLocation, locationToParse) => {
        const parse = ({
          pathname,
          search,
          hash,
          state
        }) => {
          const parsedSearch = this.options.parseSearch(search);
          const searchStr = this.options.stringifySearch(parsedSearch);
          return {
            pathname,
            searchStr,
            search: replaceEqualDeep$1(previousLocation == null ? void 0 : previousLocation.search, parsedSearch),
            hash: hash.split("#").reverse()[0] ?? "",
            href: `${pathname}${searchStr}${hash}`,
            state: replaceEqualDeep$1(previousLocation == null ? void 0 : previousLocation.state, state)
          };
        };
        const location2 = parse(locationToParse ?? this.history.location);
        const { __tempLocation, __tempKey } = location2.state;
        if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {
          const parsedTempLocation = parse(__tempLocation);
          parsedTempLocation.state.key = location2.state.key;
          parsedTempLocation.state.__TSR_key = location2.state.__TSR_key;
          delete parsedTempLocation.state.__tempLocation;
          return {
            ...parsedTempLocation,
            maskedLocation: location2
          };
        }
        return location2;
      };
      this.resolvePathWithBase = (from, path) => {
        const resolvedPath = resolvePath({
          basepath: this.basepath,
          base: from,
          to: cleanPath(path),
          trailingSlash: this.options.trailingSlash,
          caseSensitive: this.options.caseSensitive,
          parseCache: this.parsePathnameCache
        });
        return resolvedPath;
      };
      this.matchRoutes = (pathnameOrNext, locationSearchOrOpts, opts) => {
        if (typeof pathnameOrNext === "string") {
          return this.matchRoutesInternal(
            {
              pathname: pathnameOrNext,
              search: locationSearchOrOpts
            },
            opts
          );
        }
        return this.matchRoutesInternal(pathnameOrNext, locationSearchOrOpts);
      };
      this.parsePathnameCache = createLRUCache(1e3);
      this.getMatchedRoutes = (pathname, routePathname) => {
        return getMatchedRoutes({
          pathname,
          routePathname,
          basepath: this.basepath,
          caseSensitive: this.options.caseSensitive,
          routesByPath: this.routesByPath,
          routesById: this.routesById,
          flatRoutes: this.flatRoutes,
          parseCache: this.parsePathnameCache
        });
      };
      this.cancelMatch = (id) => {
        const match = this.getMatch(id);
        if (!match) return;
        match.abortController.abort();
        this.updateMatch(id, (prev) => {
          clearTimeout(prev.pendingTimeout);
          return {
            ...prev,
            pendingTimeout: void 0
          };
        });
      };
      this.cancelMatches = () => {
        var _a2;
        (_a2 = this.state.pendingMatches) == null ? void 0 : _a2.forEach((match) => {
          this.cancelMatch(match.id);
        });
      };
      this.buildLocation = (opts) => {
        const build = (dest = {}) => {
          var _a2;
          const currentLocation = dest._fromLocation || this.latestLocation;
          const allCurrentLocationMatches = this.matchRoutes(currentLocation, {
            _buildLocation: true
          });
          const lastMatch = last(allCurrentLocationMatches);
          let fromPath = lastMatch.fullPath;
          const toPath = dest.to ? this.resolvePathWithBase(fromPath, `${dest.to}`) : this.resolvePathWithBase(fromPath, ".");
          const routeIsChanging = !!dest.to && !comparePaths(dest.to.toString(), fromPath) && !comparePaths(toPath, fromPath);
          if (dest.unsafeRelative === "path") {
            fromPath = currentLocation.pathname;
          } else if (routeIsChanging && dest.from) {
            fromPath = dest.from;
          }
          const fromSearch = lastMatch.search;
          const fromParams = { ...lastMatch.params };
          const nextTo = dest.to ? this.resolvePathWithBase(fromPath, `${dest.to}`) : this.resolvePathWithBase(fromPath, ".");
          let nextParams = dest.params === false || dest.params === null ? {} : (dest.params ?? true) === true ? fromParams : {
            ...fromParams,
            ...functionalUpdate$1(dest.params, fromParams)
          };
          const interpolatedNextTo = interpolatePath({
            path: nextTo,
            params: nextParams ?? {},
            parseCache: this.parsePathnameCache
          }).interpolatedPath;
          const destRoutes = this.matchRoutes(
            interpolatedNextTo,
            {},
            {
              _buildLocation: true
            }
          ).map((d) => this.looseRoutesById[d.routeId]);
          if (Object.keys(nextParams).length > 0) {
            destRoutes.map((route) => {
              var _a22;
              return ((_a22 = route.options.params) == null ? void 0 : _a22.stringify) ?? route.options.stringifyParams;
            }).filter(Boolean).forEach((fn) => {
              nextParams = { ...nextParams, ...fn(nextParams) };
            });
          }
          const nextPathname = interpolatePath({
            // Use the original template path for interpolation
            // This preserves the original parameter syntax including optional parameters
            path: nextTo,
            params: nextParams ?? {},
            leaveWildcards: false,
            leaveParams: opts.leaveParams,
            decodeCharMap: this.pathParamsDecodeCharMap,
            parseCache: this.parsePathnameCache
          }).interpolatedPath;
          let nextSearch = fromSearch;
          if (opts._includeValidateSearch && ((_a2 = this.options.search) == null ? void 0 : _a2.strict)) {
            let validatedSearch = {};
            destRoutes.forEach((route) => {
              try {
                if (route.options.validateSearch) {
                  validatedSearch = {
                    ...validatedSearch,
                    ...validateSearch(route.options.validateSearch, {
                      ...validatedSearch,
                      ...nextSearch
                    }) ?? {}
                  };
                }
              } catch {
              }
            });
            nextSearch = validatedSearch;
          }
          nextSearch = applySearchMiddleware({
            search: nextSearch,
            dest,
            destRoutes,
            _includeValidateSearch: opts._includeValidateSearch
          });
          nextSearch = replaceEqualDeep$1(fromSearch, nextSearch);
          const searchStr = this.options.stringifySearch(nextSearch);
          const hash = dest.hash === true ? currentLocation.hash : dest.hash ? functionalUpdate$1(dest.hash, currentLocation.hash) : void 0;
          const hashStr = hash ? `#${hash}` : "";
          let nextState = dest.state === true ? currentLocation.state : dest.state ? functionalUpdate$1(dest.state, currentLocation.state) : {};
          nextState = replaceEqualDeep$1(currentLocation.state, nextState);
          return {
            pathname: nextPathname,
            search: nextSearch,
            searchStr,
            state: nextState,
            hash: hash ?? "",
            href: `${nextPathname}${searchStr}${hashStr}`,
            unmaskOnReload: dest.unmaskOnReload
          };
        };
        const buildWithMatches = (dest = {}, maskedDest) => {
          var _a2;
          const next = build(dest);
          let maskedNext = maskedDest ? build(maskedDest) : void 0;
          if (!maskedNext) {
            let params = {};
            const foundMask = (_a2 = this.options.routeMasks) == null ? void 0 : _a2.find((d) => {
              const match = matchPathname(
                this.basepath,
                next.pathname,
                {
                  to: d.from,
                  caseSensitive: false,
                  fuzzy: false
                },
                this.parsePathnameCache
              );
              if (match) {
                params = match;
                return true;
              }
              return false;
            });
            if (foundMask) {
              const { from: _from, ...maskProps } = foundMask;
              maskedDest = {
                ...pick(opts, ["from"]),
                ...maskProps,
                params
              };
              maskedNext = build(maskedDest);
            }
          }
          if (maskedNext) {
            const maskedFinal = build(maskedDest);
            next.maskedLocation = maskedFinal;
          }
          return next;
        };
        if (opts.mask) {
          return buildWithMatches(opts, {
            ...pick(opts, ["from"]),
            ...opts.mask
          });
        }
        return buildWithMatches(opts);
      };
      this.commitLocation = ({
        viewTransition,
        ignoreBlocker,
        ...next
      }) => {
        const isSameState = () => {
          const ignoredProps = [
            "key",
            // TODO: Remove in v2 - use __TSR_key instead
            "__TSR_key",
            "__TSR_index",
            "__hashScrollIntoViewOptions"
          ];
          ignoredProps.forEach((prop) => {
            next.state[prop] = this.latestLocation.state[prop];
          });
          const isEqual = deepEqual$1(next.state, this.latestLocation.state);
          ignoredProps.forEach((prop) => {
            delete next.state[prop];
          });
          return isEqual;
        };
        const isSameUrl = this.latestLocation.href === next.href;
        const previousCommitPromise = this.commitLocationPromise;
        this.commitLocationPromise = createControlledPromise(() => {
          previousCommitPromise == null ? void 0 : previousCommitPromise.resolve();
        });
        if (isSameUrl && isSameState()) {
          this.load();
        } else {
          let { maskedLocation, hashScrollIntoView, ...nextHistory } = next;
          if (maskedLocation) {
            nextHistory = {
              ...maskedLocation,
              state: {
                ...maskedLocation.state,
                __tempKey: void 0,
                __tempLocation: {
                  ...nextHistory,
                  search: nextHistory.searchStr,
                  state: {
                    ...nextHistory.state,
                    __tempKey: void 0,
                    __tempLocation: void 0,
                    __TSR_key: void 0,
                    key: void 0
                    // TODO: Remove in v2 - use __TSR_key instead
                  }
                }
              }
            };
            if (nextHistory.unmaskOnReload ?? this.options.unmaskOnReload ?? false) {
              nextHistory.state.__tempKey = this.tempLocationKey;
            }
          }
          nextHistory.state.__hashScrollIntoViewOptions = hashScrollIntoView ?? this.options.defaultHashScrollIntoView ?? true;
          this.shouldViewTransition = viewTransition;
          this.history[next.replace ? "replace" : "push"](
            nextHistory.href,
            nextHistory.state,
            { ignoreBlocker }
          );
        }
        this.resetNextScroll = next.resetScroll ?? true;
        if (!this.history.subscribers.size) {
          this.load();
        }
        return this.commitLocationPromise;
      };
      this.buildAndCommitLocation = ({
        replace: replace2,
        resetScroll,
        hashScrollIntoView,
        viewTransition,
        ignoreBlocker,
        href,
        ...rest
      } = {}) => {
        if (href) {
          const currentIndex = this.history.location.state.__TSR_index;
          const parsed = parseHref(href, {
            __TSR_index: replace2 ? currentIndex : currentIndex + 1
          });
          rest.to = parsed.pathname;
          rest.search = this.options.parseSearch(parsed.search);
          rest.hash = parsed.hash.slice(1);
        }
        const location2 = this.buildLocation({
          ...rest,
          _includeValidateSearch: true
        });
        return this.commitLocation({
          ...location2,
          viewTransition,
          replace: replace2,
          resetScroll,
          hashScrollIntoView,
          ignoreBlocker
        });
      };
      this.navigate = ({ to, reloadDocument, href, ...rest }) => {
        if (!reloadDocument && href) {
          try {
            new URL(`${href}`);
            reloadDocument = true;
          } catch {
          }
        }
        if (reloadDocument) {
          if (!href) {
            const location2 = this.buildLocation({ to, ...rest });
            href = this.history.createHref(location2.href);
          }
          if (rest.replace) {
            window.location.replace(href);
          } else {
            window.location.href = href;
          }
          return Promise.resolve();
        }
        return this.buildAndCommitLocation({
          ...rest,
          href,
          to,
          _isNavigate: true
        });
      };
      this.beforeLoad = () => {
        this.cancelMatches();
        this.latestLocation = this.parseLocation(this.latestLocation);
        if (this.isServer) {
          const nextLocation = this.buildLocation({
            to: this.latestLocation.pathname,
            search: true,
            params: true,
            hash: true,
            state: true,
            _includeValidateSearch: true
          });
          const normalizeUrl2 = (url) => {
            try {
              return encodeURI(decodeURI(url));
            } catch {
              return url;
            }
          };
          if (trimPath(normalizeUrl2(this.latestLocation.href)) !== trimPath(normalizeUrl2(nextLocation.href))) {
            throw redirect({ href: nextLocation.href });
          }
        }
        const pendingMatches = this.matchRoutes(this.latestLocation);
        this.__store.setState((s) => ({
          ...s,
          status: "pending",
          statusCode: 200,
          isLoading: true,
          location: this.latestLocation,
          pendingMatches,
          // If a cached moved to pendingMatches, remove it from cachedMatches
          cachedMatches: s.cachedMatches.filter(
            (d) => !pendingMatches.find((e) => e.id === d.id)
          )
        }));
      };
      this.load = async (opts) => {
        let redirect2;
        let notFound;
        let loadPromise;
        loadPromise = new Promise((resolve) => {
          this.startTransition(async () => {
            var _a2;
            try {
              this.beforeLoad();
              const next = this.latestLocation;
              const prevLocation = this.state.resolvedLocation;
              if (!this.state.redirect) {
                this.emit({
                  type: "onBeforeNavigate",
                  ...getLocationChangeInfo({
                    resolvedLocation: prevLocation,
                    location: next
                  })
                });
              }
              this.emit({
                type: "onBeforeLoad",
                ...getLocationChangeInfo({
                  resolvedLocation: prevLocation,
                  location: next
                })
              });
              await this.loadMatches({
                sync: opts == null ? void 0 : opts.sync,
                matches: this.state.pendingMatches,
                location: next,
                // eslint-disable-next-line @typescript-eslint/require-await
                onReady: async () => {
                  this.startViewTransition(async () => {
                    let exitingMatches;
                    let enteringMatches;
                    let stayingMatches;
                    batch(() => {
                      this.__store.setState((s) => {
                        const previousMatches = s.matches;
                        const newMatches = s.pendingMatches || s.matches;
                        exitingMatches = previousMatches.filter(
                          (match) => !newMatches.find((d) => d.id === match.id)
                        );
                        enteringMatches = newMatches.filter(
                          (match) => !previousMatches.find((d) => d.id === match.id)
                        );
                        stayingMatches = previousMatches.filter(
                          (match) => newMatches.find((d) => d.id === match.id)
                        );
                        return {
                          ...s,
                          isLoading: false,
                          loadedAt: Date.now(),
                          matches: newMatches,
                          pendingMatches: void 0,
                          cachedMatches: [
                            ...s.cachedMatches,
                            ...exitingMatches.filter((d) => d.status !== "error")
                          ]
                        };
                      });
                      this.clearExpiredCache();
                    });
                    [
                      [exitingMatches, "onLeave"],
                      [enteringMatches, "onEnter"],
                      [stayingMatches, "onStay"]
                    ].forEach(([matches2, hook]) => {
                      matches2.forEach((match) => {
                        var _a22, _b2;
                        (_b2 = (_a22 = this.looseRoutesById[match.routeId].options)[hook]) == null ? void 0 : _b2.call(_a22, match);
                      });
                    });
                  });
                }
              });
            } catch (err2) {
              if (isRedirect(err2)) {
                redirect2 = err2;
                if (!this.isServer) {
                  this.navigate({
                    ...redirect2.options,
                    replace: true,
                    ignoreBlocker: true
                  });
                }
              } else if (isNotFound(err2)) {
                notFound = err2;
              }
              this.__store.setState((s) => ({
                ...s,
                statusCode: redirect2 ? redirect2.status : notFound ? 404 : s.matches.some((d) => d.status === "error") ? 500 : 200,
                redirect: redirect2
              }));
            }
            if (this.latestLoadPromise === loadPromise) {
              (_a2 = this.commitLocationPromise) == null ? void 0 : _a2.resolve();
              this.latestLoadPromise = void 0;
              this.commitLocationPromise = void 0;
            }
            resolve();
          });
        });
        this.latestLoadPromise = loadPromise;
        await loadPromise;
        while (this.latestLoadPromise && loadPromise !== this.latestLoadPromise) {
          await this.latestLoadPromise;
        }
        if (this.hasNotFoundMatch()) {
          this.__store.setState((s) => ({
            ...s,
            statusCode: 404
          }));
        }
      };
      this.startViewTransition = (fn) => {
        const shouldViewTransition = this.shouldViewTransition ?? this.options.defaultViewTransition;
        delete this.shouldViewTransition;
        if (shouldViewTransition && typeof document !== "undefined" && "startViewTransition" in document && typeof document.startViewTransition === "function") {
          let startViewTransitionParams;
          if (typeof shouldViewTransition === "object" && this.isViewTransitionTypesSupported) {
            const next = this.latestLocation;
            const prevLocation = this.state.resolvedLocation;
            const resolvedViewTransitionTypes = typeof shouldViewTransition.types === "function" ? shouldViewTransition.types(
              getLocationChangeInfo({
                resolvedLocation: prevLocation,
                location: next
              })
            ) : shouldViewTransition.types;
            startViewTransitionParams = {
              update: fn,
              types: resolvedViewTransitionTypes
            };
          } else {
            startViewTransitionParams = fn;
          }
          document.startViewTransition(startViewTransitionParams);
        } else {
          fn();
        }
      };
      this.updateMatch = (id, updater) => {
        var _a2;
        let updated;
        const isPending = (_a2 = this.state.pendingMatches) == null ? void 0 : _a2.find((d) => d.id === id);
        const isMatched = this.state.matches.find((d) => d.id === id);
        const isCached = this.state.cachedMatches.find((d) => d.id === id);
        const matchesKey = isPending ? "pendingMatches" : isMatched ? "matches" : isCached ? "cachedMatches" : "";
        if (matchesKey) {
          this.__store.setState((s) => {
            var _a22;
            return {
              ...s,
              [matchesKey]: (_a22 = s[matchesKey]) == null ? void 0 : _a22.map(
                (d) => d.id === id ? updated = updater(d) : d
              )
            };
          });
        }
        return updated;
      };
      this.getMatch = (matchId) => {
        return [
          ...this.state.cachedMatches,
          ...this.state.pendingMatches ?? [],
          ...this.state.matches
        ].find((d) => d.id === matchId);
      };
      this.loadMatches = async ({
        location: location2,
        matches: matches2,
        preload: allPreload,
        onReady,
        updateMatch = this.updateMatch,
        sync
      }) => {
        let firstBadMatchIndex;
        let rendered = false;
        const triggerOnReady = async () => {
          if (!rendered) {
            rendered = true;
            await (onReady == null ? void 0 : onReady());
          }
        };
        const resolvePreload = (matchId) => {
          return !!(allPreload && !this.state.matches.find((d) => d.id === matchId));
        };
        if (!this.isServer && this.state.matches.find((d) => d._forcePending)) {
          triggerOnReady();
        }
        const handleRedirectAndNotFound = (match, err2) => {
          var _a2, _b2, _c2;
          if (isRedirect(err2) || isNotFound(err2)) {
            if (isRedirect(err2)) {
              if (err2.redirectHandled) {
                if (!err2.options.reloadDocument) {
                  throw err2;
                }
              }
            }
            (_a2 = match.beforeLoadPromise) == null ? void 0 : _a2.resolve();
            (_b2 = match.loaderPromise) == null ? void 0 : _b2.resolve();
            updateMatch(match.id, (prev) => ({
              ...prev,
              status: isRedirect(err2) ? "redirected" : isNotFound(err2) ? "notFound" : "error",
              isFetching: false,
              error: err2,
              beforeLoadPromise: void 0,
              loaderPromise: void 0
            }));
            if (!err2.routeId) {
              err2.routeId = match.routeId;
            }
            (_c2 = match.loadPromise) == null ? void 0 : _c2.resolve();
            if (isRedirect(err2)) {
              rendered = true;
              err2.options._fromLocation = location2;
              err2.redirectHandled = true;
              err2 = this.resolveRedirect(err2);
              throw err2;
            } else if (isNotFound(err2)) {
              this._handleNotFound(matches2, err2, {
                updateMatch
              });
              throw err2;
            }
          }
        };
        const shouldSkipLoader = (matchId) => {
          const match = this.getMatch(matchId);
          if (!this.isServer && match._dehydrated) {
            return true;
          }
          if (this.isServer) {
            if (match.ssr === false) {
              return true;
            }
          }
          return false;
        };
        try {
          await new Promise((resolveAll, rejectAll) => {
            ;
            (async () => {
              var _a2, _b2, _c2, _d2;
              try {
                const handleSerialError = (index, err2, routerCode) => {
                  var _a22, _b22;
                  const { id: matchId, routeId } = matches2[index];
                  const route = this.looseRoutesById[routeId];
                  if (err2 instanceof Promise) {
                    throw err2;
                  }
                  err2.routerCode = routerCode;
                  firstBadMatchIndex = firstBadMatchIndex ?? index;
                  handleRedirectAndNotFound(this.getMatch(matchId), err2);
                  try {
                    (_b22 = (_a22 = route.options).onError) == null ? void 0 : _b22.call(_a22, err2);
                  } catch (errorHandlerErr) {
                    err2 = errorHandlerErr;
                    handleRedirectAndNotFound(this.getMatch(matchId), err2);
                  }
                  updateMatch(matchId, (prev) => {
                    var _a3, _b3;
                    (_a3 = prev.beforeLoadPromise) == null ? void 0 : _a3.resolve();
                    (_b3 = prev.loadPromise) == null ? void 0 : _b3.resolve();
                    return {
                      ...prev,
                      error: err2,
                      status: "error",
                      isFetching: false,
                      updatedAt: Date.now(),
                      abortController: new AbortController(),
                      beforeLoadPromise: void 0
                    };
                  });
                };
                for (const [index, { id: matchId, routeId }] of matches2.entries()) {
                  const existingMatch = this.getMatch(matchId);
                  const parentMatchId = (_a2 = matches2[index - 1]) == null ? void 0 : _a2.id;
                  const parentMatch = parentMatchId ? this.getMatch(parentMatchId) : void 0;
                  const route = this.looseRoutesById[routeId];
                  const pendingMs = route.options.pendingMs ?? this.options.defaultPendingMs;
                  if (this.isServer) {
                    let ssr;
                    if (this.isShell()) {
                      ssr = matchId === rootRouteId;
                    } else {
                      const defaultSsr = this.options.defaultSsr ?? true;
                      if ((parentMatch == null ? void 0 : parentMatch.ssr) === false) {
                        ssr = false;
                      } else {
                        let tempSsr;
                        if (route.options.ssr === void 0) {
                          tempSsr = defaultSsr;
                        } else if (typeof route.options.ssr === "function") {
                          let makeMaybe = function(value, error) {
                            if (error) {
                              return { status: "error", error };
                            }
                            return { status: "success", value };
                          };
                          const { search, params } = this.getMatch(matchId);
                          const ssrFnContext = {
                            search: makeMaybe(search, existingMatch.searchError),
                            params: makeMaybe(params, existingMatch.paramsError),
                            location: location2,
                            matches: matches2.map((match) => ({
                              index: match.index,
                              pathname: match.pathname,
                              fullPath: match.fullPath,
                              staticData: match.staticData,
                              id: match.id,
                              routeId: match.routeId,
                              search: makeMaybe(match.search, match.searchError),
                              params: makeMaybe(match.params, match.paramsError),
                              ssr: match.ssr
                            }))
                          };
                          tempSsr = await route.options.ssr(ssrFnContext) ?? defaultSsr;
                        } else {
                          tempSsr = route.options.ssr;
                        }
                        if (tempSsr === true && (parentMatch == null ? void 0 : parentMatch.ssr) === "data-only") {
                          ssr = "data-only";
                        } else {
                          ssr = tempSsr;
                        }
                      }
                    }
                    updateMatch(matchId, (prev) => ({
                      ...prev,
                      ssr
                    }));
                  }
                  if (shouldSkipLoader(matchId)) {
                    continue;
                  }
                  const shouldPending = !!(onReady && !this.isServer && !resolvePreload(matchId) && (route.options.loader || route.options.beforeLoad || routeNeedsPreload(route)) && typeof pendingMs === "number" && pendingMs !== Infinity && (route.options.pendingComponent ?? ((_b2 = this.options) == null ? void 0 : _b2.defaultPendingComponent)));
                  let executeBeforeLoad = true;
                  const setupPendingTimeout = () => {
                    if (shouldPending && this.getMatch(matchId).pendingTimeout === void 0) {
                      const pendingTimeout = setTimeout(() => {
                        try {
                          triggerOnReady();
                        } catch {
                        }
                      }, pendingMs);
                      updateMatch(matchId, (prev) => ({
                        ...prev,
                        pendingTimeout
                      }));
                    }
                  };
                  if (
                    // If we are in the middle of a load, either of these will be present
                    // (not to be confused with `loadPromise`, which is always defined)
                    existingMatch.beforeLoadPromise || existingMatch.loaderPromise
                  ) {
                    setupPendingTimeout();
                    await existingMatch.beforeLoadPromise;
                    const match = this.getMatch(matchId);
                    if (match.status === "error") {
                      executeBeforeLoad = true;
                    } else if (match.preload && (match.status === "redirected" || match.status === "notFound")) {
                      handleRedirectAndNotFound(match, match.error);
                    }
                  }
                  if (executeBeforeLoad) {
                    try {
                      updateMatch(matchId, (prev) => {
                        const prevLoadPromise = prev.loadPromise;
                        return {
                          ...prev,
                          loadPromise: createControlledPromise(() => {
                            prevLoadPromise == null ? void 0 : prevLoadPromise.resolve();
                          }),
                          beforeLoadPromise: createControlledPromise()
                        };
                      });
                      const { paramsError, searchError } = this.getMatch(matchId);
                      if (paramsError) {
                        handleSerialError(index, paramsError, "PARSE_PARAMS");
                      }
                      if (searchError) {
                        handleSerialError(index, searchError, "VALIDATE_SEARCH");
                      }
                      setupPendingTimeout();
                      const abortController = new AbortController();
                      const parentMatchContext = (parentMatch == null ? void 0 : parentMatch.context) ?? this.options.context ?? {};
                      updateMatch(matchId, (prev) => ({
                        ...prev,
                        isFetching: "beforeLoad",
                        fetchCount: prev.fetchCount + 1,
                        abortController,
                        context: {
                          ...parentMatchContext,
                          ...prev.__routeContext
                        }
                      }));
                      const { search, params, context, cause } = this.getMatch(matchId);
                      const preload = resolvePreload(matchId);
                      const beforeLoadFnContext = {
                        search,
                        abortController,
                        params,
                        preload,
                        context,
                        location: location2,
                        navigate: (opts) => this.navigate({ ...opts, _fromLocation: location2 }),
                        buildLocation: this.buildLocation,
                        cause: preload ? "preload" : cause,
                        matches: matches2
                      };
                      const beforeLoadContext = await ((_d2 = (_c2 = route.options).beforeLoad) == null ? void 0 : _d2.call(_c2, beforeLoadFnContext));
                      if (isRedirect(beforeLoadContext) || isNotFound(beforeLoadContext)) {
                        handleSerialError(index, beforeLoadContext, "BEFORE_LOAD");
                      }
                      updateMatch(matchId, (prev) => {
                        return {
                          ...prev,
                          __beforeLoadContext: beforeLoadContext,
                          context: {
                            ...parentMatchContext,
                            ...prev.__routeContext,
                            ...beforeLoadContext
                          },
                          abortController
                        };
                      });
                    } catch (err2) {
                      handleSerialError(index, err2, "BEFORE_LOAD");
                    }
                    updateMatch(matchId, (prev) => {
                      var _a22;
                      (_a22 = prev.beforeLoadPromise) == null ? void 0 : _a22.resolve();
                      return {
                        ...prev,
                        beforeLoadPromise: void 0,
                        isFetching: false
                      };
                    });
                  }
                }
                const validResolvedMatches = matches2.slice(0, firstBadMatchIndex);
                const matchPromises = [];
                validResolvedMatches.forEach(({ id: matchId, routeId }, index) => {
                  matchPromises.push(
                    (async () => {
                      let loaderShouldRunAsync = false;
                      let loaderIsRunningAsync = false;
                      const route = this.looseRoutesById[routeId];
                      const executeHead = async () => {
                        var _a22, _b22, _c22, _d22, _e2, _f2;
                        const match = this.getMatch(matchId);
                        if (!match) {
                          return;
                        }
                        const assetContext = {
                          matches: matches2,
                          match,
                          params: match.params,
                          loaderData: match.loaderData
                        };
                        const headFnContent = await ((_b22 = (_a22 = route.options).head) == null ? void 0 : _b22.call(_a22, assetContext));
                        const meta = headFnContent == null ? void 0 : headFnContent.meta;
                        const links = headFnContent == null ? void 0 : headFnContent.links;
                        const headScripts = headFnContent == null ? void 0 : headFnContent.scripts;
                        const styles2 = headFnContent == null ? void 0 : headFnContent.styles;
                        const scripts = await ((_d22 = (_c22 = route.options).scripts) == null ? void 0 : _d22.call(_c22, assetContext));
                        const headers = await ((_f2 = (_e2 = route.options).headers) == null ? void 0 : _f2.call(_e2, assetContext));
                        return {
                          meta,
                          links,
                          headScripts,
                          headers,
                          scripts,
                          styles: styles2
                        };
                      };
                      const potentialPendingMinPromise = async () => {
                        const latestMatch = this.getMatch(matchId);
                        if (latestMatch.minPendingPromise) {
                          await latestMatch.minPendingPromise;
                        }
                      };
                      const prevMatch = this.getMatch(matchId);
                      if (shouldSkipLoader(matchId)) {
                        if (this.isServer) {
                          const head = await executeHead();
                          updateMatch(matchId, (prev) => ({
                            ...prev,
                            ...head
                          }));
                          return this.getMatch(matchId);
                        }
                      } else if (prevMatch.loaderPromise) {
                        if (prevMatch.status === "success" && !sync && !prevMatch.preload) {
                          return this.getMatch(matchId);
                        }
                        await prevMatch.loaderPromise;
                        const match = this.getMatch(matchId);
                        if (match.error) {
                          handleRedirectAndNotFound(match, match.error);
                        }
                      } else {
                        const parentMatchPromise = matchPromises[index - 1];
                        const getLoaderContext = () => {
                          const {
                            params,
                            loaderDeps,
                            abortController,
                            context,
                            cause
                          } = this.getMatch(matchId);
                          const preload2 = resolvePreload(matchId);
                          return {
                            params,
                            deps: loaderDeps,
                            preload: !!preload2,
                            parentMatchPromise,
                            abortController,
                            context,
                            location: location2,
                            navigate: (opts) => this.navigate({ ...opts, _fromLocation: location2 }),
                            cause: preload2 ? "preload" : cause,
                            route
                          };
                        };
                        const age = Date.now() - this.getMatch(matchId).updatedAt;
                        const preload = resolvePreload(matchId);
                        const staleAge = preload ? route.options.preloadStaleTime ?? this.options.defaultPreloadStaleTime ?? 3e4 : route.options.staleTime ?? this.options.defaultStaleTime ?? 0;
                        const shouldReloadOption = route.options.shouldReload;
                        const shouldReload = typeof shouldReloadOption === "function" ? shouldReloadOption(getLoaderContext()) : shouldReloadOption;
                        updateMatch(matchId, (prev) => ({
                          ...prev,
                          loaderPromise: createControlledPromise(),
                          preload: !!preload && !this.state.matches.find((d) => d.id === matchId)
                        }));
                        const runLoader = async () => {
                          var _a22, _b22, _c22, _d22;
                          try {
                            try {
                              if (!this.isServer || this.isServer && this.getMatch(matchId).ssr === true) {
                                this.loadRouteChunk(route);
                              }
                              updateMatch(matchId, (prev) => ({
                                ...prev,
                                isFetching: "loader"
                              }));
                              const loaderData = await ((_b22 = (_a22 = route.options).loader) == null ? void 0 : _b22.call(_a22, getLoaderContext()));
                              handleRedirectAndNotFound(
                                this.getMatch(matchId),
                                loaderData
                              );
                              updateMatch(matchId, (prev) => ({
                                ...prev,
                                loaderData
                              }));
                              await route._lazyPromise;
                              const head = await executeHead();
                              await potentialPendingMinPromise();
                              await route._componentsPromise;
                              updateMatch(matchId, (prev) => ({
                                ...prev,
                                error: void 0,
                                status: "success",
                                isFetching: false,
                                updatedAt: Date.now(),
                                ...head
                              }));
                            } catch (e) {
                              let error = e;
                              await potentialPendingMinPromise();
                              handleRedirectAndNotFound(this.getMatch(matchId), e);
                              try {
                                (_d22 = (_c22 = route.options).onError) == null ? void 0 : _d22.call(_c22, e);
                              } catch (onErrorError) {
                                error = onErrorError;
                                handleRedirectAndNotFound(
                                  this.getMatch(matchId),
                                  onErrorError
                                );
                              }
                              const head = await executeHead();
                              updateMatch(matchId, (prev) => ({
                                ...prev,
                                error,
                                status: "error",
                                isFetching: false,
                                ...head
                              }));
                            }
                          } catch (err2) {
                            const head = await executeHead();
                            updateMatch(matchId, (prev) => ({
                              ...prev,
                              loaderPromise: void 0,
                              ...head
                            }));
                            handleRedirectAndNotFound(this.getMatch(matchId), err2);
                          }
                        };
                        const { status, invalid } = this.getMatch(matchId);
                        loaderShouldRunAsync = status === "success" && (invalid || (shouldReload ?? age > staleAge));
                        if (preload && route.options.preload === false) {
                        } else if (loaderShouldRunAsync && !sync) {
                          loaderIsRunningAsync = true;
                          (async () => {
                            try {
                              await runLoader();
                              const { loaderPromise, loadPromise } = this.getMatch(matchId);
                              loaderPromise == null ? void 0 : loaderPromise.resolve();
                              loadPromise == null ? void 0 : loadPromise.resolve();
                              updateMatch(matchId, (prev) => ({
                                ...prev,
                                loaderPromise: void 0
                              }));
                            } catch (err2) {
                              if (isRedirect(err2)) {
                                await this.navigate(err2.options);
                              }
                            }
                          })();
                        } else if (status !== "success" || loaderShouldRunAsync && sync) {
                          await runLoader();
                        } else {
                          const head = await executeHead();
                          updateMatch(matchId, (prev) => ({
                            ...prev,
                            ...head
                          }));
                        }
                      }
                      if (!loaderIsRunningAsync) {
                        const { loaderPromise, loadPromise } = this.getMatch(matchId);
                        loaderPromise == null ? void 0 : loaderPromise.resolve();
                        loadPromise == null ? void 0 : loadPromise.resolve();
                      }
                      updateMatch(matchId, (prev) => {
                        clearTimeout(prev.pendingTimeout);
                        return {
                          ...prev,
                          isFetching: loaderIsRunningAsync ? prev.isFetching : false,
                          loaderPromise: loaderIsRunningAsync ? prev.loaderPromise : void 0,
                          invalid: false,
                          pendingTimeout: void 0,
                          _dehydrated: void 0
                        };
                      });
                      return this.getMatch(matchId);
                    })()
                  );
                });
                await Promise.all(matchPromises);
                resolveAll();
              } catch (err2) {
                rejectAll(err2);
              }
            })();
          });
          await triggerOnReady();
        } catch (err2) {
          if (isRedirect(err2) || isNotFound(err2)) {
            if (isNotFound(err2) && !allPreload) {
              await triggerOnReady();
            }
            throw err2;
          }
        }
        return matches2;
      };
      this.invalidate = (opts) => {
        const invalidate = (d) => {
          var _a2;
          if (((_a2 = opts == null ? void 0 : opts.filter) == null ? void 0 : _a2.call(opts, d)) ?? true) {
            return {
              ...d,
              invalid: true,
              ...(opts == null ? void 0 : opts.forcePending) || d.status === "error" ? { status: "pending", error: void 0 } : {}
            };
          }
          return d;
        };
        this.__store.setState((s) => {
          var _a2;
          return {
            ...s,
            matches: s.matches.map(invalidate),
            cachedMatches: s.cachedMatches.map(invalidate),
            pendingMatches: (_a2 = s.pendingMatches) == null ? void 0 : _a2.map(invalidate)
          };
        });
        this.shouldViewTransition = false;
        return this.load({ sync: opts == null ? void 0 : opts.sync });
      };
      this.resolveRedirect = (redirect2) => {
        if (!redirect2.options.href) {
          redirect2.options.href = this.buildLocation(redirect2.options).href;
          redirect2.headers.set("Location", redirect2.options.href);
        }
        if (!redirect2.headers.get("Location")) {
          redirect2.headers.set("Location", redirect2.options.href);
        }
        return redirect2;
      };
      this.clearCache = (opts) => {
        const filter = opts == null ? void 0 : opts.filter;
        if (filter !== void 0) {
          this.__store.setState((s) => {
            return {
              ...s,
              cachedMatches: s.cachedMatches.filter(
                (m) => !filter(m)
              )
            };
          });
        } else {
          this.__store.setState((s) => {
            return {
              ...s,
              cachedMatches: []
            };
          });
        }
      };
      this.clearExpiredCache = () => {
        const filter = (d) => {
          const route = this.looseRoutesById[d.routeId];
          if (!route.options.loader) {
            return true;
          }
          const gcTime = (d.preload ? route.options.preloadGcTime ?? this.options.defaultPreloadGcTime : route.options.gcTime ?? this.options.defaultGcTime) ?? 5 * 60 * 1e3;
          return !(d.status !== "error" && Date.now() - d.updatedAt < gcTime);
        };
        this.clearCache({ filter });
      };
      this.loadRouteChunk = (route) => {
        if (route._lazyPromise === void 0) {
          if (route.lazyFn) {
            route._lazyPromise = route.lazyFn().then((lazyRoute) => {
              const { id: _id, ...options2 } = lazyRoute.options;
              Object.assign(route.options, options2);
            });
          } else {
            route._lazyPromise = Promise.resolve();
          }
        }
        if (route._componentsPromise === void 0) {
          route._componentsPromise = route._lazyPromise.then(
            () => Promise.all(
              componentTypes.map(async (type) => {
                const component = route.options[type];
                if (component == null ? void 0 : component.preload) {
                  await component.preload();
                }
              })
            )
          );
        }
        return route._componentsPromise;
      };
      this.preloadRoute = async (opts) => {
        const next = this.buildLocation(opts);
        let matches2 = this.matchRoutes(next, {
          throwOnError: true,
          preload: true,
          dest: opts
        });
        const activeMatchIds = new Set(
          [...this.state.matches, ...this.state.pendingMatches ?? []].map(
            (d) => d.id
          )
        );
        const loadedMatchIds = /* @__PURE__ */ new Set([
          ...activeMatchIds,
          ...this.state.cachedMatches.map((d) => d.id)
        ]);
        batch(() => {
          matches2.forEach((match) => {
            if (!loadedMatchIds.has(match.id)) {
              this.__store.setState((s) => ({
                ...s,
                cachedMatches: [...s.cachedMatches, match]
              }));
            }
          });
        });
        try {
          matches2 = await this.loadMatches({
            matches: matches2,
            location: next,
            preload: true,
            updateMatch: (id, updater) => {
              if (activeMatchIds.has(id)) {
                matches2 = matches2.map((d) => d.id === id ? updater(d) : d);
              } else {
                this.updateMatch(id, updater);
              }
            }
          });
          return matches2;
        } catch (err2) {
          if (isRedirect(err2)) {
            if (err2.options.reloadDocument) {
              return void 0;
            }
            return await this.preloadRoute({
              ...err2.options,
              _fromLocation: next
            });
          }
          if (!isNotFound(err2)) {
            console.error(err2);
          }
          return void 0;
        }
      };
      this.matchRoute = (location2, opts) => {
        const matchLocation = {
          ...location2,
          to: location2.to ? this.resolvePathWithBase(
            location2.from || "",
            location2.to
          ) : void 0,
          params: location2.params || {},
          leaveParams: true
        };
        const next = this.buildLocation(matchLocation);
        if ((opts == null ? void 0 : opts.pending) && this.state.status !== "pending") {
          return false;
        }
        const pending = (opts == null ? void 0 : opts.pending) === void 0 ? !this.state.isLoading : opts.pending;
        const baseLocation = pending ? this.latestLocation : this.state.resolvedLocation || this.state.location;
        const match = matchPathname(
          this.basepath,
          baseLocation.pathname,
          {
            ...opts,
            to: next.pathname
          },
          this.parsePathnameCache
        );
        if (!match) {
          return false;
        }
        if (location2.params) {
          if (!deepEqual$1(match, location2.params, { partial: true })) {
            return false;
          }
        }
        if (match && ((opts == null ? void 0 : opts.includeSearch) ?? true)) {
          return deepEqual$1(baseLocation.search, next.search, { partial: true }) ? match : false;
        }
        return match;
      };
      this._handleNotFound = (matches2, err2, {
        updateMatch = this.updateMatch
      } = {}) => {
        var _a2;
        const routeCursor = this.routesById[err2.routeId ?? ""] ?? this.routeTree;
        const matchesByRouteId = {};
        for (const match of matches2) {
          matchesByRouteId[match.routeId] = match;
        }
        if (!routeCursor.options.notFoundComponent && ((_a2 = this.options) == null ? void 0 : _a2.defaultNotFoundComponent)) {
          routeCursor.options.notFoundComponent = this.options.defaultNotFoundComponent;
        }
        invariant$1(
          routeCursor.options.notFoundComponent
        );
        const matchForRoute = matchesByRouteId[routeCursor.id];
        invariant$1(
          matchForRoute,
          "Could not find match for route: " + routeCursor.id
        );
        updateMatch(matchForRoute.id, (prev) => ({
          ...prev,
          status: "notFound",
          error: err2,
          isFetching: false
        }));
        if (err2.routerCode === "BEFORE_LOAD" && routeCursor.parentRoute) {
          err2.routeId = routeCursor.parentRoute.id;
          this._handleNotFound(matches2, err2, {
            updateMatch
          });
        }
      };
      this.hasNotFoundMatch = () => {
        return this.__store.state.matches.some(
          (d) => d.status === "notFound" || d.globalNotFound
        );
      };
      this.update({
        defaultPreloadDelay: 50,
        defaultPendingMs: 1e3,
        defaultPendingMinMs: 500,
        context: void 0,
        ...options,
        caseSensitive: options.caseSensitive ?? false,
        notFoundMode: options.notFoundMode ?? "fuzzy",
        stringifySearch: options.stringifySearch ?? defaultStringifySearch,
        parseSearch: options.parseSearch ?? defaultParseSearch
      });
      if (typeof document !== "undefined") {
        self.__TSR_ROUTER__ = this;
      }
    }
    isShell() {
      return this.options.isShell;
    }
    get state() {
      return this.__store.state;
    }
    get looseRoutesById() {
      return this.routesById;
    }
    matchRoutesInternal(next, opts) {
      var _a2;
      const { foundRoute, matchedRoutes, routeParams } = this.getMatchedRoutes(
        next.pathname,
        (_a2 = opts == null ? void 0 : opts.dest) == null ? void 0 : _a2.to
      );
      let isGlobalNotFound = false;
      if (
        // If we found a route, and it's not an index route and we have left over path
        foundRoute ? foundRoute.path !== "/" && routeParams["**"] : (
          // Or if we didn't find a route and we have left over path
          trimPathRight(next.pathname)
        )
      ) {
        if (this.options.notFoundRoute) {
          matchedRoutes.push(this.options.notFoundRoute);
        } else {
          isGlobalNotFound = true;
        }
      }
      const globalNotFoundRouteId = (() => {
        if (!isGlobalNotFound) {
          return void 0;
        }
        if (this.options.notFoundMode !== "root") {
          for (let i2 = matchedRoutes.length - 1; i2 >= 0; i2--) {
            const route = matchedRoutes[i2];
            if (route.children) {
              return route.id;
            }
          }
        }
        return rootRouteId;
      })();
      const parseErrors = matchedRoutes.map((route) => {
        var _a22;
        let parsedParamsError;
        const parseParams = ((_a22 = route.options.params) == null ? void 0 : _a22.parse) ?? route.options.parseParams;
        if (parseParams) {
          try {
            const parsedParams = parseParams(routeParams);
            Object.assign(routeParams, parsedParams);
          } catch (err2) {
            parsedParamsError = new PathParamError(err2.message, {
              cause: err2
            });
            if (opts == null ? void 0 : opts.throwOnError) {
              throw parsedParamsError;
            }
            return parsedParamsError;
          }
        }
        return;
      });
      const matches2 = [];
      const getParentContext = (parentMatch) => {
        const parentMatchId = parentMatch == null ? void 0 : parentMatch.id;
        const parentContext = !parentMatchId ? this.options.context ?? {} : parentMatch.context ?? this.options.context ?? {};
        return parentContext;
      };
      matchedRoutes.forEach((route, index) => {
        var _a22, _b2;
        const parentMatch = matches2[index - 1];
        const [preMatchSearch, strictMatchSearch, searchError] = (() => {
          const parentSearch = (parentMatch == null ? void 0 : parentMatch.search) ?? next.search;
          const parentStrictSearch = (parentMatch == null ? void 0 : parentMatch._strictSearch) ?? {};
          try {
            const strictSearch = validateSearch(route.options.validateSearch, { ...parentSearch }) ?? {};
            return [
              {
                ...parentSearch,
                ...strictSearch
              },
              { ...parentStrictSearch, ...strictSearch },
              void 0
            ];
          } catch (err2) {
            let searchParamError = err2;
            if (!(err2 instanceof SearchParamError)) {
              searchParamError = new SearchParamError(err2.message, {
                cause: err2
              });
            }
            if (opts == null ? void 0 : opts.throwOnError) {
              throw searchParamError;
            }
            return [parentSearch, {}, searchParamError];
          }
        })();
        const loaderDeps = ((_b2 = (_a22 = route.options).loaderDeps) == null ? void 0 : _b2.call(_a22, {
          search: preMatchSearch
        })) ?? "";
        const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : "";
        const { usedParams, interpolatedPath } = interpolatePath({
          path: route.fullPath,
          params: routeParams,
          decodeCharMap: this.pathParamsDecodeCharMap
        });
        const matchId = interpolatePath({
          path: route.id,
          params: routeParams,
          leaveWildcards: true,
          decodeCharMap: this.pathParamsDecodeCharMap,
          parseCache: this.parsePathnameCache
        }).interpolatedPath + loaderDepsHash;
        const existingMatch = this.getMatch(matchId);
        const previousMatch = this.state.matches.find(
          (d) => d.routeId === route.id
        );
        const cause = previousMatch ? "stay" : "enter";
        let match;
        if (existingMatch) {
          match = {
            ...existingMatch,
            cause,
            params: previousMatch ? replaceEqualDeep$1(previousMatch.params, routeParams) : routeParams,
            _strictParams: usedParams,
            search: previousMatch ? replaceEqualDeep$1(previousMatch.search, preMatchSearch) : replaceEqualDeep$1(existingMatch.search, preMatchSearch),
            _strictSearch: strictMatchSearch
          };
        } else {
          const status = route.options.loader || route.options.beforeLoad || route.lazyFn || routeNeedsPreload(route) ? "pending" : "success";
          match = {
            id: matchId,
            index,
            routeId: route.id,
            params: previousMatch ? replaceEqualDeep$1(previousMatch.params, routeParams) : routeParams,
            _strictParams: usedParams,
            pathname: joinPaths([this.basepath, interpolatedPath]),
            updatedAt: Date.now(),
            search: previousMatch ? replaceEqualDeep$1(previousMatch.search, preMatchSearch) : preMatchSearch,
            _strictSearch: strictMatchSearch,
            searchError: void 0,
            status,
            isFetching: false,
            error: void 0,
            paramsError: parseErrors[index],
            __routeContext: {},
            __beforeLoadContext: void 0,
            context: {},
            abortController: new AbortController(),
            fetchCount: 0,
            cause,
            loaderDeps: previousMatch ? replaceEqualDeep$1(previousMatch.loaderDeps, loaderDeps) : loaderDeps,
            invalid: false,
            preload: false,
            links: void 0,
            scripts: void 0,
            headScripts: void 0,
            meta: void 0,
            staticData: route.options.staticData || {},
            loadPromise: createControlledPromise(),
            fullPath: route.fullPath
          };
        }
        if (!(opts == null ? void 0 : opts.preload)) {
          match.globalNotFound = globalNotFoundRouteId === route.id;
        }
        match.searchError = searchError;
        const parentContext = getParentContext(parentMatch);
        match.context = {
          ...parentContext,
          ...match.__routeContext,
          ...match.__beforeLoadContext
        };
        matches2.push(match);
      });
      matches2.forEach((match, index) => {
        var _a22, _b2;
        const route = this.looseRoutesById[match.routeId];
        const existingMatch = this.getMatch(match.id);
        if (!existingMatch && (opts == null ? void 0 : opts._buildLocation) !== true) {
          const parentMatch = matches2[index - 1];
          const parentContext = getParentContext(parentMatch);
          const contextFnContext = {
            deps: match.loaderDeps,
            params: match.params,
            context: parentContext,
            location: next,
            navigate: (opts2) => this.navigate({ ...opts2, _fromLocation: next }),
            buildLocation: this.buildLocation,
            cause: match.cause,
            abortController: match.abortController,
            preload: !!match.preload,
            matches: matches2
          };
          match.__routeContext = ((_b2 = (_a22 = route.options).context) == null ? void 0 : _b2.call(_a22, contextFnContext)) ?? {};
          match.context = {
            ...parentContext,
            ...match.__routeContext,
            ...match.__beforeLoadContext
          };
        }
      });
      return matches2;
    }
  }
  class SearchParamError extends Error {
  }
  class PathParamError extends Error {
  }
  const normalize$1 = (str) => str.endsWith("/") && str.length > 1 ? str.slice(0, -1) : str;
  function comparePaths(a, b2) {
    return normalize$1(a) === normalize$1(b2);
  }
  function getInitialRouterState(location2) {
    return {
      loadedAt: 0,
      isLoading: false,
      isTransitioning: false,
      status: "idle",
      resolvedLocation: void 0,
      location: location2,
      matches: [],
      pendingMatches: [],
      cachedMatches: [],
      statusCode: 200
    };
  }
  function validateSearch(validateSearch2, input) {
    if (validateSearch2 == null) return {};
    if ("~standard" in validateSearch2) {
      const result = validateSearch2["~standard"].validate(input);
      if (result instanceof Promise)
        throw new SearchParamError("Async validation not supported");
      if (result.issues)
        throw new SearchParamError(JSON.stringify(result.issues, void 0, 2), {
          cause: result
        });
      return result.value;
    }
    if ("parse" in validateSearch2) {
      return validateSearch2.parse(input);
    }
    if (typeof validateSearch2 === "function") {
      return validateSearch2(input);
    }
    return {};
  }
  const componentTypes = [
    "component",
    "errorComponent",
    "pendingComponent",
    "notFoundComponent"
  ];
  function routeNeedsPreload(route) {
    var _a2;
    for (const componentType of componentTypes) {
      if ((_a2 = route.options[componentType]) == null ? void 0 : _a2.preload) {
        return true;
      }
    }
    return false;
  }
  const REQUIRED_PARAM_BASE_SCORE = 0.5;
  const OPTIONAL_PARAM_BASE_SCORE = 0.4;
  const WILDCARD_PARAM_BASE_SCORE = 0.25;
  function handleParam(segment, baseScore) {
    if (segment.prefixSegment && segment.suffixSegment) {
      return baseScore + 0.05;
    }
    if (segment.prefixSegment) {
      return baseScore + 0.02;
    }
    if (segment.suffixSegment) {
      return baseScore + 0.01;
    }
    return baseScore;
  }
  function processRouteTree({
    routeTree: routeTree2,
    initRoute
  }) {
    const routesById = {};
    const routesByPath = {};
    const recurseRoutes = (childRoutes) => {
      childRoutes.forEach((childRoute, i2) => {
        initRoute == null ? void 0 : initRoute(childRoute, i2);
        const existingRoute = routesById[childRoute.id];
        invariant$1(
          !existingRoute,
          `Duplicate routes found with id: ${String(childRoute.id)}`
        );
        routesById[childRoute.id] = childRoute;
        if (!childRoute.isRoot && childRoute.path) {
          const trimmedFullPath = trimPathRight(childRoute.fullPath);
          if (!routesByPath[trimmedFullPath] || childRoute.fullPath.endsWith("/")) {
            routesByPath[trimmedFullPath] = childRoute;
          }
        }
        const children = childRoute.children;
        if (children == null ? void 0 : children.length) {
          recurseRoutes(children);
        }
      });
    };
    recurseRoutes([routeTree2]);
    const scoredRoutes = [];
    const routes = Object.values(routesById);
    routes.forEach((d, i2) => {
      var _a2;
      if (d.isRoot || !d.path) {
        return;
      }
      const trimmed = trimPathLeft(d.fullPath);
      let parsed = parsePathname(trimmed);
      let skip = 0;
      while (parsed.length > skip + 1 && ((_a2 = parsed[skip]) == null ? void 0 : _a2.value) === "/") {
        skip++;
      }
      if (skip > 0) parsed = parsed.slice(skip);
      let optionalParamCount = 0;
      let hasStaticAfter = false;
      const scores = parsed.map((segment, index) => {
        if (segment.value === "/") {
          return 0.75;
        }
        let baseScore = void 0;
        if (segment.type === SEGMENT_TYPE_PARAM) {
          baseScore = REQUIRED_PARAM_BASE_SCORE;
        } else if (segment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {
          baseScore = OPTIONAL_PARAM_BASE_SCORE;
          optionalParamCount++;
        } else if (segment.type === SEGMENT_TYPE_WILDCARD) {
          baseScore = WILDCARD_PARAM_BASE_SCORE;
        }
        if (baseScore) {
          for (let i22 = index + 1; i22 < parsed.length; i22++) {
            const nextSegment = parsed[i22];
            if (nextSegment.type === SEGMENT_TYPE_PATHNAME && nextSegment.value !== "/") {
              hasStaticAfter = true;
              return handleParam(segment, baseScore + 0.2);
            }
          }
          return handleParam(segment, baseScore);
        }
        return 1;
      });
      scoredRoutes.push({
        child: d,
        trimmed,
        parsed,
        index: i2,
        scores,
        optionalParamCount,
        hasStaticAfter
      });
    });
    const flatRoutes = scoredRoutes.sort((a, b2) => {
      const minLength = Math.min(a.scores.length, b2.scores.length);
      for (let i2 = 0; i2 < minLength; i2++) {
        if (a.scores[i2] !== b2.scores[i2]) {
          return b2.scores[i2] - a.scores[i2];
        }
      }
      if (a.scores.length !== b2.scores.length) {
        if (a.optionalParamCount !== b2.optionalParamCount) {
          if (a.hasStaticAfter === b2.hasStaticAfter) {
            return a.optionalParamCount - b2.optionalParamCount;
          } else if (a.hasStaticAfter && !b2.hasStaticAfter) {
            return -1;
          } else if (!a.hasStaticAfter && b2.hasStaticAfter) {
            return 1;
          }
        }
        return b2.scores.length - a.scores.length;
      }
      for (let i2 = 0; i2 < minLength; i2++) {
        if (a.parsed[i2].value !== b2.parsed[i2].value) {
          return a.parsed[i2].value > b2.parsed[i2].value ? 1 : -1;
        }
      }
      return a.index - b2.index;
    }).map((d, i2) => {
      d.child.rank = i2;
      return d.child;
    });
    return { routesById, routesByPath, flatRoutes };
  }
  function getMatchedRoutes({
    pathname,
    routePathname,
    basepath,
    caseSensitive,
    routesByPath,
    routesById,
    flatRoutes,
    parseCache
  }) {
    let routeParams = {};
    const trimmedPath = trimPathRight(pathname);
    const getMatchedParams = (route) => {
      var _a2;
      const result = matchPathname(
        basepath,
        trimmedPath,
        {
          to: route.fullPath,
          caseSensitive: ((_a2 = route.options) == null ? void 0 : _a2.caseSensitive) ?? caseSensitive,
          // we need fuzzy matching for `notFoundMode: 'fuzzy'`
          fuzzy: true
        },
        parseCache
      );
      return result;
    };
    let foundRoute = routePathname !== void 0 ? routesByPath[routePathname] : void 0;
    if (foundRoute) {
      routeParams = getMatchedParams(foundRoute);
    } else {
      let fuzzyMatch = void 0;
      for (const route of flatRoutes) {
        const matchedParams = getMatchedParams(route);
        if (matchedParams) {
          if (route.path !== "/" && matchedParams["**"]) {
            if (!fuzzyMatch) {
              fuzzyMatch = { foundRoute: route, routeParams: matchedParams };
            }
          } else {
            foundRoute = route;
            routeParams = matchedParams;
            break;
          }
        }
      }
      if (!foundRoute && fuzzyMatch) {
        foundRoute = fuzzyMatch.foundRoute;
        routeParams = fuzzyMatch.routeParams;
      }
    }
    let routeCursor = foundRoute || routesById[rootRouteId];
    const matchedRoutes = [routeCursor];
    while (routeCursor.parentRoute) {
      routeCursor = routeCursor.parentRoute;
      matchedRoutes.push(routeCursor);
    }
    matchedRoutes.reverse();
    return { matchedRoutes, routeParams, foundRoute };
  }
  function applySearchMiddleware({
    search,
    dest,
    destRoutes,
    _includeValidateSearch
  }) {
    const allMiddlewares = destRoutes.reduce(
      (acc, route) => {
        var _a2;
        const middlewares = [];
        if ("search" in route.options) {
          if ((_a2 = route.options.search) == null ? void 0 : _a2.middlewares) {
            middlewares.push(...route.options.search.middlewares);
          }
        } else if (route.options.preSearchFilters || route.options.postSearchFilters) {
          const legacyMiddleware = ({
            search: search2,
            next
          }) => {
            let nextSearch = search2;
            if ("preSearchFilters" in route.options && route.options.preSearchFilters) {
              nextSearch = route.options.preSearchFilters.reduce(
                (prev, next2) => next2(prev),
                search2
              );
            }
            const result = next(nextSearch);
            if ("postSearchFilters" in route.options && route.options.postSearchFilters) {
              return route.options.postSearchFilters.reduce(
                (prev, next2) => next2(prev),
                result
              );
            }
            return result;
          };
          middlewares.push(legacyMiddleware);
        }
        if (_includeValidateSearch && route.options.validateSearch) {
          const validate = ({ search: search2, next }) => {
            const result = next(search2);
            try {
              const validatedSearch = {
                ...result,
                ...validateSearch(route.options.validateSearch, result) ?? {}
              };
              return validatedSearch;
            } catch {
              return result;
            }
          };
          middlewares.push(validate);
        }
        return acc.concat(middlewares);
      },
      []
    ) ?? [];
    const final = ({ search: search2 }) => {
      if (!dest.search) {
        return {};
      }
      if (dest.search === true) {
        return search2;
      }
      return functionalUpdate$1(dest.search, search2);
    };
    allMiddlewares.push(final);
    const applyNext = (index, currentSearch) => {
      if (index >= allMiddlewares.length) {
        return currentSearch;
      }
      const middleware = allMiddlewares[index];
      const next = (newSearch) => {
        return applyNext(index + 1, newSearch);
      };
      return middleware({ search: currentSearch, next });
    };
    return applyNext(0, search);
  }
  const preloadWarning = "Error preloading route! ";
  class BaseRoute {
    constructor(options) {
      this.init = (opts) => {
        var _a2, _b2;
        this.originalIndex = opts.originalIndex;
        const options2 = this.options;
        const isRoot = !(options2 == null ? void 0 : options2.path) && !(options2 == null ? void 0 : options2.id);
        this.parentRoute = (_b2 = (_a2 = this.options).getParentRoute) == null ? void 0 : _b2.call(_a2);
        if (isRoot) {
          this._path = rootRouteId;
        } else if (!this.parentRoute) {
          invariant$1(
            false
          );
        }
        let path = isRoot ? rootRouteId : options2 == null ? void 0 : options2.path;
        if (path && path !== "/") {
          path = trimPathLeft(path);
        }
        const customId = (options2 == null ? void 0 : options2.id) || path;
        let id = isRoot ? rootRouteId : joinPaths([
          this.parentRoute.id === rootRouteId ? "" : this.parentRoute.id,
          customId
        ]);
        if (path === rootRouteId) {
          path = "/";
        }
        if (id !== rootRouteId) {
          id = joinPaths(["/", id]);
        }
        const fullPath = id === rootRouteId ? "/" : joinPaths([this.parentRoute.fullPath, path]);
        this._path = path;
        this._id = id;
        this._fullPath = fullPath;
        this._to = fullPath;
      };
      this.clone = (other) => {
        this._path = other._path;
        this._id = other._id;
        this._fullPath = other._fullPath;
        this._to = other._to;
        this.options.getParentRoute = other.options.getParentRoute;
        this.children = other.children;
      };
      this.addChildren = (children) => {
        return this._addFileChildren(children);
      };
      this._addFileChildren = (children) => {
        if (Array.isArray(children)) {
          this.children = children;
        }
        if (typeof children === "object" && children !== null) {
          this.children = Object.values(children);
        }
        return this;
      };
      this._addFileTypes = () => {
        return this;
      };
      this.updateLoader = (options2) => {
        Object.assign(this.options, options2);
        return this;
      };
      this.update = (options2) => {
        Object.assign(this.options, options2);
        return this;
      };
      this.lazy = (lazyFn) => {
        this.lazyFn = lazyFn;
        return this;
      };
      this.options = options || {};
      this.isRoot = !(options == null ? void 0 : options.getParentRoute);
      if ((options == null ? void 0 : options.id) && (options == null ? void 0 : options.path)) {
        throw new Error(`Route cannot have both an 'id' and a 'path' option.`);
      }
    }
    get to() {
      return this._to;
    }
    get id() {
      return this._id;
    }
    get path() {
      return this._path;
    }
    get fullPath() {
      return this._fullPath;
    }
  }
  class BaseRootRoute extends BaseRoute {
    constructor(options) {
      super(options);
    }
  }
  function CatchBoundary(props) {
    const errorComponent = props.errorComponent ?? ErrorComponent;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      CatchBoundaryImpl,
      {
        getResetKey: props.getResetKey,
        onCatch: props.onCatch,
        children: ({ error, reset }) => {
          if (error) {
            return reactExports.createElement(errorComponent, {
              error,
              reset
            });
          }
          return props.children;
        }
      }
    );
  }
  class CatchBoundaryImpl extends reactExports.Component {
    constructor() {
      super(...arguments);
      this.state = { error: null };
    }
    static getDerivedStateFromProps(props) {
      return { resetKey: props.getResetKey() };
    }
    static getDerivedStateFromError(error) {
      return { error };
    }
    reset() {
      this.setState({ error: null });
    }
    componentDidUpdate(prevProps, prevState) {
      if (prevState.error && prevState.resetKey !== this.state.resetKey) {
        this.reset();
      }
    }
    componentDidCatch(error, errorInfo) {
      if (this.props.onCatch) {
        this.props.onCatch(error, errorInfo);
      }
    }
    render() {
      return this.props.children({
        error: this.state.resetKey !== this.props.getResetKey() ? null : this.state.error,
        reset: () => {
          this.reset();
        }
      });
    }
  }
  function ErrorComponent({ error }) {
    const [show, setShow] = reactExports.useState(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: ".5rem", maxWidth: "100%" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: ".5rem" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { style: { fontSize: "1rem" }, children: "Something went wrong!" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            style: {
              appearance: "none",
              fontSize: ".6em",
              border: "1px solid currentColor",
              padding: ".1rem .2rem",
              fontWeight: "bold",
              borderRadius: ".25rem"
            },
            onClick: () => setShow((d) => !d),
            children: show ? "Hide Error" : "Show Error"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: ".25rem" } }),
      show ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "pre",
        {
          style: {
            fontSize: ".7em",
            border: "1px solid red",
            borderRadius: ".25rem",
            padding: ".3rem",
            color: "red",
            overflow: "auto"
          },
          children: error.message ? /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: error.message }) : null
        }
      ) }) : null
    ] });
  }
  function ClientOnly({ children, fallback = null }) {
    return useHydrated() ? /* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, { children }) : /* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, { children: fallback });
  }
  function useHydrated() {
    return React.useSyncExternalStore(
      subscribe,
      () => true,
      () => false
    );
  }
  function subscribe() {
    return () => {
    };
  }
  var withSelector = { exports: {} };
  var withSelector_production = {};
  var shim = { exports: {} };
  var useSyncExternalStoreShim_production = {};
  /**
   * @license React
   * use-sync-external-store-shim.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredUseSyncExternalStoreShim_production;
  function requireUseSyncExternalStoreShim_production() {
    if (hasRequiredUseSyncExternalStoreShim_production) return useSyncExternalStoreShim_production;
    hasRequiredUseSyncExternalStoreShim_production = 1;
    var React2 = requireReact();
    function is(x2, y) {
      return x2 === y && (0 !== x2 || 1 / x2 === 1 / y) || x2 !== x2 && y !== y;
    }
    var objectIs = "function" === typeof Object.is ? Object.is : is, useState2 = React2.useState, useEffect2 = React2.useEffect, useLayoutEffect2 = React2.useLayoutEffect, useDebugValue = React2.useDebugValue;
    function useSyncExternalStore$22(subscribe2, getSnapshot) {
      var value = getSnapshot(), _useState = useState2({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
      useLayoutEffect2(
        function() {
          inst.value = value;
          inst.getSnapshot = getSnapshot;
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        },
        [subscribe2, value, getSnapshot]
      );
      useEffect2(
        function() {
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          return subscribe2(function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          });
        },
        [subscribe2]
      );
      useDebugValue(value);
      return value;
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return true;
      }
    }
    function useSyncExternalStore$12(subscribe2, getSnapshot) {
      return getSnapshot();
    }
    var shim2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$12 : useSyncExternalStore$22;
    useSyncExternalStoreShim_production.useSyncExternalStore = void 0 !== React2.useSyncExternalStore ? React2.useSyncExternalStore : shim2;
    return useSyncExternalStoreShim_production;
  }
  var hasRequiredShim;
  function requireShim() {
    if (hasRequiredShim) return shim.exports;
    hasRequiredShim = 1;
    {
      shim.exports = requireUseSyncExternalStoreShim_production();
    }
    return shim.exports;
  }
  /**
   * @license React
   * use-sync-external-store-shim/with-selector.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredWithSelector_production;
  function requireWithSelector_production() {
    if (hasRequiredWithSelector_production) return withSelector_production;
    hasRequiredWithSelector_production = 1;
    var React2 = requireReact(), shim2 = requireShim();
    function is(x2, y) {
      return x2 === y && (0 !== x2 || 1 / x2 === 1 / y) || x2 !== x2 && y !== y;
    }
    var objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore2 = shim2.useSyncExternalStore, useRef2 = React2.useRef, useEffect2 = React2.useEffect, useMemo2 = React2.useMemo, useDebugValue = React2.useDebugValue;
    withSelector_production.useSyncExternalStoreWithSelector = function(subscribe2, getSnapshot, getServerSnapshot, selector2, isEqual) {
      var instRef = useRef2(null);
      if (null === instRef.current) {
        var inst = { hasValue: false, value: null };
        instRef.current = inst;
      } else inst = instRef.current;
      instRef = useMemo2(
        function() {
          function memoizedSelector(nextSnapshot) {
            if (!hasMemo) {
              hasMemo = true;
              memoizedSnapshot = nextSnapshot;
              nextSnapshot = selector2(nextSnapshot);
              if (void 0 !== isEqual && inst.hasValue) {
                var currentSelection = inst.value;
                if (isEqual(currentSelection, nextSnapshot))
                  return memoizedSelection = currentSelection;
              }
              return memoizedSelection = nextSnapshot;
            }
            currentSelection = memoizedSelection;
            if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
            var nextSelection = selector2(nextSnapshot);
            if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
              return memoizedSnapshot = nextSnapshot, currentSelection;
            memoizedSnapshot = nextSnapshot;
            return memoizedSelection = nextSelection;
          }
          var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
          return [
            function() {
              return memoizedSelector(getSnapshot());
            },
            null === maybeGetServerSnapshot ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            }
          ];
        },
        [getSnapshot, getServerSnapshot, selector2, isEqual]
      );
      var value = useSyncExternalStore2(subscribe2, instRef[0], instRef[1]);
      useEffect2(
        function() {
          inst.hasValue = true;
          inst.value = value;
        },
        [value]
      );
      useDebugValue(value);
      return value;
    };
    return withSelector_production;
  }
  var hasRequiredWithSelector;
  function requireWithSelector() {
    if (hasRequiredWithSelector) return withSelector.exports;
    hasRequiredWithSelector = 1;
    {
      withSelector.exports = requireWithSelector_production();
    }
    return withSelector.exports;
  }
  var withSelectorExports = requireWithSelector();
  function useStore$1(store, selector2 = (d) => d) {
    const slice = withSelectorExports.useSyncExternalStoreWithSelector(
      store.subscribe,
      () => store.state,
      () => store.state,
      selector2,
      shallow
    );
    return slice;
  }
  function shallow(objA, objB) {
    if (Object.is(objA, objB)) {
      return true;
    }
    if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
      return false;
    }
    if (objA instanceof Map && objB instanceof Map) {
      if (objA.size !== objB.size) return false;
      for (const [k2, v] of objA) {
        if (!objB.has(k2) || !Object.is(v, objB.get(k2))) return false;
      }
      return true;
    }
    if (objA instanceof Set && objB instanceof Set) {
      if (objA.size !== objB.size) return false;
      for (const v of objA) {
        if (!objB.has(v)) return false;
      }
      return true;
    }
    if (objA instanceof Date && objB instanceof Date) {
      if (objA.getTime() !== objB.getTime()) return false;
      return true;
    }
    const keysA = Object.keys(objA);
    if (keysA.length !== Object.keys(objB).length) {
      return false;
    }
    for (let i2 = 0; i2 < keysA.length; i2++) {
      if (!Object.prototype.hasOwnProperty.call(objB, keysA[i2]) || !Object.is(objA[keysA[i2]], objB[keysA[i2]])) {
        return false;
      }
    }
    return true;
  }
  const routerContext = reactExports.createContext(null);
  function getRouterContext() {
    if (typeof document === "undefined") {
      return routerContext;
    }
    if (window.__TSR_ROUTER_CONTEXT__) {
      return window.__TSR_ROUTER_CONTEXT__;
    }
    window.__TSR_ROUTER_CONTEXT__ = routerContext;
    return routerContext;
  }
  function useRouter(opts) {
    const value = reactExports.useContext(getRouterContext());
    warning(
      !(((opts == null ? void 0 : opts.warn) ?? true) && !value)
    );
    return value;
  }
  function useRouterState(opts) {
    const contextRouter = useRouter({
      warn: (opts == null ? void 0 : opts.router) === void 0
    });
    const router2 = (opts == null ? void 0 : opts.router) || contextRouter;
    const previousResult = reactExports.useRef(void 0);
    return useStore$1(router2.__store, (state) => {
      if (opts == null ? void 0 : opts.select) {
        if (opts.structuralSharing ?? router2.options.defaultStructuralSharing) {
          const newSlice = replaceEqualDeep$1(
            previousResult.current,
            opts.select(state)
          );
          previousResult.current = newSlice;
          return newSlice;
        }
        return opts.select(state);
      }
      return state;
    });
  }
  const matchContext = reactExports.createContext(void 0);
  const dummyMatchContext = reactExports.createContext(
    void 0
  );
  function useMatch(opts) {
    const nearestMatchId = reactExports.useContext(
      opts.from ? dummyMatchContext : matchContext
    );
    const matchSelection = useRouterState({
      select: (state) => {
        const match = state.matches.find(
          (d) => opts.from ? opts.from === d.routeId : d.id === nearestMatchId
        );
        invariant$1(
          !((opts.shouldThrow ?? true) && !match),
          `Could not find ${opts.from ? `an active match from "${opts.from}"` : "a nearest match!"}`
        );
        if (match === void 0) {
          return void 0;
        }
        return opts.select ? opts.select(match) : match;
      },
      structuralSharing: opts.structuralSharing
    });
    return matchSelection;
  }
  function useLoaderData(opts) {
    return useMatch({
      from: opts.from,
      strict: opts.strict,
      structuralSharing: opts.structuralSharing,
      select: (s) => {
        return opts.select ? opts.select(s.loaderData) : s.loaderData;
      }
    });
  }
  function useLoaderDeps(opts) {
    const { select, ...rest } = opts;
    return useMatch({
      ...rest,
      select: (s) => {
        return select ? select(s.loaderDeps) : s.loaderDeps;
      }
    });
  }
  function useParams(opts) {
    return useMatch({
      from: opts.from,
      strict: opts.strict,
      shouldThrow: opts.shouldThrow,
      structuralSharing: opts.structuralSharing,
      select: (match) => {
        return opts.select ? opts.select(match.params) : match.params;
      }
    });
  }
  function useSearch(opts) {
    return useMatch({
      from: opts.from,
      strict: opts.strict,
      shouldThrow: opts.shouldThrow,
      structuralSharing: opts.structuralSharing,
      select: (match) => {
        return opts.select ? opts.select(match.search) : match.search;
      }
    });
  }
  function useNavigate(_defaultOpts) {
    const { navigate, state } = useRouter();
    const matchIndex = useMatch({
      strict: false,
      select: (match) => match.index
    });
    return reactExports.useCallback(
      (options) => {
        const from = options.from ?? (_defaultOpts == null ? void 0 : _defaultOpts.from) ?? state.matches[matchIndex].fullPath;
        return navigate({
          ...options,
          from
        });
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [_defaultOpts == null ? void 0 : _defaultOpts.from, navigate]
    );
  }
  var reactDomExports = requireReactDom();
  const reactDom = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
  const useLayoutEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
  function usePrevious$1(value) {
    const ref = reactExports.useRef({
      value,
      prev: null
    });
    const current = ref.current.value;
    if (value !== current) {
      ref.current = {
        value,
        prev: current
      };
    }
    return ref.current.prev;
  }
  function useIntersectionObserver(ref, callback, intersectionObserverOptions2 = {}, options = {}) {
    reactExports.useEffect(() => {
      if (!ref.current || options.disabled || typeof IntersectionObserver !== "function") {
        return;
      }
      const observer = new IntersectionObserver(([entry]) => {
        callback(entry);
      }, intersectionObserverOptions2);
      observer.observe(ref.current);
      return () => {
        observer.disconnect();
      };
    }, [callback, intersectionObserverOptions2, options.disabled, ref]);
  }
  function useForwardedRef(ref) {
    const innerRef = reactExports.useRef(null);
    reactExports.useImperativeHandle(ref, () => innerRef.current, []);
    return innerRef;
  }
  function useLinkProps(options, forwardedRef) {
    const router2 = useRouter();
    const [isTransitioning, setIsTransitioning] = reactExports.useState(false);
    const hasRenderFetched = reactExports.useRef(false);
    const innerRef = useForwardedRef(forwardedRef);
    const {
      // custom props
      activeProps,
      inactiveProps,
      activeOptions,
      to,
      preload: userPreload,
      preloadDelay: userPreloadDelay,
      hashScrollIntoView,
      replace: replace2,
      startTransition,
      resetScroll,
      viewTransition,
      // element props
      children,
      target,
      disabled,
      style,
      className,
      onClick,
      onFocus,
      onMouseEnter,
      onMouseLeave,
      onTouchStart,
      ignoreBlocker,
      // prevent these from being returned
      params: _params,
      search: _search,
      hash: _hash,
      state: _state,
      mask: _mask,
      reloadDocument: _reloadDocument,
      unsafeRelative: _unsafeRelative,
      from: _from,
      _fromLocation,
      ...propsSafeToSpread
    } = options;
    const type = reactExports.useMemo(() => {
      try {
        new URL(to);
        return "external";
      } catch {
      }
      return "internal";
    }, [to]);
    const currentSearch = useRouterState({
      select: (s) => s.location.search,
      structuralSharing: true
    });
    const from = useMatch({
      strict: false,
      select: (match) => options.from ?? match.fullPath
    });
    const next = reactExports.useMemo(
      () => router2.buildLocation({ ...options, from }),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [
        router2,
        currentSearch,
        options._fromLocation,
        from,
        options.hash,
        options.to,
        options.search,
        options.params,
        options.state,
        options.mask,
        options.unsafeRelative
      ]
    );
    const isExternal = type === "external";
    const preload = options.reloadDocument || isExternal ? false : userPreload ?? router2.options.defaultPreload;
    const preloadDelay = userPreloadDelay ?? router2.options.defaultPreloadDelay ?? 0;
    const isActive = useRouterState({
      select: (s) => {
        if (isExternal) return false;
        if (activeOptions == null ? void 0 : activeOptions.exact) {
          const testExact = exactPathTest(
            s.location.pathname,
            next.pathname,
            router2.basepath
          );
          if (!testExact) {
            return false;
          }
        } else {
          const currentPathSplit = removeTrailingSlash(
            s.location.pathname,
            router2.basepath
          );
          const nextPathSplit = removeTrailingSlash(
            next.pathname,
            router2.basepath
          );
          const pathIsFuzzyEqual = currentPathSplit.startsWith(nextPathSplit) && (currentPathSplit.length === nextPathSplit.length || currentPathSplit[nextPathSplit.length] === "/");
          if (!pathIsFuzzyEqual) {
            return false;
          }
        }
        if ((activeOptions == null ? void 0 : activeOptions.includeSearch) ?? true) {
          const searchTest = deepEqual$1(s.location.search, next.search, {
            partial: !(activeOptions == null ? void 0 : activeOptions.exact),
            ignoreUndefined: !(activeOptions == null ? void 0 : activeOptions.explicitUndefined)
          });
          if (!searchTest) {
            return false;
          }
        }
        if (activeOptions == null ? void 0 : activeOptions.includeHash) {
          return s.location.hash === next.hash;
        }
        return true;
      }
    });
    const doPreload = reactExports.useCallback(
      () => {
        router2.preloadRoute({ ...options, from }).catch((err2) => {
          console.warn(err2);
          console.warn(preloadWarning);
        });
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [
        router2,
        options.to,
        options._fromLocation,
        from,
        options.search,
        options.hash,
        options.params,
        options.state,
        options.mask,
        options.unsafeRelative,
        options.hashScrollIntoView,
        options.href,
        options.ignoreBlocker,
        options.reloadDocument,
        options.replace,
        options.resetScroll,
        options.viewTransition
      ]
    );
    const preloadViewportIoCallback = reactExports.useCallback(
      (entry) => {
        if (entry == null ? void 0 : entry.isIntersecting) {
          doPreload();
        }
      },
      [doPreload]
    );
    useIntersectionObserver(
      innerRef,
      preloadViewportIoCallback,
      intersectionObserverOptions,
      { disabled: !!disabled || !(preload === "viewport") }
    );
    reactExports.useEffect(() => {
      if (hasRenderFetched.current) {
        return;
      }
      if (!disabled && preload === "render") {
        doPreload();
        hasRenderFetched.current = true;
      }
    }, [disabled, doPreload, preload]);
    if (isExternal) {
      return {
        ...propsSafeToSpread,
        ref: innerRef,
        type,
        href: to,
        ...children && { children },
        ...target && { target },
        ...disabled && { disabled },
        ...style && { style },
        ...className && { className },
        ...onClick && { onClick },
        ...onFocus && { onFocus },
        ...onMouseEnter && { onMouseEnter },
        ...onMouseLeave && { onMouseLeave },
        ...onTouchStart && { onTouchStart }
      };
    }
    const handleClick = (e) => {
      if (!disabled && !isCtrlEvent(e) && !e.defaultPrevented && (!target || target === "_self") && e.button === 0) {
        e.preventDefault();
        reactDomExports.flushSync(() => {
          setIsTransitioning(true);
        });
        const unsub = router2.subscribe("onResolved", () => {
          unsub();
          setIsTransitioning(false);
        });
        router2.navigate({
          ...options,
          from,
          replace: replace2,
          resetScroll,
          hashScrollIntoView,
          startTransition,
          viewTransition,
          ignoreBlocker
        });
      }
    };
    const handleFocus = (_2) => {
      if (disabled) return;
      if (preload) {
        doPreload();
      }
    };
    const handleTouchStart = handleFocus;
    const handleEnter = (e) => {
      if (disabled || !preload) return;
      if (!preloadDelay) {
        doPreload();
      } else {
        const eventTarget = e.target;
        if (timeoutMap.has(eventTarget)) {
          return;
        }
        const id = setTimeout(() => {
          timeoutMap.delete(eventTarget);
          doPreload();
        }, preloadDelay);
        timeoutMap.set(eventTarget, id);
      }
    };
    const handleLeave = (e) => {
      if (disabled || !preload || !preloadDelay) return;
      const eventTarget = e.target;
      const id = timeoutMap.get(eventTarget);
      if (id) {
        clearTimeout(id);
        timeoutMap.delete(eventTarget);
      }
    };
    const resolvedActiveProps = isActive ? functionalUpdate$1(activeProps, {}) ?? STATIC_ACTIVE_OBJECT : STATIC_EMPTY_OBJECT;
    const resolvedInactiveProps = isActive ? STATIC_EMPTY_OBJECT : functionalUpdate$1(inactiveProps, {}) ?? STATIC_EMPTY_OBJECT;
    const resolvedClassName = [
      className,
      resolvedActiveProps.className,
      resolvedInactiveProps.className
    ].filter(Boolean).join(" ");
    const resolvedStyle = (style || resolvedActiveProps.style || resolvedInactiveProps.style) && {
      ...style,
      ...resolvedActiveProps.style,
      ...resolvedInactiveProps.style
    };
    return {
      ...propsSafeToSpread,
      ...resolvedActiveProps,
      ...resolvedInactiveProps,
      href: disabled ? void 0 : next.maskedLocation ? router2.history.createHref(next.maskedLocation.href) : router2.history.createHref(next.href),
      ref: innerRef,
      onClick: composeHandlers([onClick, handleClick]),
      onFocus: composeHandlers([onFocus, handleFocus]),
      onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),
      onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),
      onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),
      disabled: !!disabled,
      target,
      ...resolvedStyle && { style: resolvedStyle },
      ...resolvedClassName && { className: resolvedClassName },
      ...disabled && STATIC_DISABLED_PROPS,
      ...isActive && STATIC_ACTIVE_PROPS,
      ...isTransitioning && STATIC_TRANSITIONING_PROPS
    };
  }
  const STATIC_EMPTY_OBJECT = {};
  const STATIC_ACTIVE_OBJECT = { className: "active" };
  const STATIC_DISABLED_PROPS = { role: "link", "aria-disabled": true };
  const STATIC_ACTIVE_PROPS = { "data-status": "active", "aria-current": "page" };
  const STATIC_TRANSITIONING_PROPS = { "data-transitioning": "transitioning" };
  const timeoutMap = /* @__PURE__ */ new WeakMap();
  const intersectionObserverOptions = {
    rootMargin: "100px"
  };
  const composeHandlers = (handlers2) => (e) => {
    handlers2.filter(Boolean).forEach((handler) => {
      if (e.defaultPrevented) return;
      handler(e);
    });
  };
  const Link$1 = reactExports.forwardRef(
    (props, ref) => {
      const { _asChild, ...rest } = props;
      const {
        type: _type,
        ref: innerRef,
        ...linkProps
      } = useLinkProps(rest, ref);
      const children = typeof rest.children === "function" ? rest.children({
        isActive: linkProps["data-status"] === "active"
      }) : rest.children;
      if (_asChild === void 0) {
        delete linkProps.disabled;
      }
      return reactExports.createElement(
        _asChild ? _asChild : "a",
        {
          ...linkProps,
          ref: innerRef
        },
        children
      );
    }
  );
  function isCtrlEvent(e) {
    return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
  }
  let Route$e = class Route extends BaseRoute {
    /**
     * @deprecated Use the `createRoute` function instead.
     */
    constructor(options) {
      super(options);
      this.useMatch = (opts) => {
        return useMatch({
          select: opts == null ? void 0 : opts.select,
          from: this.id,
          structuralSharing: opts == null ? void 0 : opts.structuralSharing
        });
      };
      this.useRouteContext = (opts) => {
        return useMatch({
          ...opts,
          from: this.id,
          select: (d) => (opts == null ? void 0 : opts.select) ? opts.select(d.context) : d.context
        });
      };
      this.useSearch = (opts) => {
        return useSearch({
          select: opts == null ? void 0 : opts.select,
          structuralSharing: opts == null ? void 0 : opts.structuralSharing,
          from: this.id
        });
      };
      this.useParams = (opts) => {
        return useParams({
          select: opts == null ? void 0 : opts.select,
          structuralSharing: opts == null ? void 0 : opts.structuralSharing,
          from: this.id
        });
      };
      this.useLoaderDeps = (opts) => {
        return useLoaderDeps({ ...opts, from: this.id });
      };
      this.useLoaderData = (opts) => {
        return useLoaderData({ ...opts, from: this.id });
      };
      this.useNavigate = () => {
        return useNavigate({ from: this.fullPath });
      };
      this.Link = React.forwardRef(
        (props, ref) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Link$1, { ref, from: this.fullPath, ...props });
        }
      );
      this.$$typeof = Symbol.for("react.memo");
    }
  };
  function createRoute(options) {
    return new Route$e(options);
  }
  function createRootRouteWithContext() {
    return (options) => {
      return createRootRoute(options);
    };
  }
  class RootRoute extends BaseRootRoute {
    /**
     * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.
     */
    constructor(options) {
      super(options);
      this.useMatch = (opts) => {
        return useMatch({
          select: opts == null ? void 0 : opts.select,
          from: this.id,
          structuralSharing: opts == null ? void 0 : opts.structuralSharing
        });
      };
      this.useRouteContext = (opts) => {
        return useMatch({
          ...opts,
          from: this.id,
          select: (d) => (opts == null ? void 0 : opts.select) ? opts.select(d.context) : d.context
        });
      };
      this.useSearch = (opts) => {
        return useSearch({
          select: opts == null ? void 0 : opts.select,
          structuralSharing: opts == null ? void 0 : opts.structuralSharing,
          from: this.id
        });
      };
      this.useParams = (opts) => {
        return useParams({
          select: opts == null ? void 0 : opts.select,
          structuralSharing: opts == null ? void 0 : opts.structuralSharing,
          from: this.id
        });
      };
      this.useLoaderDeps = (opts) => {
        return useLoaderDeps({ ...opts, from: this.id });
      };
      this.useLoaderData = (opts) => {
        return useLoaderData({ ...opts, from: this.id });
      };
      this.useNavigate = () => {
        return useNavigate({ from: this.fullPath });
      };
      this.Link = React.forwardRef(
        (props, ref) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Link$1, { ref, from: this.fullPath, ...props });
        }
      );
      this.$$typeof = Symbol.for("react.memo");
    }
  }
  function createRootRoute(options) {
    return new RootRoute(options);
  }
  function createFileRoute(path) {
    if (typeof path === "object") {
      return new FileRoute(path, {
        silent: true
      }).createRoute(path);
    }
    return new FileRoute(path, {
      silent: true
    }).createRoute;
  }
  class FileRoute {
    constructor(path, _opts) {
      this.path = path;
      this.createRoute = (options) => {
        warning(
          this.silent
        );
        const route = createRoute(options);
        route.isRoot = false;
        return route;
      };
      this.silent = _opts == null ? void 0 : _opts.silent;
    }
  }
  class LazyRoute {
    constructor(opts) {
      this.useMatch = (opts2) => {
        return useMatch({
          select: opts2 == null ? void 0 : opts2.select,
          from: this.options.id,
          structuralSharing: opts2 == null ? void 0 : opts2.structuralSharing
        });
      };
      this.useRouteContext = (opts2) => {
        return useMatch({
          from: this.options.id,
          select: (d) => (opts2 == null ? void 0 : opts2.select) ? opts2.select(d.context) : d.context
        });
      };
      this.useSearch = (opts2) => {
        return useSearch({
          select: opts2 == null ? void 0 : opts2.select,
          structuralSharing: opts2 == null ? void 0 : opts2.structuralSharing,
          from: this.options.id
        });
      };
      this.useParams = (opts2) => {
        return useParams({
          select: opts2 == null ? void 0 : opts2.select,
          structuralSharing: opts2 == null ? void 0 : opts2.structuralSharing,
          from: this.options.id
        });
      };
      this.useLoaderDeps = (opts2) => {
        return useLoaderDeps({ ...opts2, from: this.options.id });
      };
      this.useLoaderData = (opts2) => {
        return useLoaderData({ ...opts2, from: this.options.id });
      };
      this.useNavigate = () => {
        const router2 = useRouter();
        return useNavigate({ from: router2.routesById[this.options.id].fullPath });
      };
      this.options = opts;
      this.$$typeof = Symbol.for("react.memo");
    }
  }
  function createLazyFileRoute(id) {
    if (typeof id === "object") {
      return new LazyRoute(id);
    }
    return (opts) => new LazyRoute({ id, ...opts });
  }
  function Transitioner() {
    const router2 = useRouter();
    const mountLoadForRouter = reactExports.useRef({ router: router2, mounted: false });
    const [isTransitioning, setIsTransitioning] = reactExports.useState(false);
    const { hasPendingMatches, isLoading } = useRouterState({
      select: (s) => ({
        isLoading: s.isLoading,
        hasPendingMatches: s.matches.some((d) => d.status === "pending")
      }),
      structuralSharing: true
    });
    const previousIsLoading = usePrevious$1(isLoading);
    const isAnyPending = isLoading || isTransitioning || hasPendingMatches;
    const previousIsAnyPending = usePrevious$1(isAnyPending);
    const isPagePending = isLoading || hasPendingMatches;
    const previousIsPagePending = usePrevious$1(isPagePending);
    router2.startTransition = (fn) => {
      setIsTransitioning(true);
      reactExports.startTransition(() => {
        fn();
        setIsTransitioning(false);
      });
    };
    reactExports.useEffect(() => {
      const unsub = router2.history.subscribe(router2.load);
      const nextLocation = router2.buildLocation({
        to: router2.latestLocation.pathname,
        search: true,
        params: true,
        hash: true,
        state: true,
        _includeValidateSearch: true
      });
      if (trimPathRight(router2.latestLocation.href) !== trimPathRight(nextLocation.href)) {
        router2.commitLocation({ ...nextLocation, replace: true });
      }
      return () => {
        unsub();
      };
    }, [router2, router2.history]);
    useLayoutEffect(() => {
      if (
        // if we are hydrating from SSR, loading is triggered in ssr-client
        typeof window !== "undefined" && router2.ssr || mountLoadForRouter.current.router === router2 && mountLoadForRouter.current.mounted
      ) {
        return;
      }
      mountLoadForRouter.current = { router: router2, mounted: true };
      const tryLoad = async () => {
        try {
          await router2.load();
        } catch (err2) {
          console.error(err2);
        }
      };
      tryLoad();
    }, [router2]);
    useLayoutEffect(() => {
      if (previousIsLoading && !isLoading) {
        router2.emit({
          type: "onLoad",
          // When the new URL has committed, when the new matches have been loaded into state.matches
          ...getLocationChangeInfo(router2.state)
        });
      }
    }, [previousIsLoading, router2, isLoading]);
    useLayoutEffect(() => {
      if (previousIsPagePending && !isPagePending) {
        router2.emit({
          type: "onBeforeRouteMount",
          ...getLocationChangeInfo(router2.state)
        });
      }
    }, [isPagePending, previousIsPagePending, router2]);
    useLayoutEffect(() => {
      if (previousIsAnyPending && !isAnyPending) {
        router2.emit({
          type: "onResolved",
          ...getLocationChangeInfo(router2.state)
        });
        router2.__store.setState((s) => ({
          ...s,
          status: "idle",
          resolvedLocation: s.location
        }));
        handleHashScroll(router2);
      }
    }, [isAnyPending, previousIsAnyPending, router2]);
    return null;
  }
  function CatchNotFound(props) {
    const resetKey = useRouterState({
      select: (s) => `not-found-${s.location.pathname}-${s.status}`
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      CatchBoundary,
      {
        getResetKey: () => resetKey,
        onCatch: (error, errorInfo) => {
          var _a2;
          if (isNotFound(error)) {
            (_a2 = props.onCatch) == null ? void 0 : _a2.call(props, error, errorInfo);
          } else {
            throw error;
          }
        },
        errorComponent: ({ error }) => {
          var _a2;
          if (isNotFound(error)) {
            return (_a2 = props.fallback) == null ? void 0 : _a2.call(props, error);
          } else {
            throw error;
          }
        },
        children: props.children
      }
    );
  }
  function DefaultGlobalNotFound() {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Not Found" });
  }
  function SafeFragment(props) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: props.children });
  }
  function renderRouteNotFound(router2, route, data) {
    if (!route.options.notFoundComponent) {
      if (router2.options.defaultNotFoundComponent) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(router2.options.defaultNotFoundComponent, { data });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultGlobalNotFound, {});
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(route.options.notFoundComponent, { data });
  }
  function ScriptOnce({
    children
  }) {
    if (typeof document !== "undefined") {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "script",
      {
        className: "$tsr",
        dangerouslySetInnerHTML: {
          __html: [children].filter(Boolean).join("\n")
        }
      }
    );
  }
  function ScrollRestoration() {
    const router2 = useRouter();
    const getKey = router2.options.getScrollRestorationKey || defaultGetScrollRestorationKey;
    const userKey = getKey(router2.latestLocation);
    const resolvedKey = userKey !== defaultGetScrollRestorationKey(router2.latestLocation) ? userKey : null;
    if (!router2.isScrollRestoring || !router2.isServer) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScriptOnce,
      {
        children: `(${restoreScroll.toString()})(${JSON.stringify(storageKey)},${JSON.stringify(resolvedKey)}, undefined, true)`
      }
    );
  }
  const Match = reactExports.memo(function MatchImpl({
    matchId
  }) {
    var _a2, _b2;
    const router2 = useRouter();
    const matchState = useRouterState({
      select: (s) => {
        const match = s.matches.find((d) => d.id === matchId);
        invariant$1(
          match
        );
        return pick(match, ["routeId", "ssr", "_displayPending"]);
      },
      structuralSharing: true
    });
    const route = router2.routesById[matchState.routeId];
    const PendingComponent = route.options.pendingComponent ?? router2.options.defaultPendingComponent;
    const pendingElement = PendingComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(PendingComponent, {}) : null;
    const routeErrorComponent = route.options.errorComponent ?? router2.options.defaultErrorComponent;
    const routeOnCatch = route.options.onCatch ?? router2.options.defaultOnCatch;
    const routeNotFoundComponent = route.isRoot ? (
      // If it's the root route, use the globalNotFound option, with fallback to the notFoundRoute's component
      route.options.notFoundComponent ?? ((_a2 = router2.options.notFoundRoute) == null ? void 0 : _a2.options.component)
    ) : route.options.notFoundComponent;
    const resolvedNoSsr = matchState.ssr === false || matchState.ssr === "data-only";
    const ResolvedSuspenseBoundary = (
      // If we're on the root route, allow forcefully wrapping in suspense
      (!route.isRoot || route.options.wrapInSuspense || resolvedNoSsr) && (route.options.wrapInSuspense ?? PendingComponent ?? (((_b2 = route.options.errorComponent) == null ? void 0 : _b2.preload) || resolvedNoSsr)) ? reactExports.Suspense : SafeFragment
    );
    const ResolvedCatchBoundary = routeErrorComponent ? CatchBoundary : SafeFragment;
    const ResolvedNotFoundBoundary = routeNotFoundComponent ? CatchNotFound : SafeFragment;
    const resetKey = useRouterState({
      select: (s) => s.loadedAt
    });
    const parentRouteId = useRouterState({
      select: (s) => {
        var _a22;
        const index = s.matches.findIndex((d) => d.id === matchId);
        return (_a22 = s.matches[index - 1]) == null ? void 0 : _a22.routeId;
      }
    });
    const ShellComponent = route.isRoot ? route.options.shellComponent ?? SafeFragment : SafeFragment;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ShellComponent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(matchContext.Provider, { value: matchId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResolvedSuspenseBoundary, { fallback: pendingElement, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        ResolvedCatchBoundary,
        {
          getResetKey: () => resetKey,
          errorComponent: routeErrorComponent || ErrorComponent,
          onCatch: (error, errorInfo) => {
            if (isNotFound(error)) throw error;
            routeOnCatch == null ? void 0 : routeOnCatch(error, errorInfo);
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            ResolvedNotFoundBoundary,
            {
              fallback: (error) => {
                if (!routeNotFoundComponent || error.routeId && error.routeId !== matchState.routeId || !error.routeId && !route.isRoot)
                  throw error;
                return reactExports.createElement(routeNotFoundComponent, error);
              },
              children: resolvedNoSsr || matchState._displayPending ? /* @__PURE__ */ jsxRuntimeExports.jsx(ClientOnly, { fallback: pendingElement, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MatchInner, { matchId }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(MatchInner, { matchId })
            }
          )
        }
      ) }) }),
      parentRouteId === rootRouteId && router2.options.scrollRestoration ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(OnRendered, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollRestoration, {})
      ] }) : null
    ] });
  });
  function OnRendered() {
    const router2 = useRouter();
    const prevLocationRef = reactExports.useRef(
      void 0
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "script",
      {
        suppressHydrationWarning: true,
        ref: (el) => {
          if (el && (prevLocationRef.current === void 0 || prevLocationRef.current.href !== router2.latestLocation.href)) {
            router2.emit({
              type: "onRendered",
              ...getLocationChangeInfo(router2.state)
            });
            prevLocationRef.current = router2.latestLocation;
          }
        }
      },
      router2.latestLocation.state.__TSR_key
    );
  }
  const MatchInner = reactExports.memo(function MatchInnerImpl({
    matchId
  }) {
    var _a2, _b2, _c2, _d2, _e2;
    const router2 = useRouter();
    const { match, key: key2, routeId } = useRouterState({
      select: (s) => {
        const matchIndex = s.matches.findIndex((d) => d.id === matchId);
        const match2 = s.matches[matchIndex];
        const routeId2 = match2.routeId;
        const remountFn = router2.routesById[routeId2].options.remountDeps ?? router2.options.defaultRemountDeps;
        const remountDeps = remountFn == null ? void 0 : remountFn({
          routeId: routeId2,
          loaderDeps: match2.loaderDeps,
          params: match2._strictParams,
          search: match2._strictSearch
        });
        const key22 = remountDeps ? JSON.stringify(remountDeps) : void 0;
        return {
          key: key22,
          routeId: routeId2,
          match: pick(match2, [
            "id",
            "status",
            "error",
            "_forcePending",
            "_displayPending"
          ])
        };
      },
      structuralSharing: true
    });
    const route = router2.routesById[routeId];
    const out = reactExports.useMemo(() => {
      const Comp = route.options.component ?? router2.options.defaultComponent;
      if (Comp) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, {}, key2);
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Outlet, {});
    }, [key2, route.options.component, router2.options.defaultComponent]);
    if (match._displayPending) {
      throw (_a2 = router2.getMatch(match.id)) == null ? void 0 : _a2.displayPendingPromise;
    }
    if (match._forcePending) {
      throw (_b2 = router2.getMatch(match.id)) == null ? void 0 : _b2.minPendingPromise;
    }
    if (match.status === "pending") {
      const pendingMinMs = route.options.pendingMinMs ?? router2.options.defaultPendingMinMs;
      if (pendingMinMs && !((_c2 = router2.getMatch(match.id)) == null ? void 0 : _c2.minPendingPromise)) {
        if (!router2.isServer) {
          const minPendingPromise = createControlledPromise();
          Promise.resolve().then(() => {
            router2.updateMatch(match.id, (prev) => ({
              ...prev,
              minPendingPromise
            }));
          });
          setTimeout(() => {
            minPendingPromise.resolve();
            router2.updateMatch(match.id, (prev) => ({
              ...prev,
              minPendingPromise: void 0
            }));
          }, pendingMinMs);
        }
      }
      throw (_d2 = router2.getMatch(match.id)) == null ? void 0 : _d2.loadPromise;
    }
    if (match.status === "notFound") {
      invariant$1(isNotFound(match.error));
      return renderRouteNotFound(router2, route, match.error);
    }
    if (match.status === "redirected") {
      invariant$1(isRedirect(match.error));
      throw (_e2 = router2.getMatch(match.id)) == null ? void 0 : _e2.loadPromise;
    }
    if (match.status === "error") {
      if (router2.isServer) {
        const RouteErrorComponent = (route.options.errorComponent ?? router2.options.defaultErrorComponent) || ErrorComponent;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          RouteErrorComponent,
          {
            error: match.error,
            reset: void 0,
            info: {
              componentStack: ""
            }
          }
        );
      }
      throw match.error;
    }
    return out;
  });
  const Outlet = reactExports.memo(function OutletImpl() {
    const router2 = useRouter();
    const matchId = reactExports.useContext(matchContext);
    const routeId = useRouterState({
      select: (s) => {
        var _a2;
        return (_a2 = s.matches.find((d) => d.id === matchId)) == null ? void 0 : _a2.routeId;
      }
    });
    const route = router2.routesById[routeId];
    const parentGlobalNotFound = useRouterState({
      select: (s) => {
        const matches2 = s.matches;
        const parentMatch = matches2.find((d) => d.id === matchId);
        invariant$1(
          parentMatch
        );
        return parentMatch.globalNotFound;
      }
    });
    const childMatchId = useRouterState({
      select: (s) => {
        var _a2;
        const matches2 = s.matches;
        const index = matches2.findIndex((d) => d.id === matchId);
        return (_a2 = matches2[index + 1]) == null ? void 0 : _a2.id;
      }
    });
    const pendingElement = router2.options.defaultPendingComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(router2.options.defaultPendingComponent, {}) : null;
    if (parentGlobalNotFound) {
      return renderRouteNotFound(router2, route, void 0);
    }
    if (!childMatchId) {
      return null;
    }
    const nextMatch = /* @__PURE__ */ jsxRuntimeExports.jsx(Match, { matchId: childMatchId });
    if (matchId === rootRouteId) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: pendingElement, children: nextMatch });
    }
    return nextMatch;
  });
  function Matches() {
    const router2 = useRouter();
    const pendingElement = router2.options.defaultPendingComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(router2.options.defaultPendingComponent, {}) : null;
    const ResolvedSuspense = router2.isServer || typeof document !== "undefined" && router2.ssr ? SafeFragment : reactExports.Suspense;
    const inner = /* @__PURE__ */ jsxRuntimeExports.jsxs(ResolvedSuspense, { fallback: pendingElement, children: [
      !router2.isServer && /* @__PURE__ */ jsxRuntimeExports.jsx(Transitioner, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(MatchesInner, {})
    ] });
    return router2.options.InnerWrap ? /* @__PURE__ */ jsxRuntimeExports.jsx(router2.options.InnerWrap, { children: inner }) : inner;
  }
  function MatchesInner() {
    const matchId = useRouterState({
      select: (s) => {
        var _a2;
        return (_a2 = s.matches[0]) == null ? void 0 : _a2.id;
      }
    });
    const resetKey = useRouterState({
      select: (s) => s.loadedAt
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(matchContext.Provider, { value: matchId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      CatchBoundary,
      {
        getResetKey: () => resetKey,
        errorComponent: ErrorComponent,
        onCatch: (error) => {
          warning(false, error.message || error.toString());
        },
        children: matchId ? /* @__PURE__ */ jsxRuntimeExports.jsx(Match, { matchId }) : null
      }
    ) });
  }
  function useMatches(opts) {
    return useRouterState({
      select: (state) => {
        const matches2 = state.matches;
        return matches2;
      },
      structuralSharing: void 0
    });
  }
  const createRouter = (options) => {
    return new Router(options);
  };
  class Router extends RouterCore {
    constructor(options) {
      super(options);
    }
  }
  if (typeof globalThis !== "undefined") {
    globalThis.createFileRoute = createFileRoute;
    globalThis.createLazyFileRoute = createLazyFileRoute;
  } else if (typeof window !== "undefined") {
    window.createFileRoute = createFileRoute;
    window.createFileRoute = createLazyFileRoute;
  }
  function RouterContextProvider({
    router: router2,
    children,
    ...rest
  }) {
    if (Object.keys(rest).length > 0) {
      router2.update({
        ...router2.options,
        ...rest,
        context: {
          ...router2.options.context,
          ...rest.context
        }
      });
    }
    const routerContext2 = getRouterContext();
    const provider = /* @__PURE__ */ jsxRuntimeExports.jsx(routerContext2.Provider, { value: router2, children });
    if (router2.options.Wrap) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(router2.options.Wrap, { children: provider });
    }
    return provider;
  }
  function RouterProvider({ router: router2, ...rest }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RouterContextProvider, { router: router2, ...rest, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Matches, {}) });
  }
  class Subscribable {
    constructor() {
      this.listeners = /* @__PURE__ */ new Set();
      this.subscribe = this.subscribe.bind(this);
    }
    subscribe(listener) {
      const identity = {
        listener
      };
      this.listeners.add(identity);
      this.onSubscribe();
      return () => {
        this.listeners.delete(identity);
        this.onUnsubscribe();
      };
    }
    hasListeners() {
      return this.listeners.size > 0;
    }
    onSubscribe() {
    }
    onUnsubscribe() {
    }
  }
  const isServer = typeof window === "undefined" || "Deno" in window;
  function noop$2() {
    return void 0;
  }
  function functionalUpdate(updater, input) {
    return typeof updater === "function" ? updater(input) : updater;
  }
  function isValidTimeout(value) {
    return typeof value === "number" && value >= 0 && value !== Infinity;
  }
  function timeUntilStale(updatedAt, staleTime) {
    return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
  }
  function parseQueryArgs(arg1, arg2, arg3) {
    if (!isQueryKey(arg1)) {
      return arg1;
    }
    if (typeof arg2 === "function") {
      return {
        ...arg3,
        queryKey: arg1,
        queryFn: arg2
      };
    }
    return {
      ...arg2,
      queryKey: arg1
    };
  }
  function parseMutationArgs(arg1, arg2, arg3) {
    if (isQueryKey(arg1)) {
      if (typeof arg2 === "function") {
        return {
          ...arg3,
          mutationKey: arg1,
          mutationFn: arg2
        };
      }
      return {
        ...arg2,
        mutationKey: arg1
      };
    }
    if (typeof arg1 === "function") {
      return {
        ...arg2,
        mutationFn: arg1
      };
    }
    return {
      ...arg1
    };
  }
  function parseFilterArgs(arg1, arg2, arg3) {
    return isQueryKey(arg1) ? [{
      ...arg2,
      queryKey: arg1
    }, arg3] : [arg1 || {}, arg2];
  }
  function matchQuery(filters, query) {
    const {
      type = "all",
      exact,
      fetchStatus,
      predicate,
      queryKey,
      stale
    } = filters;
    if (isQueryKey(queryKey)) {
      if (exact) {
        if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
          return false;
        }
      } else if (!partialMatchKey(query.queryKey, queryKey)) {
        return false;
      }
    }
    if (type !== "all") {
      const isActive = query.isActive();
      if (type === "active" && !isActive) {
        return false;
      }
      if (type === "inactive" && isActive) {
        return false;
      }
    }
    if (typeof stale === "boolean" && query.isStale() !== stale) {
      return false;
    }
    if (typeof fetchStatus !== "undefined" && fetchStatus !== query.state.fetchStatus) {
      return false;
    }
    if (predicate && !predicate(query)) {
      return false;
    }
    return true;
  }
  function matchMutation(filters, mutation) {
    const {
      exact,
      fetching,
      predicate,
      mutationKey
    } = filters;
    if (isQueryKey(mutationKey)) {
      if (!mutation.options.mutationKey) {
        return false;
      }
      if (exact) {
        if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {
          return false;
        }
      } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
        return false;
      }
    }
    if (typeof fetching === "boolean" && mutation.state.status === "loading" !== fetching) {
      return false;
    }
    if (predicate && !predicate(mutation)) {
      return false;
    }
    return true;
  }
  function hashQueryKeyByOptions(queryKey, options) {
    const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;
    return hashFn(queryKey);
  }
  function hashQueryKey(queryKey) {
    return JSON.stringify(queryKey, (_2, val) => isPlainObject$2(val) ? Object.keys(val).sort().reduce((result, key2) => {
      result[key2] = val[key2];
      return result;
    }, {}) : val);
  }
  function partialMatchKey(a, b2) {
    return partialDeepEqual(a, b2);
  }
  function partialDeepEqual(a, b2) {
    if (a === b2) {
      return true;
    }
    if (typeof a !== typeof b2) {
      return false;
    }
    if (a && b2 && typeof a === "object" && typeof b2 === "object") {
      return !Object.keys(b2).some((key2) => !partialDeepEqual(a[key2], b2[key2]));
    }
    return false;
  }
  function replaceEqualDeep(a, b2) {
    if (a === b2) {
      return a;
    }
    const array = isPlainArray(a) && isPlainArray(b2);
    if (array || isPlainObject$2(a) && isPlainObject$2(b2)) {
      const aSize = array ? a.length : Object.keys(a).length;
      const bItems = array ? b2 : Object.keys(b2);
      const bSize = bItems.length;
      const copy2 = array ? [] : {};
      let equalItems = 0;
      for (let i2 = 0; i2 < bSize; i2++) {
        const key2 = array ? i2 : bItems[i2];
        copy2[key2] = replaceEqualDeep(a[key2], b2[key2]);
        if (copy2[key2] === a[key2]) {
          equalItems++;
        }
      }
      return aSize === bSize && equalItems === aSize ? a : copy2;
    }
    return b2;
  }
  function shallowEqualObjects(a, b2) {
    if (a && !b2 || b2 && !a) {
      return false;
    }
    for (const key2 in a) {
      if (a[key2] !== b2[key2]) {
        return false;
      }
    }
    return true;
  }
  function isPlainArray(value) {
    return Array.isArray(value) && value.length === Object.keys(value).length;
  }
  function isPlainObject$2(o) {
    if (!hasObjectPrototype(o)) {
      return false;
    }
    const ctor = o.constructor;
    if (typeof ctor === "undefined") {
      return true;
    }
    const prot = ctor.prototype;
    if (!hasObjectPrototype(prot)) {
      return false;
    }
    if (!prot.hasOwnProperty("isPrototypeOf")) {
      return false;
    }
    return true;
  }
  function hasObjectPrototype(o) {
    return Object.prototype.toString.call(o) === "[object Object]";
  }
  function isQueryKey(value) {
    return Array.isArray(value);
  }
  function sleep(timeout) {
    return new Promise((resolve) => {
      setTimeout(resolve, timeout);
    });
  }
  function scheduleMicrotask(callback) {
    sleep(0).then(callback);
  }
  function getAbortController() {
    if (typeof AbortController === "function") {
      return new AbortController();
    }
    return;
  }
  function replaceData(prevData, data, options) {
    if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {
      return prevData;
    } else if (typeof options.structuralSharing === "function") {
      return options.structuralSharing(prevData, data);
    } else if (options.structuralSharing !== false) {
      return replaceEqualDeep(prevData, data);
    }
    return data;
  }
  class FocusManager extends Subscribable {
    constructor() {
      super();
      this.setup = (onFocus) => {
        if (!isServer && window.addEventListener) {
          const listener = () => onFocus();
          window.addEventListener("visibilitychange", listener, false);
          window.addEventListener("focus", listener, false);
          return () => {
            window.removeEventListener("visibilitychange", listener);
            window.removeEventListener("focus", listener);
          };
        }
        return;
      };
    }
    onSubscribe() {
      if (!this.cleanup) {
        this.setEventListener(this.setup);
      }
    }
    onUnsubscribe() {
      if (!this.hasListeners()) {
        var _this$cleanup;
        (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
        this.cleanup = void 0;
      }
    }
    setEventListener(setup) {
      var _this$cleanup2;
      this.setup = setup;
      (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
      this.cleanup = setup((focused) => {
        if (typeof focused === "boolean") {
          this.setFocused(focused);
        } else {
          this.onFocus();
        }
      });
    }
    setFocused(focused) {
      const changed = this.focused !== focused;
      if (changed) {
        this.focused = focused;
        this.onFocus();
      }
    }
    onFocus() {
      this.listeners.forEach(({
        listener
      }) => {
        listener();
      });
    }
    isFocused() {
      if (typeof this.focused === "boolean") {
        return this.focused;
      }
      if (typeof document === "undefined") {
        return true;
      }
      return [void 0, "visible", "prerender"].includes(document.visibilityState);
    }
  }
  const focusManager = new FocusManager();
  const onlineEvents = ["online", "offline"];
  class OnlineManager extends Subscribable {
    constructor() {
      super();
      this.setup = (onOnline) => {
        if (!isServer && window.addEventListener) {
          const listener = () => onOnline();
          onlineEvents.forEach((event) => {
            window.addEventListener(event, listener, false);
          });
          return () => {
            onlineEvents.forEach((event) => {
              window.removeEventListener(event, listener);
            });
          };
        }
        return;
      };
    }
    onSubscribe() {
      if (!this.cleanup) {
        this.setEventListener(this.setup);
      }
    }
    onUnsubscribe() {
      if (!this.hasListeners()) {
        var _this$cleanup;
        (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
        this.cleanup = void 0;
      }
    }
    setEventListener(setup) {
      var _this$cleanup2;
      this.setup = setup;
      (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
      this.cleanup = setup((online) => {
        if (typeof online === "boolean") {
          this.setOnline(online);
        } else {
          this.onOnline();
        }
      });
    }
    setOnline(online) {
      const changed = this.online !== online;
      if (changed) {
        this.online = online;
        this.onOnline();
      }
    }
    onOnline() {
      this.listeners.forEach(({
        listener
      }) => {
        listener();
      });
    }
    isOnline() {
      if (typeof this.online === "boolean") {
        return this.online;
      }
      if (typeof navigator === "undefined" || typeof navigator.onLine === "undefined") {
        return true;
      }
      return navigator.onLine;
    }
  }
  const onlineManager = new OnlineManager();
  function defaultRetryDelay(failureCount) {
    return Math.min(1e3 * 2 ** failureCount, 3e4);
  }
  function canFetch(networkMode) {
    return (networkMode != null ? networkMode : "online") === "online" ? onlineManager.isOnline() : true;
  }
  class CancelledError {
    constructor(options) {
      this.revert = options == null ? void 0 : options.revert;
      this.silent = options == null ? void 0 : options.silent;
    }
  }
  function isCancelledError(value) {
    return value instanceof CancelledError;
  }
  function createRetryer(config) {
    let isRetryCancelled = false;
    let failureCount = 0;
    let isResolved = false;
    let continueFn;
    let promiseResolve;
    let promiseReject;
    const promise = new Promise((outerResolve, outerReject) => {
      promiseResolve = outerResolve;
      promiseReject = outerReject;
    });
    const cancel = (cancelOptions) => {
      if (!isResolved) {
        reject(new CancelledError(cancelOptions));
        config.abort == null ? void 0 : config.abort();
      }
    };
    const cancelRetry = () => {
      isRetryCancelled = true;
    };
    const continueRetry = () => {
      isRetryCancelled = false;
    };
    const shouldPause = () => !focusManager.isFocused() || config.networkMode !== "always" && !onlineManager.isOnline();
    const resolve = (value) => {
      if (!isResolved) {
        isResolved = true;
        config.onSuccess == null ? void 0 : config.onSuccess(value);
        continueFn == null ? void 0 : continueFn();
        promiseResolve(value);
      }
    };
    const reject = (value) => {
      if (!isResolved) {
        isResolved = true;
        config.onError == null ? void 0 : config.onError(value);
        continueFn == null ? void 0 : continueFn();
        promiseReject(value);
      }
    };
    const pause = () => {
      return new Promise((continueResolve) => {
        continueFn = (value) => {
          const canContinue = isResolved || !shouldPause();
          if (canContinue) {
            continueResolve(value);
          }
          return canContinue;
        };
        config.onPause == null ? void 0 : config.onPause();
      }).then(() => {
        continueFn = void 0;
        if (!isResolved) {
          config.onContinue == null ? void 0 : config.onContinue();
        }
      });
    };
    const run = () => {
      if (isResolved) {
        return;
      }
      let promiseOrValue;
      try {
        promiseOrValue = config.fn();
      } catch (error) {
        promiseOrValue = Promise.reject(error);
      }
      Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
        var _config$retry, _config$retryDelay;
        if (isResolved) {
          return;
        }
        const retry = (_config$retry = config.retry) != null ? _config$retry : 3;
        const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;
        const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
        const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
        if (isRetryCancelled || !shouldRetry) {
          reject(error);
          return;
        }
        failureCount++;
        config.onFail == null ? void 0 : config.onFail(failureCount, error);
        sleep(delay).then(() => {
          if (shouldPause()) {
            return pause();
          }
          return;
        }).then(() => {
          if (isRetryCancelled) {
            reject(error);
          } else {
            run();
          }
        });
      });
    };
    if (canFetch(config.networkMode)) {
      run();
    } else {
      pause().then(run);
    }
    return {
      promise,
      cancel,
      continue: () => {
        const didContinue = continueFn == null ? void 0 : continueFn();
        return didContinue ? promise : Promise.resolve();
      },
      cancelRetry,
      continueRetry
    };
  }
  const defaultLogger = console;
  function createNotifyManager() {
    let queue = [];
    let transactions = 0;
    let notifyFn = (callback) => {
      callback();
    };
    let batchNotifyFn = (callback) => {
      callback();
    };
    const batch2 = (callback) => {
      let result;
      transactions++;
      try {
        result = callback();
      } finally {
        transactions--;
        if (!transactions) {
          flush();
        }
      }
      return result;
    };
    const schedule = (callback) => {
      if (transactions) {
        queue.push(callback);
      } else {
        scheduleMicrotask(() => {
          notifyFn(callback);
        });
      }
    };
    const batchCalls = (callback) => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    };
    const flush = () => {
      const originalQueue = queue;
      queue = [];
      if (originalQueue.length) {
        scheduleMicrotask(() => {
          batchNotifyFn(() => {
            originalQueue.forEach((callback) => {
              notifyFn(callback);
            });
          });
        });
      }
    };
    const setNotifyFunction = (fn) => {
      notifyFn = fn;
    };
    const setBatchNotifyFunction = (fn) => {
      batchNotifyFn = fn;
    };
    return {
      batch: batch2,
      batchCalls,
      schedule,
      setNotifyFunction,
      setBatchNotifyFunction
    };
  }
  const notifyManager = createNotifyManager();
  class Removable {
    destroy() {
      this.clearGcTimeout();
    }
    scheduleGc() {
      this.clearGcTimeout();
      if (isValidTimeout(this.cacheTime)) {
        this.gcTimeout = setTimeout(() => {
          this.optionalRemove();
        }, this.cacheTime);
      }
    }
    updateCacheTime(newCacheTime) {
      this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1e3);
    }
    clearGcTimeout() {
      if (this.gcTimeout) {
        clearTimeout(this.gcTimeout);
        this.gcTimeout = void 0;
      }
    }
  }
  class Query extends Removable {
    constructor(config) {
      super();
      this.abortSignalConsumed = false;
      this.defaultOptions = config.defaultOptions;
      this.setOptions(config.options);
      this.observers = [];
      this.cache = config.cache;
      this.logger = config.logger || defaultLogger;
      this.queryKey = config.queryKey;
      this.queryHash = config.queryHash;
      this.initialState = config.state || getDefaultState$1(this.options);
      this.state = this.initialState;
      this.scheduleGc();
    }
    get meta() {
      return this.options.meta;
    }
    setOptions(options) {
      this.options = {
        ...this.defaultOptions,
        ...options
      };
      this.updateCacheTime(this.options.cacheTime);
    }
    optionalRemove() {
      if (!this.observers.length && this.state.fetchStatus === "idle") {
        this.cache.remove(this);
      }
    }
    setData(newData, options) {
      const data = replaceData(this.state.data, newData, this.options);
      this.dispatch({
        data,
        type: "success",
        dataUpdatedAt: options == null ? void 0 : options.updatedAt,
        manual: options == null ? void 0 : options.manual
      });
      return data;
    }
    setState(state, setStateOptions) {
      this.dispatch({
        type: "setState",
        state,
        setStateOptions
      });
    }
    cancel(options) {
      var _this$retryer;
      const promise = this.promise;
      (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);
      return promise ? promise.then(noop$2).catch(noop$2) : Promise.resolve();
    }
    destroy() {
      super.destroy();
      this.cancel({
        silent: true
      });
    }
    reset() {
      this.destroy();
      this.setState(this.initialState);
    }
    isActive() {
      return this.observers.some((observer) => observer.options.enabled !== false);
    }
    isDisabled() {
      return this.getObserversCount() > 0 && !this.isActive();
    }
    isStale() {
      return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some((observer) => observer.getCurrentResult().isStale);
    }
    isStaleByTime(staleTime = 0) {
      return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
    }
    onFocus() {
      var _this$retryer2;
      const observer = this.observers.find((x2) => x2.shouldFetchOnWindowFocus());
      if (observer) {
        observer.refetch({
          cancelRefetch: false
        });
      }
      (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();
    }
    onOnline() {
      var _this$retryer3;
      const observer = this.observers.find((x2) => x2.shouldFetchOnReconnect());
      if (observer) {
        observer.refetch({
          cancelRefetch: false
        });
      }
      (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();
    }
    addObserver(observer) {
      if (!this.observers.includes(observer)) {
        this.observers.push(observer);
        this.clearGcTimeout();
        this.cache.notify({
          type: "observerAdded",
          query: this,
          observer
        });
      }
    }
    removeObserver(observer) {
      if (this.observers.includes(observer)) {
        this.observers = this.observers.filter((x2) => x2 !== observer);
        if (!this.observers.length) {
          if (this.retryer) {
            if (this.abortSignalConsumed) {
              this.retryer.cancel({
                revert: true
              });
            } else {
              this.retryer.cancelRetry();
            }
          }
          this.scheduleGc();
        }
        this.cache.notify({
          type: "observerRemoved",
          query: this,
          observer
        });
      }
    }
    getObserversCount() {
      return this.observers.length;
    }
    invalidate() {
      if (!this.state.isInvalidated) {
        this.dispatch({
          type: "invalidate"
        });
      }
    }
    fetch(options, fetchOptions) {
      var _this$options$behavio, _context$fetchOptions;
      if (this.state.fetchStatus !== "idle") {
        if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {
          this.cancel({
            silent: true
          });
        } else if (this.promise) {
          var _this$retryer4;
          (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry();
          return this.promise;
        }
      }
      if (options) {
        this.setOptions(options);
      }
      if (!this.options.queryFn) {
        const observer = this.observers.find((x2) => x2.options.queryFn);
        if (observer) {
          this.setOptions(observer.options);
        }
      }
      const abortController = getAbortController();
      const queryFnContext = {
        queryKey: this.queryKey,
        pageParam: void 0,
        meta: this.meta
      };
      const addSignalProperty = (object) => {
        Object.defineProperty(object, "signal", {
          enumerable: true,
          get: () => {
            if (abortController) {
              this.abortSignalConsumed = true;
              return abortController.signal;
            }
            return void 0;
          }
        });
      };
      addSignalProperty(queryFnContext);
      const fetchFn = () => {
        if (!this.options.queryFn) {
          return Promise.reject("Missing queryFn for queryKey '" + this.options.queryHash + "'");
        }
        this.abortSignalConsumed = false;
        return this.options.queryFn(queryFnContext);
      };
      const context = {
        fetchOptions,
        options: this.options,
        queryKey: this.queryKey,
        state: this.state,
        fetchFn
      };
      addSignalProperty(context);
      (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context);
      this.revertState = this.state;
      if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {
        var _context$fetchOptions2;
        this.dispatch({
          type: "fetch",
          meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta
        });
      }
      const onError = (error) => {
        if (!(isCancelledError(error) && error.silent)) {
          this.dispatch({
            type: "error",
            error
          });
        }
        if (!isCancelledError(error)) {
          var _this$cache$config$on, _this$cache$config, _this$cache$config$on2, _this$cache$config2;
          (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);
          (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, this.state.data, error, this);
        }
        if (!this.isFetchingOptimistic) {
          this.scheduleGc();
        }
        this.isFetchingOptimistic = false;
      };
      this.retryer = createRetryer({
        fn: context.fetchFn,
        abort: abortController == null ? void 0 : abortController.abort.bind(abortController),
        onSuccess: (data) => {
          var _this$cache$config$on3, _this$cache$config3, _this$cache$config$on4, _this$cache$config4;
          if (typeof data === "undefined") {
            onError(new Error(this.queryHash + " data is undefined"));
            return;
          }
          this.setData(data);
          (_this$cache$config$on3 = (_this$cache$config3 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on3.call(_this$cache$config3, data, this);
          (_this$cache$config$on4 = (_this$cache$config4 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on4.call(_this$cache$config4, data, this.state.error, this);
          if (!this.isFetchingOptimistic) {
            this.scheduleGc();
          }
          this.isFetchingOptimistic = false;
        },
        onError,
        onFail: (failureCount, error) => {
          this.dispatch({
            type: "failed",
            failureCount,
            error
          });
        },
        onPause: () => {
          this.dispatch({
            type: "pause"
          });
        },
        onContinue: () => {
          this.dispatch({
            type: "continue"
          });
        },
        retry: context.options.retry,
        retryDelay: context.options.retryDelay,
        networkMode: context.options.networkMode
      });
      this.promise = this.retryer.promise;
      return this.promise;
    }
    dispatch(action) {
      const reducer = (state) => {
        var _action$meta, _action$dataUpdatedAt;
        switch (action.type) {
          case "failed":
            return {
              ...state,
              fetchFailureCount: action.failureCount,
              fetchFailureReason: action.error
            };
          case "pause":
            return {
              ...state,
              fetchStatus: "paused"
            };
          case "continue":
            return {
              ...state,
              fetchStatus: "fetching"
            };
          case "fetch":
            return {
              ...state,
              fetchFailureCount: 0,
              fetchFailureReason: null,
              fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,
              fetchStatus: canFetch(this.options.networkMode) ? "fetching" : "paused",
              ...!state.dataUpdatedAt && {
                error: null,
                status: "loading"
              }
            };
          case "success":
            return {
              ...state,
              data: action.data,
              dataUpdateCount: state.dataUpdateCount + 1,
              dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),
              error: null,
              isInvalidated: false,
              status: "success",
              ...!action.manual && {
                fetchStatus: "idle",
                fetchFailureCount: 0,
                fetchFailureReason: null
              }
            };
          case "error":
            const error = action.error;
            if (isCancelledError(error) && error.revert && this.revertState) {
              return {
                ...this.revertState,
                fetchStatus: "idle"
              };
            }
            return {
              ...state,
              error,
              errorUpdateCount: state.errorUpdateCount + 1,
              errorUpdatedAt: Date.now(),
              fetchFailureCount: state.fetchFailureCount + 1,
              fetchFailureReason: error,
              fetchStatus: "idle",
              status: "error"
            };
          case "invalidate":
            return {
              ...state,
              isInvalidated: true
            };
          case "setState":
            return {
              ...state,
              ...action.state
            };
        }
      };
      this.state = reducer(this.state);
      notifyManager.batch(() => {
        this.observers.forEach((observer) => {
          observer.onQueryUpdate(action);
        });
        this.cache.notify({
          query: this,
          type: "updated",
          action
        });
      });
    }
  }
  function getDefaultState$1(options) {
    const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
    const hasData = typeof data !== "undefined";
    const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
    return {
      data,
      dataUpdateCount: 0,
      dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,
      error: null,
      errorUpdateCount: 0,
      errorUpdatedAt: 0,
      fetchFailureCount: 0,
      fetchFailureReason: null,
      fetchMeta: null,
      isInvalidated: false,
      status: hasData ? "success" : "loading",
      fetchStatus: "idle"
    };
  }
  class QueryCache extends Subscribable {
    constructor(config) {
      super();
      this.config = config || {};
      this.queries = [];
      this.queriesMap = {};
    }
    build(client2, options, state) {
      var _options$queryHash;
      const queryKey = options.queryKey;
      const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);
      let query = this.get(queryHash);
      if (!query) {
        query = new Query({
          cache: this,
          logger: client2.getLogger(),
          queryKey,
          queryHash,
          options: client2.defaultQueryOptions(options),
          state,
          defaultOptions: client2.getQueryDefaults(queryKey)
        });
        this.add(query);
      }
      return query;
    }
    add(query) {
      if (!this.queriesMap[query.queryHash]) {
        this.queriesMap[query.queryHash] = query;
        this.queries.push(query);
        this.notify({
          type: "added",
          query
        });
      }
    }
    remove(query) {
      const queryInMap = this.queriesMap[query.queryHash];
      if (queryInMap) {
        query.destroy();
        this.queries = this.queries.filter((x2) => x2 !== query);
        if (queryInMap === query) {
          delete this.queriesMap[query.queryHash];
        }
        this.notify({
          type: "removed",
          query
        });
      }
    }
    clear() {
      notifyManager.batch(() => {
        this.queries.forEach((query) => {
          this.remove(query);
        });
      });
    }
    get(queryHash) {
      return this.queriesMap[queryHash];
    }
    getAll() {
      return this.queries;
    }
    /**
     * @deprecated This method should be used with only one object argument.
     */
    find(arg1, arg2) {
      const [filters] = parseFilterArgs(arg1, arg2);
      if (typeof filters.exact === "undefined") {
        filters.exact = true;
      }
      return this.queries.find((query) => matchQuery(filters, query));
    }
    /**
     * @deprecated This method should be used with only one object argument.
     */
    findAll(arg1, arg2) {
      const [filters] = parseFilterArgs(arg1, arg2);
      return Object.keys(filters).length > 0 ? this.queries.filter((query) => matchQuery(filters, query)) : this.queries;
    }
    notify(event) {
      notifyManager.batch(() => {
        this.listeners.forEach(({
          listener
        }) => {
          listener(event);
        });
      });
    }
    onFocus() {
      notifyManager.batch(() => {
        this.queries.forEach((query) => {
          query.onFocus();
        });
      });
    }
    onOnline() {
      notifyManager.batch(() => {
        this.queries.forEach((query) => {
          query.onOnline();
        });
      });
    }
  }
  class Mutation extends Removable {
    constructor(config) {
      super();
      this.defaultOptions = config.defaultOptions;
      this.mutationId = config.mutationId;
      this.mutationCache = config.mutationCache;
      this.logger = config.logger || defaultLogger;
      this.observers = [];
      this.state = config.state || getDefaultState();
      this.setOptions(config.options);
      this.scheduleGc();
    }
    setOptions(options) {
      this.options = {
        ...this.defaultOptions,
        ...options
      };
      this.updateCacheTime(this.options.cacheTime);
    }
    get meta() {
      return this.options.meta;
    }
    setState(state) {
      this.dispatch({
        type: "setState",
        state
      });
    }
    addObserver(observer) {
      if (!this.observers.includes(observer)) {
        this.observers.push(observer);
        this.clearGcTimeout();
        this.mutationCache.notify({
          type: "observerAdded",
          mutation: this,
          observer
        });
      }
    }
    removeObserver(observer) {
      this.observers = this.observers.filter((x2) => x2 !== observer);
      this.scheduleGc();
      this.mutationCache.notify({
        type: "observerRemoved",
        mutation: this,
        observer
      });
    }
    optionalRemove() {
      if (!this.observers.length) {
        if (this.state.status === "loading") {
          this.scheduleGc();
        } else {
          this.mutationCache.remove(this);
        }
      }
    }
    continue() {
      var _this$retryer$continu, _this$retryer;
      return (_this$retryer$continu = (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.continue()) != null ? _this$retryer$continu : this.execute();
    }
    async execute() {
      const executeMutation = () => {
        var _this$options$retry;
        this.retryer = createRetryer({
          fn: () => {
            if (!this.options.mutationFn) {
              return Promise.reject("No mutationFn found");
            }
            return this.options.mutationFn(this.state.variables);
          },
          onFail: (failureCount, error) => {
            this.dispatch({
              type: "failed",
              failureCount,
              error
            });
          },
          onPause: () => {
            this.dispatch({
              type: "pause"
            });
          },
          onContinue: () => {
            this.dispatch({
              type: "continue"
            });
          },
          retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,
          retryDelay: this.options.retryDelay,
          networkMode: this.options.networkMode
        });
        return this.retryer.promise;
      };
      const restored = this.state.status === "loading";
      try {
        var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onSettl, _this$options3;
        if (!restored) {
          var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;
          this.dispatch({
            type: "loading",
            variables: this.options.variables
          });
          await ((_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this));
          const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));
          if (context !== this.state.context) {
            this.dispatch({
              type: "loading",
              context,
              variables: this.state.variables
            });
          }
        }
        const data = await executeMutation();
        await ((_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this));
        await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context));
        await ((_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, data, null, this.state.variables, this.state.context, this));
        await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));
        this.dispatch({
          type: "success",
          data
        });
        return data;
      } catch (error) {
        try {
          var _this$mutationCache$c7, _this$mutationCache$c8, _this$options$onError, _this$options4, _this$mutationCache$c9, _this$mutationCache$c10, _this$options$onSettl2, _this$options5;
          await ((_this$mutationCache$c7 = (_this$mutationCache$c8 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c7.call(_this$mutationCache$c8, error, this.state.variables, this.state.context, this));
          if (false) ;
          await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context));
          await ((_this$mutationCache$c9 = (_this$mutationCache$c10 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c9.call(_this$mutationCache$c10, void 0, error, this.state.variables, this.state.context, this));
          await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, void 0, error, this.state.variables, this.state.context));
          throw error;
        } finally {
          this.dispatch({
            type: "error",
            error
          });
        }
      }
    }
    dispatch(action) {
      const reducer = (state) => {
        switch (action.type) {
          case "failed":
            return {
              ...state,
              failureCount: action.failureCount,
              failureReason: action.error
            };
          case "pause":
            return {
              ...state,
              isPaused: true
            };
          case "continue":
            return {
              ...state,
              isPaused: false
            };
          case "loading":
            return {
              ...state,
              context: action.context,
              data: void 0,
              failureCount: 0,
              failureReason: null,
              error: null,
              isPaused: !canFetch(this.options.networkMode),
              status: "loading",
              variables: action.variables
            };
          case "success":
            return {
              ...state,
              data: action.data,
              failureCount: 0,
              failureReason: null,
              error: null,
              status: "success",
              isPaused: false
            };
          case "error":
            return {
              ...state,
              data: void 0,
              error: action.error,
              failureCount: state.failureCount + 1,
              failureReason: action.error,
              isPaused: false,
              status: "error"
            };
          case "setState":
            return {
              ...state,
              ...action.state
            };
        }
      };
      this.state = reducer(this.state);
      notifyManager.batch(() => {
        this.observers.forEach((observer) => {
          observer.onMutationUpdate(action);
        });
        this.mutationCache.notify({
          mutation: this,
          type: "updated",
          action
        });
      });
    }
  }
  function getDefaultState() {
    return {
      context: void 0,
      data: void 0,
      error: null,
      failureCount: 0,
      failureReason: null,
      isPaused: false,
      status: "idle",
      variables: void 0
    };
  }
  class MutationCache extends Subscribable {
    constructor(config) {
      super();
      this.config = config || {};
      this.mutations = [];
      this.mutationId = 0;
    }
    build(client2, options, state) {
      const mutation = new Mutation({
        mutationCache: this,
        logger: client2.getLogger(),
        mutationId: ++this.mutationId,
        options: client2.defaultMutationOptions(options),
        state,
        defaultOptions: options.mutationKey ? client2.getMutationDefaults(options.mutationKey) : void 0
      });
      this.add(mutation);
      return mutation;
    }
    add(mutation) {
      this.mutations.push(mutation);
      this.notify({
        type: "added",
        mutation
      });
    }
    remove(mutation) {
      this.mutations = this.mutations.filter((x2) => x2 !== mutation);
      this.notify({
        type: "removed",
        mutation
      });
    }
    clear() {
      notifyManager.batch(() => {
        this.mutations.forEach((mutation) => {
          this.remove(mutation);
        });
      });
    }
    getAll() {
      return this.mutations;
    }
    find(filters) {
      if (typeof filters.exact === "undefined") {
        filters.exact = true;
      }
      return this.mutations.find((mutation) => matchMutation(filters, mutation));
    }
    findAll(filters) {
      return this.mutations.filter((mutation) => matchMutation(filters, mutation));
    }
    notify(event) {
      notifyManager.batch(() => {
        this.listeners.forEach(({
          listener
        }) => {
          listener(event);
        });
      });
    }
    resumePausedMutations() {
      var _this$resuming;
      this.resuming = ((_this$resuming = this.resuming) != null ? _this$resuming : Promise.resolve()).then(() => {
        const pausedMutations = this.mutations.filter((x2) => x2.state.isPaused);
        return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop$2)), Promise.resolve()));
      }).then(() => {
        this.resuming = void 0;
      });
      return this.resuming;
    }
  }
  function infiniteQueryBehavior() {
    return {
      onFetch: (context) => {
        context.fetchFn = () => {
          var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;
          const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;
          const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;
          const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;
          const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === "forward";
          const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === "backward";
          const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];
          const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];
          let newPageParams = oldPageParams;
          let cancelled = false;
          const addSignalProperty = (object) => {
            Object.defineProperty(object, "signal", {
              enumerable: true,
              get: () => {
                var _context$signal;
                if ((_context$signal = context.signal) != null && _context$signal.aborted) {
                  cancelled = true;
                } else {
                  var _context$signal2;
                  (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener("abort", () => {
                    cancelled = true;
                  });
                }
                return context.signal;
              }
            });
          };
          const queryFn = context.options.queryFn || (() => Promise.reject("Missing queryFn for queryKey '" + context.options.queryHash + "'"));
          const buildNewPages = (pages, param, page, previous) => {
            newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];
            return previous ? [page, ...pages] : [...pages, page];
          };
          const fetchPage = (pages, manual, param, previous) => {
            if (cancelled) {
              return Promise.reject("Cancelled");
            }
            if (typeof param === "undefined" && !manual && pages.length) {
              return Promise.resolve(pages);
            }
            const queryFnContext = {
              queryKey: context.queryKey,
              pageParam: param,
              meta: context.options.meta
            };
            addSignalProperty(queryFnContext);
            const queryFnResult = queryFn(queryFnContext);
            const promise2 = Promise.resolve(queryFnResult).then((page) => buildNewPages(pages, param, page, previous));
            return promise2;
          };
          let promise;
          if (!oldPages.length) {
            promise = fetchPage([]);
          } else if (isFetchingNextPage) {
            const manual = typeof pageParam !== "undefined";
            const param = manual ? pageParam : getNextPageParam(context.options, oldPages);
            promise = fetchPage(oldPages, manual, param);
          } else if (isFetchingPreviousPage) {
            const manual = typeof pageParam !== "undefined";
            const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);
            promise = fetchPage(oldPages, manual, param, true);
          } else {
            newPageParams = [];
            const manual = typeof context.options.getNextPageParam === "undefined";
            const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true;
            promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]));
            for (let i2 = 1; i2 < oldPages.length; i2++) {
              promise = promise.then((pages) => {
                const shouldFetchNextPage = refetchPage && oldPages[i2] ? refetchPage(oldPages[i2], i2, oldPages) : true;
                if (shouldFetchNextPage) {
                  const param = manual ? oldPageParams[i2] : getNextPageParam(context.options, pages);
                  return fetchPage(pages, manual, param);
                }
                return Promise.resolve(buildNewPages(pages, oldPageParams[i2], oldPages[i2]));
              });
            }
          }
          const finalPromise = promise.then((pages) => ({
            pages,
            pageParams: newPageParams
          }));
          return finalPromise;
        };
      }
    };
  }
  function getNextPageParam(options, pages) {
    return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);
  }
  function getPreviousPageParam(options, pages) {
    return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);
  }
  class QueryClient {
    constructor(config = {}) {
      this.queryCache = config.queryCache || new QueryCache();
      this.mutationCache = config.mutationCache || new MutationCache();
      this.logger = config.logger || defaultLogger;
      this.defaultOptions = config.defaultOptions || {};
      this.queryDefaults = [];
      this.mutationDefaults = [];
      this.mountCount = 0;
    }
    mount() {
      this.mountCount++;
      if (this.mountCount !== 1) return;
      this.unsubscribeFocus = focusManager.subscribe(() => {
        if (focusManager.isFocused()) {
          this.resumePausedMutations();
          this.queryCache.onFocus();
        }
      });
      this.unsubscribeOnline = onlineManager.subscribe(() => {
        if (onlineManager.isOnline()) {
          this.resumePausedMutations();
          this.queryCache.onOnline();
        }
      });
    }
    unmount() {
      var _this$unsubscribeFocu, _this$unsubscribeOnli;
      this.mountCount--;
      if (this.mountCount !== 0) return;
      (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);
      this.unsubscribeFocus = void 0;
      (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);
      this.unsubscribeOnline = void 0;
    }
    /**
     * @deprecated This method should be used with only one object argument.
     */
    isFetching(arg1, arg2) {
      const [filters] = parseFilterArgs(arg1, arg2);
      filters.fetchStatus = "fetching";
      return this.queryCache.findAll(filters).length;
    }
    isMutating(filters) {
      return this.mutationCache.findAll({
        ...filters,
        fetching: true
      }).length;
    }
    /**
     * @deprecated This method will accept only queryKey in the next major version.
     */
    getQueryData(queryKey, filters) {
      var _this$queryCache$find;
      return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;
    }
    /**
     * @deprecated This method should be used with only one object argument.
     */
    ensureQueryData(arg1, arg2, arg3) {
      const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
      const cachedData = this.getQueryData(parsedOptions.queryKey);
      return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(parsedOptions);
    }
    /**
     * @deprecated This method should be used with only one object argument.
     */
    getQueriesData(queryKeyOrFilters) {
      return this.getQueryCache().findAll(queryKeyOrFilters).map(({
        queryKey,
        state
      }) => {
        const data = state.data;
        return [queryKey, data];
      });
    }
    setQueryData(queryKey, updater, options) {
      const query = this.queryCache.find(queryKey);
      const prevData = query == null ? void 0 : query.state.data;
      const data = functionalUpdate(updater, prevData);
      if (typeof data === "undefined") {
        return void 0;
      }
      const parsedOptions = parseQueryArgs(queryKey);
      const defaultedOptions = this.defaultQueryOptions(parsedOptions);
      return this.queryCache.build(this, defaultedOptions).setData(data, {
        ...options,
        manual: true
      });
    }
    /**
     * @deprecated This method should be used with only one object argument.
     */
    setQueriesData(queryKeyOrFilters, updater, options) {
      return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({
        queryKey
      }) => [queryKey, this.setQueryData(queryKey, updater, options)]));
    }
    getQueryState(queryKey, filters) {
      var _this$queryCache$find2;
      return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;
    }
    /**
     * @deprecated This method should be used with only one object argument.
     */
    removeQueries(arg1, arg2) {
      const [filters] = parseFilterArgs(arg1, arg2);
      const queryCache = this.queryCache;
      notifyManager.batch(() => {
        queryCache.findAll(filters).forEach((query) => {
          queryCache.remove(query);
        });
      });
    }
    /**
     * @deprecated This method should be used with only one object argument.
     */
    resetQueries(arg1, arg2, arg3) {
      const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
      const queryCache = this.queryCache;
      const refetchFilters = {
        type: "active",
        ...filters
      };
      return notifyManager.batch(() => {
        queryCache.findAll(filters).forEach((query) => {
          query.reset();
        });
        return this.refetchQueries(refetchFilters, options);
      });
    }
    /**
     * @deprecated This method should be used with only one object argument.
     */
    cancelQueries(arg1, arg2, arg3) {
      const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);
      if (typeof cancelOptions.revert === "undefined") {
        cancelOptions.revert = true;
      }
      const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map((query) => query.cancel(cancelOptions)));
      return Promise.all(promises).then(noop$2).catch(noop$2);
    }
    /**
     * @deprecated This method should be used with only one object argument.
     */
    invalidateQueries(arg1, arg2, arg3) {
      const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
      return notifyManager.batch(() => {
        var _ref, _filters$refetchType;
        this.queryCache.findAll(filters).forEach((query) => {
          query.invalidate();
        });
        if (filters.refetchType === "none") {
          return Promise.resolve();
        }
        const refetchFilters = {
          ...filters,
          type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : "active"
        };
        return this.refetchQueries(refetchFilters, options);
      });
    }
    /**
     * @deprecated This method should be used with only one object argument.
     */
    refetchQueries(arg1, arg2, arg3) {
      const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
      const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
        var _options$cancelRefetc;
        return query.fetch(void 0, {
          ...options,
          cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,
          meta: {
            refetchPage: filters.refetchPage
          }
        });
      }));
      let promise = Promise.all(promises).then(noop$2);
      if (!(options != null && options.throwOnError)) {
        promise = promise.catch(noop$2);
      }
      return promise;
    }
    /**
     * @deprecated This method should be used with only one object argument.
     */
    fetchQuery(arg1, arg2, arg3) {
      const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
      const defaultedOptions = this.defaultQueryOptions(parsedOptions);
      if (typeof defaultedOptions.retry === "undefined") {
        defaultedOptions.retry = false;
      }
      const query = this.queryCache.build(this, defaultedOptions);
      return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
    }
    /**
     * @deprecated This method should be used with only one object argument.
     */
    prefetchQuery(arg1, arg2, arg3) {
      return this.fetchQuery(arg1, arg2, arg3).then(noop$2).catch(noop$2);
    }
    /**
     * @deprecated This method should be used with only one object argument.
     */
    fetchInfiniteQuery(arg1, arg2, arg3) {
      const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
      parsedOptions.behavior = infiniteQueryBehavior();
      return this.fetchQuery(parsedOptions);
    }
    /**
     * @deprecated This method should be used with only one object argument.
     */
    prefetchInfiniteQuery(arg1, arg2, arg3) {
      return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop$2).catch(noop$2);
    }
    resumePausedMutations() {
      return this.mutationCache.resumePausedMutations();
    }
    getQueryCache() {
      return this.queryCache;
    }
    getMutationCache() {
      return this.mutationCache;
    }
    getLogger() {
      return this.logger;
    }
    getDefaultOptions() {
      return this.defaultOptions;
    }
    setDefaultOptions(options) {
      this.defaultOptions = options;
    }
    setQueryDefaults(queryKey, options) {
      const result = this.queryDefaults.find((x2) => hashQueryKey(queryKey) === hashQueryKey(x2.queryKey));
      if (result) {
        result.defaultOptions = options;
      } else {
        this.queryDefaults.push({
          queryKey,
          defaultOptions: options
        });
      }
    }
    getQueryDefaults(queryKey) {
      if (!queryKey) {
        return void 0;
      }
      const firstMatchingDefaults = this.queryDefaults.find((x2) => partialMatchKey(queryKey, x2.queryKey));
      return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
    }
    setMutationDefaults(mutationKey, options) {
      const result = this.mutationDefaults.find((x2) => hashQueryKey(mutationKey) === hashQueryKey(x2.mutationKey));
      if (result) {
        result.defaultOptions = options;
      } else {
        this.mutationDefaults.push({
          mutationKey,
          defaultOptions: options
        });
      }
    }
    getMutationDefaults(mutationKey) {
      if (!mutationKey) {
        return void 0;
      }
      const firstMatchingDefaults = this.mutationDefaults.find((x2) => partialMatchKey(mutationKey, x2.mutationKey));
      return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
    }
    defaultQueryOptions(options) {
      if (options != null && options._defaulted) {
        return options;
      }
      const defaultedOptions = {
        ...this.defaultOptions.queries,
        ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),
        ...options,
        _defaulted: true
      };
      if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {
        defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);
      }
      if (typeof defaultedOptions.refetchOnReconnect === "undefined") {
        defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
      }
      if (typeof defaultedOptions.useErrorBoundary === "undefined") {
        defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;
      }
      return defaultedOptions;
    }
    defaultMutationOptions(options) {
      if (options != null && options._defaulted) {
        return options;
      }
      return {
        ...this.defaultOptions.mutations,
        ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),
        ...options,
        _defaulted: true
      };
    }
    clear() {
      this.queryCache.clear();
      this.mutationCache.clear();
    }
  }
  class QueryObserver extends Subscribable {
    constructor(client2, options) {
      super();
      this.client = client2;
      this.options = options;
      this.trackedProps = /* @__PURE__ */ new Set();
      this.selectError = null;
      this.bindMethods();
      this.setOptions(options);
    }
    bindMethods() {
      this.remove = this.remove.bind(this);
      this.refetch = this.refetch.bind(this);
    }
    onSubscribe() {
      if (this.listeners.size === 1) {
        this.currentQuery.addObserver(this);
        if (shouldFetchOnMount(this.currentQuery, this.options)) {
          this.executeFetch();
        }
        this.updateTimers();
      }
    }
    onUnsubscribe() {
      if (!this.hasListeners()) {
        this.destroy();
      }
    }
    shouldFetchOnReconnect() {
      return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);
    }
    shouldFetchOnWindowFocus() {
      return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
    }
    destroy() {
      this.listeners = /* @__PURE__ */ new Set();
      this.clearStaleTimeout();
      this.clearRefetchInterval();
      this.currentQuery.removeObserver(this);
    }
    setOptions(options, notifyOptions) {
      const prevOptions = this.options;
      const prevQuery = this.currentQuery;
      this.options = this.client.defaultQueryOptions(options);
      if (!shallowEqualObjects(prevOptions, this.options)) {
        this.client.getQueryCache().notify({
          type: "observerOptionsUpdated",
          query: this.currentQuery,
          observer: this
        });
      }
      if (typeof this.options.enabled !== "undefined" && typeof this.options.enabled !== "boolean") {
        throw new Error("Expected enabled to be a boolean");
      }
      if (!this.options.queryKey) {
        this.options.queryKey = prevOptions.queryKey;
      }
      this.updateQuery();
      const mounted = this.hasListeners();
      if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {
        this.executeFetch();
      }
      this.updateResult(notifyOptions);
      if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {
        this.updateStaleTimeout();
      }
      const nextRefetchInterval = this.computeRefetchInterval();
      if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {
        this.updateRefetchInterval(nextRefetchInterval);
      }
    }
    getOptimisticResult(options) {
      const query = this.client.getQueryCache().build(this.client, options);
      const result = this.createResult(query, options);
      if (shouldAssignObserverCurrentProperties(this, result, options)) {
        this.currentResult = result;
        this.currentResultOptions = this.options;
        this.currentResultState = this.currentQuery.state;
      }
      return result;
    }
    getCurrentResult() {
      return this.currentResult;
    }
    trackResult(result) {
      const trackedResult = {};
      Object.keys(result).forEach((key2) => {
        Object.defineProperty(trackedResult, key2, {
          configurable: false,
          enumerable: true,
          get: () => {
            this.trackedProps.add(key2);
            return result[key2];
          }
        });
      });
      return trackedResult;
    }
    getCurrentQuery() {
      return this.currentQuery;
    }
    remove() {
      this.client.getQueryCache().remove(this.currentQuery);
    }
    refetch({
      refetchPage,
      ...options
    } = {}) {
      return this.fetch({
        ...options,
        meta: {
          refetchPage
        }
      });
    }
    fetchOptimistic(options) {
      const defaultedOptions = this.client.defaultQueryOptions(options);
      const query = this.client.getQueryCache().build(this.client, defaultedOptions);
      query.isFetchingOptimistic = true;
      return query.fetch().then(() => this.createResult(query, defaultedOptions));
    }
    fetch(fetchOptions) {
      var _fetchOptions$cancelR;
      return this.executeFetch({
        ...fetchOptions,
        cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true
      }).then(() => {
        this.updateResult();
        return this.currentResult;
      });
    }
    executeFetch(fetchOptions) {
      this.updateQuery();
      let promise = this.currentQuery.fetch(this.options, fetchOptions);
      if (!(fetchOptions != null && fetchOptions.throwOnError)) {
        promise = promise.catch(noop$2);
      }
      return promise;
    }
    updateStaleTimeout() {
      this.clearStaleTimeout();
      if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {
        return;
      }
      const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime);
      const timeout = time + 1;
      this.staleTimeoutId = setTimeout(() => {
        if (!this.currentResult.isStale) {
          this.updateResult();
        }
      }, timeout);
    }
    computeRefetchInterval() {
      var _this$options$refetch;
      return typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;
    }
    updateRefetchInterval(nextInterval) {
      this.clearRefetchInterval();
      this.currentRefetchInterval = nextInterval;
      if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {
        return;
      }
      this.refetchIntervalId = setInterval(() => {
        if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
          this.executeFetch();
        }
      }, this.currentRefetchInterval);
    }
    updateTimers() {
      this.updateStaleTimeout();
      this.updateRefetchInterval(this.computeRefetchInterval());
    }
    clearStaleTimeout() {
      if (this.staleTimeoutId) {
        clearTimeout(this.staleTimeoutId);
        this.staleTimeoutId = void 0;
      }
    }
    clearRefetchInterval() {
      if (this.refetchIntervalId) {
        clearInterval(this.refetchIntervalId);
        this.refetchIntervalId = void 0;
      }
    }
    createResult(query, options) {
      const prevQuery = this.currentQuery;
      const prevOptions = this.options;
      const prevResult = this.currentResult;
      const prevResultState = this.currentResultState;
      const prevResultOptions = this.currentResultOptions;
      const queryChange = query !== prevQuery;
      const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;
      const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;
      const {
        state
      } = query;
      let {
        dataUpdatedAt,
        error,
        errorUpdatedAt,
        fetchStatus,
        status
      } = state;
      let isPreviousData = false;
      let isPlaceholderData = false;
      let data;
      if (options._optimisticResults) {
        const mounted = this.hasListeners();
        const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
        const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
        if (fetchOnMount || fetchOptionally) {
          fetchStatus = canFetch(query.options.networkMode) ? "fetching" : "paused";
          if (!dataUpdatedAt) {
            status = "loading";
          }
        }
        if (options._optimisticResults === "isRestoring") {
          fetchStatus = "idle";
        }
      }
      if (options.keepPreviousData && !state.dataUpdatedAt && prevQueryResult != null && prevQueryResult.isSuccess && status !== "error") {
        data = prevQueryResult.data;
        dataUpdatedAt = prevQueryResult.dataUpdatedAt;
        status = prevQueryResult.status;
        isPreviousData = true;
      } else if (options.select && typeof state.data !== "undefined") {
        if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {
          data = this.selectResult;
        } else {
          try {
            this.selectFn = options.select;
            data = options.select(state.data);
            data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);
            this.selectResult = data;
            this.selectError = null;
          } catch (selectError) {
            this.selectError = selectError;
          }
        }
      } else {
        data = state.data;
      }
      if (typeof options.placeholderData !== "undefined" && typeof data === "undefined" && status === "loading") {
        let placeholderData;
        if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
          placeholderData = prevResult.data;
        } else {
          placeholderData = typeof options.placeholderData === "function" ? options.placeholderData() : options.placeholderData;
          if (options.select && typeof placeholderData !== "undefined") {
            try {
              placeholderData = options.select(placeholderData);
              this.selectError = null;
            } catch (selectError) {
              this.selectError = selectError;
            }
          }
        }
        if (typeof placeholderData !== "undefined") {
          status = "success";
          data = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);
          isPlaceholderData = true;
        }
      }
      if (this.selectError) {
        error = this.selectError;
        data = this.selectResult;
        errorUpdatedAt = Date.now();
        status = "error";
      }
      const isFetching = fetchStatus === "fetching";
      const isLoading = status === "loading";
      const isError2 = status === "error";
      const result = {
        status,
        fetchStatus,
        isLoading,
        isSuccess: status === "success",
        isError: isError2,
        isInitialLoading: isLoading && isFetching,
        data,
        dataUpdatedAt,
        error,
        errorUpdatedAt,
        failureCount: state.fetchFailureCount,
        failureReason: state.fetchFailureReason,
        errorUpdateCount: state.errorUpdateCount,
        isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,
        isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,
        isFetching,
        isRefetching: isFetching && !isLoading,
        isLoadingError: isError2 && state.dataUpdatedAt === 0,
        isPaused: fetchStatus === "paused",
        isPlaceholderData,
        isPreviousData,
        isRefetchError: isError2 && state.dataUpdatedAt !== 0,
        isStale: isStale(query, options),
        refetch: this.refetch,
        remove: this.remove
      };
      return result;
    }
    updateResult(notifyOptions) {
      const prevResult = this.currentResult;
      const nextResult = this.createResult(this.currentQuery, this.options);
      this.currentResultState = this.currentQuery.state;
      this.currentResultOptions = this.options;
      if (shallowEqualObjects(nextResult, prevResult)) {
        return;
      }
      this.currentResult = nextResult;
      const defaultNotifyOptions = {
        cache: true
      };
      const shouldNotifyListeners = () => {
        if (!prevResult) {
          return true;
        }
        const {
          notifyOnChangeProps
        } = this.options;
        const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
        if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !this.trackedProps.size) {
          return true;
        }
        const includedProps = new Set(notifyOnChangePropsValue != null ? notifyOnChangePropsValue : this.trackedProps);
        if (this.options.useErrorBoundary) {
          includedProps.add("error");
        }
        return Object.keys(this.currentResult).some((key2) => {
          const typedKey = key2;
          const changed = this.currentResult[typedKey] !== prevResult[typedKey];
          return changed && includedProps.has(typedKey);
        });
      };
      if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
        defaultNotifyOptions.listeners = true;
      }
      this.notify({
        ...defaultNotifyOptions,
        ...notifyOptions
      });
    }
    updateQuery() {
      const query = this.client.getQueryCache().build(this.client, this.options);
      if (query === this.currentQuery) {
        return;
      }
      const prevQuery = this.currentQuery;
      this.currentQuery = query;
      this.currentQueryInitialState = query.state;
      this.previousQueryResult = this.currentResult;
      if (this.hasListeners()) {
        prevQuery == null ? void 0 : prevQuery.removeObserver(this);
        query.addObserver(this);
      }
    }
    onQueryUpdate(action) {
      const notifyOptions = {};
      if (action.type === "success") {
        notifyOptions.onSuccess = !action.manual;
      } else if (action.type === "error" && !isCancelledError(action.error)) {
        notifyOptions.onError = true;
      }
      this.updateResult(notifyOptions);
      if (this.hasListeners()) {
        this.updateTimers();
      }
    }
    notify(notifyOptions) {
      notifyManager.batch(() => {
        if (notifyOptions.onSuccess) {
          var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;
          (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);
          (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);
        } else if (notifyOptions.onError) {
          var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;
          (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);
          (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, void 0, this.currentResult.error);
        }
        if (notifyOptions.listeners) {
          this.listeners.forEach(({
            listener
          }) => {
            listener(this.currentResult);
          });
        }
        if (notifyOptions.cache) {
          this.client.getQueryCache().notify({
            query: this.currentQuery,
            type: "observerResultsUpdated"
          });
        }
      });
    }
  }
  function shouldLoadOnMount(query, options) {
    return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === "error" && options.retryOnMount === false);
  }
  function shouldFetchOnMount(query, options) {
    return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);
  }
  function shouldFetchOn(query, options, field) {
    if (options.enabled !== false) {
      const value = typeof field === "function" ? field(query) : field;
      return value === "always" || value !== false && isStale(query, options);
    }
    return false;
  }
  function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
    return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
  }
  function isStale(query, options) {
    return query.isStaleByTime(options.staleTime);
  }
  function shouldAssignObserverCurrentProperties(observer, optimisticResult, options) {
    if (options.keepPreviousData) {
      return false;
    }
    if (options.placeholderData !== void 0) {
      return optimisticResult.isPlaceholderData;
    }
    if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
      return true;
    }
    return false;
  }
  let MutationObserver$1 = class MutationObserver extends Subscribable {
    constructor(client2, options) {
      super();
      this.client = client2;
      this.setOptions(options);
      this.bindMethods();
      this.updateResult();
    }
    bindMethods() {
      this.mutate = this.mutate.bind(this);
      this.reset = this.reset.bind(this);
    }
    setOptions(options) {
      var _this$currentMutation;
      const prevOptions = this.options;
      this.options = this.client.defaultMutationOptions(options);
      if (!shallowEqualObjects(prevOptions, this.options)) {
        this.client.getMutationCache().notify({
          type: "observerOptionsUpdated",
          mutation: this.currentMutation,
          observer: this
        });
      }
      (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.setOptions(this.options);
    }
    onUnsubscribe() {
      if (!this.hasListeners()) {
        var _this$currentMutation2;
        (_this$currentMutation2 = this.currentMutation) == null ? void 0 : _this$currentMutation2.removeObserver(this);
      }
    }
    onMutationUpdate(action) {
      this.updateResult();
      const notifyOptions = {
        listeners: true
      };
      if (action.type === "success") {
        notifyOptions.onSuccess = true;
      } else if (action.type === "error") {
        notifyOptions.onError = true;
      }
      this.notify(notifyOptions);
    }
    getCurrentResult() {
      return this.currentResult;
    }
    reset() {
      this.currentMutation = void 0;
      this.updateResult();
      this.notify({
        listeners: true
      });
    }
    mutate(variables, options) {
      this.mutateOptions = options;
      if (this.currentMutation) {
        this.currentMutation.removeObserver(this);
      }
      this.currentMutation = this.client.getMutationCache().build(this.client, {
        ...this.options,
        variables: typeof variables !== "undefined" ? variables : this.options.variables
      });
      this.currentMutation.addObserver(this);
      return this.currentMutation.execute();
    }
    updateResult() {
      const state = this.currentMutation ? this.currentMutation.state : getDefaultState();
      const isLoading = state.status === "loading";
      const result = {
        ...state,
        isLoading,
        isPending: isLoading,
        isSuccess: state.status === "success",
        isError: state.status === "error",
        isIdle: state.status === "idle",
        mutate: this.mutate,
        reset: this.reset
      };
      this.currentResult = result;
    }
    notify(options) {
      notifyManager.batch(() => {
        if (this.mutateOptions && this.hasListeners()) {
          if (options.onSuccess) {
            var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;
            (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);
            (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);
          } else if (options.onError) {
            var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;
            (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
            (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, void 0, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
          }
        }
        if (options.listeners) {
          this.listeners.forEach(({
            listener
          }) => {
            listener(this.currentResult);
          });
        }
      });
    }
  };
  var shimExports = requireShim();
  const useSyncExternalStore$2 = shimExports.useSyncExternalStore;
  const defaultContext = /* @__PURE__ */ reactExports.createContext(void 0);
  const QueryClientSharingContext = /* @__PURE__ */ reactExports.createContext(false);
  function getQueryClientContext(context, contextSharing) {
    if (context) {
      return context;
    }
    if (contextSharing && typeof window !== "undefined") {
      if (!window.ReactQueryClientContext) {
        window.ReactQueryClientContext = defaultContext;
      }
      return window.ReactQueryClientContext;
    }
    return defaultContext;
  }
  const useQueryClient = ({
    context
  } = {}) => {
    const queryClient2 = reactExports.useContext(getQueryClientContext(context, reactExports.useContext(QueryClientSharingContext)));
    if (!queryClient2) {
      throw new Error("No QueryClient set, use QueryClientProvider to set one");
    }
    return queryClient2;
  };
  const QueryClientProvider = ({
    client: client2,
    children,
    context,
    contextSharing = false
  }) => {
    reactExports.useEffect(() => {
      client2.mount();
      return () => {
        client2.unmount();
      };
    }, [client2]);
    const Context = getQueryClientContext(context, contextSharing);
    return /* @__PURE__ */ reactExports.createElement(QueryClientSharingContext.Provider, {
      value: !context && contextSharing
    }, /* @__PURE__ */ reactExports.createElement(Context.Provider, {
      value: client2
    }, children));
  };
  const IsRestoringContext = /* @__PURE__ */ reactExports.createContext(false);
  const useIsRestoring = () => reactExports.useContext(IsRestoringContext);
  IsRestoringContext.Provider;
  function createValue() {
    let isReset = false;
    return {
      clearReset: () => {
        isReset = false;
      },
      reset: () => {
        isReset = true;
      },
      isReset: () => {
        return isReset;
      }
    };
  }
  const QueryErrorResetBoundaryContext = /* @__PURE__ */ reactExports.createContext(createValue());
  const useQueryErrorResetBoundary = () => reactExports.useContext(QueryErrorResetBoundaryContext);
  function shouldThrowError(_useErrorBoundary, params) {
    if (typeof _useErrorBoundary === "function") {
      return _useErrorBoundary(...params);
    }
    return !!_useErrorBoundary;
  }
  const ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
    if (options.suspense || options.useErrorBoundary) {
      if (!errorResetBoundary.isReset()) {
        options.retryOnMount = false;
      }
    }
  };
  const useClearResetErrorBoundary = (errorResetBoundary) => {
    reactExports.useEffect(() => {
      errorResetBoundary.clearReset();
    }, [errorResetBoundary]);
  };
  const getHasError = ({
    result,
    errorResetBoundary,
    useErrorBoundary,
    query
  }) => {
    return result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(useErrorBoundary, [result.error, query]);
  };
  const ensureStaleTime = (defaultedOptions) => {
    if (defaultedOptions.suspense) {
      if (typeof defaultedOptions.staleTime !== "number") {
        defaultedOptions.staleTime = 1e3;
      }
    }
  };
  const willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;
  const shouldSuspend = (defaultedOptions, result, isRestoring) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && willFetch(result, isRestoring);
  const fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).then(({
    data
  }) => {
    defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);
    defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);
  }).catch((error) => {
    errorResetBoundary.clearReset();
    defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);
    defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(void 0, error);
  });
  function useBaseQuery(options, Observer) {
    const queryClient2 = useQueryClient({
      context: options.context
    });
    const isRestoring = useIsRestoring();
    const errorResetBoundary = useQueryErrorResetBoundary();
    const defaultedOptions = queryClient2.defaultQueryOptions(options);
    defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
    if (defaultedOptions.onError) {
      defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);
    }
    if (defaultedOptions.onSuccess) {
      defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);
    }
    if (defaultedOptions.onSettled) {
      defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);
    }
    ensureStaleTime(defaultedOptions);
    ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
    useClearResetErrorBoundary(errorResetBoundary);
    const [observer] = reactExports.useState(() => new Observer(queryClient2, defaultedOptions));
    const result = observer.getOptimisticResult(defaultedOptions);
    useSyncExternalStore$2(reactExports.useCallback((onStoreChange) => {
      const unsubscribe = isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange));
      observer.updateResult();
      return unsubscribe;
    }, [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
    reactExports.useEffect(() => {
      observer.setOptions(defaultedOptions, {
        listeners: false
      });
    }, [defaultedOptions, observer]);
    if (shouldSuspend(defaultedOptions, result, isRestoring)) {
      throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
    }
    if (getHasError({
      result,
      errorResetBoundary,
      useErrorBoundary: defaultedOptions.useErrorBoundary,
      query: observer.getCurrentQuery()
    })) {
      throw result.error;
    }
    return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
  }
  function useQuery(arg1, arg2, arg3) {
    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
    return useBaseQuery(parsedOptions, QueryObserver);
  }
  function useMutation(arg1, arg2, arg3) {
    const options = parseMutationArgs(arg1, arg2, arg3);
    const queryClient2 = useQueryClient({
      context: options.context
    });
    const [observer] = reactExports.useState(() => new MutationObserver$1(queryClient2, options));
    reactExports.useEffect(() => {
      observer.setOptions(options);
    }, [observer, options]);
    const result = useSyncExternalStore$2(reactExports.useCallback((onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
    const mutate = reactExports.useCallback((variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop$1);
    }, [observer]);
    if (result.error && shouldThrowError(observer.options.useErrorBoundary, [result.error])) {
      throw result.error;
    }
    return {
      ...result,
      mutate,
      mutateAsync: result.mutate
    };
  }
  function noop$1() {
  }
  const queryClient$1 = new QueryClient();
  function getContext() {
    return {
      queryClient: queryClient$1
    };
  }
  function Provider({ children }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientProvider, { client: queryClient$1, children });
  }
  const TanStackRouterDevtools = function() {
    return null;
  };
  const ReactQueryDevtools = function() {
    return null;
  };
  function LayoutAddition() {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ReactQueryDevtools, { position: "bottom-right" });
  }
  function lt(c, { insertAt: a } = {}) {
    if (typeof document == "undefined") return;
    let t = document.head || document.getElementsByTagName("head")[0], s = document.createElement("style");
    s.type = "text/css", a === "top" && t.firstChild ? t.insertBefore(s, t.firstChild) : t.appendChild(s), s.styleSheet ? s.styleSheet.cssText = c : s.appendChild(document.createTextNode(c));
  }
  lt(`html[dir=ltr],[data-sonner-toaster][dir=ltr]{--toast-icon-margin-start: -3px;--toast-icon-margin-end: 4px;--toast-svg-margin-start: -1px;--toast-svg-margin-end: 0px;--toast-button-margin-start: auto;--toast-button-margin-end: 0;--toast-close-button-start: 0;--toast-close-button-end: unset;--toast-close-button-transform: translate(-35%, -35%)}html[dir=rtl],[data-sonner-toaster][dir=rtl]{--toast-icon-margin-start: 4px;--toast-icon-margin-end: -3px;--toast-svg-margin-start: 0px;--toast-svg-margin-end: -1px;--toast-button-margin-start: 0;--toast-button-margin-end: auto;--toast-close-button-start: unset;--toast-close-button-end: 0;--toast-close-button-transform: translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1: hsl(0, 0%, 99%);--gray2: hsl(0, 0%, 97.3%);--gray3: hsl(0, 0%, 95.1%);--gray4: hsl(0, 0%, 93%);--gray5: hsl(0, 0%, 90.9%);--gray6: hsl(0, 0%, 88.7%);--gray7: hsl(0, 0%, 85.8%);--gray8: hsl(0, 0%, 78%);--gray9: hsl(0, 0%, 56.1%);--gray10: hsl(0, 0%, 52.3%);--gray11: hsl(0, 0%, 43.5%);--gray12: hsl(0, 0%, 9%);--border-radius: 8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999}[data-sonner-toaster][data-x-position=right]{right:max(var(--offset),env(safe-area-inset-right))}[data-sonner-toaster][data-x-position=left]{left:max(var(--offset),env(safe-area-inset-left))}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translate(-50%)}[data-sonner-toaster][data-y-position=top]{top:max(var(--offset),env(safe-area-inset-top))}[data-sonner-toaster][data-y-position=bottom]{bottom:max(var(--offset),env(safe-area-inset-bottom))}[data-sonner-toast]{--y: translateY(100%);--lift-amount: calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;will-change:transform,opacity,height;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:none;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px #0000001a;width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}[data-sonner-toast][data-y-position=top]{top:0;--y: translateY(-100%);--lift: 1;--lift-amount: calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y: translateY(100%);--lift: -1;--lift-amount: calc(var(--lift) * var(--gap))}[data-sonner-toast] [data-description]{font-weight:400;line-height:1.4;color:inherit}[data-sonner-toast] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast] [data-icon]>*{flex-shrink:0}[data-sonner-toast] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast] [data-content]{display:flex;flex-direction:column;gap:2px}[data-sonner-toast] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:none;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}[data-sonner-toast] [data-button]:focus-visible{box-shadow:0 0 0 2px #0006}[data-sonner-toast] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toast][data-theme=dark] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;background:var(--gray1);color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast] [data-close-button]:focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}[data-sonner-toast] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]:before{content:"";position:absolute;left:0;right:0;height:100%;z-index:-1}[data-sonner-toast][data-y-position=top][data-swiping=true]:before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]:before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]:before{content:"";position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast]:after{content:"";position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y: translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale: var(--toasts-before) * .05 + 1;--y: translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y: translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y: translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y: translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y: translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]:before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount, 0px));transition:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation:swipe-out .2s ease-out forwards}@keyframes swipe-out{0%{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount)));opacity:1}to{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount) + var(--lift) * -100%));opacity:0}}@media (max-width: 600px){[data-sonner-toaster]{position:fixed;--mobile-offset: 16px;right:var(--mobile-offset);left:var(--mobile-offset);width:100%}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - 32px)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset)}[data-sonner-toaster][data-y-position=bottom]{bottom:20px}[data-sonner-toaster][data-y-position=top]{top:20px}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset);right:var(--mobile-offset);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg: #fff;--normal-border: var(--gray4);--normal-text: var(--gray12);--success-bg: hsl(143, 85%, 96%);--success-border: hsl(145, 92%, 91%);--success-text: hsl(140, 100%, 27%);--info-bg: hsl(208, 100%, 97%);--info-border: hsl(221, 91%, 91%);--info-text: hsl(210, 92%, 45%);--warning-bg: hsl(49, 100%, 97%);--warning-border: hsl(49, 91%, 91%);--warning-text: hsl(31, 92%, 45%);--error-bg: hsl(359, 100%, 97%);--error-border: hsl(359, 100%, 94%);--error-text: hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg: #fff;--normal-border: var(--gray3);--normal-text: var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1);--success-bg: hsl(150, 100%, 6%);--success-border: hsl(147, 100%, 12%);--success-text: hsl(150, 86%, 65%);--info-bg: hsl(215, 100%, 6%);--info-border: hsl(223, 100%, 12%);--info-text: hsl(216, 87%, 65%);--warning-bg: hsl(64, 100%, 6%);--warning-border: hsl(60, 100%, 12%);--warning-text: hsl(46, 87%, 65%);--error-bg: hsl(358, 76%, 10%);--error-border: hsl(357, 89%, 16%);--error-text: hsl(358, 100%, 81%)}[data-rich-colors=true] [data-sonner-toast][data-type=success],[data-rich-colors=true] [data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true] [data-sonner-toast][data-type=info],[data-rich-colors=true] [data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true] [data-sonner-toast][data-type=warning],[data-rich-colors=true] [data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true] [data-sonner-toast][data-type=error],[data-rich-colors=true] [data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size: 16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}to{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}to{opacity:.15}}@media (prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}
`);
  var St = (c) => {
    switch (c) {
      case "success":
        return zt;
      case "info":
        return Yt;
      case "warning":
        return At;
      case "error":
        return jt;
      default:
        return null;
    }
  }, Lt = Array(12).fill(0), kt = ({ visible: c }) => React.createElement("div", { className: "sonner-loading-wrapper", "data-visible": c }, React.createElement("div", { className: "sonner-spinner" }, Lt.map((a, t) => React.createElement("div", { className: "sonner-loading-bar", key: `spinner-bar-${t}` })))), zt = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, React.createElement("path", { fillRule: "evenodd", d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z", clipRule: "evenodd" })), At = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", height: "20", width: "20" }, React.createElement("path", { fillRule: "evenodd", d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z", clipRule: "evenodd" })), Yt = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, React.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z", clipRule: "evenodd" })), jt = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, React.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z", clipRule: "evenodd" }));
  var Bt = () => {
    let [c, a] = React.useState(false);
    return React.useEffect(() => {
      let t = () => {
        a(document.hidden);
      };
      return document.addEventListener("visibilitychange", t), () => window.removeEventListener("visibilitychange", t);
    }, []), c;
  };
  var dt = 1, ct = class {
    constructor() {
      this.subscribe = (a) => (this.subscribers.push(a), () => {
        let t = this.subscribers.indexOf(a);
        this.subscribers.splice(t, 1);
      });
      this.publish = (a) => {
        this.subscribers.forEach((t) => t(a));
      };
      this.addToast = (a) => {
        this.publish(a), this.toasts = [...this.toasts, a];
      };
      this.create = (a) => {
        var m;
        let { message: t, ...s } = a, y = typeof (a == null ? void 0 : a.id) == "number" || ((m = a.id) == null ? void 0 : m.length) > 0 ? a.id : dt++, g = this.toasts.find((r) => r.id === y), f = a.dismissible === void 0 ? true : a.dismissible;
        return g ? this.toasts = this.toasts.map((r) => r.id === y ? (this.publish({ ...r, ...a, id: y, title: t }), { ...r, ...a, id: y, dismissible: f, title: t }) : r) : this.addToast({ title: t, ...s, dismissible: f, id: y }), y;
      };
      this.dismiss = (a) => (a || this.toasts.forEach((t) => {
        this.subscribers.forEach((s) => s({ id: t.id, dismiss: true }));
      }), this.subscribers.forEach((t) => t({ id: a, dismiss: true })), a);
      this.message = (a, t) => this.create({ ...t, message: a });
      this.error = (a, t) => this.create({ ...t, message: a, type: "error" });
      this.success = (a, t) => this.create({ ...t, type: "success", message: a });
      this.info = (a, t) => this.create({ ...t, type: "info", message: a });
      this.warning = (a, t) => this.create({ ...t, type: "warning", message: a });
      this.loading = (a, t) => this.create({ ...t, type: "loading", message: a });
      this.promise = (a, t) => {
        if (!t) return;
        let s;
        t.loading !== void 0 && (s = this.create({ ...t, promise: a, type: "loading", message: t.loading, description: typeof t.description != "function" ? t.description : void 0 }));
        let y = a instanceof Promise ? a : a(), g = s !== void 0;
        return y.then((f) => {
          if (f && typeof f.ok == "boolean" && !f.ok) {
            g = false;
            let m = typeof t.error == "function" ? t.error(`HTTP error! status: ${f.status}`) : t.error, r = typeof t.description == "function" ? t.description(`HTTP error! status: ${f.status}`) : t.description;
            this.create({ id: s, type: "error", message: m, description: r });
          } else if (t.success !== void 0) {
            g = false;
            let m = typeof t.success == "function" ? t.success(f) : t.success, r = typeof t.description == "function" ? t.description(f) : t.description;
            this.create({ id: s, type: "success", message: m, description: r });
          }
        }).catch((f) => {
          if (t.error !== void 0) {
            g = false;
            let m = typeof t.error == "function" ? t.error(f) : t.error, r = typeof t.description == "function" ? t.description(f) : t.description;
            this.create({ id: s, type: "error", message: m, description: r });
          }
        }).finally(() => {
          var f;
          g && (this.dismiss(s), s = void 0), (f = t.finally) == null || f.call(t);
        }), s;
      };
      this.custom = (a, t) => {
        let s = (t == null ? void 0 : t.id) || dt++;
        return this.create({ jsx: a(s), id: s, ...t }), s;
      };
      this.subscribers = [], this.toasts = [];
    }
  }, T$1 = new ct(), Ft = (c, a) => {
    let t = (a == null ? void 0 : a.id) || dt++;
    return T$1.addToast({ title: c, ...a, id: t }), t;
  }, $t = Ft, Ut = Object.assign($t, { success: T$1.success, info: T$1.info, warning: T$1.warning, error: T$1.error, custom: T$1.custom, message: T$1.message, promise: T$1.promise, dismiss: T$1.dismiss, loading: T$1.loading });
  var _t = 3, Vt = "32px", Kt = 4e3, Xt = 356, Nt = 14, Jt = 20, Gt = 200;
  function j(...c) {
    return c.filter(Boolean).join(" ");
  }
  var qt = (c) => {
    var ht, bt, yt, vt, xt, Tt, wt;
    let { invert: a, toast: t, unstyled: s, interacting: y, setHeights: g, visibleToasts: f, heights: m, index: r, toasts: Z, expanded: F, removeToast: _2, closeButton: V, style: n, cancelButtonStyle: K, actionButtonStyle: tt, className: et = "", descriptionClassName: at = "", duration: X, position: B2, gap: $2 = Nt, loadingIcon: J, expandByDefault: z2, classNames: l, closeButtonAriaLabel: ot = "Close toast", pauseWhenPageIsHidden: M2 } = c, [H2, G] = React.useState(false), [q2, R2] = React.useState(false), [P, O2] = React.useState(false), [S2, L2] = React.useState(false), [st, i2] = React.useState(0), [p, h2] = React.useState(0), N2 = React.useRef(null), x2 = React.useRef(null), u = r === 0, U = r + 1 <= f, v = t.type, D2 = t.dismissible !== false, W = t.className || "", Dt = t.descriptionClassName || "", Q = React.useMemo(() => m.findIndex((o) => o.toastId === t.id) || 0, [m, t.id]), Pt = React.useMemo(() => {
      var o;
      return (o = t.closeButton) != null ? o : V;
    }, [t.closeButton, V]), ut = React.useMemo(() => t.duration || X || Kt, [t.duration, X]), nt = React.useRef(0), A2 = React.useRef(0), ft = React.useRef(0), Y = React.useRef(null), [mt, Ct] = B2.split("-"), pt = React.useMemo(() => m.reduce((o, d, b2) => b2 >= Q ? o : o + d.height, 0), [m, Q]), gt = Bt(), Ht = t.invert || a, rt = v === "loading";
    A2.current = React.useMemo(() => Q * $2 + pt, [Q, pt]), React.useEffect(() => {
      G(true);
    }, []), React.useLayoutEffect(() => {
      if (!H2) return;
      let o = x2.current, d = o.style.height;
      o.style.height = "auto";
      let b2 = o.getBoundingClientRect().height;
      o.style.height = d, h2(b2), g((k2) => k2.find((w2) => w2.toastId === t.id) ? k2.map((w2) => w2.toastId === t.id ? { ...w2, height: b2 } : w2) : [{ toastId: t.id, height: b2, position: t.position }, ...k2]);
    }, [H2, t.title, t.description, g, t.id]);
    let C2 = React.useCallback(() => {
      R2(true), i2(A2.current), g((o) => o.filter((d) => d.toastId !== t.id)), setTimeout(() => {
        _2(t);
      }, Gt);
    }, [t, _2, g, A2]);
    React.useEffect(() => {
      if (t.promise && v === "loading" || t.duration === 1 / 0 || t.type === "loading") return;
      let o, d = ut;
      return F || y || M2 && gt ? (() => {
        if (ft.current < nt.current) {
          let I = (/* @__PURE__ */ new Date()).getTime() - nt.current;
          d = d - I;
        }
        ft.current = (/* @__PURE__ */ new Date()).getTime();
      })() : (() => {
        nt.current = (/* @__PURE__ */ new Date()).getTime(), o = setTimeout(() => {
          var I;
          (I = t.onAutoClose) == null || I.call(t, t), C2();
        }, d);
      })(), () => clearTimeout(o);
    }, [F, y, z2, t, ut, C2, t.promise, v, M2, gt]), React.useEffect(() => {
      let o = x2.current;
      if (o) {
        let d = o.getBoundingClientRect().height;
        return h2(d), g((b2) => [{ toastId: t.id, height: d, position: t.position }, ...b2]), () => g((b2) => b2.filter((k2) => k2.toastId !== t.id));
      }
    }, [g, t.id]), React.useEffect(() => {
      t.delete && C2();
    }, [C2, t.delete]);
    function Rt() {
      return J ? React.createElement("div", { className: "sonner-loader", "data-visible": v === "loading" }, J) : React.createElement(kt, { visible: v === "loading" });
    }
    return React.createElement("li", { "aria-live": t.important ? "assertive" : "polite", "aria-atomic": "true", role: "status", tabIndex: 0, ref: x2, className: j(et, W, l == null ? void 0 : l.toast, (ht = t == null ? void 0 : t.classNames) == null ? void 0 : ht.toast, l == null ? void 0 : l[v], (bt = t == null ? void 0 : t.classNames) == null ? void 0 : bt[v]), "data-sonner-toast": "", "data-styled": !(t.jsx || t.unstyled || s), "data-mounted": H2, "data-promise": !!t.promise, "data-removed": q2, "data-visible": U, "data-y-position": mt, "data-x-position": Ct, "data-index": r, "data-front": u, "data-swiping": P, "data-dismissible": D2, "data-type": v, "data-invert": Ht, "data-swipe-out": S2, "data-expanded": !!(F || z2 && H2), style: { "--index": r, "--toasts-before": r, "--z-index": Z.length - r, "--offset": `${q2 ? st : A2.current}px`, "--initial-height": z2 ? "auto" : `${p}px`, ...n, ...t.style }, onPointerDown: (o) => {
      rt || !D2 || (N2.current = /* @__PURE__ */ new Date(), i2(A2.current), o.target.setPointerCapture(o.pointerId), o.target.tagName !== "BUTTON" && (O2(true), Y.current = { x: o.clientX, y: o.clientY }));
    }, onPointerUp: () => {
      var k2, I, w2, it;
      if (S2 || !D2) return;
      Y.current = null;
      let o = Number(((k2 = x2.current) == null ? void 0 : k2.style.getPropertyValue("--swipe-amount").replace("px", "")) || 0), d = (/* @__PURE__ */ new Date()).getTime() - ((I = N2.current) == null ? void 0 : I.getTime()), b2 = Math.abs(o) / d;
      if (Math.abs(o) >= Jt || b2 > 0.11) {
        i2(A2.current), (w2 = t.onDismiss) == null || w2.call(t, t), C2(), L2(true);
        return;
      }
      (it = x2.current) == null || it.style.setProperty("--swipe-amount", "0px"), O2(false);
    }, onPointerMove: (o) => {
      var Et;
      if (!Y.current || !D2) return;
      let d = o.clientY - Y.current.y, b2 = o.clientX - Y.current.x, I = (mt === "top" ? Math.min : Math.max)(0, d), w2 = o.pointerType === "touch" ? 10 : 2;
      Math.abs(I) > w2 ? (Et = x2.current) == null || Et.style.setProperty("--swipe-amount", `${d}px`) : Math.abs(b2) > w2 && (Y.current = null);
    } }, Pt && !t.jsx ? React.createElement("button", { "aria-label": ot, "data-disabled": rt, "data-close-button": true, onClick: rt || !D2 ? () => {
    } : () => {
      var o;
      C2(), (o = t.onDismiss) == null || o.call(t, t);
    }, className: j(l == null ? void 0 : l.closeButton, (yt = t == null ? void 0 : t.classNames) == null ? void 0 : yt.closeButton) }, React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }, React.createElement("line", { x1: "18", y1: "6", x2: "6", y2: "18" }), React.createElement("line", { x1: "6", y1: "6", x2: "18", y2: "18" }))) : null, t.jsx || React.isValidElement(t.title) ? t.jsx || t.title : React.createElement(React.Fragment, null, v || t.icon || t.promise ? React.createElement("div", { "data-icon": "" }, (t.promise || t.type === "loading") && !t.icon ? Rt() : null, t.icon || St(v)) : null, React.createElement("div", { "data-content": "" }, React.createElement("div", { "data-title": "", className: j(l == null ? void 0 : l.title, (vt = t == null ? void 0 : t.classNames) == null ? void 0 : vt.title) }, t.title), t.description ? React.createElement("div", { "data-description": "", className: j(at, Dt, l == null ? void 0 : l.description, (xt = t == null ? void 0 : t.classNames) == null ? void 0 : xt.description) }, t.description) : null), t.cancel ? React.createElement("button", { "data-button": true, "data-cancel": true, style: t.cancelButtonStyle || K, onClick: (o) => {
      var d;
      D2 && (C2(), (d = t.cancel) != null && d.onClick && t.cancel.onClick(o));
    }, className: j(l == null ? void 0 : l.cancelButton, (Tt = t == null ? void 0 : t.classNames) == null ? void 0 : Tt.cancelButton) }, t.cancel.label) : null, t.action ? React.createElement("button", { "data-button": "", style: t.actionButtonStyle || tt, onClick: (o) => {
      var d;
      (d = t.action) == null || d.onClick(o), !o.defaultPrevented && C2();
    }, className: j(l == null ? void 0 : l.actionButton, (wt = t == null ? void 0 : t.classNames) == null ? void 0 : wt.actionButton) }, t.action.label) : null));
  };
  function Mt() {
    if (typeof window == "undefined" || typeof document == "undefined") return "ltr";
    let c = document.documentElement.getAttribute("dir");
    return c === "auto" || !c ? window.getComputedStyle(document.documentElement).direction : c;
  }
  var ce = (c) => {
    let { invert: a, position: t = "bottom-right", hotkey: s = ["altKey", "KeyT"], expand: y, closeButton: g, className: f, offset: m, theme: r = "light", richColors: Z, duration: F, style: _2, visibleToasts: V = _t, toastOptions: n, dir: K = Mt(), gap: tt, loadingIcon: et, containerAriaLabel: at = "Notifications", pauseWhenPageIsHidden: X } = c, [B2, $2] = React.useState([]), J = React.useMemo(() => Array.from(new Set([t].concat(B2.filter((i2) => i2.position).map((i2) => i2.position)))), [B2, t]), [z2, l] = React.useState([]), [ot, M2] = React.useState(false), [H2, G] = React.useState(false), [q2, R2] = React.useState(r !== "system" ? r : typeof window != "undefined" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), P = React.useRef(null), O2 = s.join("+").replace(/Key/g, "").replace(/Digit/g, ""), S2 = React.useRef(null), L2 = React.useRef(false), st = React.useCallback((i2) => $2((p) => p.filter(({ id: h2 }) => h2 !== i2.id)), []);
    return React.useEffect(() => T$1.subscribe((i2) => {
      if (i2.dismiss) {
        $2((p) => p.map((h2) => h2.id === i2.id ? { ...h2, delete: true } : h2));
        return;
      }
      setTimeout(() => {
        reactDom.flushSync(() => {
          $2((p) => {
            let h2 = p.findIndex((N2) => N2.id === i2.id);
            return h2 !== -1 ? [...p.slice(0, h2), { ...p[h2], ...i2 }, ...p.slice(h2 + 1)] : [i2, ...p];
          });
        });
      });
    }), []), React.useEffect(() => {
      if (r !== "system") {
        R2(r);
        return;
      }
      r === "system" && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? R2("dark") : R2("light")), typeof window != "undefined" && window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches: i2 }) => {
        R2(i2 ? "dark" : "light");
      });
    }, [r]), React.useEffect(() => {
      B2.length <= 1 && M2(false);
    }, [B2]), React.useEffect(() => {
      let i2 = (p) => {
        var N2, x2;
        s.every((u) => p[u] || p.code === u) && (M2(true), (N2 = P.current) == null || N2.focus()), p.code === "Escape" && (document.activeElement === P.current || (x2 = P.current) != null && x2.contains(document.activeElement)) && M2(false);
      };
      return document.addEventListener("keydown", i2), () => document.removeEventListener("keydown", i2);
    }, [s]), React.useEffect(() => {
      if (P.current) return () => {
        S2.current && (S2.current.focus({ preventScroll: true }), S2.current = null, L2.current = false);
      };
    }, [P.current]), B2.length ? React.createElement("section", { "aria-label": `${at} ${O2}`, tabIndex: -1 }, J.map((i2, p) => {
      var x2;
      let [h2, N2] = i2.split("-");
      return React.createElement("ol", { key: i2, dir: K === "auto" ? Mt() : K, tabIndex: -1, ref: P, className: f, "data-sonner-toaster": true, "data-theme": q2, "data-rich-colors": Z, "data-y-position": h2, "data-x-position": N2, style: { "--front-toast-height": `${(x2 = z2[0]) == null ? void 0 : x2.height}px`, "--offset": typeof m == "number" ? `${m}px` : m || Vt, "--width": `${Xt}px`, "--gap": `${Nt}px`, ..._2 }, onBlur: (u) => {
        L2.current && !u.currentTarget.contains(u.relatedTarget) && (L2.current = false, S2.current && (S2.current.focus({ preventScroll: true }), S2.current = null));
      }, onFocus: (u) => {
        u.target instanceof HTMLElement && u.target.dataset.dismissible === "false" || L2.current || (L2.current = true, S2.current = u.relatedTarget);
      }, onMouseEnter: () => M2(true), onMouseMove: () => M2(true), onMouseLeave: () => {
        H2 || M2(false);
      }, onPointerDown: (u) => {
        u.target instanceof HTMLElement && u.target.dataset.dismissible === "false" || G(true);
      }, onPointerUp: () => G(false) }, B2.filter((u) => !u.position && p === 0 || u.position === i2).map((u, U) => {
        var v, D2;
        return React.createElement(qt, { key: u.id, index: U, toast: u, duration: (v = n == null ? void 0 : n.duration) != null ? v : F, className: n == null ? void 0 : n.className, descriptionClassName: n == null ? void 0 : n.descriptionClassName, invert: a, visibleToasts: V, closeButton: (D2 = n == null ? void 0 : n.closeButton) != null ? D2 : g, interacting: H2, position: i2, style: n == null ? void 0 : n.style, unstyled: n == null ? void 0 : n.unstyled, classNames: n == null ? void 0 : n.classNames, cancelButtonStyle: n == null ? void 0 : n.cancelButtonStyle, actionButtonStyle: n == null ? void 0 : n.actionButtonStyle, removeToast: st, toasts: B2.filter((W) => W.position == u.position), heights: z2.filter((W) => W.position == u.position), setHeights: l, expandByDefault: y, gap: tt, loadingIcon: et, expanded: ot, pauseWhenPageIsHidden: X });
      }));
    })) : null;
  };
  var define_process_env_default$2 = {};
  function parseWithDictionary(dictionary, value) {
    const result = {};
    const issues = [];
    for (const key2 in dictionary) {
      const schema2 = dictionary[key2];
      const prop = value[key2];
      const propResult = schema2["~standard"].validate(prop);
      if (propResult instanceof Promise) {
        throw new Error(`Validation must be synchronous, but ${key2} returned a Promise.`);
      }
      if (propResult.issues) {
        issues.push(...propResult.issues.map((issue) => ({
          ...issue,
          path: [
            key2,
            ...issue.path ?? []
          ]
        })));
        continue;
      }
      result[key2] = propResult.value;
    }
    if (issues.length) {
      return {
        issues
      };
    }
    return {
      value: result
    };
  }
  function createEnv(opts) {
    const runtimeEnv = opts.runtimeEnvStrict ?? opts.runtimeEnv ?? define_process_env_default$2;
    {
      for (const [key2, value] of Object.entries(runtimeEnv)) {
        if (value === "") {
          delete runtimeEnv[key2];
        }
      }
    }
    const skip = !!opts.skipValidation;
    if (skip) return runtimeEnv;
    const _client = typeof opts.client === "object" ? opts.client : {};
    const _server = typeof opts.server === "object" ? opts.server : {};
    const _shared = typeof opts.shared === "object" ? opts.shared : {};
    const isServer2 = opts.isServer ?? (typeof window === "undefined" || "Deno" in window);
    const finalSchema = isServer2 ? {
      ..._server,
      ..._shared,
      ..._client
    } : {
      ..._client,
      ..._shared
    };
    const parsed = parseWithDictionary(finalSchema, runtimeEnv);
    const onValidationError = opts.onValidationError ?? ((issues) => {
      console.error(" Invalid environment variables:", issues);
      throw new Error("Invalid environment variables");
    });
    const onInvalidAccess = opts.onInvalidAccess ?? (() => {
      throw new Error(" Attempted to access a server-side environment variable on the client");
    });
    if (parsed.issues) {
      return onValidationError(parsed.issues);
    }
    const isServerAccess = (prop) => {
      if (!opts.clientPrefix) return true;
      return !prop.startsWith(opts.clientPrefix) && !(prop in _shared);
    };
    const isValidServerAccess = (prop) => {
      return isServer2 || !isServerAccess(prop);
    };
    const ignoreProp = (prop) => {
      return prop === "__esModule" || prop === "$$typeof";
    };
    const extendedObj = (opts.extends ?? []).reduce((acc, curr) => {
      return Object.assign(acc, curr);
    }, {});
    const fullObj = Object.assign(parsed.value, extendedObj);
    const env2 = new Proxy(fullObj, {
      get(target, prop) {
        if (typeof prop !== "string") return void 0;
        if (ignoreProp(prop)) return void 0;
        if (!isValidServerAccess(prop)) return onInvalidAccess(prop);
        return Reflect.get(target, prop);
      }
    });
    return env2;
  }
  var util;
  (function(util2) {
    util2.assertEqual = (_2) => {
    };
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever(_x2) {
      throw new Error();
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
      const filtered = {};
      for (const k2 of validKeys) {
        filtered[k2] = obj[k2];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys2 = [];
      for (const key2 in object) {
        if (Object.prototype.hasOwnProperty.call(object, key2)) {
          keys2.push(key2);
        }
      }
      return keys2;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator2 = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator2);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_2, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType.array;
        }
        if (data === null) {
          return ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };
  const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  class ZodError extends Error {
    get errors() {
      return this.issues;
    }
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i2 = 0;
            while (i2 < issue.path.length) {
              const el = issue.path[i2];
              const terminal = i2 === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i2++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          const firstEl = sub.path[0];
          fieldErrors[firstEl] = fieldErrors[firstEl] || [];
          fieldErrors[firstEl].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  }
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };
  const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "bigint")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return { message };
  };
  let overrideErrorMap = errorMap;
  function setErrorMap(map) {
    overrideErrorMap = map;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }
  const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    if (issueData.message !== void 0) {
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message
      };
    }
    let errorMessage = "";
    const maps = errorMaps.filter((m) => !!m).slice().reverse();
    for (const map of maps) {
      errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: errorMessage
    };
  };
  const EMPTY_PATH = [];
  function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        // contextual error map is first priority
        ctx.schemaErrorMap,
        // then schema-bound map if available
        overrideMap,
        // then global override map
        overrideMap === errorMap ? void 0 : errorMap
        // then global default map
      ].filter((x2) => !!x2)
    });
    ctx.common.issues.push(issue);
  }
  class ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s of results) {
        if (s.status === "aborted")
          return INVALID;
        if (s.status === "dirty")
          status.dirty();
        arrayValue.push(s.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        const key2 = await pair.key;
        const value = await pair.value;
        syncPairs.push({
          key: key2,
          value
        });
      }
      return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key: key2, value } = pair;
        if (key2.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key2.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key2.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key2.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  }
  const INVALID = Object.freeze({
    status: "aborted"
  });
  const DIRTY = (value) => ({ status: "dirty", value });
  const OK = (value) => ({ status: "valid", value });
  const isAborted = (x2) => x2.status === "aborted";
  const isDirty = (x2) => x2.status === "dirty";
  const isValid = (x2) => x2.status === "valid";
  const isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
  })(errorUtil || (errorUtil = {}));
  class ParseInputLazyPath {
    constructor(parent, value, path, key2) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key2;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (Array.isArray(this._key)) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  }
  const handleResult = (ctx, result) => {
    if (isValid(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error = new ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      const { message } = params;
      if (iss.code === "invalid_enum_value") {
        return { message: message ?? ctx.defaultError };
      }
      if (typeof ctx.data === "undefined") {
        return { message: message ?? required_error ?? ctx.defaultError };
      }
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      return { message: message ?? invalid_type_error ?? ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  class ZodType {
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if (isAsync(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      const ctx = {
        common: {
          issues: [],
          async: (params == null ? void 0 : params.async) ?? false,
          contextualErrorMap: params == null ? void 0 : params.errorMap
        },
        path: (params == null ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const result = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    "~validate"(data) {
      var _a2, _b2;
      const ctx = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      if (!this["~standard"].async) {
        try {
          const result = this._parseSync({ data, path: [], parent: ctx });
          return isValid(result) ? {
            value: result.value
          } : {
            issues: ctx.common.issues
          };
        } catch (err2) {
          if ((_b2 = (_a2 = err2 == null ? void 0 : err2.message) == null ? void 0 : _a2.toLowerCase()) == null ? void 0 : _b2.includes("encountered")) {
            this["~standard"].async = true;
          }
          ctx.common = {
            issues: [],
            async: true
          };
        }
      }
      return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
        value: result.value
      } : {
        issues: ctx.common.issues
      });
    }
    async parseAsync(data, params) {
      const result = await this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params == null ? void 0 : params.errorMap,
          async: true
        },
        path: (params == null ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
      this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (data) => this["~validate"](data)
      };
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  const cuidRegex = /^c[^\s-]{8,}$/i;
  const cuid2Regex = /^[0-9a-z]+$/;
  const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  const nanoidRegex = /^[a-z0-9_-]{21}$/i;
  const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  let emojiRegex;
  const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
  const dateRegex = new RegExp(`^${dateRegexSource}$`);
  function timeRegexSource(args) {
    let secondsRegexSource = `[0-5]\\d`;
    if (args.precision) {
      secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
      secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
    }
    const secondsQuantifier = args.precision ? "+" : "?";
    return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
  }
  function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
  }
  function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
      opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
  }
  function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt))
      return false;
    try {
      const [header] = jwt.split(".");
      if (!header)
        return false;
      const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
      const decoded = JSON.parse(atob(base64));
      if (typeof decoded !== "object" || decoded === null)
        return false;
      if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
        return false;
      if (!decoded.alg)
        return false;
      if (alg && decoded.alg !== alg)
        return false;
      return true;
    } catch {
      return false;
    }
  }
  function isValidCidr(ip, version) {
    if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
      return true;
    }
    return false;
  }
  class ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "nanoid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "duration",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "jwt") {
          if (!isValidJWT(input.data, check.alg)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "jwt",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cidr") {
          if (!isValidCidr(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cidr",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64url") {
          if (!base64urlRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    base64url(message) {
      return this._addCheck({
        kind: "base64url",
        ...errorUtil.errToObj(message)
      });
    }
    jwt(options) {
      return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    cidr(options) {
      return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
        offset: (options == null ? void 0 : options.offset) ?? false,
        local: (options == null ? void 0 : options.local) ?? false,
        ...errorUtil.errToObj(options == null ? void 0 : options.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
        ...errorUtil.errToObj(options == null ? void 0 : options.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options == null ? void 0 : options.position,
        ...errorUtil.errToObj(options == null ? void 0 : options.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
      let min2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min2 === null || ch.value > min2)
            min2 = ch.value;
        }
      }
      return min2;
    }
    get maxLength() {
      let max2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return max2;
    }
  }
  ZodString.create = (params) => {
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: (params == null ? void 0 : params.coerce) ?? false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / 10 ** decCount;
  }
  class ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min2 === null || ch.value > min2)
            min2 = ch.value;
        }
      }
      return min2;
    }
    get maxValue() {
      let max2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return max2;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max2 = null;
      let min2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min2 === null || ch.value > min2)
            min2 = ch.value;
        } else if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return Number.isFinite(min2) && Number.isFinite(max2);
    }
  }
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: (params == null ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  class ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        try {
          input.data = BigInt(input.data);
        } catch {
          return this._getInvalidInput(input);
        }
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        return this._getInvalidInput(input);
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min2 === null || ch.value > min2)
            min2 = ch.value;
        }
      }
      return min2;
    }
    get maxValue() {
      let max2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return max2;
    }
  }
  ZodBigInt.create = (params) => {
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: (params == null ? void 0 : params.coerce) ?? false,
      ...processCreateParams(params)
    });
  };
  class ZodBoolean extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: (params == null ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  class ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (Number.isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min2 === null || ch.value > min2)
            min2 = ch.value;
        }
      }
      return min2 != null ? new Date(min2) : null;
    }
    get maxDate() {
      let max2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return max2 != null ? new Date(max2) : null;
    }
  }
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: (params == null ? void 0 : params.coerce) || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  class ZodSymbol extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  class ZodUndefined extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  class ZodNull extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  class ZodAny extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  class ZodUnknown extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  class ZodNever extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  }
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  class ZodVoid extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  class ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i2) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i2) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodArray.create = (schema2, params) => {
    return new ZodArray({
      type: schema2,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema2) {
    if (schema2 instanceof ZodObject) {
      const newShape = {};
      for (const key2 in schema2.shape) {
        const fieldSchema = schema2.shape[key2];
        newShape[key2] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema2._def,
        shape: () => newShape
      });
    } else if (schema2 instanceof ZodArray) {
      return new ZodArray({
        ...schema2._def,
        type: deepPartialify(schema2.element)
      });
    } else if (schema2 instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema2.unwrap()));
    } else if (schema2 instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema2.unwrap()));
    } else if (schema2 instanceof ZodTuple) {
      return ZodTuple.create(schema2.items.map((item) => deepPartialify(item)));
    } else {
      return schema2;
    }
  }
  class ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys2 = util.objectKeys(shape);
      this._cached = { shape, keys: keys2 };
      return this._cached;
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key2 in ctx.data) {
          if (!shapeKeys.includes(key2)) {
            extraKeys.push(key2);
          }
        }
      }
      const pairs = [];
      for (const key2 of shapeKeys) {
        const keyValidator = shape[key2];
        const value = ctx.data[key2];
        pairs.push({
          key: { status: "valid", value: key2 },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key2)),
          alwaysSet: key2 in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key2 of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key2 },
              value: { status: "valid", value: ctx.data[key2] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key2 of extraKeys) {
          const value = ctx.data[key2];
          pairs.push({
            key: { status: "valid", value: key2 },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key2)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key2 in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key2 = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key: key2,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            var _a2, _b2;
            const defaultError = ((_b2 = (_a2 = this._def).errorMap) == null ? void 0 : _b2.call(_a2, issue, ctx).message) ?? ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: errorUtil.errToObj(message).message ?? defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key2, schema2) {
      return this.augment({ [key2]: schema2 });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
      return new ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      for (const key2 of util.objectKeys(mask)) {
        if (mask[key2] && this.shape[key2]) {
          shape[key2] = this.shape[key2];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      for (const key2 of util.objectKeys(this.shape)) {
        if (!mask[key2]) {
          shape[key2] = this.shape[key2];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      for (const key2 of util.objectKeys(this.shape)) {
        const fieldSchema = this.shape[key2];
        if (mask && !mask[key2]) {
          newShape[key2] = fieldSchema;
        } else {
          newShape[key2] = fieldSchema.optional();
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      for (const key2 of util.objectKeys(this.shape)) {
        if (mask && !mask[key2]) {
          newShape[key2] = this.shape[key2];
        } else {
          const fieldSchema = this.shape[key2];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key2] = newField;
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  }
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  class ZodUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [type.value];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return util.objectValues(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [void 0];
    } else if (type instanceof ZodNull) {
      return [null];
    } else if (type instanceof ZodOptional) {
      return [void 0, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodNullable) {
      return [null, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodBranded) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodReadonly) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodCatch) {
      return getDiscriminator(type._def.innerType);
    } else {
      return [];
    }
  };
  class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  }
  function mergeValues(a, b2) {
    const aType = getParsedType(a);
    const bType = getParsedType(b2);
    if (a === b2) {
      return { valid: true, data: a };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b2);
      const sharedKeys = util.objectKeys(a).filter((key2) => bKeys.indexOf(key2) !== -1);
      const newObj = { ...a, ...b2 };
      for (const key2 of sharedKeys) {
        const sharedValue = mergeValues(a[key2], b2[key2]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key2] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a.length !== b2.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0; index < a.length; index++) {
        const itemA = a[index];
        const itemB = b2[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b2) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }
  class ZodIntersection extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  }
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  class ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema2 = this._def.items[itemIndex] || this._def.rest;
        if (!schema2)
          return null;
        return schema2._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x2) => !!x2);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  }
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  class ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key2 in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, key2)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key2], ctx.path, key2)),
          alwaysSet: key2 in ctx.data
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  }
  class ZodMap extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key2, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key2 = await pair.key;
            const value = await pair.value;
            if (key2.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key2.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key2.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key2 = pair.key;
          const value = pair.value;
          if (key2.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key2.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key2.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  }
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  class ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  class ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), errorMap].filter((x2) => !!x2),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), errorMap].filter((x2) => !!x2),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me = this;
        return OK(async function(...args) {
          const error = new ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return OK(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  }
  class ZodLazy extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  }
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  class ZodLiteral extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  }
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  class ZodEnum extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(this._def.values);
      }
      if (!this._cache.has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  }
  ZodEnum.create = createZodEnum;
  class ZodNativeEnum extends ZodType {
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(util.getValidEnumValues(this._def.values));
      }
      if (!this._cache.has(input.data)) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  class ZodPromise extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  }
  ZodPromise.create = (schema2, params) => {
    return new ZodPromise({
      type: schema2,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  class ZodEffects extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base2 = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base2))
            return INVALID;
          const result = effect.transform(base2.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base2) => {
            if (!isValid(base2))
              return INVALID;
            return Promise.resolve(effect.transform(base2.value, checkCtx)).then((result) => ({
              status: status.value,
              value: result
            }));
          });
        }
      }
      util.assertNever(effect);
    }
  }
  ZodEffects.create = (schema2, effect, params) => {
    return new ZodEffects({
      schema: schema2,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema2, params) => {
    return new ZodEffects({
      schema: schema2,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  class ZodOptional extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  class ZodNullable extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  class ZodDefault extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  class ZodCatch extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  class ZodNaN extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  }
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  const BRAND = Symbol("zod_brand");
  class ZodBranded extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  class ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b2) {
      return new ZodPipeline({
        in: a,
        out: b2,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  }
  class ZodReadonly extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze2 = (data) => {
        if (isValid(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return isAsync(result) ? result.then((data) => freeze2(data)) : freeze2(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  function cleanParams(params, data) {
    const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
    const p2 = typeof p === "string" ? { message: p } : p;
    return p2;
  }
  function custom(check, _params = {}, fatal) {
    if (check)
      return ZodAny.create().superRefine((data, ctx) => {
        const r = check(data);
        if (r instanceof Promise) {
          return r.then((r2) => {
            if (!r2) {
              const params = cleanParams(_params, data);
              const _fatal = params.fatal ?? fatal ?? true;
              ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
            }
          });
        }
        if (!r) {
          const params = cleanParams(_params, data);
          const _fatal = params.fatal ?? fatal ?? true;
          ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
        }
        return;
      });
    return ZodAny.create();
  }
  const late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  const instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom((data) => data instanceof cls, params);
  const stringType = ZodString.create;
  const numberType = ZodNumber.create;
  const nanType = ZodNaN.create;
  const bigIntType = ZodBigInt.create;
  const booleanType = ZodBoolean.create;
  const dateType = ZodDate.create;
  const symbolType = ZodSymbol.create;
  const undefinedType = ZodUndefined.create;
  const nullType = ZodNull.create;
  const anyType = ZodAny.create;
  const unknownType = ZodUnknown.create;
  const neverType = ZodNever.create;
  const voidType = ZodVoid.create;
  const arrayType = ZodArray.create;
  const objectType = ZodObject.create;
  const strictObjectType = ZodObject.strictCreate;
  const unionType = ZodUnion.create;
  const discriminatedUnionType = ZodDiscriminatedUnion.create;
  const intersectionType = ZodIntersection.create;
  const tupleType = ZodTuple.create;
  const recordType = ZodRecord.create;
  const mapType = ZodMap.create;
  const setType = ZodSet.create;
  const functionType = ZodFunction.create;
  const lazyType = ZodLazy.create;
  const literalType = ZodLiteral.create;
  const enumType = ZodEnum.create;
  const nativeEnumType = ZodNativeEnum.create;
  const promiseType = ZodPromise.create;
  const effectsType = ZodEffects.create;
  const optionalType = ZodOptional.create;
  const nullableType = ZodNullable.create;
  const preprocessType = ZodEffects.createWithPreprocess;
  const pipelineType = ZodPipeline.create;
  const ostring = () => stringType().optional();
  const onumber = () => numberType().optional();
  const oboolean = () => booleanType().optional();
  const coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  const NEVER = INVALID;
  const z$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    BRAND,
    DIRTY,
    EMPTY_PATH,
    INVALID,
    NEVER,
    OK,
    ParseStatus,
    Schema: ZodType,
    ZodAny,
    ZodArray,
    ZodBigInt,
    ZodBoolean,
    ZodBranded,
    ZodCatch,
    ZodDate,
    ZodDefault,
    ZodDiscriminatedUnion,
    ZodEffects,
    ZodEnum,
    ZodError,
    get ZodFirstPartyTypeKind() {
      return ZodFirstPartyTypeKind;
    },
    ZodFunction,
    ZodIntersection,
    ZodIssueCode,
    ZodLazy,
    ZodLiteral,
    ZodMap,
    ZodNaN,
    ZodNativeEnum,
    ZodNever,
    ZodNull,
    ZodNullable,
    ZodNumber,
    ZodObject,
    ZodOptional,
    ZodParsedType,
    ZodPipeline,
    ZodPromise,
    ZodReadonly,
    ZodRecord,
    ZodSchema: ZodType,
    ZodSet,
    ZodString,
    ZodSymbol,
    ZodTransformer: ZodEffects,
    ZodTuple,
    ZodType,
    ZodUndefined,
    ZodUnion,
    ZodUnknown,
    ZodVoid,
    addIssueToContext,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    coerce,
    custom,
    date: dateType,
    datetimeRegex,
    defaultErrorMap: errorMap,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    enum: enumType,
    function: functionType,
    getErrorMap,
    getParsedType,
    instanceof: instanceOfType,
    intersection: intersectionType,
    isAborted,
    isAsync,
    isDirty,
    isValid,
    late,
    lazy: lazyType,
    literal: literalType,
    makeIssue,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    null: nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    get objectUtil() {
      return objectUtil;
    },
    oboolean,
    onumber,
    optional: optionalType,
    ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    quotelessJson,
    record: recordType,
    set: setType,
    setErrorMap,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    undefined: undefinedType,
    union: unionType,
    unknown: unknownType,
    get util() {
      return util;
    },
    void: voidType
  }, Symbol.toStringTag, { value: "Module" }));
  const __vite_import_meta_env__$3 = { "BASE_URL": "/", "DEV": false, "MODE": "production", "PROD": true, "SSR": false, "VITE_ASSOCIATION_VIEW_URL_KEY": "associationsViewUrl", "VITE_AUTH_PORTAL_KEY": "portalSettings", "VITE_AUTH_TOKEN_KEY": "testToken", "VITE_AUTH_USER_KEY": "testUser", "VITE_COOKIE_EXPIRE": "7", "VITE_DATA_SOURCE_SET": "false", "VITE_DEV": "false", "VITE_HUBSPOT_DEFAULT_OBJECT_IDS": '{"contacts":"0-1","companies":"0-2","deals":"0-3","tickets":"0-5"}', "VITE_LOGIN_DETAILS": "testLogin", "VITE_NODE_ENV": "production", "VITE_NOTE_INTERVAL_TIME": "10000", "VITE_PORTAL": "portal", "VITE_PORTAL_URL": "https://48715351.hs-sites.com", "VITE_PUBLIC_REST_API_ENDPOINT": "https://app.dev.one.digitalwoods.io", "VITE_ROUTE_MENU_CONFIG_KEY": "routeMenuConfig", "VITE_TABLE_PAGE_LIMIT": "10", "VITE_TWO_FA": "testTWOFA" };
  const env$1 = createEnv({
    server: {
      SERVER_URL: stringType().url().optional()
    },
    /**
     * The prefix that client-side variables must have. This is enforced both at
     * a type-level and at runtime.
     */
    clientPrefix: "VITE_",
    client: {
      VITE_NODE_ENV: enumType(["development", "production"]).default("development"),
      VITE_APP_TITLE: stringType().min(1).optional(),
      VITE_DEV: anyType(),
      VITE_PORTAL_URL: stringType().url(),
      VITE_PUBLIC_REST_API_ENDPOINT: stringType().url(),
      VITE_LOGIN_DETAILS: stringType(),
      VITE_SUBSCRIPTION_TYPE: stringType(),
      VITE_TWO_FA: stringType(),
      VITE_PORTAL: stringType(),
      VITE_AUTH_TOKEN_KEY: stringType(),
      VITE_AUTH_USER_KEY: stringType(),
      VITE_AUTH_PORTAL_KEY: stringType(),
      VITE_ROUTE_MENU_CONFIG_KEY: stringType(),
      VITE_ASSOCIATION_VIEW_URL_KEY: stringType(),
      VITE_COOKIE_EXPIRE: stringType(),
      VITE_DATA_SOURCE_SET: anyType(),
      VITE_NOTE_INTERVAL_TIME: stringType(),
      VITE_TABLE_PAGE_LIMIT: stringType(),
      VITE_HUBSPOT_DEFAULT_OBJECT_IDS: anyType()
    },
    /**
     * What object holds the environment variables at runtime. This is usually
     * `process.env` or `import.meta.env`.
     */
    runtimeEnv: __vite_import_meta_env__$3
  });
  const primarycolor = "";
  const secondarycolor = "";
  const dataSourceSet = false;
  const hubId$1 = 48715351;
  const apiBaseUrlOption = "";
  const userData$1 = {
    "email": "manab@digitalwoods.io"
  };
  const objectList$1 = [];
  const showCompanyNameOption$1 = true;
  const showSidebarCtaOption$1 = true;
  const addHomeTabOption$1 = null;
  const sidebarMenuOptions$1 = [
    {
      "homeCardsView": "grid",
      "icon": '    <svg      viewBox="0 0 1024 1024"      fill="currentColor"      height="1em"      width="1em"      {...props}    >      <path d="M946.5 505L560.1 118.8l-25.9-25.9a31.5 31.5 0 00-44.4 0L77.5 505a63.9 63.9 0 00-18.8 46c.4 35.2 29.7 63.3 64.9 63.3h42.5V940h691.8V614.3h43.4c17.1 0 33.2-6.7 45.3-18.8a63.6 63.6 0 0018.7-45.3c0-17-6.7-33.1-18.8-45.2zM568 868H456V664h112v204zm217.9-325.7V868H632V640c0-22.1-17.9-40-40-40H432c-22.1 0-40 17.9-40 40v228H238.1V542.3h-96l370-369.7 23.1 23.1L882 542.3h-96.1z" />    </svg>',
      "tabName": "User Home"
    },
    {
      "associateObjectName": null,
      "associateObjectProperties": null,
      "companyAsMediator": true,
      "hubspotObjectId": 4,
      "hubspotObjectTypeId": "0-3",
      "icon": '    <svg      viewBox="0 0 24 24"      fill="currentColor"      height="1em"      width="1em"      {...props}    >      <path fill="none" d="M0 0h24v24H0z" />      <path d="M19 7h5v2h-5V7zm-2 5h7v2h-7v-2zm3 5h4v2h-4v-2zM2 22a8 8 0 1116 0h-2a6 6 0 10-12 0H2zm8-9c-3.315 0-6-2.685-6-6s2.685-6 6-6 6 2.685 6 6-2.685 6-6 6zm0-2c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4z" />    </svg>',
      "iframeProperties": [
        {
          "button_name": "View",
          "on_click_action": "showIframe",
          "properties_value": "Label",
          "property_value_show_as": "link"
        }
      ],
      "label": "Primary Company Deals",
      "listObjectName": "Primary Company Deals",
      "listObjectProperties": "dealname,dealstage,amount",
      "objectDescription": null,
      "objectType": "HUBSPOT_DEFINED",
      "objectUserProperties": [
        {
          "button_name": "View",
          "on_click_action": "showIframe",
          "properties_value": "Label",
          "property_type": "company",
          "property_value_show_as": "simpleText"
        }
      ],
      "objectUserPropertiesView": "grid",
      "pipeLineId": "0",
      "propertyName": null,
      "showIframe": false,
      "specPipeLine": false
    },
    {
      "associateObjectName": null,
      "associateObjectProperties": null,
      "companyAsMediator": true,
      "hubspotObjectId": 4,
      "hubspotObjectTypeId": "0-3",
      "icon": '    <svg      viewBox="0 0 24 24"      fill="currentColor"      height="1em"      width="1em"      {...props}    >      <path fill="none" d="M0 0h24v24H0z" />      <path d="M19 7h5v2h-5V7zm-2 5h7v2h-7v-2zm3 5h4v2h-4v-2zM2 22a8 8 0 1116 0h-2a6 6 0 10-12 0H2zm8-9c-3.315 0-6-2.685-6-6s2.685-6 6-6 6 2.685 6 6-2.685 6-6 6zm0-2c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4z" />    </svg>',
      "iframeProperties": [
        {
          "button_name": "View",
          "on_click_action": "showIframe",
          "properties_value": "Label",
          "property_value_show_as": "link"
        }
      ],
      "label": "Pipeline Primary Company Deals",
      "listObjectName": "Pipeline Primary Company Deals",
      "listObjectProperties": "dealname,dealstage,amount",
      "objectDescription": "",
      "objectType": "HUBSPOT_DEFINED",
      "objectUserProperties": [
        {
          "button_name": "View",
          "on_click_action": "showIframe",
          "properties_value": "Label",
          "property_type": "company",
          "property_value_show_as": "simpleText"
        }
      ],
      "objectUserPropertiesView": "grid",
      "pipeLineId": "default",
      "propertyName": null,
      "showIframe": false,
      "specPipeLine": true
    },
    {
      "associateObjectName": null,
      "associateObjectProperties": null,
      "companyAsMediator": false,
      "hubspotObjectId": 4,
      "hubspotObjectTypeId": "0-3",
      "icon": '    <svg      viewBox="0 0 24 24"      fill="currentColor"      height="1em"      width="1em"      {...props}    >      <path fill="none" d="M0 0h24v24H0z" />      <path d="M19 7h5v2h-5V7zm-2 5h7v2h-7v-2zm3 5h4v2h-4v-2zM2 22a8 8 0 1116 0h-2a6 6 0 10-12 0H2zm8-9c-3.315 0-6-2.685-6-6s2.685-6 6-6 6 2.685 6 6-2.685 6-6 6zm0-2c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4z" />    </svg>',
      "iframeProperties": [
        {
          "button_name": "View",
          "on_click_action": "showIframe",
          "properties_value": "Label",
          "property_value_show_as": "link"
        }
      ],
      "label": "Direct Deals",
      "listObjectName": "Direct Deals",
      "listObjectProperties": "dealname,dealstage,amount",
      "objectDescription": null,
      "objectType": "HUBSPOT_DEFINED",
      "objectUserProperties": [
        {
          "button_name": "View",
          "on_click_action": "showIframe",
          "properties_value": "Label",
          "property_type": "company",
          "property_value_show_as": "simpleText"
        }
      ],
      "objectUserPropertiesView": "grid",
      "pipeLineId": "0",
      "propertyName": null,
      "showIframe": false,
      "specPipeLine": false
    },
    {
      "associateObjectName": null,
      "associateObjectProperties": null,
      "companyAsMediator": true,
      "hubspotObjectId": 4,
      "hubspotObjectTypeId": "0-5",
      "icon": '    <svg      xmlns="http://www.w3.org/2000/svg"      viewBox="0 0 16 16"      width="1em"      height="1em"      {...props}    >      <path        fill="none"        stroke="currentColor"        strokeLinejoin="round"        d="M6 10h2.5c.55 0 1-.45 1-1s-.45-1-1-1h-1c-.55 0-1-.45-1-1s.45-1 1-1H10M8 4.5v1.167M8 9.5v2M13.5 5v8.5H3M2.5 11V2.5H12"      ></path>    </svg>',
      "iframeProperties": [
        {
          "button_name": "View",
          "on_click_action": "showIframe",
          "properties_value": "Label",
          "property_value_show_as": "link"
        }
      ],
      "label": "Primary Company Tickets",
      "listObjectName": "Primary Company Tickets",
      "listObjectProperties": "dealname,dealstage,amount",
      "objectDescription": null,
      "objectType": "HUBSPOT_DEFINED",
      "objectUserProperties": [
        {
          "button_name": "View",
          "on_click_action": "showIframe",
          "properties_value": "Label",
          "property_type": "company",
          "property_value_show_as": "simpleText"
        }
      ],
      "objectUserPropertiesView": "grid",
      "pipeLineId": "0",
      "propertyName": null,
      "showIframe": false,
      "specPipeLine": false
    },
    {
      "associateObjectName": null,
      "associateObjectProperties": null,
      "companyAsMediator": false,
      "hubspotObjectId": 4,
      "hubspotObjectTypeId": "0-5",
      "icon": '    <svg      xmlns="http://www.w3.org/2000/svg"      viewBox="0 0 16 16"      width="1em"      height="1em"      {...props}    >      <path        fill="none"        stroke="currentColor"        strokeLinejoin="round"        d="M6 10h2.5c.55 0 1-.45 1-1s-.45-1-1-1h-1c-.55 0-1-.45-1-1s.45-1 1-1H10M8 4.5v1.167M8 9.5v2M13.5 5v8.5H3M2.5 11V2.5H12"      ></path>    </svg>',
      "iframeProperties": [
        {
          "button_name": "View",
          "on_click_action": "showIframe",
          "properties_value": "Label",
          "property_value_show_as": "link"
        }
      ],
      "label": "Direct Tickets",
      "listObjectName": "Direct Tickets",
      "listObjectProperties": "dealname,dealstage,amount",
      "objectDescription": null,
      "objectType": "HUBSPOT_DEFINED",
      "objectUserProperties": [
        {
          "button_name": "View",
          "on_click_action": "showIframe",
          "properties_value": "Label",
          "property_type": "company",
          "property_value_show_as": "simpleText"
        }
      ],
      "objectUserPropertiesView": "grid",
      "pipeLineId": "0",
      "propertyName": null,
      "showIframe": false,
      "specPipeLine": false
    },
    {
      "associateObjectName": null,
      "associateObjectProperties": null,
      "companyAsMediator": true,
      "hubspotObjectId": 4,
      "hubspotObjectTypeId": "0-2",
      "icon": '    <svg      xmlns="http://www.w3.org/2000/svg"      viewBox="0 0 16 16"      width="1em"      height="1em"      {...props}    >      <path        fill="none"        stroke="currentColor"        strokeLinejoin="round"        d="M6 10h2.5c.55 0 1-.45 1-1s-.45-1-1-1h-1c-.55 0-1-.45-1-1s.45-1 1-1H10M8 4.5v1.167M8 9.5v2M13.5 5v8.5H3M2.5 11V2.5H12"      ></path>    </svg>',
      "iframeProperties": [
        {
          "button_name": "View",
          "on_click_action": "showIframe",
          "properties_value": "Label",
          "property_value_show_as": "link"
        }
      ],
      "label": "Primary Companies",
      "listObjectName": "Primary Companies",
      "listObjectProperties": "dealname,dealstage,amount",
      "objectDescription": null,
      "objectType": "HUBSPOT_DEFINED",
      "objectUserProperties": [
        {
          "button_name": "View",
          "on_click_action": "showIframe",
          "properties_value": "Label",
          "property_type": "company",
          "property_value_show_as": "simpleText"
        }
      ],
      "objectUserPropertiesView": "grid",
      "pipeLineId": "0",
      "propertyName": null,
      "showIframe": false,
      "specPipeLine": false
    },
    {
      "associateObjectName": null,
      "associateObjectProperties": null,
      "companyAsMediator": false,
      "hubspotObjectId": 4,
      "hubspotObjectTypeId": "0-2",
      "icon": '    <svg      xmlns="http://www.w3.org/2000/svg"      viewBox="0 0 16 16"      width="1em"      height="1em"      {...props}    >      <path        fill="none"        stroke="currentColor"        strokeLinejoin="round"        d="M6 10h2.5c.55 0 1-.45 1-1s-.45-1-1-1h-1c-.55 0-1-.45-1-1s.45-1 1-1H10M8 4.5v1.167M8 9.5v2M13.5 5v8.5H3M2.5 11V2.5H12"      ></path>    </svg>',
      "iframeProperties": [
        {
          "button_name": "View",
          "on_click_action": "showIframe",
          "properties_value": "Label",
          "property_value_show_as": "link"
        }
      ],
      "label": "Direct Companies",
      "listObjectName": "Direct Companies",
      "listObjectProperties": "dealname,dealstage,amount",
      "objectDescription": null,
      "objectType": "HUBSPOT_DEFINED",
      "objectUserProperties": [
        {
          "button_name": "View",
          "on_click_action": "showIframe",
          "properties_value": "Label",
          "property_type": "company",
          "property_value_show_as": "simpleText"
        }
      ],
      "objectUserPropertiesView": "grid",
      "pipeLineId": "0",
      "propertyName": null,
      "showIframe": false,
      "specPipeLine": false
    },
    {
      "associateObjectName": null,
      "associateObjectProperties": null,
      "companyAsMediator": false,
      "hubspotObjectId": null,
      "hubspotObjectTypeId": "2-38796726",
      "icon": '    <svg      viewBox="0 0 24 24"      fill="currentColor"      height="1em"      width="1em"      {...props}    >      <path d="M20.315 4.319l-8.69 8.719-3.31-3.322-2.069 2.076 5.379 5.398 10.76-10.796zM5.849 14.689L0 19.682h24l-5.864-4.991h-3.2l-1.024.896h3.584l3.072 2.815H3.417l3.072-2.815h2.688l-.896-.896z" />    </svg>',
      "iframeProperties": [
        {
          "button_name": "View",
          "on_click_action": "showIframe",
          "properties_value": "Label",
          "property_value_show_as": "link"
        }
      ],
      "label": "Sites",
      "listObjectName": "Sites",
      "listObjectProperties": null,
      "objectDescription": null,
      "objectType": "USER_DEFINED",
      "objectUserProperties": [
        {
          "button_name": "View",
          "on_click_action": "showIframe",
          "properties_value": "Label",
          "property_type": "company",
          "property_value_show_as": "simpleText"
        }
      ],
      "objectUserPropertiesView": "grid",
      "pipeLineId": "0",
      "propertyName": null,
      "showIframe": false,
      "specPipeLine": false
    },
    {
      "associateObjectName": null,
      "associateObjectProperties": null,
      "companyAsMediator": false,
      "hubspotObjectId": null,
      "hubspotObjectTypeId": "2-38796732",
      "icon": '    <svg      viewBox="0 0 24 24"      fill="currentColor"      height="1em"      width="1em"      {...props}    >      <path d="M20.315 4.319l-8.69 8.719-3.31-3.322-2.069 2.076 5.379 5.398 10.76-10.796zM5.849 14.689L0 19.682h24l-5.864-4.991h-3.2l-1.024.896h3.584l3.072 2.815H3.417l3.072-2.815h2.688l-.896-.896z" />    </svg>',
      "iframeProperties": [
        {
          "button_name": "View",
          "on_click_action": "showIframe",
          "properties_value": "Label",
          "property_value_show_as": "link"
        }
      ],
      "label": "Jobs",
      "listObjectName": "Jobs",
      "listObjectProperties": null,
      "objectDescription": null,
      "objectType": "USER_DEFINED",
      "objectUserProperties": [
        {
          "button_name": "View",
          "on_click_action": "showIframe",
          "properties_value": "Label",
          "property_type": "company",
          "property_value_show_as": "simpleText"
        }
      ],
      "objectUserPropertiesView": "grid",
      "pipeLineId": "0",
      "propertyName": null,
      "showIframe": false,
      "specPipeLine": false
    }
  ];
  const moduleIframeListOptions$1 = [];
  const sidebarListDataOption$1 = [
    {
      "associateObjectName": null,
      "associateObjectProperties": null,
      "companyAsMediator": true,
      "hubspotObjectId": 15,
      "hubspotObjectTypeId": "0-3",
      "icon": null,
      "iframeProperties": [
        {
          "button_name": "View",
          "on_click_action": "showIframe",
          "properties_value": "Label",
          "property_value_show_as": "button"
        }
      ],
      "label": "Deals Direct",
      "listObjectName": "Deals Direct",
      "listObjectProperties": "subject,hs_pipeline_stage,hs_pipeline",
      "objectType": "HUBSPOT_DEFINED",
      "pipeLineId": "0",
      "propertyName": null,
      "showIframe": false,
      "specPipeLine": false
    },
    {
      "associateObjectName": null,
      "associateObjectProperties": null,
      "companyAsMediator": false,
      "hubspotObjectId": 15,
      "hubspotObjectTypeId": "0-3",
      "icon": null,
      "iframeProperties": [
        {
          "button_name": "View",
          "on_click_action": "showIframe",
          "properties_value": "Label",
          "property_value_show_as": "button"
        }
      ],
      "label": "Deals Normal",
      "listObjectName": "Deals Normal",
      "listObjectProperties": "subject,hs_pipeline_stage,hs_pipeline",
      "objectType": "HUBSPOT_DEFINED",
      "pipeLineId": "0",
      "propertyName": null,
      "showIframe": false,
      "specPipeLine": false
    }
  ];
  const showSidebarListDataOption$1 = true;
  const sidebarCtaDetails$1 = [
    {
      title: "Test 1",
      buttonUrl: "Test 1",
      buttonText: "Test 1"
    }
  ];
  const baseCompanyOptions$1 = {
    logoImg: "https://48715364.fs1.hubspotusercontent-na1.net/hubfs/48715364/logo.fef91145.svg",
    companyName: "Digital Woods",
    smallLogo: "https://48715364.fs1.hubspotusercontent-na1.net/hubfs/48715364/logo.fef91145.svg",
    authPopupFormLogo: "https://48715364.fs1.hubspotusercontent-na1.net/hubfs/48715364/logo.fef91145.svg",
    welcomeMessage: "",
    createAccountBool: true,
    createAccountLink: `<a href={href} target="_blank" rel="noopener noreferrer">Signup</a>`
  };
  const moduleStylesOptions$1 = {
    "homeTabStyles": {
      "overlayer": {
        "color": "",
        "opacity": "0"
      },
      "svgColor": {
        "color": ""
      }
    },
    "noteStyle": {}
  };
  const sidebarCtaStyles = {};
  const recorBtnCustom$1 = false;
  const enableDashboardCards$1 = true;
  const dashboardCards$1 = [
    {
      "description": '<p data-start="247" data-end="336"><strong data-stringify-type="bold">Welcome</strong><span>&nbsp;</span><strong data-stringify-type="bold">to your Customer Portal Dashboard</strong></p>\n<p data-start="247" data-end="336"><span aria-label="&nbsp;" data-stringify-type="paragraph-break"></span><span>Use this portal to manage support tickets and coordinate any custom work with our team.</span></p>\n<p data-start="340" data-end="424">&nbsp;</p>',
      "properties": [
        {
          "button_name": "View",
          "on_click_action": "showIframe",
          "properties_value": "Label",
          "property_type": "company",
          "property_value_show_as": "simpleText"
        }
      ],
      "show_date": true,
      "show_title": true,
      "title": "",
      "view": "grid"
    }
  ];
  const homeTabsDataTypeFilter$1 = {
    "files": "contact",
    "notes": "contact",
    "tickets": "contact"
  };
  const defaultData = {
    dataSourceSet,
    apiBaseUrlOption,
    addHomeTabOption: addHomeTabOption$1,
    moduleIframeListOptions: moduleIframeListOptions$1,
    sidebarListDataOption: sidebarListDataOption$1,
    showSidebarListDataOption: showSidebarListDataOption$1,
    primarycolor,
    secondarycolor,
    hubId: hubId$1,
    sidebarMenuOptions: sidebarMenuOptions$1,
    sidebarCtaDetails: sidebarCtaDetails$1,
    objectList: objectList$1,
    showCompanyNameOption: showCompanyNameOption$1,
    showSidebarCtaOption: showSidebarCtaOption$1,
    baseCompanyOptions: baseCompanyOptions$1,
    moduleStylesOptions: moduleStylesOptions$1,
    sidebarCtaStyles,
    userData: userData$1,
    recorBtnCustom: recorBtnCustom$1,
    enableDashboardCards: enableDashboardCards$1,
    dashboardCards: dashboardCards$1,
    homeTabsDataTypeFilter: homeTabsDataTypeFilter$1
  };
  const API_ENDPOINTS = {
    PRE_LOGIN: "/api/auth/pre-login",
    USERS_LOGIN: "/api/auth/login",
    EXISTING_USER_REGISTER: "/api/auth/existing-user-register",
    VERIFY_EMAIL: "api/auth/verify-email",
    VERIFY_OTP: "/api/auth/verify-otp",
    USER_LOGOUT: "/api/auth/logout",
    USERS_REGISTER: "/register",
    USERS_CHANGE_PASSWORD: "/api/auth/change-password",
    USERS_FORGET_PASSWORD: "/api/auth/forget-password",
    USER_RESET_PASSWORD: "/api/auth/reset-password",
    RESEND_EMAIL: "/api/auth/resend-email",
    VERIFY_EMAIL_RESEND: "/api/auth/verify-email/resend",
    PRODUCTS: "/products",
    FEATURES: "api/templates/demo/features?featureType=BASE",
    OBJECTS: "/api/feature-data",
    OBJECTS_BY_ID: "/api/feature-data",
    PROFILE_UPDATE: "api/users",
    GET_PROFILE_DETAILS: "/api/auth/me",
    USERS_ME: "/api/auth/me",
    CLIENT_SESSION: "/api/auth/client-session",
    DETAILS_SAVE: "/api/:hubId/:portalId/hubspot-object-forms/:objectTypeId/properties/:recordId",
    STAGES: "/api/:hubId/:portalId/hubspot-object-pipelines/:objectTypeId/:pipelineId/stages",
    //File Upload
    FILE_UPLOAD: "/api/feature-data/files",
    ALL_FILES: "/api/feature-data/files",
    ONE_FILE: "/api/feature-data/files",
    DELETE_ONE_FILE: "/api/feature-data/files",
    //Folder Upload
    FOLDER_UPLOAD: "/api/feature-data/folders",
    //notes
    ALL_NOTES: "/api/feature-data/notes",
    NOTES_UPLOAD: "/api/feature-data/notes",
    //notes-Image
    IMAGE_UPLOAD: "/api/feature-data/notes/images"
  };
  function bind$1(fn, thisArg) {
    return function wrap2() {
      return fn.apply(thisArg, arguments);
    };
  }
  var define_process_default$2 = {};
  const { toString } = Object.prototype;
  const { getPrototypeOf: getPrototypeOf$1 } = Object;
  const { iterator, toStringTag } = Symbol;
  const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null));
  const kindOfTest = (type) => {
    type = type.toLowerCase();
    return (thing) => kindOf(thing) === type;
  };
  const typeOfTest = (type) => (thing) => typeof thing === type;
  const { isArray: isArray$1 } = Array;
  const isUndefined$1 = typeOfTest("undefined");
  function isBuffer(val) {
    return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  const isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  const isString$1 = typeOfTest("string");
  const isFunction$1 = typeOfTest("function");
  const isNumber$1 = typeOfTest("number");
  const isObject$2 = (thing) => thing !== null && typeof thing === "object";
  const isBoolean$1 = (thing) => thing === true || thing === false;
  const isPlainObject$1 = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }
    const prototype2 = getPrototypeOf$1(val);
    return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
  };
  const isEmptyObject$1 = (val) => {
    if (!isObject$2(val) || isBuffer(val)) {
      return false;
    }
    try {
      return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
    } catch (e) {
      return false;
    }
  };
  const isDate = kindOfTest("Date");
  const isFile = kindOfTest("File");
  const isBlob = kindOfTest("Blob");
  const isFileList = kindOfTest("FileList");
  const isStream = (val) => isObject$2(val) && isFunction$1(val.pipe);
  const isFormData = (thing) => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
  };
  const isURLSearchParams = kindOfTest("URLSearchParams");
  const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
  const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach(obj, fn, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i2;
    let l;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray$1(obj)) {
      for (i2 = 0, l = obj.length; i2 < l; i2++) {
        fn.call(null, obj[i2], i2, obj);
      }
    } else {
      if (isBuffer(obj)) {
        return;
      }
      const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys2.length;
      let key2;
      for (i2 = 0; i2 < len; i2++) {
        key2 = keys2[i2];
        fn.call(null, obj[key2], key2, obj);
      }
    }
  }
  function findKey(obj, key2) {
    if (isBuffer(obj)) {
      return null;
    }
    key2 = key2.toLowerCase();
    const keys2 = Object.keys(obj);
    let i2 = keys2.length;
    let _key;
    while (i2-- > 0) {
      _key = keys2[i2];
      if (key2 === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  const _global = (() => {
    if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
  })();
  const isContextDefined = (context) => !isUndefined$1(context) && context !== _global;
  function merge() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key2) => {
      const targetKey = caseless && findKey(result, key2) || key2;
      if (isPlainObject$1(result[targetKey]) && isPlainObject$1(val)) {
        result[targetKey] = merge(result[targetKey], val);
      } else if (isPlainObject$1(val)) {
        result[targetKey] = merge({}, val);
      } else if (isArray$1(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (let i2 = 0, l = arguments.length; i2 < l; i2++) {
      arguments[i2] && forEach(arguments[i2], assignValue);
    }
    return result;
  }
  const extend = (a, b2, thisArg, { allOwnKeys } = {}) => {
    forEach(b2, (val, key2) => {
      if (thisArg && isFunction$1(val)) {
        a[key2] = bind$1(val, thisArg);
      } else {
        a[key2] = val;
      }
    }, { allOwnKeys });
    return a;
  };
  const stripBOM = (content) => {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  };
  const inherits = (constructor, superConstructor, props, descriptors2) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };
  const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
    let props;
    let i2;
    let prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null) return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i2 = props.length;
      while (i2-- > 0) {
        prop = props[i2];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter !== false && getPrototypeOf$1(sourceObj);
    } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  const endsWith = (str, searchString, position) => {
    str = String(str);
    if (position === void 0 || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
  const toArray = (thing) => {
    if (!thing) return null;
    if (isArray$1(thing)) return thing;
    let i2 = thing.length;
    if (!isNumber$1(i2)) return null;
    const arr = new Array(i2);
    while (i2-- > 0) {
      arr[i2] = thing[i2];
    }
    return arr;
  };
  const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf$1(Uint8Array));
  const forEachEntry = (obj, fn) => {
    const generator = obj && obj[iterator];
    const _iterator = generator.call(obj);
    let result;
    while ((result = _iterator.next()) && !result.done) {
      const pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  };
  const matchAll = (regExp, str) => {
    let matches2;
    const arr = [];
    while ((matches2 = regExp.exec(str)) !== null) {
      arr.push(matches2);
    }
    return arr;
  };
  const isHTMLForm = kindOfTest("HTMLFormElement");
  const toCamelCase = (str) => {
    return str.toLowerCase().replace(
      /[-_\s]([a-z\d])(\w*)/g,
      function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };
  const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
  const isRegExp = kindOfTest("RegExp");
  const reduceDescriptors = (obj, reducer) => {
    const descriptors2 = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors2, (descriptor, name) => {
      let ret;
      if ((ret = reducer(descriptor, name, obj)) !== false) {
        reducedDescriptors[name] = ret || descriptor;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };
  const freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor, name) => {
      if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
        return false;
      }
      const value = obj[name];
      if (!isFunction$1(value)) return;
      descriptor.enumerable = false;
      if ("writable" in descriptor) {
        descriptor.writable = false;
        return;
      }
      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error("Can not rewrite read-only method '" + name + "'");
        };
      }
    });
  };
  const toObjectSet = (arrayOrString, delimiter) => {
    const obj = {};
    const define = (arr) => {
      arr.forEach((value) => {
        obj[value] = true;
      });
    };
    isArray$1(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
    return obj;
  };
  const noop = () => {
  };
  const toFiniteNumber = (value, defaultValue) => {
    return value != null && Number.isFinite(value = +value) ? value : defaultValue;
  };
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction$1(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
  }
  const toJSONObject = (obj) => {
    const stack = new Array(10);
    const visit = (source, i2) => {
      if (isObject$2(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }
        if (isBuffer(source)) {
          return source;
        }
        if (!("toJSON" in source)) {
          stack[i2] = source;
          const target = isArray$1(source) ? [] : {};
          forEach(source, (value, key2) => {
            const reducedValue = visit(value, i2 + 1);
            !isUndefined$1(reducedValue) && (target[key2] = reducedValue);
          });
          stack[i2] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit(obj, 0);
  };
  const isAsyncFn = kindOfTest("AsyncFunction");
  const isThenable = (thing) => thing && (isObject$2(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
  const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
    if (setImmediateSupported) {
      return setImmediate;
    }
    return postMessageSupported ? ((token, callbacks) => {
      _global.addEventListener("message", ({ source, data }) => {
        if (source === _global && data === token) {
          callbacks.length && callbacks.shift()();
        }
      }, false);
      return (cb) => {
        callbacks.push(cb);
        _global.postMessage(token, "*");
      };
    })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
  })(
    typeof setImmediate === "function",
    isFunction$1(_global.postMessage)
  );
  const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof define_process_default$2 !== "undefined" && define_process_default$2.nextTick || _setImmediate;
  const isIterable = (thing) => thing != null && isFunction$1(thing[iterator]);
  const utils$1 = {
    isArray: isArray$1,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString: isString$1,
    isNumber: isNumber$1,
    isBoolean: isBoolean$1,
    isObject: isObject$2,
    isPlainObject: isPlainObject$1,
    isEmptyObject: isEmptyObject$1,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined: isUndefined$1,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction: isFunction$1,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable,
    setImmediate: _setImmediate,
    asap,
    isIterable
  };
  function AxiosError$1(message, code2, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code2 && (this.code = code2);
    config && (this.config = config);
    request && (this.request = request);
    if (response) {
      this.response = response;
      this.status = response.status ? response.status : null;
    }
  }
  utils$1.inherits(AxiosError$1, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils$1.toJSONObject(this.config),
        code: this.code,
        status: this.status
      };
    }
  });
  const prototype$1 = AxiosError$1.prototype;
  const descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((code2) => {
    descriptors[code2] = { value: code2 };
  });
  Object.defineProperties(AxiosError$1, descriptors);
  Object.defineProperty(prototype$1, "isAxiosError", { value: true });
  AxiosError$1.from = (error, code2, config, request, response, customProps) => {
    const axiosError = Object.create(prototype$1);
    utils$1.toFlatObject(error, axiosError, function filter(obj) {
      return obj !== Error.prototype;
    }, (prop) => {
      return prop !== "isAxiosError";
    });
    AxiosError$1.call(axiosError, error.message, code2, config, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  const httpAdapter = null;
  function isVisitable(thing) {
    return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
  }
  function removeBrackets(key2) {
    return utils$1.endsWith(key2, "[]") ? key2.slice(0, -2) : key2;
  }
  function renderKey(path, key2, dots) {
    if (!path) return key2;
    return path.concat(key2).map(function each(token, i2) {
      token = removeBrackets(token);
      return !dots && i2 ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils$1.isArray(arr) && !arr.some(isVisitable);
  }
  const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
  });
  function toFormData$1(obj, formData, options) {
    if (!utils$1.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new FormData();
    options = utils$1.toFlatObject(options, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils$1.isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
    if (!utils$1.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null) return "";
      if (utils$1.isDate(value)) {
        return value.toISOString();
      }
      if (utils$1.isBoolean(value)) {
        return value.toString();
      }
      if (!useBlob && utils$1.isBlob(value)) {
        throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
      }
      if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key2, path) {
      let arr = value;
      if (value && !path && typeof value === "object") {
        if (utils$1.endsWith(key2, "{}")) {
          key2 = metaTokens ? key2 : key2.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key2, "[]")) && (arr = utils$1.toArray(value))) {
          key2 = removeBrackets(key2);
          arr.forEach(function each(el, index) {
            !(utils$1.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key2], index, dots) : indexes === null ? key2 : key2 + "[]",
              convertValue(el)
            );
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path, key2, dots), convertValue(value));
      return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build(value, path) {
      if (utils$1.isUndefined(value)) return;
      if (stack.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path.join("."));
      }
      stack.push(value);
      utils$1.forEach(value, function each(el, key2) {
        const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
          formData,
          el,
          utils$1.isString(key2) ? key2.trim() : key2,
          path,
          exposedHelpers
        );
        if (result === true) {
          build(el, path ? path.concat(key2) : [key2]);
        }
      });
      stack.pop();
    }
    if (!utils$1.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
  }
  function encode$1(str) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
      return charMap[match];
    });
  }
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && toFormData$1(params, this, options);
  }
  const prototype = AxiosURLSearchParams.prototype;
  prototype.append = function append(name, value) {
    this._pairs.push([name, value]);
  };
  prototype.toString = function toString2(encoder) {
    const _encode = encoder ? function(value) {
      return encoder.call(this, value, encode$1);
    } : encode$1;
    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL(url, params, options) {
    if (!params) {
      return url;
    }
    const _encode = options && options.encode || encode;
    if (utils$1.isFunction(options)) {
      options = {
        serialize: options
      };
    }
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options);
    } else {
      serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  }
  class InterceptorManager {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn) {
      utils$1.forEach(this.handlers, function forEachHandler(h2) {
        if (h2 !== null) {
          fn(h2);
        }
      });
    }
  }
  const transitionalDefaults = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
  const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
  const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
  const platform$2 = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams$1,
      FormData: FormData$1,
      Blob: Blob$1
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
  };
  const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
  const _navigator = typeof navigator === "object" && navigator || void 0;
  const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
  const hasStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  const origin = hasBrowserEnv && window.location.href || "http://localhost";
  const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    hasBrowserEnv,
    hasStandardBrowserEnv,
    hasStandardBrowserWebWorkerEnv,
    navigator: _navigator,
    origin
  }, Symbol.toStringTag, { value: "Module" }));
  const platform$1 = {
    ...utils,
    ...platform$2
  };
  function toURLEncodedForm(data, options) {
    return toFormData$1(data, new platform$1.classes.URLSearchParams(), {
      visitor: function(value, key2, path, helpers) {
        if (platform$1.isNode && utils$1.isBuffer(value)) {
          this.append(key2, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      },
      ...options
    });
  }
  function parsePropPath(name) {
    return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
      return match[0] === "[]" ? "" : match[1] || match[0];
    });
  }
  function arrayToObject(arr) {
    const obj = {};
    const keys2 = Object.keys(arr);
    let i2;
    const len = keys2.length;
    let key2;
    for (i2 = 0; i2 < len; i2++) {
      key2 = keys2[i2];
      obj[key2] = arr[key2];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
      let name = path[index++];
      if (name === "__proto__") return true;
      const isNumericKey = Number.isFinite(+name);
      const isLast = index >= path.length;
      name = !name && utils$1.isArray(target) ? target.length : name;
      if (isLast) {
        if (utils$1.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }
        return !isNumericKey;
      }
      if (!target[name] || !utils$1.isObject(target[name])) {
        target[name] = [];
      }
      const result = buildPath(path, value, target[name], index);
      if (result && utils$1.isArray(target[name])) {
        target[name] = arrayToObject(target[name]);
      }
      return !isNumericKey;
    }
    if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
      const obj = {};
      utils$1.forEachEntry(formData, (name, value) => {
        buildPath(parsePropPath(name), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  function stringifySafely(rawValue, parser, encoder) {
    if (utils$1.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils$1.trim(rawValue);
      } catch (e) {
        if (e.name !== "SyntaxError") {
          throw e;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  const defaults = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils$1.isObject(data);
      if (isObjectPayload && utils$1.isHTMLForm(data)) {
        data = new FormData(data);
      }
      const isFormData2 = utils$1.isFormData(data);
      if (isFormData2) {
        return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
      }
      if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
        return data;
      }
      if (utils$1.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$1.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }
        if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData$1(
            isFileList2 ? { "files[]": data } : data,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      const transitional = this.transitional || defaults.transitional;
      const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
        return data;
      }
      if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional && transitional.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === "SyntaxError") {
              throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform$1.classes.FormData,
      Blob: platform$1.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
    defaults.headers[method] = {};
  });
  const ignoreDuplicateOf = utils$1.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  const parseHeaders = (rawHeaders) => {
    const parsed = {};
    let key2;
    let val;
    let i2;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
      i2 = line.indexOf(":");
      key2 = line.substring(0, i2).trim().toLowerCase();
      val = line.substring(i2 + 1).trim();
      if (!key2 || parsed[key2] && ignoreDuplicateOf[key2]) {
        return;
      }
      if (key2 === "set-cookie") {
        if (parsed[key2]) {
          parsed[key2].push(val);
        } else {
          parsed[key2] = [val];
        }
      } else {
        parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
      }
    });
    return parsed;
  };
  const $internals = Symbol("internals");
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
  }
  function parseTokens(str) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while (match = tokensRE.exec(str)) {
      tokens[match[1]] = match[2];
    }
    return tokens;
  }
  const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
  function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
    if (utils$1.isFunction(filter)) {
      return filter.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils$1.isString(value)) return;
    if (utils$1.isString(filter)) {
      return value.indexOf(filter) !== -1;
    }
    if (utils$1.isRegExp(filter)) {
      return filter.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
      return char.toUpperCase() + str;
    });
  }
  function buildAccessors(obj, header) {
    const accessorName = utils$1.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  let AxiosHeaders$1 = class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key2 = utils$1.findKey(self2, lHeader);
        if (!key2 || self2[key2] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key2] !== false) {
          self2[key2 || _header] = normalizeValue(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders(header), valueOrRewrite);
      } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
        let obj = {}, dest, key2;
        for (const entry of header) {
          if (!utils$1.isArray(entry)) {
            throw TypeError("Object iterator must return a key-value pair");
          }
          obj[key2 = entry[0]] = (dest = obj[key2]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
        }
        setHeaders(obj, valueOrRewrite);
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser) {
      header = normalizeHeader(header);
      if (header) {
        const key2 = utils$1.findKey(this, header);
        if (key2) {
          const value = this[key2];
          if (!parser) {
            return value;
          }
          if (parser === true) {
            return parseTokens(value);
          }
          if (utils$1.isFunction(parser)) {
            return parser.call(this, value, key2);
          }
          if (utils$1.isRegExp(parser)) {
            return parser.exec(value);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      header = normalizeHeader(header);
      if (header) {
        const key2 = utils$1.findKey(this, header);
        return !!(key2 && this[key2] !== void 0 && (!matcher || matchHeaderValue(this, this[key2], key2, matcher)));
      }
      return false;
    }
    delete(header, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key2 = utils$1.findKey(self2, _header);
          if (key2 && (!matcher || matchHeaderValue(self2, self2[key2], key2, matcher))) {
            delete self2[key2];
            deleted = true;
          }
        }
      }
      if (utils$1.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
    clear(matcher) {
      const keys2 = Object.keys(this);
      let i2 = keys2.length;
      let deleted = false;
      while (i2--) {
        const key2 = keys2[i2];
        if (!matcher || matchHeaderValue(this, this[key2], key2, matcher, true)) {
          delete this[key2];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format) {
      const self2 = this;
      const headers = {};
      utils$1.forEach(this, (value, header) => {
        const key2 = utils$1.findKey(headers, header);
        if (key2) {
          self2[key2] = normalizeValue(value);
          delete self2[header];
          return;
        }
        const normalized = format ? formatHeader(header) : String(header).trim();
        if (normalized !== header) {
          delete self2[header];
        }
        self2[normalized] = normalizeValue(value);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = /* @__PURE__ */ Object.create(null);
      utils$1.forEach(this, (value, header) => {
        value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
    }
    getSetCookie() {
      return this.get("set-cookie") || [];
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed = new this(first);
      targets.forEach((target) => computed.set(target));
      return computed;
    }
    static accessor(header) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype2 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype2, _header);
          accessors[lHeader] = true;
        }
      }
      utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  };
  AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key2) => {
    let mapped = key2[0].toUpperCase() + key2.slice(1);
    return {
      get: () => value,
      set(headerValue) {
        this[mapped] = headerValue;
      }
    };
  });
  utils$1.freezeMethods(AxiosHeaders$1);
  function transformData(fns, response) {
    const config = this || defaults;
    const context = response || config;
    const headers = AxiosHeaders$1.from(context.headers);
    let data = context.data;
    utils$1.forEach(fns, function transform(fn) {
      data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
  }
  function isCancel$1(value) {
    return !!(value && value.__CANCEL__);
  }
  function CanceledError$1(message, config, request) {
    AxiosError$1.call(this, message == null ? "canceled" : message, AxiosError$1.ERR_CANCELED, config, request);
    this.name = "CanceledError";
  }
  utils$1.inherits(CanceledError$1, AxiosError$1, {
    __CANCEL__: true
  });
  function settle(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError$1(
        "Request failed with status code " + response.status,
        [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }
  function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
  }
  function speedometer(samplesCount, min2) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min2 = min2 !== void 0 ? min2 : 1e3;
    return function push(chunkLength) {
      const now = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now;
      let i2 = tail;
      let bytesCount = 0;
      while (i2 !== head) {
        bytesCount += bytes[i2++];
        i2 = i2 % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now - firstSampleTS < min2) {
        return;
      }
      const passed = startedAt && now - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  function throttle(fn, freq) {
    let timestamp = 0;
    let threshold = 1e3 / freq;
    let lastArgs;
    let timer;
    const invoke = (args, now = Date.now()) => {
      timestamp = now;
      lastArgs = null;
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      fn(...args);
    };
    const throttled = (...args) => {
      const now = Date.now();
      const passed = now - timestamp;
      if (passed >= threshold) {
        invoke(args, now);
      } else {
        lastArgs = args;
        if (!timer) {
          timer = setTimeout(() => {
            timer = null;
            invoke(lastArgs);
          }, threshold - passed);
        }
      }
    };
    const flush = () => lastArgs && invoke(lastArgs);
    return [throttled, flush];
  }
  const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
    let bytesNotified = 0;
    const _speedometer = speedometer(50, 250);
    return throttle((e) => {
      const loaded = e.loaded;
      const total = e.lengthComputable ? e.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
        event: e,
        lengthComputable: total != null,
        [isDownloadStream ? "download" : "upload"]: true
      };
      listener(data);
    }, freq);
  };
  const progressEventDecorator = (total, throttled) => {
    const lengthComputable = total != null;
    return [(loaded) => throttled[0]({
      lengthComputable,
      total,
      loaded
    }), throttled[1]];
  };
  const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
  const isURLSameOrigin = platform$1.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
    url = new URL(url, platform$1.origin);
    return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
  })(
    new URL(platform$1.origin),
    platform$1.navigator && /(msie|trident)/i.test(platform$1.navigator.userAgent)
  ) : () => true;
  const cookies = platform$1.hasStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    {
      write(name, value, expires, path, domain, secure) {
        const cookie = [name + "=" + encodeURIComponent(value)];
        utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
        utils$1.isString(path) && cookie.push("path=" + path);
        utils$1.isString(domain) && cookie.push("domain=" + domain);
        secure === true && cookie.push("secure");
        document.cookie = cookie.join("; ");
      },
      read(name) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    }
  ) : (
    // Non-standard browser env (web workers, react-native) lack needed support.
    {
      write() {
      },
      read() {
        return null;
      },
      remove() {
      }
    }
  );
  function isAbsoluteURL(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  }
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }
  function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
    let isRelativeUrl = !isAbsoluteURL(requestedURL);
    if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }
  const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
  function mergeConfig$1(config1, config2) {
    config2 = config2 || {};
    const config = {};
    function getMergedValue(target, source, prop, caseless) {
      if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
        return utils$1.merge.call({ caseless }, target, source);
      } else if (utils$1.isPlainObject(source)) {
        return utils$1.merge({}, source);
      } else if (utils$1.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a, b2, prop, caseless) {
      if (!utils$1.isUndefined(b2)) {
        return getMergedValue(a, b2, prop, caseless);
      } else if (!utils$1.isUndefined(a)) {
        return getMergedValue(void 0, a, prop, caseless);
      }
    }
    function valueFromConfig2(a, b2) {
      if (!utils$1.isUndefined(b2)) {
        return getMergedValue(void 0, b2);
      }
    }
    function defaultToConfig2(a, b2) {
      if (!utils$1.isUndefined(b2)) {
        return getMergedValue(void 0, b2);
      } else if (!utils$1.isUndefined(a)) {
        return getMergedValue(void 0, a);
      }
    }
    function mergeDirectKeys(a, b2, prop) {
      if (prop in config2) {
        return getMergedValue(a, b2);
      } else if (prop in config1) {
        return getMergedValue(void 0, a);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a, b2, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b2), prop, true)
    };
    utils$1.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
      const merge2 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge2(config1[prop], config2[prop], prop);
      utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
  }
  const resolveConfig = (config) => {
    const newConfig = mergeConfig$1({}, config);
    let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
    newConfig.headers = headers = AxiosHeaders$1.from(headers);
    newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
    if (auth) {
      headers.set(
        "Authorization",
        "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
      );
    }
    let contentType;
    if (utils$1.isFormData(data)) {
      if (platform$1.hasStandardBrowserEnv || platform$1.hasStandardBrowserWebWorkerEnv) {
        headers.setContentType(void 0);
      } else if ((contentType = headers.getContentType()) !== false) {
        const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
        headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    if (platform$1.hasStandardBrowserEnv) {
      withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
        const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
        if (xsrfValue) {
          headers.set(xsrfHeaderName, xsrfValue);
        }
      }
    }
    return newConfig;
  };
  const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  const xhrAdapter = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      const _config = resolveConfig(config);
      let requestData = _config.data;
      const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
      let { responseType, onUploadProgress, onDownloadProgress } = _config;
      let onCanceled;
      let uploadThrottled, downloadThrottled;
      let flushUpload, flushDownload;
      function done() {
        flushUpload && flushUpload();
        flushDownload && flushDownload();
        _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
        _config.signal && _config.signal.removeEventListener("abort", onCanceled);
      }
      let request = new XMLHttpRequest();
      request.open(_config.method.toUpperCase(), _config.url, true);
      request.timeout = _config.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders$1.from(
          "getAllResponseHeaders" in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };
        settle(function _resolve(value) {
          resolve(value);
          done();
        }, function _reject(err2) {
          reject(err2);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config, request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional = _config.transitional || transitionalDefaults;
        if (_config.timeoutErrorMessage) {
          timeoutErrorMessage = _config.timeoutErrorMessage;
        }
        reject(new AxiosError$1(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
          config,
          request
        ));
        request = null;
      };
      requestData === void 0 && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key2) {
          request.setRequestHeader(key2, val);
        });
      }
      if (!utils$1.isUndefined(_config.withCredentials)) {
        request.withCredentials = !!_config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = _config.responseType;
      }
      if (onDownloadProgress) {
        [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
        request.addEventListener("progress", downloadThrottled);
      }
      if (onUploadProgress && request.upload) {
        [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
        request.upload.addEventListener("progress", uploadThrottled);
        request.upload.addEventListener("loadend", flushUpload);
      }
      if (_config.cancelToken || _config.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError$1(null, config, request) : cancel);
          request.abort();
          request = null;
        };
        _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
        if (_config.signal) {
          _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol = parseProtocol(_config.url);
      if (protocol && platform$1.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config));
        return;
      }
      request.send(requestData || null);
    });
  };
  const composeSignals = (signals, timeout) => {
    const { length } = signals = signals ? signals.filter(Boolean) : [];
    if (timeout || length) {
      let controller = new AbortController();
      let aborted;
      const onabort = function(reason) {
        if (!aborted) {
          aborted = true;
          unsubscribe();
          const err2 = reason instanceof Error ? reason : this.reason;
          controller.abort(err2 instanceof AxiosError$1 ? err2 : new CanceledError$1(err2 instanceof Error ? err2.message : err2));
        }
      };
      let timer = timeout && setTimeout(() => {
        timer = null;
        onabort(new AxiosError$1(`timeout ${timeout} of ms exceeded`, AxiosError$1.ETIMEDOUT));
      }, timeout);
      const unsubscribe = () => {
        if (signals) {
          timer && clearTimeout(timer);
          timer = null;
          signals.forEach((signal2) => {
            signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
          });
          signals = null;
        }
      };
      signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
      const { signal } = controller;
      signal.unsubscribe = () => utils$1.asap(unsubscribe);
      return signal;
    }
  };
  const streamChunk = function* (chunk, chunkSize) {
    let len = chunk.byteLength;
    if (len < chunkSize) {
      yield chunk;
      return;
    }
    let pos = 0;
    let end;
    while (pos < len) {
      end = pos + chunkSize;
      yield chunk.slice(pos, end);
      pos = end;
    }
  };
  const readBytes = async function* (iterable, chunkSize) {
    for await (const chunk of readStream(iterable)) {
      yield* streamChunk(chunk, chunkSize);
    }
  };
  const readStream = async function* (stream) {
    if (stream[Symbol.asyncIterator]) {
      yield* stream;
      return;
    }
    const reader = stream.getReader();
    try {
      for (; ; ) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        yield value;
      }
    } finally {
      await reader.cancel();
    }
  };
  const trackStream = (stream, chunkSize, onProgress, onFinish) => {
    const iterator2 = readBytes(stream, chunkSize);
    let bytes = 0;
    let done;
    let _onFinish = (e) => {
      if (!done) {
        done = true;
        onFinish && onFinish(e);
      }
    };
    return new ReadableStream({
      async pull(controller) {
        try {
          const { done: done2, value } = await iterator2.next();
          if (done2) {
            _onFinish();
            controller.close();
            return;
          }
          let len = value.byteLength;
          if (onProgress) {
            let loadedBytes = bytes += len;
            onProgress(loadedBytes);
          }
          controller.enqueue(new Uint8Array(value));
        } catch (err2) {
          _onFinish(err2);
          throw err2;
        }
      },
      cancel(reason) {
        _onFinish(reason);
        return iterator2.return();
      }
    }, {
      highWaterMark: 2
    });
  };
  const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
  const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
  const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
  const test = (fn, ...args) => {
    try {
      return !!fn(...args);
    } catch (e) {
      return false;
    }
  };
  const supportsRequestStream = isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform$1.origin, {
      body: new ReadableStream(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  const DEFAULT_CHUNK_SIZE = 64 * 1024;
  const supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
  const resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && ((res) => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
      !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_2, config) => {
        throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config);
      });
    });
  })(new Response());
  const getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils$1.isBlob(body)) {
      return body.size;
    }
    if (utils$1.isSpecCompliantForm(body)) {
      const _request = new Request(platform$1.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils$1.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils$1.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  const resolveBodyLength = async (headers, body) => {
    const length = utils$1.toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
  };
  const fetchAdapter = isFetchSupported && (async (config) => {
    let {
      url,
      method,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig(config);
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
    let request;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils$1.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = "credentials" in Request.prototype;
      request = new Request(url, {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : void 0
      });
      let response = await fetch(request, fetchOptions);
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response = new Response(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {
          data: responseData,
          headers: AxiosHeaders$1.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config,
          request
        });
      });
    } catch (err2) {
      unsubscribe && unsubscribe();
      if (err2 && err2.name === "TypeError" && /Load failed|fetch/i.test(err2.message)) {
        throw Object.assign(
          new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request),
          {
            cause: err2.cause || err2
          }
        );
      }
      throw AxiosError$1.from(err2, err2 && err2.code, config, request);
    }
  });
  const knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter,
    fetch: fetchAdapter
  };
  utils$1.forEach(knownAdapters, (fn, value) => {
    if (fn) {
      try {
        Object.defineProperty(fn, "name", { value });
      } catch (e) {
      }
      Object.defineProperty(fn, "adapterName", { value });
    }
  });
  const renderReason = (reason) => `- ${reason}`;
  const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
  const adapters = {
    getAdapter: (adapters2) => {
      adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
      const { length } = adapters2;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i2 = 0; i2 < length; i2++) {
        nameOrAdapter = adapters2[i2];
        let id;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
          if (adapter === void 0) {
            throw new AxiosError$1(`Unknown adapter '${id}'`);
          }
        }
        if (adapter) {
          break;
        }
        rejectedReasons[id || "#" + i2] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(
          ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
        );
        let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError$1(
          `There is no suitable adapter to dispatch the request ` + s,
          "ERR_NOT_SUPPORT"
        );
      }
      return adapter;
    },
    adapters: knownAdapters
  };
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
      throw new CanceledError$1(null, config);
    }
  }
  function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = AxiosHeaders$1.from(config.headers);
    config.data = transformData.call(
      config,
      config.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config.method) !== -1) {
      config.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters.getAdapter(config.adapter || defaults.adapter);
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData.call(
        config,
        config.transformResponse,
        response
      );
      response.headers = AxiosHeaders$1.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel$1(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config,
            config.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }
  const VERSION$1 = "1.11.0";
  const validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
    validators$1[type] = function validator2(thing) {
      return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
    };
  });
  const deprecatedWarnings = {};
  validators$1.transitional = function transitional(validator2, version, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value, opt, opts) => {
      if (validator2 === false) {
        throw new AxiosError$1(
          formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
          AxiosError$1.ERR_DEPRECATED
        );
      }
      if (version && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version + " and will be removed in the near future"
          )
        );
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  validators$1.spelling = function spelling(correctSpelling) {
    return (value, opt) => {
      console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
      return true;
    };
  };
  function assertOptions(options, schema2, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
    }
    const keys2 = Object.keys(options);
    let i2 = keys2.length;
    while (i2-- > 0) {
      const opt = keys2[i2];
      const validator2 = schema2[opt];
      if (validator2) {
        const value = options[opt];
        const result = value === void 0 || validator2(value, opt, options);
        if (result !== true) {
          throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
      }
    }
  }
  const validator = {
    assertOptions,
    validators: validators$1
  };
  const validators = validator.validators;
  let Axios$2 = class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig || {};
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    async request(configOrUrl, config) {
      try {
        return await this._request(configOrUrl, config);
      } catch (err2) {
        if (err2 instanceof Error) {
          let dummy = {};
          Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
          const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
          try {
            if (!err2.stack) {
              err2.stack = stack;
            } else if (stack && !String(err2.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
              err2.stack += "\n" + stack;
            }
          } catch (e) {
          }
        }
        throw err2;
      }
    }
    _request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig$1(this.defaults, config);
      const { transitional, paramsSerializer, headers } = config;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      if (paramsSerializer != null) {
        if (utils$1.isFunction(paramsSerializer)) {
          config.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }
      }
      if (config.allowAbsoluteUrls !== void 0) ;
      else if (this.defaults.allowAbsoluteUrls !== void 0) {
        config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
      } else {
        config.allowAbsoluteUrls = true;
      }
      validator.assertOptions(config, {
        baseUrl: validators.spelling("baseURL"),
        withXsrfToken: validators.spelling("withXSRFToken")
      }, true);
      config.method = (config.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders = headers && utils$1.merge(
        headers.common,
        headers[config.method]
      );
      headers && utils$1.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (method) => {
          delete headers[method];
        }
      );
      config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i2 = 0;
      let len;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), void 0];
        chain.unshift(...requestInterceptorChain);
        chain.push(...responseInterceptorChain);
        len = chain.length;
        promise = Promise.resolve(config);
        while (i2 < len) {
          promise = promise.then(chain[i2++], chain[i2++]);
        }
        return promise;
      }
      len = requestInterceptorChain.length;
      let newConfig = config;
      i2 = 0;
      while (i2 < len) {
        const onFulfilled = requestInterceptorChain[i2++];
        const onRejected = requestInterceptorChain[i2++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected.call(this, error);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      i2 = 0;
      len = responseInterceptorChain.length;
      while (i2 < len) {
        promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
      }
      return promise;
    }
    getUri(config) {
      config = mergeConfig$1(this.defaults, config);
      const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    }
  };
  utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios$2.prototype[method] = function(url, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });
  utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data, config) {
        return this.request(mergeConfig$1(config || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url,
          data
        }));
      };
    }
    Axios$2.prototype[method] = generateHTTPMethod();
    Axios$2.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  let CancelToken$1 = class CancelToken2 {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      const token = this;
      this.promise.then((cancel) => {
        if (!token._listeners) return;
        let i2 = token._listeners.length;
        while (i2-- > 0) {
          token._listeners[i2](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve) => {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config, request) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError$1(message, config, request);
        resolvePromise(token.reason);
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    }
    toAbortSignal() {
      const controller = new AbortController();
      const abort = (err2) => {
        controller.abort(err2);
      };
      this.subscribe(abort);
      controller.signal.unsubscribe = () => this.unsubscribe(abort);
      return controller.signal;
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token = new CancelToken2(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    }
  };
  function spread$1(callback) {
    return function wrap2(arr) {
      return callback.apply(null, arr);
    };
  }
  function isAxiosError$1(payload) {
    return utils$1.isObject(payload) && payload.isAxiosError === true;
  }
  const HttpStatusCode$1 = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(HttpStatusCode$1).forEach(([key2, value]) => {
    HttpStatusCode$1[value] = key2;
  });
  function createInstance(defaultConfig) {
    const context = new Axios$2(defaultConfig);
    const instance = bind$1(Axios$2.prototype.request, context);
    utils$1.extend(instance, Axios$2.prototype, context, { allOwnKeys: true });
    utils$1.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create2(instanceConfig) {
      return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
    };
    return instance;
  }
  const axios = createInstance(defaults);
  axios.Axios = Axios$2;
  axios.CanceledError = CanceledError$1;
  axios.CancelToken = CancelToken$1;
  axios.isCancel = isCancel$1;
  axios.VERSION = VERSION$1;
  axios.toFormData = toFormData$1;
  axios.AxiosError = AxiosError$1;
  axios.Cancel = axios.CanceledError;
  axios.all = function all2(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread$1;
  axios.isAxiosError = isAxiosError$1;
  axios.mergeConfig = mergeConfig$1;
  axios.AxiosHeaders = AxiosHeaders$1;
  axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.getAdapter = adapters.getAdapter;
  axios.HttpStatusCode = HttpStatusCode$1;
  axios.default = axios;
  const {
    Axios: Axios$1,
    AxiosError,
    CanceledError,
    isCancel,
    CancelToken,
    VERSION,
    all,
    Cancel,
    isAxiosError,
    spread,
    toFormData,
    AxiosHeaders,
    HttpStatusCode,
    formToJSON,
    getAdapter,
    mergeConfig
  } = axios;
  /*! js-cookie v3.0.5 | MIT */
  function assign(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key2 in source) {
        target[key2] = source[key2];
      }
    }
    return target;
  }
  var defaultConverter = {
    read: function(value) {
      if (value[0] === '"') {
        value = value.slice(1, -1);
      }
      return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
    },
    write: function(value) {
      return encodeURIComponent(value).replace(
        /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
        decodeURIComponent
      );
    }
  };
  function init(converter, defaultAttributes) {
    function set2(name, value, attributes) {
      if (typeof document === "undefined") {
        return;
      }
      attributes = assign({}, defaultAttributes, attributes);
      if (typeof attributes.expires === "number") {
        attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
      }
      if (attributes.expires) {
        attributes.expires = attributes.expires.toUTCString();
      }
      name = encodeURIComponent(name).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
      var stringifiedAttributes = "";
      for (var attributeName in attributes) {
        if (!attributes[attributeName]) {
          continue;
        }
        stringifiedAttributes += "; " + attributeName;
        if (attributes[attributeName] === true) {
          continue;
        }
        stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
      }
      return document.cookie = name + "=" + converter.write(value, name) + stringifiedAttributes;
    }
    function get2(name) {
      if (typeof document === "undefined" || arguments.length && !name) {
        return;
      }
      var cookies2 = document.cookie ? document.cookie.split("; ") : [];
      var jar = {};
      for (var i2 = 0; i2 < cookies2.length; i2++) {
        var parts = cookies2[i2].split("=");
        var value = parts.slice(1).join("=");
        try {
          var found2 = decodeURIComponent(parts[0]);
          jar[found2] = converter.read(value, found2);
          if (name === found2) {
            break;
          }
        } catch (e) {
        }
      }
      return name ? jar[name] : jar;
    }
    return Object.create(
      {
        set: set2,
        get: get2,
        remove: function(name, attributes) {
          set2(
            name,
            "",
            assign({}, attributes, {
              expires: -1
            })
          );
        },
        withAttributes: function(attributes) {
          return init(this.converter, assign({}, this.attributes, attributes));
        },
        withConverter: function(converter2) {
          return init(assign({}, this.converter, converter2), this.attributes);
        }
      },
      {
        attributes: { value: Object.freeze(defaultAttributes) },
        converter: { value: Object.freeze(converter) }
      }
    );
  }
  var api = init(defaultConverter, { path: "/" });
  const VITE_PUBLIC_REST_API_ENDPOINT = env$1.VITE_PUBLIC_REST_API_ENDPOINT ?? "";
  const Axios = axios.create({
    baseURL: VITE_PUBLIC_REST_API_ENDPOINT,
    timeout: 5e4,
    headers: {
      "Content-Type": "application/json"
    }
  });
  const AUTH_TOKEN_KEY$1 = env$1.VITE_AUTH_TOKEN_KEY ?? "authToken";
  Axios.interceptors.request.use((config) => {
    const cookies2 = api.get(AUTH_TOKEN_KEY$1);
    let token = cookies2;
    config.headers = token ? { ...config.headers, Authorization: `Bearer ${token}` } : { ...config.headers };
    return config;
  });
  Axios.interceptors.response.use(
    (response) => response,
    (error) => {
      return Promise.reject(error);
    }
  );
  function formatBooleanSearchParam(key2, value) {
    return value ? `${key2}:1` : `${key2}:`;
  }
  class HttpClient {
    static async get(url, params) {
      const response = await Axios.get(url, { params });
      return response.data;
    }
    static async post(url, data, options) {
      const response = await Axios.post(url, data, options);
      return response.data;
    }
    static async put(url, data) {
      const response = await Axios.put(url, data);
      return response.data;
    }
    static async delete(url) {
      const response = await Axios.delete(url);
      return response.data;
    }
    static formatSearchParams(params) {
      return Object.entries(params).filter(([, value]) => Boolean(value)).map(
        ([k2, v]) => [
          "type",
          "categories",
          "tags",
          "author",
          "manufacturer",
          "shops",
          "refund_reason"
        ].includes(k2) ? `${k2}.slug:${v}` : ["is_approved"].includes(k2) ? formatBooleanSearchParam(k2, v) : `${k2}:${v}`
      ).join(";");
    }
  }
  const setCookie = (key2, value) => {
    return api.set(key2, value, {
      sameSite: "none",
      secure: true
    });
  };
  const getCookie = (key2) => {
    return api.get(key2);
  };
  const removeCookie = (key2) => {
    return api.remove(key2);
  };
  const setLoggedInDetails = async (data) => {
    return new Promise((resolve) => {
      setCookie(env$1.VITE_LOGIN_DETAILS, JSON.stringify(data));
      resolve();
    });
  };
  const setSubscriptionType = async (data) => {
    return new Promise((resolve) => {
      setCookie(env$1.VITE_SUBSCRIPTION_TYPE, JSON.stringify(data));
      resolve();
    });
  };
  const setTwoFa = async (data) => {
    return new Promise((resolve) => {
      setCookie(env$1.VITE_TWO_FA, JSON.stringify(data));
      resolve();
    });
  };
  const setPortal = async (data) => {
    return new Promise((resolve) => {
      setCookie(env$1.VITE_PORTAL, JSON.stringify(data));
      resolve();
    });
  };
  const setRouteMenuConfig = async (data) => {
    return new Promise((resolve) => {
      setCookie(env$1.VITE_ROUTE_MENU_CONFIG_KEY, JSON.stringify(data));
      resolve();
    });
  };
  const getAuthCredentials = () => {
    return getCookie(env$1.VITE_AUTH_TOKEN_KEY);
  };
  const getUserDetails = () => {
    return JSON.parse(getCookie(env$1.VITE_AUTH_USER_KEY));
  };
  const getPortal = () => {
    const portal = getCookie(env$1.VITE_PORTAL);
    return portal ? JSON.parse(getCookie(env$1.VITE_PORTAL)) : null;
  };
  function checkHasAuthToken() {
    const token = getCookie(env$1.VITE_AUTH_TOKEN_KEY);
    return !!token;
  }
  function getAuthToken() {
    return getCookie(env$1.VITE_AUTH_TOKEN_KEY);
  }
  function removeAuthToken() {
    removeCookie(env$1.VITE_AUTH_TOKEN_KEY);
  }
  function setAuthToken(token) {
    setCookie(env$1.VITE_AUTH_TOKEN_KEY, token);
  }
  function isAuthenticated() {
    if (isLivePreview()) return true;
    return !!getCookie(env$1.VITE_AUTH_TOKEN_KEY);
  }
  const isLivePreview = () => {
    const fragment = window.location.hash.substring(1);
    const livePreview = fragment.includes("live-preview");
    return livePreview;
  };
  const getRouteMenuConfig = () => {
    const routeMenuConfig = getCookie(env$1.VITE_ROUTE_MENU_CONFIG_KEY);
    return routeMenuConfig ? JSON.parse(routeMenuConfig) : null;
  };
  const generateApiUrl = ({
    route,
    params = [],
    queryParams = ""
  }) => {
    var _a2;
    let portalId;
    if (env$1.VITE_DATA_SOURCE_SET != true) {
      portalId = (_a2 = getPortal()) == null ? void 0 : _a2.portalId;
    }
    const defaultParams = {
      hubId,
      portalId
    };
    params = { ...defaultParams, ...params };
    const url = route == null ? void 0 : route.replace(/:([a-zA-Z]+)/g, (_2, key2) => {
      if (key2 in params) {
        return encodeURIComponent(params[key2]);
      }
      return encodeURIComponent(`missing-${key2}`);
    });
    const queryString = new URLSearchParams(queryParams).toString();
    return queryString ? `${url}?${queryString}` : url;
  };
  const Client = {
    authentication: {
      preLogin: (data) => HttpClient.post(API_ENDPOINTS.PRE_LOGIN, data),
      // login: (data: any) => HttpClient.post(API_ENDPOINTS.USERS_LOGIN, data),
      login: (data, hub_id) => HttpClient.post(`${API_ENDPOINTS.USERS_LOGIN}?portal=portal_client&hubId=${hub_id}`, data),
      existingUserRegister: (data) => HttpClient.post(API_ENDPOINTS.EXISTING_USER_REGISTER, data),
      verifyEmail: (data) => HttpClient.post(API_ENDPOINTS.VERIFY_EMAIL, data),
      verifyOtp: (data) => HttpClient.post(API_ENDPOINTS.VERIFY_OTP, data),
      register: (data) => HttpClient.post(API_ENDPOINTS.USERS_REGISTER, data),
      Logout: () => HttpClient.post(API_ENDPOINTS.USER_LOGOUT, null),
      changePassword: (data) => HttpClient.post(API_ENDPOINTS.USERS_CHANGE_PASSWORD, data),
      forgetPassword: (data) => HttpClient.post(API_ENDPOINTS.USERS_FORGET_PASSWORD, data),
      resetPassword: (data) => HttpClient.post(API_ENDPOINTS.USER_RESET_PASSWORD, data),
      resendEmail: (data) => HttpClient.post(API_ENDPOINTS.RESEND_EMAIL, data),
      verifyEmailResend: (data) => HttpClient.post(API_ENDPOINTS.VERIFY_EMAIL_RESEND, data),
      clientSession: (data) => HttpClient.post(API_ENDPOINTS.CLIENT_SESSION, data)
    },
    fetchAllFeatures: {
      all: () => HttpClient.get(API_ENDPOINTS.FEATURES)
    },
    profile: {
      update: (data) => HttpClient.put(API_ENDPOINTS.PROFILE_UPDATE, data)
    },
    getProfileDetails: {
      all: () => HttpClient.get(API_ENDPOINTS.GET_PROFILE_DETAILS)
    },
    users: {
      me: (hub_id) => {
        const GET_PROFILE_DETAILS = `${API_ENDPOINTS.GET_PROFILE_DETAILS}?portal=portal_client&hubId=${hub_id}`;
        return HttpClient.get(GET_PROFILE_DETAILS);
      }
    },
    user: {
      profile: async ({ portalId, cache, ...query }) => {
        try {
          const url = `/api/${hubId}/${portalId}/profiles`;
          const response = await HttpClient.get(url, { cache, ...query });
          return response;
        } catch (error) {
          console.error("Error fetching profile:", error);
          throw error;
        }
      }
    },
    files: {
      all: ({ objectId, id, portalId, cache, ...query }) => {
        const url = `/api/${hubId}/${portalId}/hubspot-object-files/${objectId}/${id}`;
        return HttpClient.get(
          url,
          {
            cache: !!cache,
            ...query
          }
        );
      },
      uploadFile: ({ objectId, id, portalId, fileData }) => {
        const url = `/api/${hubId}/${portalId}/hubspot-object-files/${objectId}/${id}`;
        return HttpClient.post(url, fileData);
      },
      getDetails: ({ objectId, id, portalId, rowId }) => {
        const url = `/api/${hubId}/${portalId}/hubspot-object-files/${objectId}/${id}/${rowId}`;
        return HttpClient.get(url);
      },
      deleteafile: (me, path, fileId, postId) => {
        const url = `${API_ENDPOINTS.ONE_FILE}/${me.hubspotPortals.templateName}${path}/${postId}/${fileId}`;
        return HttpClient.delete(url);
      },
      createAfolder: ({ objectId, id, portalId, fileData }) => {
        const url = `/api/${hubId}/${portalId}/hubspot-object-folders/${objectId}/${id}`;
        return HttpClient.post(url, fileData);
      }
    },
    notes: {
      all: ({ objectId, id, limit = 5, page, portalId, cache, ...query }) => {
        const url = `/api/${hubId}/${portalId}/hubspot-object-notes/${objectId}/${id}`;
        return HttpClient.get(url, {
          limit,
          page,
          cache: !!cache,
          ...query
        });
      },
      createnote: ({ objectId, id, noteBody, attachmentId, portalId }) => {
        const url = `/api/${hubId}/${portalId}/hubspot-object-notes/${objectId}/${id}`;
        return HttpClient.post(url, { noteBody, attachmentId });
      },
      updateNote: ({ objectId, id, note, note_id, portalId }) => {
        const url = `/api/${hubId}/${portalId}/hubspot-object-notes/${objectId}/${id}/${note_id}`;
        return HttpClient.put(url, note);
      },
      imageUpload: (me, fileId, path, data) => {
        const url = `${API_ENDPOINTS.ALL_NOTES}/${me.hubspotPortals.templateName}${path}/${fileId}`;
        return HttpClient.post(url, data);
      }
    },
    objects: {
      all: ({
        // limit = 10,
        // after,
        // sort = "updatedAt",
        // inputValue,
        // page,
        // me,
        // // portalId,
        // // hubspotObjectTypeId,
        // API_ENDPOINT,
        // cache,
        // // param,
        // ...query
        API_ENDPOINT,
        param
      }) => HttpClient.get(
        // `/api/${portalId}/hubspot-object-data/${hubspotObjectTypeId}${param}`,
        API_ENDPOINT,
        // `${API_ENDPOINTS.OBJECTS}/${me.hubspotPortals.templateName}${path}`,
        param
      ),
      byObjectId: ({ path, objectId, id, urlParam, portalId, hubId: hubId2, cache, ...query }) => HttpClient.get(
        // `${API_ENDPOINTS.OBJECTS_BY_ID}/${me.hubspotPortals.templateName}${path}/${objectId}`
        // `/api/${portalId}/hubspot-object-data/${objectId}/${id}${mediatorObjectTypeId && mediatorObjectRecordId ? '?mediatorObjectTypeId='+mediatorObjectTypeId+'&mediatorObjectRecordId='+mediatorObjectRecordId : ''}`
        `/api/${hubId2}/${portalId}/hubspot-object-data/${objectId}/${id}${urlParam}`,
        {
          cache: !!cache,
          ...query
        }
      )
    },
    products: {
      all: ({ categories, tags, name, shop_id, price, page, ...query }) => HttpClient.get(API_ENDPOINTS.PRODUCTS, {
        searchJoin: "and",
        with: "shop",
        orderBy: "updated_at",
        sortedBy: "ASC",
        page,
        ...query,
        search: HttpClient.formatSearchParams({
          categories,
          tags,
          name,
          shop_id,
          price,
          status: "publish"
        })
      }),
      store: (data) => HttpClient.post(API_ENDPOINTS.PRODUCTS, data)
    },
    form: {
      fields: ({ API }) => HttpClient.get(API),
      formData: ({ API, params }) => HttpClient.get(generateApiUrl({ route: API, params })),
      stages: ({ API }) => HttpClient.get(API),
      options: ({ API }) => HttpClient.get(API),
      create: ({ API, data }) => HttpClient.post(API, data),
      createExisting: ({ API, params, data }) => HttpClient.post(generateApiUrl({ route: API, params }), data),
      removeExisting: ({ API, params, data }) => HttpClient.post(generateApiUrl({ route: API, params }), data),
      update: ({ API, data }) => HttpClient.put(API, data)
    },
    details: {
      update: ({ data, params, queryParams }) => {
        const apiUrl = generateApiUrl({ route: API_ENDPOINTS.DETAILS_SAVE, params, queryParams });
        return HttpClient.put(apiUrl, data);
      },
      stages: ({ params }) => {
        const apiUrl = generateApiUrl({ route: API_ENDPOINTS.STAGES, params });
        return HttpClient.get(apiUrl);
      }
    },
    Deals: {
      pipelines: ({ API_ENDPOINT, param }) => {
        return HttpClient.get(
          API_ENDPOINT,
          param
          // {
          //   cache: !!cache,
          //   ...query,
          // }
        );
      },
      pipelineDeals: ({ API_ENDPOINT }) => {
        return HttpClient.get(
          API_ENDPOINT
          // {
          //   cache: !!cache,
          //   ...query,
          // }
        );
      },
      updatePipelineDeal: ({ API_ENDPOINT, data }) => {
        return HttpClient.put(API_ENDPOINT, data);
      }
      // uploadFile: ({objectId, id, portalId, fileData}) => {
      //   // const url = `${API_ENDPOINTS.FILE_UPLOAD}/${me.hubspotPortals.templateName}${path}/${fileId}`;
      //   const url = `/api/${hubId}/${portalId}/hubspot-object-files/${objectId}/${id}`;
      //   return HttpClient.post(url, fileData);
      // },
      // getDetails: ({objectId, id, portalId, rowId}) => {
      //   // const url = `${API_ENDPOINTS.ONE_FILE}/${me.hubspotPortals.templateName}${path}/${postId}/${fileId}`;
      //   const url = `/api/${hubId}/${portalId}/hubspot-object-files/${objectId}/${id}/${rowId}`;
      //   return HttpClient.get(url);
      // },
      // deleteafile: (me, path, fileId, postId) => {
      //   const url = `${API_ENDPOINTS.ONE_FILE}/${me.hubspotPortals.templateName}${path}/${postId}/${fileId}`;
      //   return HttpClient.delete(url);
      // },
      // createAfolder: ({objectId, id, portalId, fileData}) => {
      //   // const url = `${API_ENDPOINTS.FOLDER_UPLOAD}/${me.hubspotPortals.templateName}${path}/${fileId}`;
      //   const url = `/api/${hubId}/${portalId}/hubspot-object-folders/${objectId}/${id}`;
      //   return HttpClient.post(url, fileData);
      // },
    }
  };
  const __vite_import_meta_env__$2 = {};
  const isSelfAtom = (atom2, a) => atom2.unstable_is ? atom2.unstable_is(a) : a === atom2;
  const hasInitialValue = (atom2) => "init" in atom2;
  const isActuallyWritableAtom = (atom2) => !!atom2.write;
  const isAtomStateInitialized = (atomState) => "v" in atomState || "e" in atomState;
  const returnAtomValue = (atomState) => {
    if ("e" in atomState) {
      throw atomState.e;
    }
    if ((__vite_import_meta_env__$2 ? "production" : void 0) !== "production" && !("v" in atomState)) {
      throw new Error("[Bug] atom state is not initialized");
    }
    return atomState.v;
  };
  const promiseStateMap = /* @__PURE__ */ new WeakMap();
  const isPendingPromise = (value) => {
    var _a2;
    return isPromiseLike$1(value) && !!((_a2 = promiseStateMap.get(value)) == null ? void 0 : _a2[0]);
  };
  const abortPromise = (promise) => {
    const promiseState = promiseStateMap.get(promise);
    if (promiseState == null ? void 0 : promiseState[0]) {
      promiseState[0] = false;
      promiseState[1].forEach((fn) => fn());
    }
  };
  const registerAbortHandler = (promise, abortHandler) => {
    let promiseState = promiseStateMap.get(promise);
    if (!promiseState) {
      promiseState = [true, /* @__PURE__ */ new Set()];
      promiseStateMap.set(promise, promiseState);
      const settle2 = () => {
        promiseState[0] = false;
      };
      promise.then(settle2, settle2);
    }
    promiseState[1].add(abortHandler);
  };
  const isPromiseLike$1 = (p) => typeof (p == null ? void 0 : p.then) === "function";
  const addPendingPromiseToDependency = (atom2, promise, dependencyAtomState) => {
    if (!dependencyAtomState.p.has(atom2)) {
      dependencyAtomState.p.add(atom2);
      promise.then(
        () => {
          dependencyAtomState.p.delete(atom2);
        },
        () => {
          dependencyAtomState.p.delete(atom2);
        }
      );
    }
  };
  const setAtomStateValueOrPromise = (atom2, valueOrPromise, ensureAtomState) => {
    const atomState = ensureAtomState(atom2);
    const hasPrevValue = "v" in atomState;
    const prevValue = atomState.v;
    if (isPromiseLike$1(valueOrPromise)) {
      for (const a of atomState.d.keys()) {
        addPendingPromiseToDependency(atom2, valueOrPromise, ensureAtomState(a));
      }
    }
    atomState.v = valueOrPromise;
    delete atomState.e;
    if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {
      ++atomState.n;
      if (isPromiseLike$1(prevValue)) {
        abortPromise(prevValue);
      }
    }
  };
  const getMountedOrPendingDependents = (atom2, atomState, mountedMap) => {
    var _a2;
    const dependents = /* @__PURE__ */ new Set();
    for (const a of ((_a2 = mountedMap.get(atom2)) == null ? void 0 : _a2.t) || []) {
      if (mountedMap.has(a)) {
        dependents.add(a);
      }
    }
    for (const atomWithPendingPromise of atomState.p) {
      dependents.add(atomWithPendingPromise);
    }
    return dependents;
  };
  const createStoreHook = () => {
    const callbacks = /* @__PURE__ */ new Set();
    const notify = () => {
      callbacks.forEach((fn) => fn());
    };
    notify.add = (fn) => {
      callbacks.add(fn);
      return () => {
        callbacks.delete(fn);
      };
    };
    return notify;
  };
  const createStoreHookForAtoms = () => {
    const all2 = {};
    const callbacks = /* @__PURE__ */ new WeakMap();
    const notify = (atom2) => {
      var _a2, _b2;
      (_a2 = callbacks.get(all2)) == null ? void 0 : _a2.forEach((fn) => fn(atom2));
      (_b2 = callbacks.get(atom2)) == null ? void 0 : _b2.forEach((fn) => fn());
    };
    notify.add = (atom2, fn) => {
      const key2 = atom2 || all2;
      const fns = (callbacks.has(key2) ? callbacks : callbacks.set(key2, /* @__PURE__ */ new Set())).get(key2);
      fns.add(fn);
      return () => {
        fns == null ? void 0 : fns.delete(fn);
        if (!fns.size) {
          callbacks.delete(key2);
        }
      };
    };
    return notify;
  };
  const initializeStoreHooks = (storeHooks) => {
    storeHooks.c || (storeHooks.c = createStoreHookForAtoms());
    storeHooks.m || (storeHooks.m = createStoreHookForAtoms());
    storeHooks.u || (storeHooks.u = createStoreHookForAtoms());
    storeHooks.f || (storeHooks.f = createStoreHook());
    return storeHooks;
  };
  const BUILDING_BLOCKS = Symbol();
  const buildStore = (atomStateMap = /* @__PURE__ */ new WeakMap(), mountedMap = /* @__PURE__ */ new WeakMap(), invalidatedAtoms = /* @__PURE__ */ new WeakMap(), changedAtoms = /* @__PURE__ */ new Set(), mountCallbacks = /* @__PURE__ */ new Set(), unmountCallbacks = /* @__PURE__ */ new Set(), storeHooks = {}, atomRead = (atom2, ...params) => atom2.read(...params), atomWrite = (atom2, ...params) => atom2.write(...params), atomOnInit = (atom2, store) => {
    var _a2;
    return (_a2 = atom2.unstable_onInit) == null ? void 0 : _a2.call(atom2, store);
  }, atomOnMount = (atom2, setAtom) => {
    var _a2;
    return (_a2 = atom2.onMount) == null ? void 0 : _a2.call(atom2, setAtom);
  }, ...buildingBlockFunctions) => {
    const ensureAtomState = buildingBlockFunctions[0] || ((atom2) => {
      if ((__vite_import_meta_env__$2 ? "production" : void 0) !== "production" && !atom2) {
        throw new Error("Atom is undefined or null");
      }
      let atomState = atomStateMap.get(atom2);
      if (!atomState) {
        atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };
        atomStateMap.set(atom2, atomState);
        atomOnInit == null ? void 0 : atomOnInit(atom2, store);
      }
      return atomState;
    });
    const flushCallbacks = buildingBlockFunctions[1] || (() => {
      const errors = [];
      const call = (fn) => {
        try {
          fn();
        } catch (e) {
          errors.push(e);
        }
      };
      do {
        if (storeHooks.f) {
          call(storeHooks.f);
        }
        const callbacks = /* @__PURE__ */ new Set();
        const add2 = callbacks.add.bind(callbacks);
        changedAtoms.forEach((atom2) => {
          var _a2;
          return (_a2 = mountedMap.get(atom2)) == null ? void 0 : _a2.l.forEach(add2);
        });
        changedAtoms.clear();
        unmountCallbacks.forEach(add2);
        unmountCallbacks.clear();
        mountCallbacks.forEach(add2);
        mountCallbacks.clear();
        callbacks.forEach(call);
        if (changedAtoms.size) {
          recomputeInvalidatedAtoms();
        }
      } while (changedAtoms.size || unmountCallbacks.size || mountCallbacks.size);
      if (errors.length) {
        throw new AggregateError(errors);
      }
    });
    const recomputeInvalidatedAtoms = buildingBlockFunctions[2] || (() => {
      const topSortedReversed = [];
      const visiting = /* @__PURE__ */ new WeakSet();
      const visited = /* @__PURE__ */ new WeakSet();
      const stack = Array.from(changedAtoms);
      while (stack.length) {
        const a = stack[stack.length - 1];
        const aState = ensureAtomState(a);
        if (visited.has(a)) {
          stack.pop();
          continue;
        }
        if (visiting.has(a)) {
          if (invalidatedAtoms.get(a) === aState.n) {
            topSortedReversed.push([a, aState]);
          } else if ((__vite_import_meta_env__$2 ? "production" : void 0) !== "production" && invalidatedAtoms.has(a)) {
            throw new Error("[Bug] invalidated atom exists");
          }
          visited.add(a);
          stack.pop();
          continue;
        }
        visiting.add(a);
        for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {
          if (!visiting.has(d)) {
            stack.push(d);
          }
        }
      }
      for (let i2 = topSortedReversed.length - 1; i2 >= 0; --i2) {
        const [a, aState] = topSortedReversed[i2];
        let hasChangedDeps = false;
        for (const dep of aState.d.keys()) {
          if (dep !== a && changedAtoms.has(dep)) {
            hasChangedDeps = true;
            break;
          }
        }
        if (hasChangedDeps) {
          readAtomState(a);
          mountDependencies(a);
        }
        invalidatedAtoms.delete(a);
      }
    });
    const readAtomState = buildingBlockFunctions[3] || ((atom2) => {
      var _a2;
      const atomState = ensureAtomState(atom2);
      if (isAtomStateInitialized(atomState)) {
        if (mountedMap.has(atom2) && invalidatedAtoms.get(atom2) !== atomState.n) {
          return atomState;
        }
        if (Array.from(atomState.d).every(
          ([a, n]) => (
            // Recursively, read the atom state of the dependency, and
            // check if the atom epoch number is unchanged
            readAtomState(a).n === n
          )
        )) {
          return atomState;
        }
      }
      atomState.d.clear();
      let isSync = true;
      const mountDependenciesIfAsync = () => {
        if (mountedMap.has(atom2)) {
          mountDependencies(atom2);
          recomputeInvalidatedAtoms();
          flushCallbacks();
        }
      };
      const getter = (a) => {
        var _a22;
        if (isSelfAtom(atom2, a)) {
          const aState2 = ensureAtomState(a);
          if (!isAtomStateInitialized(aState2)) {
            if (hasInitialValue(a)) {
              setAtomStateValueOrPromise(a, a.init, ensureAtomState);
            } else {
              throw new Error("no atom init");
            }
          }
          return returnAtomValue(aState2);
        }
        const aState = readAtomState(a);
        try {
          return returnAtomValue(aState);
        } finally {
          atomState.d.set(a, aState.n);
          if (isPendingPromise(atomState.v)) {
            addPendingPromiseToDependency(atom2, atomState.v, aState);
          }
          (_a22 = mountedMap.get(a)) == null ? void 0 : _a22.t.add(atom2);
          if (!isSync) {
            mountDependenciesIfAsync();
          }
        }
      };
      let controller;
      let setSelf;
      const options = {
        get signal() {
          if (!controller) {
            controller = new AbortController();
          }
          return controller.signal;
        },
        get setSelf() {
          if ((__vite_import_meta_env__$2 ? "production" : void 0) !== "production" && !isActuallyWritableAtom(atom2)) {
            console.warn("setSelf function cannot be used with read-only atom");
          }
          if (!setSelf && isActuallyWritableAtom(atom2)) {
            setSelf = (...args) => {
              if ((__vite_import_meta_env__$2 ? "production" : void 0) !== "production" && isSync) {
                console.warn("setSelf function cannot be called in sync");
              }
              if (!isSync) {
                try {
                  return writeAtomState(atom2, ...args);
                } finally {
                  recomputeInvalidatedAtoms();
                  flushCallbacks();
                }
              }
            };
          }
          return setSelf;
        }
      };
      const prevEpochNumber = atomState.n;
      try {
        const valueOrPromise = atomRead(atom2, getter, options);
        setAtomStateValueOrPromise(atom2, valueOrPromise, ensureAtomState);
        if (isPromiseLike$1(valueOrPromise)) {
          registerAbortHandler(valueOrPromise, () => controller == null ? void 0 : controller.abort());
          valueOrPromise.then(
            mountDependenciesIfAsync,
            mountDependenciesIfAsync
          );
        }
        return atomState;
      } catch (error) {
        delete atomState.v;
        atomState.e = error;
        ++atomState.n;
        return atomState;
      } finally {
        isSync = false;
        if (prevEpochNumber !== atomState.n && invalidatedAtoms.get(atom2) === prevEpochNumber) {
          invalidatedAtoms.set(atom2, atomState.n);
          changedAtoms.add(atom2);
          (_a2 = storeHooks.c) == null ? void 0 : _a2.call(storeHooks, atom2);
        }
      }
    });
    const invalidateDependents = buildingBlockFunctions[4] || ((atom2) => {
      const stack = [atom2];
      while (stack.length) {
        const a = stack.pop();
        const aState = ensureAtomState(a);
        for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {
          const dState = ensureAtomState(d);
          invalidatedAtoms.set(d, dState.n);
          stack.push(d);
        }
      }
    });
    const writeAtomState = buildingBlockFunctions[5] || ((atom2, ...args) => {
      let isSync = true;
      const getter = (a) => returnAtomValue(readAtomState(a));
      const setter = (a, ...args2) => {
        var _a2;
        const aState = ensureAtomState(a);
        try {
          if (isSelfAtom(atom2, a)) {
            if (!hasInitialValue(a)) {
              throw new Error("atom not writable");
            }
            const prevEpochNumber = aState.n;
            const v = args2[0];
            setAtomStateValueOrPromise(a, v, ensureAtomState);
            mountDependencies(a);
            if (prevEpochNumber !== aState.n) {
              changedAtoms.add(a);
              (_a2 = storeHooks.c) == null ? void 0 : _a2.call(storeHooks, a);
              invalidateDependents(a);
            }
            return void 0;
          } else {
            return writeAtomState(a, ...args2);
          }
        } finally {
          if (!isSync) {
            recomputeInvalidatedAtoms();
            flushCallbacks();
          }
        }
      };
      try {
        return atomWrite(atom2, getter, setter, ...args);
      } finally {
        isSync = false;
      }
    });
    const mountDependencies = buildingBlockFunctions[6] || ((atom2) => {
      var _a2;
      const atomState = ensureAtomState(atom2);
      const mounted = mountedMap.get(atom2);
      if (mounted && !isPendingPromise(atomState.v)) {
        for (const [a, n] of atomState.d) {
          if (!mounted.d.has(a)) {
            const aState = ensureAtomState(a);
            const aMounted = mountAtom(a);
            aMounted.t.add(atom2);
            mounted.d.add(a);
            if (n !== aState.n) {
              changedAtoms.add(a);
              (_a2 = storeHooks.c) == null ? void 0 : _a2.call(storeHooks, a);
              invalidateDependents(a);
            }
          }
        }
        for (const a of mounted.d || []) {
          if (!atomState.d.has(a)) {
            mounted.d.delete(a);
            const aMounted = unmountAtom(a);
            aMounted == null ? void 0 : aMounted.t.delete(atom2);
          }
        }
      }
    });
    const mountAtom = buildingBlockFunctions[7] || ((atom2) => {
      var _a2;
      const atomState = ensureAtomState(atom2);
      let mounted = mountedMap.get(atom2);
      if (!mounted) {
        readAtomState(atom2);
        for (const a of atomState.d.keys()) {
          const aMounted = mountAtom(a);
          aMounted.t.add(atom2);
        }
        mounted = {
          l: /* @__PURE__ */ new Set(),
          d: new Set(atomState.d.keys()),
          t: /* @__PURE__ */ new Set()
        };
        mountedMap.set(atom2, mounted);
        (_a2 = storeHooks.m) == null ? void 0 : _a2.call(storeHooks, atom2);
        if (isActuallyWritableAtom(atom2)) {
          const processOnMount = () => {
            let isSync = true;
            const setAtom = (...args) => {
              try {
                return writeAtomState(atom2, ...args);
              } finally {
                if (!isSync) {
                  recomputeInvalidatedAtoms();
                  flushCallbacks();
                }
              }
            };
            try {
              const onUnmount = atomOnMount(atom2, setAtom);
              if (onUnmount) {
                mounted.u = () => {
                  isSync = true;
                  try {
                    onUnmount();
                  } finally {
                    isSync = false;
                  }
                };
              }
            } finally {
              isSync = false;
            }
          };
          mountCallbacks.add(processOnMount);
        }
      }
      return mounted;
    });
    const unmountAtom = buildingBlockFunctions[8] || ((atom2) => {
      var _a2;
      const atomState = ensureAtomState(atom2);
      let mounted = mountedMap.get(atom2);
      if (mounted && !mounted.l.size && !Array.from(mounted.t).some((a) => {
        var _a22;
        return (_a22 = mountedMap.get(a)) == null ? void 0 : _a22.d.has(atom2);
      })) {
        if (mounted.u) {
          unmountCallbacks.add(mounted.u);
        }
        mounted = void 0;
        mountedMap.delete(atom2);
        (_a2 = storeHooks.u) == null ? void 0 : _a2.call(storeHooks, atom2);
        for (const a of atomState.d.keys()) {
          const aMounted = unmountAtom(a);
          aMounted == null ? void 0 : aMounted.t.delete(atom2);
        }
        return void 0;
      }
      return mounted;
    });
    const buildingBlocks = [
      // store state
      atomStateMap,
      mountedMap,
      invalidatedAtoms,
      changedAtoms,
      mountCallbacks,
      unmountCallbacks,
      storeHooks,
      // atom interceptors
      atomRead,
      atomWrite,
      atomOnInit,
      atomOnMount,
      // building-block functions
      ensureAtomState,
      flushCallbacks,
      recomputeInvalidatedAtoms,
      readAtomState,
      invalidateDependents,
      writeAtomState,
      mountDependencies,
      mountAtom,
      unmountAtom
    ];
    const store = {
      get: (atom2) => returnAtomValue(readAtomState(atom2)),
      set: (atom2, ...args) => {
        try {
          return writeAtomState(atom2, ...args);
        } finally {
          recomputeInvalidatedAtoms();
          flushCallbacks();
        }
      },
      sub: (atom2, listener) => {
        const mounted = mountAtom(atom2);
        const listeners = mounted.l;
        listeners.add(listener);
        flushCallbacks();
        return () => {
          listeners.delete(listener);
          unmountAtom(atom2);
          flushCallbacks();
        };
      }
    };
    Object.defineProperty(store, BUILDING_BLOCKS, { value: buildingBlocks });
    return store;
  };
  const INTERNAL_buildStoreRev1 = buildStore;
  const INTERNAL_initializeStoreHooks = initializeStoreHooks;
  const INTERNAL_registerAbortHandler = registerAbortHandler;
  const __vite_import_meta_env__$1 = {};
  let keyCount = 0;
  function atom(read, write) {
    const key2 = `atom${++keyCount}`;
    const config = {
      toString() {
        return (__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && this.debugLabel ? key2 + ":" + this.debugLabel : key2;
      }
    };
    if (typeof read === "function") {
      config.read = read;
    } else {
      config.init = read;
      config.read = defaultRead;
      config.write = defaultWrite;
    }
    return config;
  }
  function defaultRead(get2) {
    return get2(this);
  }
  function defaultWrite(get2, set2, arg) {
    return set2(
      this,
      typeof arg === "function" ? arg(get2(this)) : arg
    );
  }
  const createDevStoreRev4 = () => {
    let inRestoreAtom = 0;
    const storeHooks = INTERNAL_initializeStoreHooks({});
    const atomStateMap = /* @__PURE__ */ new WeakMap();
    const mountedAtoms = /* @__PURE__ */ new WeakMap();
    const store = INTERNAL_buildStoreRev1(
      atomStateMap,
      mountedAtoms,
      void 0,
      void 0,
      void 0,
      void 0,
      storeHooks,
      void 0,
      (atom2, get2, set2, ...args) => {
        if (inRestoreAtom) {
          return set2(atom2, ...args);
        }
        return atom2.write(get2, set2, ...args);
      }
    );
    const debugMountedAtoms = /* @__PURE__ */ new Set();
    storeHooks.m.add(void 0, (atom2) => {
      debugMountedAtoms.add(atom2);
      const atomState = atomStateMap.get(atom2);
      atomState.m = mountedAtoms.get(atom2);
    });
    storeHooks.u.add(void 0, (atom2) => {
      debugMountedAtoms.delete(atom2);
      const atomState = atomStateMap.get(atom2);
      delete atomState.m;
    });
    const devStore = {
      // store dev methods (these are tentative and subject to change without notice)
      dev4_get_internal_weak_map: () => {
        console.log("Deprecated: Use devstore from the devtools library");
        return atomStateMap;
      },
      dev4_get_mounted_atoms: () => debugMountedAtoms,
      dev4_restore_atoms: (values) => {
        const restoreAtom = {
          read: () => null,
          write: (_get, set2) => {
            ++inRestoreAtom;
            try {
              for (const [atom2, value] of values) {
                if ("init" in atom2) {
                  set2(atom2, value);
                }
              }
            } finally {
              --inRestoreAtom;
            }
          }
        };
        store.set(restoreAtom);
      }
    };
    return Object.assign(store, devStore);
  };
  function createStore() {
    if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production") {
      return createDevStoreRev4();
    }
    return INTERNAL_buildStoreRev1();
  }
  let defaultStore$1;
  function getDefaultStore() {
    if (!defaultStore$1) {
      defaultStore$1 = createStore();
      if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production") {
        globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore$1);
        if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore$1) {
          console.warn(
            "Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044"
          );
        }
      }
    }
    return defaultStore$1;
  }
  const __vite_import_meta_env__ = {};
  const StoreContext = reactExports.createContext(
    void 0
  );
  function useStore(options) {
    const store = reactExports.useContext(StoreContext);
    return store || getDefaultStore();
  }
  const isPromiseLike = (x2) => typeof (x2 == null ? void 0 : x2.then) === "function";
  const attachPromiseStatus = (promise) => {
    if (!promise.status) {
      promise.status = "pending";
      promise.then(
        (v) => {
          promise.status = "fulfilled";
          promise.value = v;
        },
        (e) => {
          promise.status = "rejected";
          promise.reason = e;
        }
      );
    }
  };
  const use = React.use || // A shim for older React versions
  ((promise) => {
    if (promise.status === "pending") {
      throw promise;
    } else if (promise.status === "fulfilled") {
      return promise.value;
    } else if (promise.status === "rejected") {
      throw promise.reason;
    } else {
      attachPromiseStatus(promise);
      throw promise;
    }
  });
  const continuablePromiseMap = /* @__PURE__ */ new WeakMap();
  const createContinuablePromise = (promise, getValue) => {
    let continuablePromise = continuablePromiseMap.get(promise);
    if (!continuablePromise) {
      continuablePromise = new Promise((resolve, reject) => {
        let curr = promise;
        const onFulfilled = (me) => (v) => {
          if (curr === me) {
            resolve(v);
          }
        };
        const onRejected = (me) => (e) => {
          if (curr === me) {
            reject(e);
          }
        };
        const onAbort = () => {
          try {
            const nextValue = getValue();
            if (isPromiseLike(nextValue)) {
              continuablePromiseMap.set(nextValue, continuablePromise);
              curr = nextValue;
              nextValue.then(onFulfilled(nextValue), onRejected(nextValue));
              INTERNAL_registerAbortHandler(nextValue, onAbort);
            } else {
              resolve(nextValue);
            }
          } catch (e) {
            reject(e);
          }
        };
        promise.then(onFulfilled(promise), onRejected(promise));
        INTERNAL_registerAbortHandler(promise, onAbort);
      });
      continuablePromiseMap.set(promise, continuablePromise);
    }
    return continuablePromise;
  };
  function useAtomValue(atom2, options) {
    const { delay, unstable_promiseStatus: promiseStatus = !React.use } = {};
    const store = useStore();
    const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = reactExports.useReducer(
      (prev) => {
        const nextValue = store.get(atom2);
        if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom2) {
          return prev;
        }
        return [nextValue, store, atom2];
      },
      void 0,
      () => [store.get(atom2), store, atom2]
    );
    let value = valueFromReducer;
    if (storeFromReducer !== store || atomFromReducer !== atom2) {
      rerender();
      value = store.get(atom2);
    }
    reactExports.useEffect(() => {
      const unsub = store.sub(atom2, () => {
        if (promiseStatus) {
          try {
            const value2 = store.get(atom2);
            if (isPromiseLike(value2)) {
              attachPromiseStatus(
                createContinuablePromise(value2, () => store.get(atom2))
              );
            }
          } catch (e) {
          }
        }
        if (typeof delay === "number") {
          setTimeout(rerender, delay);
          return;
        }
        rerender();
      });
      rerender();
      return unsub;
    }, [store, atom2, delay, promiseStatus]);
    reactExports.useDebugValue(value);
    if (isPromiseLike(value)) {
      const promise = createContinuablePromise(value, () => store.get(atom2));
      if (promiseStatus) {
        attachPromiseStatus(promise);
      }
      return use(promise);
    }
    return value;
  }
  function useSetAtom(atom2, options) {
    const store = useStore();
    const setAtom = reactExports.useCallback(
      (...args) => {
        if ((__vite_import_meta_env__ ? "production" : void 0) !== "production" && !("write" in atom2)) {
          throw new Error("not writable atom");
        }
        return store.set(atom2, ...args);
      },
      [store, atom2]
    );
    return setAtom;
  }
  function useAtom(atom2, options) {
    return [
      useAtomValue(atom2),
      // We do wrong type assertion here, which results in throwing an error.
      useSetAtom(atom2)
    ];
  }
  const isCollapsibleState = atom(false);
  const isOpenState = atom(false);
  const profileState = atom({
    firstName: "",
    lastName: "",
    email: "",
    hubId: "",
    templatename: "",
    logo: "",
    primaryColor: "",
    secondaryColor: "",
    hubspotDomain: ""
  });
  const authorizationState = atom(checkHasAuthToken());
  const logoutDialogState = atom(false);
  const routeState = atom([]);
  const syncState = atom(false);
  const syncLoadingState = atom(false);
  const syncDisableState = atom(false);
  const breadcrumbState = atom([]);
  const fontState = atom("Select");
  const isLoadingUploadingState = atom(false);
  const uploadProgressState = atom(0);
  const attachmentsState = atom([]);
  const linkDataState = atom(null);
  atom("");
  atom(localStorage.theme);
  const toasterState = atom(null);
  const pageLimit$1 = env$1.VITE_TABLE_PAGE_LIMIT;
  const tableSortState = atom("-hs_createdate");
  const tableLimitState = atom(pageLimit$1);
  const tableAfterState = atom("");
  const tablePageState = atom(1);
  const tableTotalItemsState = atom(1);
  const tableNumOfPagesState = atom(1);
  const tableCurrentPageState = atom(1);
  const tableSearchState = atom("");
  const tableFilterPropertyNameState = atom("hs_pipeline");
  const tableFilterPropertyOperatorState = atom("eq");
  const tableFilterPropertyValueState = atom("");
  const tableIsPrimaryCompanyState = atom(null);
  const tableViewState = atom(null);
  const tableSelectedPipelineState = atom("");
  const tableParamState = atom({});
  const gridDataState = atom([]);
  function useAuth() {
    const [isAuthorized, setAuthorized] = useAtom(authorizationState);
    const [logoutDialog, setLogoutDialog] = useAtom(logoutDialogState);
    const [profileDetails, setProfileDetails] = useAtom(profileState);
    return {
      setToken: setAuthToken,
      getToken: getAuthToken,
      isAuthorized,
      authorize(token) {
        setAuthToken(token);
        setAuthorized(true);
      },
      unauthorize() {
        setAuthorized(false);
        removeAuthToken();
      },
      profileDetails,
      setProfileDetails,
      logoutDialog,
      setLogoutDialog
    };
  }
  function useMe$1() {
    const { isAuthorized } = useAuth();
    let response = null;
    const { data, isLoading, error, refetch } = useQuery({
      queryKey: ["me_data"],
      queryFn: () => Client.users.me(hubId),
      staleTime: 1e4
      // queryFn: async () => Client.users.me,
      // enabled: isAuthorized
    });
    const getMe = () => {
      refetch();
    };
    if (data) {
      response = data.data;
      const portalSettings = response.portalSettings;
      setCookie(
        env$1.VITE_AUTH_PORTAL_KEY,
        JSON.stringify(portalSettings)
      );
      setCookie(env$1.VITE_AUTH_USER_KEY, JSON.stringify(response));
    }
    return {
      me: response,
      isLoading,
      error,
      isAuthorized,
      getMe
    };
  }
  function useLogout() {
    const { unauthorize, setLogoutDialog } = useAuth();
    const mutation = useMutation({
      mutationFn: Client.authentication.Logout,
      onSuccess: () => {
        window.location.hash = "/login";
        unauthorize();
        setLogoutDialog(false);
      },
      onError: (err2) => {
        console.error("Logout failed: ", err2);
      }
    });
    return {
      logout: mutation.mutate,
      isLoading: mutation.isLoading,
      error: mutation.error
    };
  }
  const Link = ({ className, children, ...props }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Link$1, { to: props.href, ...props, className, children });
  };
  const OpenIcon = ({
    color = "currentColor",
    width = "12px",
    height = "12px",
    ...props
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width,
        height,
        fill: color,
        ...props,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h280v80H200v560h560v-280h80v280q0 33-23.5 56.5T760-120H200Zm188-212-56-56 372-372H560v-80h280v280h-80v-144L388-332Z" })
      }
    );
  };
  const currencyLogo = {
    "AED": ".",
    "AFN": "",
    "ALL": "L",
    "AMD": "",
    "ANG": "",
    "AOA": "Kz",
    "ARS": "$",
    "AUD": "$",
    "AWG": "",
    "AZN": "",
    "BAM": "KM",
    "BBD": "$",
    "BDT": "",
    "BGN": "",
    "BHD": "..",
    "BIF": "FBu",
    "BMD": "$",
    "BND": "$",
    "BOB": "Bs.",
    "BRL": "R$",
    "BSD": "$",
    "BTN": "Nu.",
    "BWP": "P",
    "BYN": "Br",
    "BZD": "BZ$",
    "CAD": "$",
    "CDF": "FC",
    "CHF": "Fr.",
    "CLP": "$",
    "CNY": "",
    "COP": "$",
    "CRC": "",
    "CUC": "$",
    "CUP": "$",
    "CVE": "$",
    "CZK": "K",
    "DJF": "Fdj",
    "DKK": "kr",
    "DOP": "RD$",
    "DZD": ".",
    "EGP": "",
    "ERN": "Nfk",
    "ETB": "Br",
    "EUR": "",
    "FJD": "$",
    "FKP": "",
    "FOK": "kr",
    "GBP": "",
    "GEL": "",
    "GGP": "",
    "GHS": "",
    "GIP": "",
    "GMD": "D",
    "GNF": "FG",
    "GTQ": "Q",
    "GYD": "$",
    "HKD": "$",
    "HNL": "L",
    "HRK": "kn",
    "HTG": "G",
    "HUF": "Ft",
    "IDR": "Rp",
    "ILS": "",
    "IMP": "",
    "INR": "",
    "IQD": ".",
    "IRR": "",
    "ISK": "kr",
    "JEP": "",
    "JMD": "J$",
    "JOD": ".",
    "JPY": "",
    "KES": "KSh",
    "KGS": "",
    "KHR": "",
    "KID": "$",
    "KMF": "CF",
    "KRW": "",
    "KWD": ".",
    "KYD": "$",
    "KZT": "",
    "LAK": "",
    "LBP": ".",
    "LKR": "Rs",
    "LRD": "$",
    "LSL": "L",
    "LYD": ".",
    "MAD": "..",
    "MDL": "L",
    "MGA": "Ar",
    "MKD": "",
    "MMK": "K",
    "MNT": "",
    "MOP": "P",
    "MRU": "UM",
    "MUR": "",
    "MVR": "Rf",
    "MWK": "MK",
    "MXN": "$",
    "MYR": "RM",
    "MZN": "MT",
    "NAD": "$",
    "NGN": "",
    "NIO": "C$",
    "NOK": "kr",
    "NPR": "",
    "NZD": "$",
    "OMR": "..",
    "PAB": "B/.",
    "PEN": "S/",
    "PGK": "K",
    "PHP": "",
    "PKR": "",
    "PLN": "z",
    "PYG": "",
    "QAR": ".",
    "RON": "lei",
    "RSD": ".",
    "RUB": "",
    "RWF": "FRw",
    "SAR": ".",
    "SBD": "$",
    "SCR": "",
    "SDG": "..",
    "SEK": "kr",
    "SGD": "$",
    "SHP": "",
    "SLL": "Le",
    "SOS": "Sh.",
    "SRD": "$",
    "SSP": "",
    "STN": "Db",
    "SYP": "",
    "SZL": "E",
    "THB": "",
    "TJS": "",
    "TMT": "m",
    "TND": ".",
    "TOP": "T$",
    "TRY": "",
    "TTD": "$",
    "TVD": "$",
    "TWD": "NT$",
    "TZS": "Sh",
    "UAH": "",
    "UGX": "USh",
    "USD": "$",
    "UYU": "$U",
    "UZS": "",
    "VES": "Bs.",
    "VND": "",
    "VUV": "VT",
    "WST": "T",
    "XAF": "FCFA",
    "XCD": "$",
    "XOF": "CFA",
    "XPF": "",
    "YER": "",
    "ZAR": "R",
    "ZMW": "ZK",
    "ZWL": "$"
  };
  const Currency = (currencyCode = "USD") => {
    const currencySymbol = currencyLogo[currencyCode];
    return currencySymbol;
  };
  const formatDate$1 = (date) => {
    const d = new Date(date);
    const day = String(d.getDate()).padStart(2, "0");
    const month = String(d.getMonth() + 1).padStart(2, "0");
    const year = d.getFullYear();
    return `${month}/${day}/${year}`;
  };
  const calculateGMToffset = (date) => {
    const offsetMinutes = date.getTimezoneOffset();
    const absOffset = Math.abs(offsetMinutes);
    const offsetHours = Math.floor(absOffset / 60);
    const offsetMins = absOffset % 60;
    const offsetSign = offsetMinutes > 0 ? "-" : "+";
    const gmtOffset = `GMT${offsetSign}${String(offsetHours).padStart(
      2,
      "0"
    )}:${String(offsetMins).padStart(2, "0")}`;
    return gmtOffset;
  };
  function formatTimestampIST(timestampStr) {
    const timestamp = Number(timestampStr);
    const date = new Date(timestamp);
    const options = {
      timeZone: "Asia/Kolkata",
      hour: "2-digit",
      minute: "2-digit",
      hour12: true
    };
    const timeFormatter = new Intl.DateTimeFormat("en-US", options);
    const dateFormatter = new Intl.DateTimeFormat("en-US", {
      timeZone: "Asia/Kolkata",
      month: "2-digit",
      day: "2-digit",
      year: "numeric"
    });
    const timePart = timeFormatter.format(date);
    const datePart = dateFormatter.format(date);
    const gmtOffset = calculateGMToffset(date);
    return {
      date: datePart,
      time: `${timePart} ${gmtOffset}`
    };
  }
  function parseISTToTimestamp(dateTimeStr) {
    if (dateTimeStr.trim().split(" ").length === 1) {
      const [mm, dd, yyyy] = dateTimeStr.split("/");
      const formattedDate = `${yyyy}-${mm}-${dd}`;
      const timestamp = (/* @__PURE__ */ new Date(`${formattedDate}T00:00:00.000Z`)).getTime();
      return timestamp;
    }
    const [datePart, timePart, meridiem, offset2] = dateTimeStr.split(" ");
    const [month, day, year] = datePart.split("/").map(Number);
    let [hours, minutes] = timePart.split(":").map(Number);
    if (meridiem === "PM" && hours !== 12) hours += 12;
    if (meridiem === "AM" && hours === 12) hours = 0;
    const dateUTC = new Date(Date.UTC(year, month - 1, day, hours, minutes));
    const offsetMatch = offset2.match(/GMT([+-])(\d+):(\d+)/);
    if (!offsetMatch) throw new Error("Invalid offset format");
    const sign = offsetMatch[1] === "+" ? 1 : -1;
    const offsetHours = parseInt(offsetMatch[2], 10);
    const offsetMinutes = parseInt(offsetMatch[3], 10);
    const totalOffsetMs = sign * (offsetHours * 60 + offsetMinutes) * 60 * 1e3;
    const finalTimestamp = dateUTC.getTime() - totalOffsetMs;
    return finalTimestamp.toString();
  }
  function profileInitial(firstName, lastName) {
    const initials = firstName && lastName ? `${firstName.charAt(0)}${lastName.charAt(0)}`.toUpperCase() : firstName ? firstName.charAt(0).toUpperCase() : lastName ? lastName.charAt(0).toUpperCase() : "U";
    return initials;
  }
  const formatDateString = (date) => {
    const options = {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit",
      hour12: true
    };
    return date.toLocaleString("en-GB", options);
  };
  const formatDate = (data, type = "date") => {
    if (!data || isNaN(new Date(data).getTime())) {
      return "";
    }
    const date = new Date(data);
    const formatted = formatDateString(date);
    const [datePart, timePart] = formatted.split(", ");
    const [day, month, year] = datePart.split("/");
    if (type === "date") {
      return `${day}-${month}-${year}`;
    } else if (type === "input") {
      return `${year}-${month}-${day}`;
    }
    return `${day}-${month}-${year} ${timePart.toLowerCase()}`;
  };
  function isObject$1(data) {
    if (data == null) return false;
    return typeof data === "object";
  }
  function isArray(data) {
    if (!Array.isArray(data)) return false;
    return data.every((item) => typeof item === "object" && item !== null);
  }
  const truncateString = (str, MAX_LENGTH = 40) => {
    if (str.length > MAX_LENGTH) {
      return {
        truncated: str.substring(0, MAX_LENGTH) + "...",
        isTruncated: true
      };
    }
    return { truncated: str, isTruncated: false };
  };
  const objectToQueryParams = (params) => {
    if (!params || typeof params !== "object") {
      return "";
    }
    return Object.entries(params).map(
      ([key2, value]) => `${encodeURIComponent(key2)}=${encodeURIComponent(value)}`
    ).join("&");
  };
  const sortData = (list, type = "list") => {
    if (type == "list" || type == "details") delete list.associations;
    const excludeKeys = ["hs_object_id", "hs_createdate", "hs_lastmodifieddate", "associations"];
    let data = list;
    if (type === "list") {
      data = data.filter((item) => !excludeKeys.includes(item.key));
      return data.sort((a, b2) => a.tableDisplayOrder - b2.tableDisplayOrder);
    }
    data = Object.entries(list).filter(([key2]) => !excludeKeys.includes(key2)).map(([key2, value]) => ({
      ...value,
      key: key2
    }));
    return data.sort((a, b2) => a.overviewDisplayOrder - b2.overviewDisplayOrder);
  };
  const replaceQuestionMarkToRegex = (text2) => {
    const replacedText = text2 && typeof text2 === "string" ? text2 == null ? void 0 : text2.replace(/\?/g, "!") : text2;
    return replacedText;
  };
  const truncatedText = (text2, maxLength = 30) => {
    if (text2) {
      const truncatedText2 = text2.length > maxLength ? text2.slice(0, maxLength) + "..." : text2;
      return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: truncatedText2 });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: text2 });
  };
  function decodeAndStripHtml(html2) {
    const tempElement = document.createElement("div");
    tempElement.innerHTML = html2;
    const parser = new DOMParser();
    const doc2 = parser.parseFromString(tempElement.textContent, "text/html");
    return doc2.body.textContent.trim();
  }
  function sanitizeForBase64(str = "") {
    const strConvert = str != null ? String(str) : "";
    return strConvert.replace(/[\u2018\u2019]/g, "'").replace(/[\u201C\u201D]/g, '"').replace(/[\u2013\u2014]/g, "-").replace(/\u2026/g, "...").replace(/[\u00A0\u00AD]/g, " ").replace(/[\u202A-\u202E]/g, "").replace(/[\u200B-\u200D\uFEFF]/g, "").normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x00-\x7F]/g, "").replace(/[\/+*=%#]/g, "-").replace(/[^a-zA-Z0-9\s\-@#&!$%^()_.,':;]/g, "").trim();
  }
  function replaceFirstSegmentInPath(hashPath2) {
    if (!hashPath2) return "";
    const [pathPart, queryString] = hashPath2.split("?");
    const segments = pathPart.split("/");
    if (segments.length === 0) return hashPath2;
    const decodedFirst = decodeURIComponent(segments[0]);
    const sanitized = sanitizeForBase64(decodedFirst);
    const encodedSanitized = encodeURIComponent(sanitized);
    segments[0] = encodedSanitized;
    const updatedPath = segments.join("/");
    return queryString ? `${updatedPath}?${queryString}` : updatedPath;
  }
  const renderCellContent = ({
    companyAsMediator = false,
    value,
    column,
    itemId = null,
    path = null,
    hubspotObjectTypeId,
    type = "list",
    associationPath = "",
    detailsView = true,
    hoverRow,
    item,
    urlParam = null
  }) => {
    var _a2;
    if (column.hidden) return null;
    if (!column || value === void 0 || value === null || !value) {
      return "--";
    }
    const changeRoute = () => {
      if (type == "associations") {
        const newPath = path.replace(/^\/+/, "");
        setItemAsync(
          env$1.VITE_ASSOCIATION_VIEW_URL_KEY,
          JSON.stringify({
            name: newPath,
            path: replaceFirstSegmentInPath(associationPath),
            routeName: `/association/${replaceFirstSegmentInPath(newPath)}`
          })
        );
      }
    };
    const setItemAsync = (key2, value2, days = env$1.VITE_COOKIE_EXPIRE) => {
      return new Promise((resolve) => {
        setCookie(key2, value2);
        resolve();
      });
    };
    if (
      // if date then conver into date format
      column && value != null && (column.type == "datetime" || column.key == "hs_createdate" || column.key == "hs_lastmodifieddate" || column.key == "createdate")
    ) {
      const formatedDateTime = formatTimestampIST(isObject$1(value) ? value.label : value);
      return truncatedText(decodeAndStripHtml(`${formatedDateTime.date} ${formatedDateTime.time}` || ""), 20);
    }
    if (
      // if date then conver into date format
      column && value != null && (column.type == "date" || column.key == "hs_createdate" || column.key == "hs_lastmodifieddate" || column.key == "createdate")
    ) {
      return formatDate(isObject$1(value) ? value.label : value);
    }
    if (column && value != null && column.key === "domain") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: `https://${value}`, className: "hover:underline flex items-center gap-1", target: "_blank", rel: "noreferrer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: value }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(OpenIcon, {})
      ] });
    }
    if (column && (type == "details" || type == "company" || type == "homeList") && value !== null && typeof value === "string" && value.startsWith("https://")) {
      const urls = value.split(",").map((url) => url.trim()).filter((url) => url.startsWith("https://"));
      if (urls.length > 0) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex flex-wrap gap-1`, children: urls.map((url, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "a",
          {
            href: url,
            className: "hover:underline flex items-center flex-wrap gap-1",
            target: "_blank",
            rel: "noreferrer",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "break-all inline-block", children: url }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(OpenIcon, {})
            ]
          },
          idx
        )) });
      }
    }
    if (column.key === "amount" && column.showCurrencySymbol) {
      let find_currency_code;
      if (type == "details") {
        find_currency_code = Array.isArray(item) ? item.find((i2) => i2.key === "deal_currency_code") : null;
      } else {
        find_currency_code = item && item.deal_currency_code ? item.deal_currency_code : null;
      }
      if (find_currency_code && find_currency_code.value) {
        const currency = isObject$1(find_currency_code.value) ? find_currency_code.value.value : find_currency_code.value;
        return `${Currency(currency)} ${formatAmount(value)}`;
      }
    }
    if (column.showCurrencySymbol) {
      const myCurrency = (_a2 = getUserDetails()) == null ? void 0 : _a2.companyCurrency;
      return `${Currency(myCurrency)} ${formatAmount(value)}`;
    }
    if (
      // if primary display property then add open button
      !value && (type == "associations" || type == "list" || type === "homeList") && column && column.isPrimaryDisplayProperty && detailsView
    ) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-1 relative items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Link,
          {
            className: "dark:text-white  text-secondary hover:underline underline-offset-4 font-semibold border-input rounded-md",
            to: `/${sanitizeForBase64(path)}/${hubspotObjectTypeId}/${itemId}?isPrimaryCompany=${companyAsMediator || false}`,
            children: "--"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Link,
          {
            className: ` text-secondary  dark:text-white`,
            to: `/${sanitizeForBase64(path)}/${hubspotObjectTypeId}/${itemId}?isPrimaryCompany=${companyAsMediator || false}`,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(OpenIcon, {})
          }
        )
      ] });
    }
    if ((type === "list" || type === "associations" || type === "homeList") && (column == null ? void 0 : column.fieldType) === "html") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-1 relative justify-between", children: truncatedText(decodeAndStripHtml(value || ""), 23) });
    }
    if (type === "details" && (column == null ? void 0 : column.fieldType) === "html") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-1 relative justify-between", children: decodeAndStripHtml(value || "") });
    }
    if (type === "details" && (column == null ? void 0 : column.key) === "hubspot_owner_id" && value) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-1 relative justify-between", children: [
        value == null ? void 0 : value.firstname,
        " ",
        value == null ? void 0 : value.lastname
      ] });
    }
    if ((type === "details" || type === "associations" || type === "list" || type === "homeList") && (column == null ? void 0 : column.fieldType) === "checkbox") {
      if (Array.isArray(value) && value.length > 0) {
        const labels = value.map((item2) => item2.label).join(", ");
        return labels;
      }
      return "--";
    }
    if (type == "details") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-1 relative  justify-between", children: isObject$1(value) ? value.label : value });
    }
    if ((type == "associations" || type == "list") && column && column.isPrimaryDisplayProperty && associationPath && detailsView) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-1 relative group items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Link,
          {
            className: "dark:text-white text-secondary font-semibold border-input rounded-md hover:underline underline-offset-4",
            onClick: changeRoute,
            to: replaceFirstSegmentInPath(associationPath),
            children: truncatedText(isObject$1(value) ? value.label : value, "23")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Link,
          {
            className: ` text-secondary  dark:text-white`,
            to: replaceFirstSegmentInPath(associationPath),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(OpenIcon, {})
          }
        )
      ] });
    }
    if (type == "list" && column && column.isPrimaryDisplayProperty && detailsView) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-1 min-w-[100px] relative items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Link,
          {
            className: "dark:text-white  text-secondary font-semibold border-input rounded-md hover:underline underline-offset-4",
            to: `/${sanitizeForBase64(path)}/${hubspotObjectTypeId}/${itemId}${urlParam ? urlParam : `?isPrimaryCompany=${companyAsMediator || false}`}`,
            children: truncatedText(isObject$1(value) ? value.label : value, 23)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Link,
          {
            className: ` text-secondary  dark:text-white`,
            to: `/${sanitizeForBase64(path)}/${hubspotObjectTypeId}/${itemId}${urlParam ? urlParam : `?isPrimaryCompany=${companyAsMediator || false}`}`,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(OpenIcon, {})
          }
        )
      ] });
    }
    if (type == "homeList" && column && column.isPrimaryDisplayProperty && detailsView) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-1 relative items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Link,
          {
            className: "dark:text-white  text-secondary font-semibold border-input rounded-md hover:underline underline-offset-4",
            to: `/${sanitizeForBase64(path)}/${hubspotObjectTypeId}/${itemId}${urlParam ? urlParam : `?isPrimaryCompany=${companyAsMediator || false}`}`,
            children: truncatedText(isObject$1(value) ? value.label : value, 23)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Link,
          {
            className: ` text-secondary  dark:text-white`,
            to: `/${sanitizeForBase64(path)}/${hubspotObjectTypeId}/${itemId}${urlParam ? urlParam : `?isPrimaryCompany=${companyAsMediator || false}`}`,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(OpenIcon, {})
          }
        )
      ] });
    }
    if (isArray(value) && value.length > 0) {
      const labels = value.map((item2) => item2.label).join(", ");
      return (
        // <Tooltip content={labels}>
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dark:text-white", children: truncatedText(labels, 23) })
      );
    }
    if (isObject$1(value)) return truncatedText(value.label, 23) || "--";
    const { truncated, isTruncated } = truncateString(value || "");
    if (type === "list" || type === "homeList") {
      return (
        // <Tooltip content={value}>
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dark:text-white", children: truncatedText(value, 23) })
      );
    } else {
      return truncatedText(value);
    }
  };
  function getFirstName() {
    const { me } = useMe$1();
    const { profileDetails } = useAuth();
    if (profileDetails && profileDetails.firstName) {
      return profileDetails.firstName;
    } else if (me && me.firstName) {
      return me.firstName;
    } else {
      return "";
    }
  }
  function getLastName() {
    const { me } = useMe$1();
    const { profileDetails } = useAuth();
    if (profileDetails && profileDetails.lastName) {
      return profileDetails.lastName;
    } else if (me && me.lastName) {
      return me.lastName;
    } else {
      return "";
    }
  }
  function getEmail() {
    const { me } = useMe$1();
    const { profileDetails } = useAuth();
    if (profileDetails && profileDetails.email) {
      return profileDetails.email;
    } else if (me && me.email) {
      return me.email;
    } else {
      return "";
    }
  }
  function wait(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  const getIconType = (filename) => {
    const extension = filename.split(".").pop().toLowerCase();
    switch (extension) {
      case "pdf":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            height: "24px",
            viewBox: "0 -960 960 960",
            width: "24px",
            className: "fill-primary dark:fill-white",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M330-250h300v-60H330v60Zm0-160h300v-60H330v60Zm-77.69 310Q222-100 201-121q-21-21-21-51.31v-615.38Q180-818 201-839q21-21 51.31-21H570l210 210v477.69Q780-142 759-121q-21 21-51.31 21H252.31ZM540-620v-180H252.31q-4.62 0-8.46 3.85-3.85 3.84-3.85 8.46v615.38q0 4.62 3.85 8.46 3.84 3.85 8.46 3.85h455.38q4.62 0 8.46-3.85 3.85-3.84 3.85-8.46V-620H540ZM240-800v180-180V-160v-640Z" })
          }
        );
      case "doc":
      case "docx":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            height: "24px",
            viewBox: "0 -960 960 960",
            width: "24px",
            className: "fill-primary dark:fill-white",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M330-250h300v-60H330v60Zm0-160h300v-60H330v60Zm-77.69 310Q222-100 201-121q-21-21-21-51.31v-615.38Q180-818 201-839q21-21 51.31-21H570l210 210v477.69Q780-142 759-121q-21 21-51.31 21H252.31ZM540-620v-180H252.31q-4.62 0-8.46 3.85-3.85 3.84-3.85 8.46v615.38q0 4.62 3.85 8.46 3.84 3.85 8.46 3.85h455.38q4.62 0 8.46-3.85 3.85-3.84 3.85-8.46V-620H540ZM240-800v180-180V-160v-640Z" })
          }
        );
      case "xls":
      case "xlsx":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            height: "24px",
            viewBox: "0 -960 960 960",
            width: "24px",
            className: "fill-primary dark:Fill-white",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M510-530h60v-80h80v-60h-80v-80h-60v80h-80v60h80v80Zm-80 160h220v-60H430v60Zm-97.69 150Q302-220 281-241q-21-21-21-51.31v-535.38Q260-858 281-879q21-21 51.31-21H610l210 210v397.69Q820-262 799-241q-21 21-51.31 21H332.31Zm0-60h415.38q4.62 0 8.46-3.85 3.85-3.84 3.85-8.46V-660L580-840H332.31q-4.62 0-8.46 3.85-3.85 3.84-3.85 8.46v535.38q0 4.62 3.85 8.46 3.84 3.85 8.46 3.85Zm-160 220Q142-60 121-81q-21-21-21-51.31V-660h60v527.69q0 4.62 3.85 8.46 3.84 3.85 8.46 3.85H580v60H172.31ZM320-280v-560V-280Z" })
          }
        );
      case "ppt":
      case "pptx":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            height: "24px",
            viewBox: "0 -960 960 960",
            width: "24px",
            className: "fill-primary dark:Fill-white",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M510-530h60v-80h80v-60h-80v-80h-60v80h-80v60h80v80Zm-80 160h220v-60H430v60Zm-97.69 150Q302-220 281-241q-21-21-21-51.31v-535.38Q260-858 281-879q21-21 51.31-21H610l210 210v397.69Q820-262 799-241q-21 21-51.31 21H332.31Zm0-60h415.38q4.62 0 8.46-3.85 3.85-3.84 3.85-8.46V-660L580-840H332.31q-4.62 0-8.46 3.85-3.85 3.84-3.85 8.46v535.38q0 4.62 3.85 8.46 3.84 3.85 8.46 3.85Zm-160 220Q142-60 121-81q-21-21-21-51.31V-660h60v527.69q0 4.62 3.85 8.46 3.84 3.85 8.46 3.85H580v60H172.31ZM320-280v-560V-280Z" })
          }
        );
      case "jpg":
      case "jpeg":
      case "png":
      case "gif":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            height: "24px",
            viewBox: "0 -960 960 960",
            width: "24px",
            className: "fill-primary dark:fill-white",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M228.31-164q-27.01 0-45.66-19Q164-202 164-228.31v-503.38Q164-758 182.65-777q18.65-19 45.66-19h503.38q27.01 0 45.66 19Q796-758 796-731.69v503.38Q796-202 777.35-183q-18.65 19-45.66 19H228.31Zm0-52h503.38q4.62 0 8.46-3.85 3.85-3.84 3.85-8.46v-503.38q0-4.62-3.85-8.46-3.84-3.85-8.46-3.85H228.31q-4.62 0-8.46 3.85-3.85 3.84-3.85 8.46v503.38q0 4.62 3.85 8.46 3.84 3.85 8.46 3.85ZM294-298h375.07L543.54-465.38 443.23-335.23l-62-78.31L294-298Zm-78 82v-528 528Z" })
          }
        );
      case "svg":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            height: "24px",
            viewBox: "0 -960 960 960",
            width: "24px",
            className: "fill-primary dark:fill-white",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M440-501Zm0 354.07-86.61-77.84Q271.77-299 215.66-354.62q-56.12-55.61-90.77-101.57-34.66-45.96-49.77-86.43Q60-583.08 60-626q0-85.15 57.42-142.27 57.43-57.11 142.58-57.11 52.38 0 99 24.5t81 70.27q34.38-45.77 81-70.27 46.62-24.5 99-24.5 75.23 0 126.96 44.34 51.73 44.35 67.12 111.04H751q-13.77-44.61-50.31-70-36.54-25.39-80.69-25.39-49.85 0-88.19 27.5-38.35 27.5-72.27 77.89h-39.08q-33.69-50.77-73.38-78.08-39.7-27.31-87.08-27.31-57.77 0-98.88 39.7Q120-686 120-626q0 33.38 14 67.77 14 34.38 50 79.27 36 44.88 98 105.15T440-228q28.31-25.31 60.62-53.77 32.3-28.46 54.46-49.61l6.69 6.69L576.46-310l14.69 14.69 6.69 6.69q-22.76 21.16-54.26 48.93-31.5 27.77-59.43 53.07L440-146.93ZM714.61-290v-120h-120v-60h120v-120h60v120h120v60h-120v120h-60Z" })
          }
        );
      default:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            height: "24px",
            viewBox: "0 -960 960 960",
            width: "24px",
            className: "fill-primary dark:fill-white",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M178-212q-28.15 0-45.08-18.09Q116-248.17 116-274.04v-409.93q0-25.87 18.08-44.95Q152.16-748 180.31-748h195.61l96 96h308.77q24.85 0 40.31 14.85 15.46 14.84 20.54 37.15H451.38l-96-96H180.31q-5.39 0-8.85 3.46t-3.46 8.85v407.38q0 4.23 2.12 6.92 2.11 2.7 5.57 4.62L251-520.31h672.31l-78.85 264.62q-6.85 19.53-17.15 31.61Q817-212 795.08-212H178Zm51.54-52h562.23l62.46-204.31H290L229.54-264Zm0 0L290-468.31 229.54-264ZM168-600V-696v96Z" })
          }
        );
    }
  };
  const getFileDetails = async (urlArray) => {
    const fileDetails = await Promise.all(
      urlArray.map(async (url) => {
        try {
          const name = decodeURIComponent(url.substring(url.lastIndexOf("/") + 1));
          const type = name.substring(name.lastIndexOf(".") + 1).toLowerCase();
          if (url.includes("docs.google.com")) {
            return {
              url,
              name: "Google Docs",
              type: "Google Docs",
              size: "N/A"
            };
          } else if (url.includes("drive.google.com")) {
            return {
              url,
              name: "Google Drive File",
              type: "Google Drive File",
              size: "N/A"
            };
          } else if (url.includes("dropbox.com")) {
            const directUrl = url.replace(
              "www.dropbox.com",
              "dl.dropboxusercontent.com"
            );
            return await fetchFileSize(directUrl, name, type);
          } else if (url.includes("onedrive.live.com")) {
            return {
              url,
              name: "OneDrive File",
              type: "OneDrive File",
              size: "N/A"
            };
          }
          return await fetchFileSize(url, name, type);
        } catch (error) {
          console.error(`Error processing URL ${url}:`, error);
          return {
            url,
            name: "Unknown",
            type: "Unknown",
            size: "N/A",
            error: error.message
          };
        }
      })
    );
    return fileDetails;
  };
  const fetchFileSize = async (url, name, type) => {
    try {
      const response = await fetch(url, { method: "HEAD" });
      const fileSize = response.headers.get("content-length");
      return {
        url,
        name,
        type,
        size: fileSize ? `${(fileSize / 1024).toFixed(2)} KB` : "Unknown size"
      };
    } catch (error) {
      console.error(`Error fetching file details for ${url}:`, error);
      return {
        url,
        name,
        type,
        size: "Error fetching file size"
      };
    }
  };
  const formatPath = (key2) => {
    return key2 && typeof key2 === "string" ? key2.replace(/\s+/g, "-").replace(/\b\w/g, (l) => l.toLowerCase()) : "";
  };
  function formatCustomObjectLabel(label = "") {
    return label && typeof label === "string" ? label.replace(/^p_/, "").replace(/_$/, "").replace(/_/g, " ") : "";
  }
  function formatColumnLabel(label) {
    return label && typeof label === "string" ? label.replace(/_/g, " ") : "";
  }
  const escapeHTML = (str) => {
    return str && typeof str === "string" ? str.replace(/'/g, "\\'") : "";
  };
  const formatAmount = (amount, locale = "en-US") => {
    if (isNaN(amount)) return "Invalid amount";
    return new Intl.NumberFormat(locale, {
      maximumFractionDigits: amount % 1 === 0 ? 0 : 2,
      useGrouping: true
    }).format(amount);
  };
  const isDevelopment = env$1.VITE_NODE_ENV === "development";
  isDevelopment ? defaultData.dataSourceSet : (_a = window == null ? void 0 : window.hubSpotData) == null ? void 0 : _a.dataSourceSet;
  const hubId = isDevelopment ? defaultData.hubId : (_b = window == null ? void 0 : window.hubSpotData) == null ? void 0 : _b.hubId;
  isDevelopment ? defaultData.apiBaseUrlOption : (_c = window == null ? void 0 : window.hubSpotData) == null ? void 0 : _c.apiBaseUrlOption;
  const userData = isDevelopment ? defaultData.userData : (_d = window == null ? void 0 : window.hubSpotData) == null ? void 0 : _d.userData;
  const objectList = isDevelopment ? defaultData.objectList : (_e = window == null ? void 0 : window.hubSpotData) == null ? void 0 : _e.objectList;
  const showCompanyNameOption = isDevelopment ? defaultData.showCompanyNameOption : (_f = window == null ? void 0 : window.hubSpotData) == null ? void 0 : _f.showCompanyNameOption;
  const showSidebarCtaOption = isDevelopment ? defaultData.showSidebarCtaOption : (_g = window == null ? void 0 : window.hubSpotData) == null ? void 0 : _g.showSidebarCtaOption;
  const addHomeTabOption = isDevelopment ? defaultData.addHomeTabOption : (_h = window == null ? void 0 : window.hubSpotData) == null ? void 0 : _h.addHomeTabOption;
  const sidebarMenuOptions = isDevelopment ? defaultData.sidebarMenuOptions : (_i = window == null ? void 0 : window.hubSpotData) == null ? void 0 : _i.sidebarMenuOptions;
  const moduleIframeListOptions = isDevelopment ? defaultData.moduleIframeListOptions : (_j = window == null ? void 0 : window.hubSpotData) == null ? void 0 : _j.moduleIframeListOptions;
  const sidebarListDataOption = isDevelopment ? defaultData.sidebarListDataOption : (_k = window == null ? void 0 : window.hubSpotData) == null ? void 0 : _k.sidebarListDataOption;
  const showSidebarListDataOption = isDevelopment ? defaultData.showSidebarListDataOption : (_l = window == null ? void 0 : window.hubSpotData) == null ? void 0 : _l.showSidebarListDataOption;
  const sidebarCtaDetails = isDevelopment ? defaultData.sidebarCtaDetails : (_m = window == null ? void 0 : window.hubSpotData) == null ? void 0 : _m.sidebarCtaDetails;
  const baseCompanyOptions = isDevelopment ? defaultData.baseCompanyOptions : (_n = window == null ? void 0 : window.hubSpotData) == null ? void 0 : _n.baseCompanyOptions;
  const enableDashboardCards = isDevelopment ? defaultData.enableDashboardCards : (_o = window == null ? void 0 : window.hubSpotData) == null ? void 0 : _o.enableDashboardCards;
  const dashboardCards = isDevelopment ? defaultData.dashboardCards : (_p = window == null ? void 0 : window.hubSpotData) == null ? void 0 : _p.dashboardCards;
  const homeTabsDataTypeFilter = isDevelopment ? defaultData.homeTabsDataTypeFilter : (_q = window == null ? void 0 : window.hubSpotData) == null ? void 0 : _q.homeTabsDataTypeFilter;
  const moduleStylesOptions = isDevelopment ? defaultData.moduleStylesOptions : (_r = window == null ? void 0 : window.hubSpotData) == null ? void 0 : _r.moduleStylesOptions;
  const recorBtnCustom = isDevelopment ? defaultData.recorBtnCustom : (_s = window == null ? void 0 : window.hubSpotData) == null ? void 0 : _s.recorBtnCustom;
  isDevelopment ? defaultData.sidebarCtaStyles : (_t2 = window == null ? void 0 : window.hubSpotData) == null ? void 0 : _t2.sidebarCtaStyles;
  const developerMode = isDevelopment ? defaultData.developerMode : (_u = window == null ? void 0 : window.hubSpotData) == null ? void 0 : _u.developerModeModule;
  const sideMenu = [
    {
      name: "CONTACT",
      labels: {
        singular: "Contact",
        plural: "Contacts"
      },
      hubspotObjectId: 1,
      hubspotObjectTypeId: "0-1",
      children: sidebarMenuOptions
    }
  ];
  const apiRoutes = sideMenu[0].children.map((menuItem) => ({
    hubspotObjectTypeId: `${menuItem.hubspotObjectTypeId}`,
    path: `/${formatPath(menuItem.tabName || menuItem.label)}`,
    title: formatCustomObjectLabel(menuItem.tabName || menuItem.label),
    icon: menuItem.icon,
    isRequiredAuth: true,
    isHeader: true,
    companyAsMediator: menuItem.companyAsMediator,
    pipeLineId: menuItem.pipeLineId,
    specPipeLine: menuItem.specPipeLine,
    objectDescription: menuItem.objectDescription,
    objectUserProperties: menuItem.objectUserProperties,
    homeCardsView: menuItem.homeCardsView,
    objectUserPropertiesView: menuItem.objectUserPropertiesView
  }));
  const configs = getRouteMenuConfig() || {};
  const key = ((_w = (_v = sideMenu[0]) == null ? void 0 : _v.children[1]) == null ? void 0 : _w.label) && !addHomeTabOption ? (_y = (_x = sideMenu[0]) == null ? void 0 : _x.children[1]) == null ? void 0 : _y.label : (_A = (_z = sideMenu[0]) == null ? void 0 : _z.children[1]) == null ? void 0 : _A.tabName;
  configs[key] = { ...configs[key], details: null };
  setRouteMenuConfig(configs);
  const hubSpotUserDetails = {
    userId: userData && userData.id ? userData.id : 1,
    firstName: userData && userData.firstname ? userData.firstname : "No firstname",
    lastName: userData && userData.lastname ? userData.lastname : "No lastname",
    email: userData && userData.email ? userData.email : "No email",
    roles: [],
    authorities: [],
    hubspotPortals: {
      hubId: 1,
      subscriptionLevel: 1,
      hubspotDomain: "",
      hubspotSelectedDomain: "",
      portalSettings: {
        theme: "light",
        logo: baseCompanyOptions && baseCompanyOptions.logoImg ? baseCompanyOptions.logoImg : baseCompanyOptions.smallLogo,
        smallLogo: baseCompanyOptions && baseCompanyOptions.smallLogo ? baseCompanyOptions.smallLogo : baseCompanyOptions.logoImg,
        authPopupFormLogo: baseCompanyOptions && baseCompanyOptions.authPopupFormLogo ? baseCompanyOptions.authPopupFormLogo : baseCompanyOptions.logoImg,
        primaryColor: defaultData.primarycolor,
        secondaryColor: defaultData.secondarycolor,
        brandName: baseCompanyOptions && baseCompanyOptions.companyName ? baseCompanyOptions.companyName : "CompanyName"
      },
      onboardStatus: true,
      templateName: "dw_office",
      activeStatus: true
    },
    sideMenu: sidebarMenuOptions,
    sideBarOptions: sidebarCtaDetails
  };
  const hubSpotTableData = {
    data: {
      results: objectList
    }
  };
  const setParam = (paramName, paramValue) => {
    const currentUrl = new URL(window.location.href);
    if (currentUrl.hash) {
      const hashPart = currentUrl.hash.substring(1);
      const [path, queryString] = hashPart.split("?");
      const params = new URLSearchParams(queryString || "");
      params.set(paramName, paramValue);
      currentUrl.hash = `${path}?${params.toString()}`;
    } else {
      currentUrl.searchParams.set(paramName, paramValue);
    }
    window.history.replaceState({}, "", currentUrl);
  };
  const getParam$1 = (key2) => {
    const url = window.location.href;
    const hash = url.split("#")[1];
    const queryString = hash ? hash.split("?")[1] : "";
    const searchParams = new URLSearchParams(queryString);
    const value = searchParams.get(key2);
    return value;
  };
  const getParamHash = (string) => {
    const result = string && typeof string === "string" ? string.replace(/%23/g, "#") : string;
    return result;
  };
  const setParamHash = (string) => {
    const result = string && typeof string === "string" ? string.replace(/#/g, "%23") : string;
    return result;
  };
  const getQueryParamsFromCurrentUrl = () => {
    const currentUrl = window.location.href;
    const queryString = currentUrl.includes("?") ? currentUrl.split("?")[1] : "";
    if (!queryString) return "";
    const params = new URLSearchParams(queryString);
    const paramsObject = {};
    params.forEach((value, key2) => {
      paramsObject[key2] = value;
    });
    delete paramsObject.t;
    delete paramsObject.b;
    delete paramsObject.objectTypeName;
    delete paramsObject.objectTypeId;
    delete paramsObject.parentObjectTypeName;
    const filteredParams = new URLSearchParams(
      Object.entries(paramsObject).filter(([_2, value]) => value !== void 0)
    );
    return filteredParams.toString() ? `?${filteredParams.toString()}` : "";
  };
  const toQueryString = (params) => {
    const searchParams = new URLSearchParams();
    Object.entries(params).forEach(([key2, value]) => {
      if (value !== void 0 && value !== null && value !== "") {
        searchParams.append(key2, value);
      }
    });
    return searchParams.toString() ? `?${searchParams.toString()}` : "";
  };
  const addParam = (url, params = {}) => {
    const queryString = new URLSearchParams(params).toString();
    const fullUrl = url.includes("?") ? `${url}&${queryString}` : `${url}?${queryString}`;
    return fullUrl;
  };
  function getQueryParamsToObject(url) {
    const params = new URLSearchParams(url);
    let obj = {};
    params.forEach((value, key2) => {
      obj[key2] = value;
    });
    return obj;
  }
  function updateParamsFromUrl(apiUrl, params) {
    const url = new URL(apiUrl, "http://example.com");
    const searchParams = new URLSearchParams(url.search);
    searchParams.forEach((value, key2) => {
      params[key2] = value;
    });
    return params;
  }
  function removeAllParams(apiUrl) {
    const url = new URL(apiUrl, "http://example.com");
    return url.pathname;
  }
  const getRouteMenu = (path) => {
    return apiRoutes.find((menu) => menu.path === path);
  };
  const getRouteMenuByObjectTypeId = (objectTypeId) => {
    return apiRoutes.find((menu) => menu.hubspotObjectTypeId === objectTypeId);
  };
  const useResponsive = () => {
    const [screenSizes, setScreenSizes] = reactExports.useState({
      isLargeScreen: false,
      isMediumScreen: false,
      isSmallScreen: false
    });
    reactExports.useEffect(() => {
      const updateScreenSizes = () => {
        const width = window.innerWidth;
        setScreenSizes({
          isLargeScreen: width > 1023,
          isMediumScreen: width > 768 && width <= 1023,
          isSmallScreen: width <= 768
        });
      };
      updateScreenSizes();
      window.addEventListener("resize", updateScreenSizes);
      return () => {
        window.removeEventListener("resize", updateScreenSizes);
      };
    }, []);
    return screenSizes;
  };
  const SvgRenderer = ({ svgContent }) => {
    const cleanSvgContent = (svgString) => {
      return svgString && typeof svgString === "string" ? svgString == null ? void 0 : svgString.replace(/{.*?}/g, "") : "";
    };
    const parseSvg = (svgString) => {
      const parser = new DOMParser();
      const doc2 = parser.parseFromString(svgString, "image/svg+xml");
      return doc2.documentElement;
    };
    const renderSvg = () => {
      const cleanedContent = cleanSvgContent(svgContent);
      const svgElement = parseSvg(cleanedContent);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "svg",
        {
          ...Array.from(svgElement.attributes).reduce((attrs, attr) => {
            attrs[attr.name] = attr.value;
            return attrs;
          }, {}),
          children: Array.from(svgElement.childNodes).map((node, index) => {
            if (node.nodeType === Node.ELEMENT_NODE) {
              return React.createElement(
                node.tagName,
                {
                  key: index,
                  ...Array.from(node.attributes).reduce((attrs, attr) => {
                    attrs[attr.name] = attr.value;
                    return attrs;
                  }, {})
                },
                node.textContent
              );
            }
            if (node.nodeType === Node.TEXT_NODE) {
              return node.textContent.trim() ? node.textContent : null;
            }
            return null;
          })
        }
      );
    };
    return renderSvg();
  };
  var classnames = { exports: {} };
  /*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  */
  var hasRequiredClassnames;
  function requireClassnames() {
    if (hasRequiredClassnames) return classnames.exports;
    hasRequiredClassnames = 1;
    (function(module) {
      (function() {
        var hasOwn = {}.hasOwnProperty;
        function classNames2() {
          var classes2 = "";
          for (var i2 = 0; i2 < arguments.length; i2++) {
            var arg = arguments[i2];
            if (arg) {
              classes2 = appendClass(classes2, parseValue(arg));
            }
          }
          return classes2;
        }
        function parseValue(arg) {
          if (typeof arg === "string" || typeof arg === "number") {
            return arg;
          }
          if (typeof arg !== "object") {
            return "";
          }
          if (Array.isArray(arg)) {
            return classNames2.apply(null, arg);
          }
          if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
            return arg.toString();
          }
          var classes2 = "";
          for (var key2 in arg) {
            if (hasOwn.call(arg, key2) && arg[key2]) {
              classes2 = appendClass(classes2, key2);
            }
          }
          return classes2;
        }
        function appendClass(value, newClass) {
          if (!newClass) {
            return value;
          }
          if (value) {
            return value + " " + newClass;
          }
          return value + newClass;
        }
        if (module.exports) {
          classNames2.default = classNames2;
          module.exports = classNames2;
        } else {
          window.classNames = classNames2;
        }
      })();
    })(classnames);
    return classnames.exports;
  }
  var classnamesExports = requireClassnames();
  const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
  const AnimatedCircles = (props) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 200 200",
        width: "1rem",
        height: "1rem",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { fill: "currentColor", stroke: "currentColor", strokeWidth: "15", r: "15", cx: "40", cy: "100", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "animate",
            {
              attributeName: "opacity",
              calcMode: "spline",
              dur: "2s",
              values: "1;0;1",
              keySplines: ".5 0 .5 1;.5 0 .5 1",
              repeatCount: "indefinite",
              begin: "-.4s"
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { fill: "currentColor", stroke: "currentColor", strokeWidth: "15", r: "15", cx: "100", cy: "100", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "animate",
            {
              attributeName: "opacity",
              calcMode: "spline",
              dur: "2s",
              values: "1;0;1",
              keySplines: ".5 0 .5 1;.5 0 .5 1",
              repeatCount: "indefinite",
              begin: "-.2s"
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { fill: "currentColor", stroke: "currentColor", strokeWidth: "15", r: "15", cx: "160", cy: "100", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "animate",
            {
              attributeName: "opacity",
              calcMode: "spline",
              dur: "2s",
              values: "1;0;1",
              keySplines: ".5 0 .5 1;.5 0 .5 1",
              repeatCount: "indefinite",
              begin: "0s"
            }
          ) })
        ]
      }
    );
  };
  const classes = {
    root: "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50"
  };
  const variantClasses = {
    default: "bg-primary text-white dark:border dark:bg-dark-400 shadow hover:bg-primary/90",
    create: `!bg-[var(--create-button-background-color)] hover:!bg-[var(--create-button-background-color)]/80 !text-[var(--create-button-text-color)]`,
    destructive: "bg-red-500 text-destructive-foreground shadow-sm hover:bg-red-200",
    outline: "border border-input dark:!text-white bg-background shadow-sm hover:bg-accent hover:text-accent-foreground dark:bg-dark-400",
    secondary: "bg-secondary text-white shadow-sm hover:bg-secondary/80 dark:border dark:bg-dark-400 ",
    ghost: "hover:bg-accent hover:text-accent-foreground",
    link: "text-secondary underline-offset-4 hover:underline dark:text-white",
    hubSpot: "text-primary dark:text-cleanWhite bg-none dark:bg-none rounded-none underline-offset-4 hover:underline flex items-center justify-center"
  };
  const sizeClasses = {
    default: "h-10 px-6 py-3",
    xsm: "h-6 rounded-md px-2 text-xs",
    sm: "h-8 rounded-md px-3 text-xs",
    lg: "h-10 rounded-md px-8",
    icon: "h-9 w-9",
    link: "p-0",
    hubSpot: "p-1"
  };
  const Button = reactExports.forwardRef((props, ref) => {
    const {
      className,
      variant = "default",
      size = "default",
      asChild = false,
      isLoading = false,
      disabled = false,
      children,
      ...rest
    } = props;
    const classesName = classNames(
      classes.root,
      // Base classes
      variantClasses[variant],
      // Dynamic variant classes
      sizeClasses[size],
      // Dynamic size classes
      className
      // User-defined classes (last for priority)
    );
    delete rest.className;
    const Comp = asChild ? "span" : "button";
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Comp,
      {
        className: classNames(classesName),
        ref,
        disabled: isLoading || props.disabled,
        ...rest,
        children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatedCircles, {}),
          children
        ] }) : children
      }
    ) });
  });
  const Logo = ({ className }) => {
    const { me } = useMe$1();
    const [logoSrc, setLogoSrc] = reactExports.useState("");
    reactExports.useEffect(() => {
      const updateLogo = () => {
        const logoParam = getParam$1("logo");
        if (logoParam && logoParam !== "null" && isValidUrl(logoParam)) {
          setLogoSrc(logoParam);
        } else if (me && me.hubspotPortals && me.hubspotPortals.portalSettings && me.hubspotPortals.portalSettings.logo && isValidUrl(hubSpotUserDetails.hubspotPortals.portalSettings.logo)) {
          setLogoSrc(hubSpotUserDetails.hubspotPortals.portalSettings.logo);
        } else {
          setLogoSrc("");
        }
      };
      updateLogo();
      const handlePopState = () => {
        updateLogo();
      };
      window.addEventListener("popstate", handlePopState);
      return () => {
        window.removeEventListener("popstate", handlePopState);
      };
    }, [me]);
    const logoToDisplay = logoSrc || hubSpotUserDetails.hubspotPortals.portalSettings.logo;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: logoToDisplay, alt: "Logo", className: `${className} h-auto w-auto` });
  };
  const isValidUrl = (string) => {
    try {
      new URL(string);
      return true;
    } catch (_2) {
      return false;
    }
  };
  const Dialog = reactExports.forwardRef((props, ref) => {
    const classes2 = {
      root: "bg-cleanWhite p-4 sm:p-6 dark:bg-dark-200"
    };
    const { open, onClose = null, className, ...rest } = props;
    const classesName2 = classNames(classes2.root, className);
    const showOverlay = () => {
      if (!open) return null;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "fixed z-[101]",
          "aria-labelledby": "modal-title",
          role: "dialog",
          "aria-modal": "true",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "fixed inset-0 bg-gray-500 dark:bg-dark-300 bg-opacity-50 dark:bg-opacity-50 backdrop-blur-md backdrop-filter transition-opacity",
                "aria-hidden": "true"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 z-20 w-screen flex items-center justify-center overflow-y-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sm:p-0 min-h-[90vh] overflow-x-auto flex items-center popup-modal", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "relative transform overflow-hidden rounded-lg",
                onClick: (e) => e.stopPropagation(),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classesName2, ref, ...rest })
              }
            ) }) })
          ]
        }
      );
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: showOverlay() });
  });
  const CloseIcon = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      height: "1rem",
      viewBox: "0 -960 960 960",
      width: "1rem",
      fill: "currentColor",
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M256-213.85 213.85-256l224-224-224-224L256-746.15l224 224 224-224L746.15-704l-224 224 224 224L704-213.85l-224-224-224 224Z" })
    }
  );
  const SidebarTogglerIcon = (props) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        className: `text-[var(--sidebar-text-color)] dark:text-white transform transition-transform duration-300 `,
        xmlns: "http://www.w3.org/2000/svg",
        width: "20",
        height: "20",
        viewBox: "0 0 20 20",
        fill: "none",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M15.8333 2.5H4.16667C3.24619 2.5 2.5 3.24619 2.5 4.16667V15.8333C2.5 16.7538 3.24619 17.5 4.16667 17.5H15.8333C16.7538 17.5 17.5 16.7538 17.5 15.8333V4.16667C17.5 3.24619 16.7538 2.5 15.8333 2.5Z",
              stroke: "currentcolor",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M7.5 2.5V17.5",
              stroke: "currentcolor",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M13.3333 12.5L10.8333 10L13.3333 7.5",
              stroke: "currentcolor",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          )
        ]
      }
    );
  };
  const defaultSvg = `
    <svg
      viewBox="0 0 20 20"
      fill="currentColor"
      height="1em"
      width="1em"
    >
      <path d="M4 12a2 2 0 110-4 2 2 0 010 4zm6 0a2 2 0 110-4 2 2 0 010 4zm6 0a2 2 0 110-4 2 2 0 010 4z" />
    </svg>
`;
  const useCollapsible = () => {
    const [sidebarCollapsed, setSidebarCollapsed] = useAtom(isCollapsibleState);
    const [sidebarOpen, setSidebarOpen] = useAtom(isOpenState);
    return {
      sidebarCollapsed,
      setSidebarCollapsed,
      sidebarOpen,
      setSidebarOpen
    };
  };
  function useRoute$1() {
    const [routes, setRoutes] = useAtom(routeState);
    return {
      routes,
      setRoutes
    };
  }
  /*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE */
  const {
    entries,
    setPrototypeOf,
    isFrozen,
    getPrototypeOf,
    getOwnPropertyDescriptor
  } = Object;
  let {
    freeze,
    seal,
    create
  } = Object;
  let {
    apply: apply$1,
    construct
  } = typeof Reflect !== "undefined" && Reflect;
  if (!freeze) {
    freeze = function freeze2(x2) {
      return x2;
    };
  }
  if (!seal) {
    seal = function seal2(x2) {
      return x2;
    };
  }
  if (!apply$1) {
    apply$1 = function apply2(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }
  if (!construct) {
    construct = function construct2(Func, args) {
      return new Func(...args);
    };
  }
  const arrayForEach = unapply(Array.prototype.forEach);
  const arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
  const arrayPop = unapply(Array.prototype.pop);
  const arrayPush = unapply(Array.prototype.push);
  const arraySplice = unapply(Array.prototype.splice);
  const stringToLowerCase = unapply(String.prototype.toLowerCase);
  const stringToString = unapply(String.prototype.toString);
  const stringMatch = unapply(String.prototype.match);
  const stringReplace = unapply(String.prototype.replace);
  const stringIndexOf = unapply(String.prototype.indexOf);
  const stringTrim = unapply(String.prototype.trim);
  const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
  const regExpTest = unapply(RegExp.prototype.test);
  const typeErrorCreate = unconstruct(TypeError);
  function unapply(func) {
    return function(thisArg) {
      if (thisArg instanceof RegExp) {
        thisArg.lastIndex = 0;
      }
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return apply$1(func, thisArg, args);
    };
  }
  function unconstruct(func) {
    return function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return construct(func, args);
    };
  }
  function addToSet(set2, array) {
    let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
    if (setPrototypeOf) {
      setPrototypeOf(set2, null);
    }
    let l = array.length;
    while (l--) {
      let element = array[l];
      if (typeof element === "string") {
        const lcElement = transformCaseFunc(element);
        if (lcElement !== element) {
          if (!isFrozen(array)) {
            array[l] = lcElement;
          }
          element = lcElement;
        }
      }
      set2[element] = true;
    }
    return set2;
  }
  function cleanArray(array) {
    for (let index = 0; index < array.length; index++) {
      const isPropertyExist = objectHasOwnProperty(array, index);
      if (!isPropertyExist) {
        array[index] = null;
      }
    }
    return array;
  }
  function clone(object) {
    const newObject = create(null);
    for (const [property, value] of entries(object)) {
      const isPropertyExist = objectHasOwnProperty(object, property);
      if (isPropertyExist) {
        if (Array.isArray(value)) {
          newObject[property] = cleanArray(value);
        } else if (value && typeof value === "object" && value.constructor === Object) {
          newObject[property] = clone(value);
        } else {
          newObject[property] = value;
        }
      }
    }
    return newObject;
  }
  function lookupGetter(object, prop) {
    while (object !== null) {
      const desc = getOwnPropertyDescriptor(object, prop);
      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }
        if (typeof desc.value === "function") {
          return unapply(desc.value);
        }
      }
      object = getPrototypeOf(object);
    }
    function fallbackValue() {
      return null;
    }
    return fallbackValue;
  }
  const html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
  const svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
  const svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
  const svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
  const mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
  const mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
  const text = freeze(["#text"]);
  const html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
  const svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
  const mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
  const xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
  const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
  const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
  const TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm);
  const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/);
  const ARIA_ATTR = seal(/^aria-[\-\w]+$/);
  const IS_ALLOWED_URI = seal(
    /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
    // eslint-disable-line no-useless-escape
  );
  const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  const ATTR_WHITESPACE = seal(
    /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
    // eslint-disable-line no-control-regex
  );
  const DOCTYPE_NAME = seal(/^html$/i);
  const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
  var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ARIA_ATTR,
    ATTR_WHITESPACE,
    CUSTOM_ELEMENT,
    DATA_ATTR,
    DOCTYPE_NAME,
    ERB_EXPR,
    IS_ALLOWED_URI,
    IS_SCRIPT_OR_DATA,
    MUSTACHE_EXPR,
    TMPLIT_EXPR
  });
  const NODE_TYPE = {
    element: 1,
    text: 3,
    // Deprecated
    progressingInstruction: 7,
    comment: 8,
    document: 9
  };
  const getGlobal = function getGlobal2() {
    return typeof window === "undefined" ? null : window;
  };
  const _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
    if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
      return null;
    }
    let suffix = null;
    const ATTR_NAME = "data-tt-policy-suffix";
    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
      suffix = purifyHostElement.getAttribute(ATTR_NAME);
    }
    const policyName = "dompurify" + (suffix ? "#" + suffix : "");
    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML(html2) {
          return html2;
        },
        createScriptURL(scriptUrl) {
          return scriptUrl;
        }
      });
    } catch (_2) {
      console.warn("TrustedTypes policy " + policyName + " could not be created.");
      return null;
    }
  };
  const _createHooksMap = function _createHooksMap2() {
    return {
      afterSanitizeAttributes: [],
      afterSanitizeElements: [],
      afterSanitizeShadowDOM: [],
      beforeSanitizeAttributes: [],
      beforeSanitizeElements: [],
      beforeSanitizeShadowDOM: [],
      uponSanitizeAttribute: [],
      uponSanitizeElement: [],
      uponSanitizeShadowNode: []
    };
  };
  function createDOMPurify() {
    let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
    const DOMPurify = (root) => createDOMPurify(root);
    DOMPurify.version = "3.2.6";
    DOMPurify.removed = [];
    if (!window2 || !window2.document || window2.document.nodeType !== NODE_TYPE.document || !window2.Element) {
      DOMPurify.isSupported = false;
      return DOMPurify;
    }
    let {
      document: document2
    } = window2;
    const originalDocument = document2;
    const currentScript = originalDocument.currentScript;
    const {
      DocumentFragment,
      HTMLTemplateElement,
      Node: Node2,
      Element: Element2,
      NodeFilter,
      NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
      HTMLFormElement,
      DOMParser: DOMParser2,
      trustedTypes
    } = window2;
    const ElementPrototype = Element2.prototype;
    const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
    const remove = lookupGetter(ElementPrototype, "remove");
    const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
    const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
    const getParentNode2 = lookupGetter(ElementPrototype, "parentNode");
    if (typeof HTMLTemplateElement === "function") {
      const template = document2.createElement("template");
      if (template.content && template.content.ownerDocument) {
        document2 = template.content.ownerDocument;
      }
    }
    let trustedTypesPolicy;
    let emptyHTML = "";
    const {
      implementation,
      createNodeIterator,
      createDocumentFragment,
      getElementsByTagName
    } = document2;
    const {
      importNode
    } = originalDocument;
    let hooks = _createHooksMap();
    DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode2 === "function" && implementation && implementation.createHTMLDocument !== void 0;
    const {
      MUSTACHE_EXPR: MUSTACHE_EXPR2,
      ERB_EXPR: ERB_EXPR2,
      TMPLIT_EXPR: TMPLIT_EXPR2,
      DATA_ATTR: DATA_ATTR2,
      ARIA_ATTR: ARIA_ATTR2,
      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
      ATTR_WHITESPACE: ATTR_WHITESPACE2,
      CUSTOM_ELEMENT: CUSTOM_ELEMENT2
    } = EXPRESSIONS;
    let {
      IS_ALLOWED_URI: IS_ALLOWED_URI$1
    } = EXPRESSIONS;
    let ALLOWED_TAGS = null;
    const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
    let ALLOWED_ATTR = null;
    const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
    let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
      tagNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: false
      }
    }));
    let FORBID_TAGS = null;
    let FORBID_ATTR = null;
    let ALLOW_ARIA_ATTR = true;
    let ALLOW_DATA_ATTR = true;
    let ALLOW_UNKNOWN_PROTOCOLS = false;
    let ALLOW_SELF_CLOSE_IN_ATTR = true;
    let SAFE_FOR_TEMPLATES = false;
    let SAFE_FOR_XML = true;
    let WHOLE_DOCUMENT = false;
    let SET_CONFIG = false;
    let FORCE_BODY = false;
    let RETURN_DOM = false;
    let RETURN_DOM_FRAGMENT = false;
    let RETURN_TRUSTED_TYPE = false;
    let SANITIZE_DOM = true;
    let SANITIZE_NAMED_PROPS = false;
    const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
    let KEEP_CONTENT = true;
    let IN_PLACE = false;
    let USE_PROFILES = {};
    let FORBID_CONTENTS = null;
    const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
    let DATA_URI_TAGS = null;
    const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
    let URI_SAFE_ATTRIBUTES = null;
    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
    const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
    const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
    const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
    let NAMESPACE = HTML_NAMESPACE;
    let IS_EMPTY_INPUT = false;
    let ALLOWED_NAMESPACES = null;
    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
    let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
    let HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
    let PARSER_MEDIA_TYPE = null;
    const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
    const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
    let transformCaseFunc = null;
    let CONFIG = null;
    const formElement = document2.createElement("form");
    const isRegexOrFunction = function isRegexOrFunction2(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    };
    const _parseConfig = function _parseConfig2() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (CONFIG && CONFIG === cfg) {
        return;
      }
      if (!cfg || typeof cfg !== "object") {
        cfg = {};
      }
      cfg = clone(cfg);
      PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
      transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
      ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
      ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
      URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});
      FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});
      USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
      SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
      RETURN_DOM = cfg.RETURN_DOM || false;
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
      FORCE_BODY = cfg.FORCE_BODY || false;
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
      IN_PLACE = cfg.IN_PLACE || false;
      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
      HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
      }
      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }
      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, text);
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html$1);
          addToSet(ALLOWED_ATTR, html);
        }
        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg$1);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl$1);
          addToSet(ALLOWED_ATTR, mathMl);
          addToSet(ALLOWED_ATTR, xml);
        }
      }
      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }
        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
      }
      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }
        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
      }
      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
      }
      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }
        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
      }
      if (KEEP_CONTENT) {
        ALLOWED_TAGS["#text"] = true;
      }
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
      }
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ["tbody"]);
        delete FORBID_TAGS.tbody;
      }
      if (cfg.TRUSTED_TYPES_POLICY) {
        if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        }
        if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        }
        trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
        emptyHTML = trustedTypesPolicy.createHTML("");
      } else {
        if (trustedTypesPolicy === void 0) {
          trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
        }
        if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
          emptyHTML = trustedTypesPolicy.createHTML("");
        }
      }
      if (freeze) {
        freeze(cfg);
      }
      CONFIG = cfg;
    };
    const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
    const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
    const _checkValidNamespace = function _checkValidNamespace2(element) {
      let parent = getParentNode2(element);
      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: NAMESPACE,
          tagName: "template"
        };
      }
      const tagName = stringToLowerCase(element.tagName);
      const parentTagName = stringToLowerCase(parent.tagName);
      if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
        return false;
      }
      if (element.namespaceURI === SVG_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "svg";
        }
        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        }
        return Boolean(ALL_SVG_TAGS[tagName]);
      }
      if (element.namespaceURI === MATHML_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "math";
        }
        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
        }
        return Boolean(ALL_MATHML_TAGS[tagName]);
      }
      if (element.namespaceURI === HTML_NAMESPACE) {
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
      }
      if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
        return true;
      }
      return false;
    };
    const _forceRemove = function _forceRemove2(node) {
      arrayPush(DOMPurify.removed, {
        element: node
      });
      try {
        getParentNode2(node).removeChild(node);
      } catch (_2) {
        remove(node);
      }
    };
    const _removeAttribute = function _removeAttribute2(name, element) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: element.getAttributeNode(name),
          from: element
        });
      } catch (_2) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: element
        });
      }
      element.removeAttribute(name);
      if (name === "is") {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(element);
          } catch (_2) {
          }
        } else {
          try {
            element.setAttribute(name, "");
          } catch (_2) {
          }
        }
      }
    };
    const _initDocument = function _initDocument2(dirty) {
      let doc2 = null;
      let leadingWhitespace = null;
      if (FORCE_BODY) {
        dirty = "<remove></remove>" + dirty;
      } else {
        const matches2 = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches2 && matches2[0];
      }
      if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
      }
      const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc2 = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch (_2) {
        }
      }
      if (!doc2 || !doc2.documentElement) {
        doc2 = implementation.createDocument(NAMESPACE, "template", null);
        try {
          doc2.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
        } catch (_2) {
        }
      }
      const body = doc2.body || doc2.documentElement;
      if (dirty && leadingWhitespace) {
        body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }
      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc2, WHOLE_DOCUMENT ? "html" : "body")[0];
      }
      return WHOLE_DOCUMENT ? doc2.documentElement : body;
    };
    const _createNodeIterator = function _createNodeIterator2(root) {
      return createNodeIterator.call(
        root.ownerDocument || root,
        root,
        // eslint-disable-next-line no-bitwise
        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
        null
      );
    };
    const _isClobbered = function _isClobbered2(element) {
      return element instanceof HTMLFormElement && (typeof element.nodeName !== "string" || typeof element.textContent !== "string" || typeof element.removeChild !== "function" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== "function" || typeof element.setAttribute !== "function" || typeof element.namespaceURI !== "string" || typeof element.insertBefore !== "function" || typeof element.hasChildNodes !== "function");
    };
    const _isNode = function _isNode2(value) {
      return typeof Node2 === "function" && value instanceof Node2;
    };
    function _executeHooks(hooks2, currentNode, data) {
      arrayForEach(hooks2, (hook) => {
        hook.call(DOMPurify, currentNode, data, CONFIG);
      });
    }
    const _sanitizeElements = function _sanitizeElements2(currentNode) {
      let content = null;
      _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      const tagName = transformCaseFunc(currentNode.nodeName);
      _executeHooks(hooks.uponSanitizeElement, currentNode, {
        tagName,
        allowedTags: ALLOWED_TAGS
      });
      if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent)) {
        _forceRemove(currentNode);
        return true;
      }
      if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
        _forceRemove(currentNode);
        return true;
      }
      if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
        _forceRemove(currentNode);
        return true;
      }
      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
            return false;
          }
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
            return false;
          }
        }
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          const parentNode2 = getParentNode2(currentNode) || currentNode.parentNode;
          const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
          if (childNodes && parentNode2) {
            const childCount = childNodes.length;
            for (let i2 = childCount - 1; i2 >= 0; --i2) {
              const childClone = cloneNode(childNodes[i2], true);
              childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
              parentNode2.insertBefore(childClone, getNextSibling(currentNode));
            }
          }
        }
        _forceRemove(currentNode);
        return true;
      }
      if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
        content = currentNode.textContent;
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          content = stringReplace(content, expr, " ");
        });
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, {
            element: currentNode.cloneNode()
          });
          currentNode.textContent = content;
        }
      }
      _executeHooks(hooks.afterSanitizeElements, currentNode, null);
      return false;
    };
    const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
      if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
        return false;
      }
      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName)) ;
      else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName)) ;
      else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        if (
          // First condition does a very basic check if a) it's basically a valid custom element tagname AND
          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
          _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
        ) ;
        else {
          return false;
        }
      } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
      else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
      else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
      else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
      else if (value) {
        return false;
      } else ;
      return true;
    };
    const _isBasicCustomElement = function _isBasicCustomElement2(tagName) {
      return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT2);
    };
    const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
      _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
      const {
        attributes
      } = currentNode;
      if (!attributes || _isClobbered(currentNode)) {
        return;
      }
      const hookEvent = {
        attrName: "",
        attrValue: "",
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR,
        forceKeepAttr: void 0
      };
      let l = attributes.length;
      while (l--) {
        const attr = attributes[l];
        const {
          name,
          namespaceURI,
          value: attrValue
        } = attr;
        const lcName = transformCaseFunc(name);
        const initValue = attrValue;
        let value = name === "value" ? initValue : stringTrim(initValue);
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = void 0;
        _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
        value = hookEvent.attrValue;
        if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
          _removeAttribute(name, currentNode);
          value = SANITIZE_NAMED_PROPS_PREFIX + value;
        }
        if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (hookEvent.forceKeepAttr) {
          continue;
        }
        if (!hookEvent.keepAttr) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (SAFE_FOR_TEMPLATES) {
          arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
            value = stringReplace(value, expr, " ");
          });
        }
        const lcTag = transformCaseFunc(currentNode.nodeName);
        if (!_isValidAttribute(lcTag, lcName, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
          if (namespaceURI) ;
          else {
            switch (trustedTypes.getAttributeType(lcTag, lcName)) {
              case "TrustedHTML": {
                value = trustedTypesPolicy.createHTML(value);
                break;
              }
              case "TrustedScriptURL": {
                value = trustedTypesPolicy.createScriptURL(value);
                break;
              }
            }
          }
        }
        if (value !== initValue) {
          try {
            if (namespaceURI) {
              currentNode.setAttributeNS(namespaceURI, name, value);
            } else {
              currentNode.setAttribute(name, value);
            }
            if (_isClobbered(currentNode)) {
              _forceRemove(currentNode);
            } else {
              arrayPop(DOMPurify.removed);
            }
          } catch (_2) {
            _removeAttribute(name, currentNode);
          }
        }
      }
      _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
    };
    const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
      let shadowNode = null;
      const shadowIterator = _createNodeIterator(fragment);
      _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
      while (shadowNode = shadowIterator.nextNode()) {
        _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
        _sanitizeElements(shadowNode);
        _sanitizeAttributes(shadowNode);
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM2(shadowNode.content);
        }
      }
      _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
    };
    DOMPurify.sanitize = function(dirty) {
      let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let body = null;
      let importedNode = null;
      let currentNode = null;
      let returnNode = null;
      IS_EMPTY_INPUT = !dirty;
      if (IS_EMPTY_INPUT) {
        dirty = "<!-->";
      }
      if (typeof dirty !== "string" && !_isNode(dirty)) {
        if (typeof dirty.toString === "function") {
          dirty = dirty.toString();
          if (typeof dirty !== "string") {
            throw typeErrorCreate("dirty is not a string, aborting");
          }
        } else {
          throw typeErrorCreate("toString is not a function");
        }
      }
      if (!DOMPurify.isSupported) {
        return dirty;
      }
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }
      DOMPurify.removed = [];
      if (typeof dirty === "string") {
        IN_PLACE = false;
      }
      if (IN_PLACE) {
        if (dirty.nodeName) {
          const tagName = transformCaseFunc(dirty.nodeName);
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
          }
        }
      } else if (dirty instanceof Node2) {
        body = _initDocument("<!---->");
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === "BODY") {
          body = importedNode;
        } else if (importedNode.nodeName === "HTML") {
          body = importedNode;
        } else {
          body.appendChild(importedNode);
        }
      } else {
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf("<") === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }
        body = _initDocument(dirty);
        if (!body) {
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
        }
      }
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }
      const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
      while (currentNode = nodeIterator.nextNode()) {
        _sanitizeElements(currentNode);
        _sanitizeAttributes(currentNode);
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }
      }
      if (IN_PLACE) {
        return dirty;
      }
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);
          while (body.firstChild) {
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }
        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
          returnNode = importNode.call(originalDocument, returnNode, true);
        }
        return returnNode;
      }
      let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
      if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
        serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
      }
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          serializedHTML = stringReplace(serializedHTML, expr, " ");
        });
      }
      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };
    DOMPurify.setConfig = function() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _parseConfig(cfg);
      SET_CONFIG = true;
    };
    DOMPurify.clearConfig = function() {
      CONFIG = null;
      SET_CONFIG = false;
    };
    DOMPurify.isValidAttribute = function(tag, attr, value) {
      if (!CONFIG) {
        _parseConfig({});
      }
      const lcTag = transformCaseFunc(tag);
      const lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };
    DOMPurify.addHook = function(entryPoint, hookFunction) {
      if (typeof hookFunction !== "function") {
        return;
      }
      arrayPush(hooks[entryPoint], hookFunction);
    };
    DOMPurify.removeHook = function(entryPoint, hookFunction) {
      if (hookFunction !== void 0) {
        const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);
        return index === -1 ? void 0 : arraySplice(hooks[entryPoint], index, 1)[0];
      }
      return arrayPop(hooks[entryPoint]);
    };
    DOMPurify.removeHooks = function(entryPoint) {
      hooks[entryPoint] = [];
    };
    DOMPurify.removeAllHooks = function() {
      hooks = _createHooksMap();
    };
    return DOMPurify;
  }
  var purify = createDOMPurify();
  const HtmlParser = ({ html: html2 }) => {
    const clean = purify.sanitize(
      html2,
      {
        USE_PROFILES: { html: true },
        ADD_ATTR: ["target"]
      }
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { dangerouslySetInnerHTML: { __html: clean } });
  };
  const useDynamicPathname = () => {
    const [customPath, setCustomPath] = reactExports.useState("");
    reactExports.useEffect(() => {
      const fullPath = window.location.href;
      const segments = fullPath.split("/");
      const dynamicBasePath = segments[3];
      const basePath = `/${dynamicBasePath}`;
      const index = fullPath.indexOf(basePath);
      if (index !== -1) {
        const extractedPath = fullPath.substring(index + basePath.length);
        setCustomPath(extractedPath);
      }
    }, []);
    return customPath;
  };
  const Drawer = ({ className }) => {
    const { sidebarCollapsed, setSidebarCollapsed } = useCollapsible();
    const [isSecondIcon, setIsSecondIcon] = reactExports.useState(false);
    const { sidebarOpen, setSidebarOpen } = useCollapsible();
    const { me } = useMe$1();
    const { logout, isLoading } = useLogout();
    const { routes } = useRoute$1();
    const [activeRoute, setActiveRoute] = reactExports.useState("");
    const [sideBarOptions, setSideBarOptions] = reactExports.useState(hubSpotUserDetails.sideBarOptions);
    const [brandName, setBrandName] = reactExports.useState(hubSpotUserDetails.hubspotPortals.portalSettings.brandName);
    const { logoutDialog, setLogoutDialog } = useAuth();
    const customPath = useDynamicPathname();
    reactExports.useEffect(() => setActiveRoute(customPath), [customPath]);
    reactExports.useEffect(() => {
      const brandParam = getParam$1("brandName");
      if (brandParam && brandParam !== "null") {
        setBrandName(brandParam);
      } else if (me && me.hubspotPortals && me.hubspotPortals.portalSettings && me.hubspotPortals.portalSettings.brandName) {
        setBrandName(me.hubspotPortals.portalSettings.brandName);
      }
    }, [me]);
    const toggleSidebar = () => {
      setSidebarCollapsed(!sidebarCollapsed);
      setIsSecondIcon(!isSecondIcon);
    };
    const shouldShowTooltip = brandName.length > 10;
    reactExports.useEffect(() => {
      setSideBarOptions(hubSpotUserDetails.sideBarOptions);
    }, [hubSpotUserDetails]);
    const { isLargeScreen, isMediumScreen, isSmallScreen } = useResponsive();
    const handleSetActiveRoute = reactExports.useCallback(
      (path) => {
        setActiveRoute((prev) => {
          if (prev !== path) {
            return path;
          }
          return prev;
        });
        setSidebarOpen(false);
        window.location.hash = path;
      },
      []
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
      sidebarOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative z-[53]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "fixed inset-0 bg-gray-500 dark:bg-dark-300 bg-opacity-50 dark:bg-opacity-50 backdrop-blur-md backdrop-filter transition-opacity lg:hidden",
          "aria-hidden": "true",
          onClick: () => setSidebarOpen(false)
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${className} relative`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: `h-[100vh] z-[55] sidebar bg-[var(--sidebar-background-color)] dark:bg-dark-300 lg:relative lg:translate-x-0 absolute inset-y-0 left-0 transform ${(isMediumScreen || isSmallScreen) && "w-[300px]"} ${isLargeScreen && "w-auto"}  transition duration-200 ease-in-out ${sidebarOpen ? "translate-x-0" : "-translate-x-full"}
        ${sidebarCollapsed ? "p-3" : "p-4"}
        `,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "h-full flex flex-col", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex relative justify-between items-center mb-8", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => handleSetActiveRoute(formatPath(hubSpotUserDetails.sideMenu[0].tabName)), className: `flex ${showCompanyNameOption === true ? "flex-row items-center" : "flex-col"} gap-2 cursor-pointer`, children: [
                showCompanyNameOption ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[50px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: hubSpotUserDetails.hubspotPortals.portalSettings.smallLogo, alt: "Logo", className: `h-auto mr-2 ` }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${sidebarCollapsed ? "w-40px" : "w-full"}  max-h-[60px]`, children: sidebarCollapsed ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: hubSpotUserDetails.hubspotPortals.portalSettings.smallLogo, alt: "Logo", className: `h-auto` }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { className: "max-h-[60px]" }) }),
                showCompanyNameOption === true ? /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: `text-sm font-semibold pr-4 pl-1 break-al ease-in-out duration-500 tra text-[var(--sidebar-text-color)] dark:text-white ${sidebarCollapsed ? "hidden" : "block"}`, children: shouldShowTooltip ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  brandName.slice(0, 15),
                  brandName.length > 15 ? "..." : ""
                ] }) : brandName }) : ""
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: " rounded-lg cursor-pointer text-[var(--sidebar-text-color)] dark:text-white bg-gray-600 px-2 py-1 lg:hidden absolute right-[-10px] top-0",
                  onClick: () => setSidebarOpen(false),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {})
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("nav", { className: "space-y-1 flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: " flex flex-col h-full justify-between ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${showSidebarCtaOption ? "max-h-[calc(100vh-355px)]" : "max-h-[calc(100vh-160px)]"} flex flex-col gap-2 overflow-y-auto overflow-x-visible hide-scrollbar relative`, children: [
                routes.length > 0 && activeRoute && routes.map(({ path, title, icon }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: `cursor-pointer block hover:bg-[#ffffff]/20 dark:hover:bg-[#ffffff]/20 dark:hover:text-white ${sidebarCollapsed ? "py-3 px-0" : "px-3 py-[0.55rem]"} rounded-md no-underline ${activeRoute === path ? "bg-[#ffffff]/20" : ""}`,
                    onClick: () => handleSetActiveRoute(path),
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "div",
                      {
                        className: `flex items-center text-[var(--sidebar-text-color)] dark:text-white gap-x-3 gap-y-1 ${sidebarCollapsed ? "justify-center" : "justify-start"}`,
                        children: [
                          icon ? /* @__PURE__ */ jsxRuntimeExports.jsx(SvgRenderer, { svgContent: icon }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SvgRenderer, { svgContent: defaultSvg }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            "p",
                            {
                              className: `${sidebarCollapsed ? "hidden opacity-0" : "opacity-100"} text-[var(--sidebar-text-color)] dark:text-white text-sm font-medium transition-opacity capitalize duration-500 opacity-0 ml-2`,
                              children: `${title}`
                            }
                          )
                        ]
                      }
                    )
                  },
                  path
                )),
                routes.length > 7 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sticky -bottom-[2] left-0 right-0 h-6 pointer-events-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-full bg-gradient-to-t from-[var(--sidebar-background-color)] dark:from-dark-300 to-transparent" }) })
              ] }),
              showSidebarCtaOption === true && (!sidebarCollapsed && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `bg-[var(--sidebarCta-background-color)] text-[var(--sidebarCta-text-color)] text-sm p-4 text-md text-center dark:bg-dark-500 dark:text-white font-medium rounded-md`, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: sideBarOptions.title }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    className: `!bg-[var(--sidebarCta-button-background-color)] text-[var(--sidebarCta-button-text-color)] dark:!bg-dark-200 dark:text-white dar mt-4 !border-none`,
                    size: "sm",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(HtmlParser, { html: sideBarOptions.htmlForCta })
                  }
                )
              ] }) })),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: ` dark:hover:text-white hidden lg:block `,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex items-center gap-x-3 gap-y-1 ${sidebarCollapsed ? "justify-center" : "justify-end"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => toggleSidebar(), className: `flex items-center justify-center hover:bg-[#ffffff]/20 dark:hover:bg-[#ffffff]/20 ${sidebarCollapsed ? "py-3 px-0 w-full" : "px-3 py-[0.55rem]"} rounded-md no-underline cursor-pointer`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `cursor-pointer ${isSecondIcon ? "rotate-180" : "rotate-0"} items-center  text-[var(--sidebar-text-color)] dark:text-white flex`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarTogglerIcon, {}) }) }) })
                }
              ) })
            ] }) })
          ] })
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: logoutDialog, onClose: () => setLogoutDialog(false), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-cleanWhite dark:bg-dark-200 dark:text-white rounded-md flex-col justify-start items-center gap-6 inline-flex", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-[200px]", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: hubSpotUserDetails.hubspotPortals.portalSettings.authPopupFormLogo,
              alt: "Light Mode Logo",
              className: "h-auto dark:hidden"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: hubSpotUserDetails.hubspotPortals.portalSettings.logo,
              alt: "Dark Mode Logo",
              className: "h-auto hidden dark:block"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-[#2F2E33] dark:text-white text-base font-semibold   leading-snug", children: "Log out of your account?" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pt-3 flex gap-x-3 justify-between w-full", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              className: "dark:text-white",
              onClick: () => setLogoutDialog(false),
              children: "Keep Me Logged In"
            }
          ),
          env$1.VITE_DATA_SOURCE_SET === "false" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "outline",
              className: "dark:text-white",
              onClick: () => {
                if (!isLoading) {
                  logout();
                }
              },
              disabled: isLoading,
              children: isLoading ? "Logging out..." : "Logout"
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "/#/logout", className: "dark:text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "outline",
              className: "dark:text-white",
              onClick: () => setLogoutDialog(false),
              children: "Logout"
            }
          ) })
        ] })
      ] }) })
    ] });
  };
  React.memo(Drawer);
  const HamburgerMenu = (props) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        height: "24px",
        viewBox: "0 -960 960 960",
        width: "24px",
        className: "dark:fill-white fill-[var(--sidebar-text-color)]",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M120-240v-80h720v80H120Zm0-200v-80h720v80H120Zm0-200v-80h720v80H120Z" })
      }
    );
  };
  const Chevron = (props) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 16 16",
        fill: "none",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M10 12L6 8L10 4",
            stroke: "currentcolor",
            strokeWidth: "1.5",
            strokeLinecap: "round",
            strokeLinejoin: "round"
          }
        )
      }
    );
  };
  function useBreadcrumb() {
    const [breadcrumbs, setBreadcrumbs] = useAtom(breadcrumbState);
    return {
      breadcrumbs,
      setBreadcrumbs
    };
  }
  const Breadcrumb = (props) => {
    const router2 = useRouter();
    const location2 = router2.state.location;
    const { pathname, searchStr, hash } = router2.state.location;
    const { routes } = useRoute$1();
    const { breadcrumbs, setBreadcrumbs } = useBreadcrumb();
    const convertToBase64 = (str = []) => {
      const base64 = btoa(unescape(encodeURIComponent(str)));
      return base64;
    };
    const decodeToBase64 = (base64) => {
      const decodedStr = decodeURIComponent(escape(atob(base64)));
      return decodedStr;
    };
    const getParentObjectUrl = () => {
      const parentObjectUrl = getCookie(env$1.VITE_ASSOCIATION_VIEW_URL_KEY);
      return parentObjectUrl;
    };
    reactExports.useEffect(() => {
      let routeMenu = getRouteMenu(pathname);
      const segments = pathname.split("/");
      const decodePathName = decodeURIComponent(pathname);
      let item = [];
      if (getParam$1("parentObjectName")) {
        const parentObjectUrl = JSON.parse(getParentObjectUrl());
        item.push(parentObjectUrl);
      }
      item.push({
        name: decodePathName === "/association" ? decodePathName : segments.length > 1 ? segments[1] : routeMenu == null ? void 0 : routeMenu.title,
        path: `${decodePathName}${searchStr || ""}`,
        routeName: decodePathName
      });
      const mRoute = routes.find((route) => route.path === decodePathName);
      let breadcrumb = getParam$1("b");
      let breadcrumbItems = breadcrumb ? JSON.parse(decodeToBase64(breadcrumb)) : breadcrumbs;
      let index = breadcrumbItems.findIndex(
        (breadcrumb2) => (breadcrumb2 == null ? void 0 : breadcrumb2.routeName) === decodePathName
      );
      let updatedBreadcrumbs = index !== -1 ? breadcrumbItems.slice(0, index + 1) : breadcrumbItems;
      let foundBreadcrumb = updatedBreadcrumbs.find(
        (breadcrumb2) => (breadcrumb2 == null ? void 0 : breadcrumb2.routeName) === decodePathName
      );
      if (!foundBreadcrumb) {
        updatedBreadcrumbs = updatedBreadcrumbs ? [...updatedBreadcrumbs, ...item] : [];
      }
      const nextBreadcrumbs = mRoute ? item : updatedBreadcrumbs;
      if (JSON.stringify(nextBreadcrumbs) !== JSON.stringify(breadcrumbItems)) {
        const newBase64 = convertToBase64(JSON.stringify(nextBreadcrumbs));
        setParam("b", newBase64);
        setBreadcrumbs(nextBreadcrumbs);
      } else {
        setBreadcrumbs(nextBreadcrumbs);
      }
    }, [routes, location2.pathname]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs", children: /* @__PURE__ */ jsxRuntimeExports.jsx("ol", { className: "flex dark:text-white flex-wrap", children: breadcrumbs.map((breadcrumb, index) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Link,
          {
            className: `capitalize hover:underline ${index == 0 ? "!text-[var(--sidebar-text-color)]" : "!text-[var(--sidebar-text-color)] opacity-90"} hover:text-[var(--sidebar-text-color)] opacity-90 dark:text-white hover:text-white hover:opacity-90`,
            to: breadcrumb == null ? void 0 : breadcrumb.path,
            children: getParamHash(formatCustomObjectLabel(breadcrumb == null ? void 0 : breadcrumb.name))
          }
        ),
        index < breadcrumbs.length - 1 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mx-1 text-[var(--sidebar-text-color)] dark:text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Chevron, { className: "rotate-180 origin-center -webkit-transform" }) })
      ] }, index);
    }) }) });
  };
  const min = Math.min;
  const max = Math.max;
  const round = Math.round;
  const floor = Math.floor;
  const createCoords = (v) => ({
    x: v,
    y: v
  });
  const oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  const oppositeAlignmentMap = {
    start: "end",
    end: "start"
  };
  function clamp(start, value, end) {
    return max(start, min(value, end));
  }
  function evaluate(value, param) {
    return typeof value === "function" ? value(param) : value;
  }
  function getSide$1(placement) {
    return placement.split("-")[0];
  }
  function getAlignment(placement) {
    return placement.split("-")[1];
  }
  function getOppositeAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function getAxisLength(axis) {
    return axis === "y" ? "height" : "width";
  }
  const yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
  function getSideAxis(placement) {
    return yAxisSides.has(getSide$1(placement)) ? "y" : "x";
  }
  function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis(placement));
  }
  function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) {
      rtl = false;
    }
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
    if (rects.reference[length] > rects.floating[length]) {
      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
  }
  function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
  }
  function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
  }
  const lrPlacement = ["left", "right"];
  const rlPlacement = ["right", "left"];
  const tbPlacement = ["top", "bottom"];
  const btPlacement = ["bottom", "top"];
  function getSideList(side, isStart, rtl) {
    switch (side) {
      case "top":
      case "bottom":
        if (rtl) return isStart ? rlPlacement : lrPlacement;
        return isStart ? lrPlacement : rlPlacement;
      case "left":
      case "right":
        return isStart ? tbPlacement : btPlacement;
      default:
        return [];
    }
  }
  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list = getSideList(getSide$1(placement), direction === "start", rtl);
    if (alignment) {
      list = list.map((side) => side + "-" + alignment);
      if (flipAlignment) {
        list = list.concat(list.map(getOppositeAlignmentPlacement));
      }
    }
    return list;
  }
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
  }
  function expandPaddingObject(padding) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...padding
    };
  }
  function getPaddingObject(padding) {
    return typeof padding !== "number" ? expandPaddingObject(padding) : {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  function rectToClientRect(rect) {
    const {
      x: x2,
      y,
      width,
      height
    } = rect;
    return {
      width,
      height,
      top: y,
      left: x2,
      right: x2 + width,
      bottom: y + height,
      x: x2,
      y
    };
  }
  function computeCoordsFromPlacement(_ref, placement, rtl) {
    let {
      reference,
      floating
    } = _ref;
    const sideAxis = getSideAxis(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const alignLength = getAxisLength(alignmentAxis);
    const side = getSide$1(placement);
    const isVertical = sideAxis === "y";
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch (side) {
      case "top":
        coords = {
          x: commonX,
          y: reference.y - floating.height
        };
        break;
      case "bottom":
        coords = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;
      case "right":
        coords = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;
      case "left":
        coords = {
          x: reference.x - floating.width,
          y: commonY
        };
        break;
      default:
        coords = {
          x: reference.x,
          y: reference.y
        };
    }
    switch (getAlignment(placement)) {
      case "start":
        coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
        break;
      case "end":
        coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
        break;
    }
    return coords;
  }
  const computePosition$1 = async (reference, floating, config) => {
    const {
      placement = "bottom",
      strategy = "absolute",
      middleware = [],
      platform: platform2
    } = config;
    const validMiddleware = middleware.filter(Boolean);
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
    let rects = await platform2.getElementRects({
      reference,
      floating,
      strategy
    });
    let {
      x: x2,
      y
    } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for (let i2 = 0; i2 < validMiddleware.length; i2++) {
      const {
        name,
        fn
      } = validMiddleware[i2];
      const {
        x: nextX,
        y: nextY,
        data,
        reset
      } = await fn({
        x: x2,
        y,
        initialPlacement: placement,
        placement: statefulPlacement,
        strategy,
        middlewareData,
        rects,
        platform: platform2,
        elements: {
          reference,
          floating
        }
      });
      x2 = nextX != null ? nextX : x2;
      y = nextY != null ? nextY : y;
      middlewareData = {
        ...middlewareData,
        [name]: {
          ...middlewareData[name],
          ...data
        }
      };
      if (reset && resetCount <= 50) {
        resetCount++;
        if (typeof reset === "object") {
          if (reset.placement) {
            statefulPlacement = reset.placement;
          }
          if (reset.rects) {
            rects = reset.rects === true ? await platform2.getElementRects({
              reference,
              floating,
              strategy
            }) : reset.rects;
          }
          ({
            x: x2,
            y
          } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
        }
        i2 = -1;
      }
    }
    return {
      x: x2,
      y,
      placement: statefulPlacement,
      strategy,
      middlewareData
    };
  };
  async function detectOverflow(state, options) {
    var _await$platform$isEle;
    if (options === void 0) {
      options = {};
    }
    const {
      x: x2,
      y,
      platform: platform2,
      rects,
      elements,
      strategy
    } = state;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding = 0
    } = evaluate(options, state);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
      element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? {
      x: x2,
      y,
      width: rects.floating.width,
      height: rects.floating.height
    } : rects.reference;
    const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
    const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements,
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  }
  const arrow$1 = (options) => ({
    name: "arrow",
    options,
    async fn(state) {
      const {
        x: x2,
        y,
        placement,
        rects,
        platform: platform2,
        elements,
        middlewareData
      } = state;
      const {
        element,
        padding = 0
      } = evaluate(options, state) || {};
      if (element == null) {
        return {};
      }
      const paddingObject = getPaddingObject(padding);
      const coords = {
        x: x2,
        y
      };
      const axis = getAlignmentAxis(placement);
      const length = getAxisLength(axis);
      const arrowDimensions = await platform2.getDimensions(element);
      const isYAxis = axis === "y";
      const minProp = isYAxis ? "top" : "left";
      const maxProp = isYAxis ? "bottom" : "right";
      const clientProp = isYAxis ? "clientHeight" : "clientWidth";
      const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
      const startDiff = coords[axis] - rects.reference[axis];
      const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
      if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
        clientSize = elements.floating[clientProp] || rects.floating[length];
      }
      const centerToReference = endDiff / 2 - startDiff / 2;
      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
      const minPadding = min(paddingObject[minProp], largestPossiblePadding);
      const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
      const min$1 = minPadding;
      const max2 = clientSize - arrowDimensions[length] - maxPadding;
      const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
      const offset2 = clamp(min$1, center, max2);
      const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
      const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
      return {
        [axis]: coords[axis] + alignmentOffset,
        data: {
          [axis]: offset2,
          centerOffset: center - offset2 - alignmentOffset,
          ...shouldAddOffset && {
            alignmentOffset
          }
        },
        reset: shouldAddOffset
      };
    }
  });
  const flip$1 = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "flip",
      options,
      async fn(state) {
        var _middlewareData$arrow, _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform: platform2,
          elements
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = "bestFit",
          fallbackAxisSideDirection = "none",
          flipAlignment = true,
          ...detectOverflowOptions
        } = evaluate(options, state);
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        const side = getSide$1(placement);
        const initialSideAxis = getSideAxis(initialPlacement);
        const isBasePlacement = getSide$1(initialPlacement) === initialPlacement;
        const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
        if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        }
        const placements = [initialPlacement, ...fallbackPlacements];
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const sides = getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow[sides[0]], overflow[sides[1]]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];
        if (!overflows.every((side2) => side2 <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex2 = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements[nextIndex2];
          if (nextPlacement) {
            const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
            if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
            // overflows the main axis.
            overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
              return {
                data: {
                  index: nextIndex2,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
          }
          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b2) => a.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case "bestFit": {
                var _overflowsData$filter2;
                const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis(d.placement);
                    return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === "y";
                  }
                  return true;
                }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b2) => a[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement2) {
                  resetPlacement = placement2;
                }
                break;
              }
              case "initialPlacement":
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      }
    };
  };
  const originSides = /* @__PURE__ */ new Set(["left", "top"]);
  async function convertValueToCoords(state, options) {
    const {
      placement,
      platform: platform2,
      elements
    } = state;
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
    const side = getSide$1(placement);
    const alignment = getAlignment(placement);
    const isVertical = getSideAxis(placement) === "y";
    const mainAxisMulti = originSides.has(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = evaluate(options, state);
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue === "number" ? {
      mainAxis: rawValue,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: rawValue.mainAxis || 0,
      crossAxis: rawValue.crossAxis || 0,
      alignmentAxis: rawValue.alignmentAxis
    };
    if (alignment && typeof alignmentAxis === "number") {
      crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  }
  const offset$1 = function(options) {
    if (options === void 0) {
      options = 0;
    }
    return {
      name: "offset",
      options,
      async fn(state) {
        var _middlewareData$offse, _middlewareData$arrow;
        const {
          x: x2,
          y,
          placement,
          middlewareData
        } = state;
        const diffCoords = await convertValueToCoords(state, options);
        if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        return {
          x: x2 + diffCoords.x,
          y: y + diffCoords.y,
          data: {
            ...diffCoords,
            placement
          }
        };
      }
    };
  };
  const shift$2 = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "shift",
      options,
      async fn(state) {
        const {
          x: x2,
          y,
          placement
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = false,
          limiter = {
            fn: (_ref) => {
              let {
                x: x3,
                y: y2
              } = _ref;
              return {
                x: x3,
                y: y2
              };
            }
          },
          ...detectOverflowOptions
        } = evaluate(options, state);
        const coords = {
          x: x2,
          y
        };
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const crossAxis = getSideAxis(getSide$1(placement));
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        if (checkMainAxis) {
          const minSide = mainAxis === "y" ? "top" : "left";
          const maxSide = mainAxis === "y" ? "bottom" : "right";
          const min2 = mainAxisCoord + overflow[minSide];
          const max2 = mainAxisCoord - overflow[maxSide];
          mainAxisCoord = clamp(min2, mainAxisCoord, max2);
        }
        if (checkCrossAxis) {
          const minSide = crossAxis === "y" ? "top" : "left";
          const maxSide = crossAxis === "y" ? "bottom" : "right";
          const min2 = crossAxisCoord + overflow[minSide];
          const max2 = crossAxisCoord - overflow[maxSide];
          crossAxisCoord = clamp(min2, crossAxisCoord, max2);
        }
        const limitedCoords = limiter.fn({
          ...state,
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        });
        return {
          ...limitedCoords,
          data: {
            x: limitedCoords.x - x2,
            y: limitedCoords.y - y,
            enabled: {
              [mainAxis]: checkMainAxis,
              [crossAxis]: checkCrossAxis
            }
          }
        };
      }
    };
  };
  function hasWindow() {
    return typeof window !== "undefined";
  }
  function getNodeName(node) {
    if (isNode(node)) {
      return (node.nodeName || "").toLowerCase();
    }
    return "#document";
  }
  function getWindow(node) {
    var _node$ownerDocument;
    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
  }
  function getDocumentElement(node) {
    var _ref;
    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
  }
  function isNode(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Node || value instanceof getWindow(value).Node;
  }
  function isElement(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Element || value instanceof getWindow(value).Element;
  }
  function isHTMLElement$1(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
  }
  function isShadowRoot(value) {
    if (!hasWindow() || typeof ShadowRoot === "undefined") {
      return false;
    }
    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
  }
  const invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
  function isOverflowElement(element) {
    const {
      overflow,
      overflowX,
      overflowY,
      display
    } = getComputedStyle$1(element);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
  }
  const tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
  function isTableElement(element) {
    return tableElements.has(getNodeName(element));
  }
  const topLayerSelectors = [":popover-open", ":modal"];
  function isTopLayer(element) {
    return topLayerSelectors.some((selector2) => {
      try {
        return element.matches(selector2);
      } catch (_e2) {
        return false;
      }
    });
  }
  const transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
  const willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
  const containValues = ["paint", "layout", "strict", "content"];
  function isContainingBlock(elementOrCss) {
    const webkit2 = isWebKit();
    const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
    return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit2 && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit2 && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
  }
  function getContainingBlock(element) {
    let currentNode = getParentNode(element);
    while (isHTMLElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
      if (isContainingBlock(currentNode)) {
        return currentNode;
      } else if (isTopLayer(currentNode)) {
        return null;
      }
      currentNode = getParentNode(currentNode);
    }
    return null;
  }
  function isWebKit() {
    if (typeof CSS === "undefined" || !CSS.supports) return false;
    return CSS.supports("-webkit-backdrop-filter", "none");
  }
  const lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
  function isLastTraversableNode(node) {
    return lastTraversableNodeNames.has(getNodeName(node));
  }
  function getComputedStyle$1(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function getNodeScroll(element) {
    if (isElement(element)) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    return {
      scrollLeft: element.scrollX,
      scrollTop: element.scrollY
    };
  }
  function getParentNode(node) {
    if (getNodeName(node) === "html") {
      return node;
    }
    const result = (
      // Step into the shadow DOM of the parent of a slotted node.
      node.assignedSlot || // DOM Element detected.
      node.parentNode || // ShadowRoot detected.
      isShadowRoot(node) && node.host || // Fallback.
      getDocumentElement(node)
    );
    return isShadowRoot(result) ? result.host : result;
  }
  function getNearestOverflowAncestor(node) {
    const parentNode2 = getParentNode(node);
    if (isLastTraversableNode(parentNode2)) {
      return node.ownerDocument ? node.ownerDocument.body : node.body;
    }
    if (isHTMLElement$1(parentNode2) && isOverflowElement(parentNode2)) {
      return parentNode2;
    }
    return getNearestOverflowAncestor(parentNode2);
  }
  function getOverflowAncestors(node, list, traverseIframes) {
    var _node$ownerDocument2;
    if (list === void 0) {
      list = [];
    }
    if (traverseIframes === void 0) {
      traverseIframes = true;
    }
    const scrollableAncestor = getNearestOverflowAncestor(node);
    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) {
      const frameElement = getFrameElement(win);
      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
    }
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
  }
  function getFrameElement(win) {
    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
  }
  function getCssDimensions(element) {
    const css = getComputedStyle$1(element);
    let width = parseFloat(css.width) || 0;
    let height = parseFloat(css.height) || 0;
    const hasOffset = isHTMLElement$1(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
    if (shouldFallback) {
      width = offsetWidth;
      height = offsetHeight;
    }
    return {
      width,
      height,
      $: shouldFallback
    };
  }
  function unwrapElement(element) {
    return !isElement(element) ? element.contextElement : element;
  }
  function getScale(element) {
    const domElement = unwrapElement(element);
    if (!isHTMLElement$1(domElement)) {
      return createCoords(1);
    }
    const rect = domElement.getBoundingClientRect();
    const {
      width,
      height,
      $: $2
    } = getCssDimensions(domElement);
    let x2 = ($2 ? round(rect.width) : rect.width) / width;
    let y = ($2 ? round(rect.height) : rect.height) / height;
    if (!x2 || !Number.isFinite(x2)) {
      x2 = 1;
    }
    if (!y || !Number.isFinite(y)) {
      y = 1;
    }
    return {
      x: x2,
      y
    };
  }
  const noOffsets = /* @__PURE__ */ createCoords(0);
  function getVisualOffsets(element) {
    const win = getWindow(element);
    if (!isWebKit() || !win.visualViewport) {
      return noOffsets;
    }
    return {
      x: win.visualViewport.offsetLeft,
      y: win.visualViewport.offsetTop
    };
  }
  function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
      return false;
    }
    return isFixed;
  }
  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    const clientRect2 = element.getBoundingClientRect();
    const domElement = unwrapElement(element);
    let scale = createCoords(1);
    if (includeScale) {
      if (offsetParent) {
        if (isElement(offsetParent)) {
          scale = getScale(offsetParent);
        }
      } else {
        scale = getScale(element);
      }
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
    let x2 = (clientRect2.left + visualOffsets.x) / scale.x;
    let y = (clientRect2.top + visualOffsets.y) / scale.y;
    let width = clientRect2.width / scale.x;
    let height = clientRect2.height / scale.y;
    if (domElement) {
      const win = getWindow(domElement);
      const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
      let currentWin = win;
      let currentIFrame = getFrameElement(currentWin);
      while (currentIFrame && offsetParent && offsetWin !== currentWin) {
        const iframeScale = getScale(currentIFrame);
        const iframeRect = currentIFrame.getBoundingClientRect();
        const css = getComputedStyle$1(currentIFrame);
        const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
        const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
        x2 *= iframeScale.x;
        y *= iframeScale.y;
        width *= iframeScale.x;
        height *= iframeScale.y;
        x2 += left;
        y += top;
        currentWin = getWindow(currentIFrame);
        currentIFrame = getFrameElement(currentWin);
      }
    }
    return rectToClientRect({
      width,
      height,
      x: x2,
      y
    });
  }
  function getWindowScrollBarX(element, rect) {
    const leftScroll = getNodeScroll(element).scrollLeft;
    if (!rect) {
      return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
    }
    return rect.left + leftScroll;
  }
  function getHTMLOffset(documentElement, scroll) {
    const htmlRect = documentElement.getBoundingClientRect();
    const x2 = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
    const y = htmlRect.top + scroll.scrollTop;
    return {
      x: x2,
      y
    };
  }
  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let {
      elements,
      rect,
      offsetParent,
      strategy
    } = _ref;
    const isFixed = strategy === "fixed";
    const documentElement = getDocumentElement(offsetParent);
    const topLayer = elements ? isTopLayer(elements.floating) : false;
    if (offsetParent === documentElement || topLayer && isFixed) {
      return rect;
    }
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    let scale = createCoords(1);
    const offsets = createCoords(0);
    const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement$1(offsetParent)) {
        const offsetRect = getBoundingClientRect(offsetParent);
        scale = getScale(offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
    return {
      width: rect.width * scale.x,
      height: rect.height * scale.y,
      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
    };
  }
  function getClientRects(element) {
    return Array.from(element.getClientRects());
  }
  function getDocumentRect(element) {
    const html2 = getDocumentElement(element);
    const scroll = getNodeScroll(element);
    const body = element.ownerDocument.body;
    const width = max(html2.scrollWidth, html2.clientWidth, body.scrollWidth, body.clientWidth);
    const height = max(html2.scrollHeight, html2.clientHeight, body.scrollHeight, body.clientHeight);
    let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
    const y = -scroll.scrollTop;
    if (getComputedStyle$1(body).direction === "rtl") {
      x2 += max(html2.clientWidth, body.clientWidth) - width;
    }
    return {
      width,
      height,
      x: x2,
      y
    };
  }
  const SCROLLBAR_MAX = 25;
  function getViewportRect(element, strategy) {
    const win = getWindow(element);
    const html2 = getDocumentElement(element);
    const visualViewport = win.visualViewport;
    let width = html2.clientWidth;
    let height = html2.clientHeight;
    let x2 = 0;
    let y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      const visualViewportBased = isWebKit();
      if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
        x2 = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    const windowScrollbarX = getWindowScrollBarX(html2);
    if (windowScrollbarX <= 0) {
      const doc2 = html2.ownerDocument;
      const body = doc2.body;
      const bodyStyles = getComputedStyle(body);
      const bodyMarginInline = doc2.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
      const clippingStableScrollbarWidth = Math.abs(html2.clientWidth - body.clientWidth - bodyMarginInline);
      if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
        width -= clippingStableScrollbarWidth;
      }
    } else if (windowScrollbarX <= SCROLLBAR_MAX) {
      width += windowScrollbarX;
    }
    return {
      width,
      height,
      x: x2,
      y
    };
  }
  const absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
  function getInnerBoundingClientRect(element, strategy) {
    const clientRect2 = getBoundingClientRect(element, true, strategy === "fixed");
    const top = clientRect2.top + element.clientTop;
    const left = clientRect2.left + element.clientLeft;
    const scale = isHTMLElement$1(element) ? getScale(element) : createCoords(1);
    const width = element.clientWidth * scale.x;
    const height = element.clientHeight * scale.y;
    const x2 = left * scale.x;
    const y = top * scale.y;
    return {
      width,
      height,
      x: x2,
      y
    };
  }
  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === "viewport") {
      rect = getViewportRect(element, strategy);
    } else if (clippingAncestor === "document") {
      rect = getDocumentRect(getDocumentElement(element));
    } else if (isElement(clippingAncestor)) {
      rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    } else {
      const visualOffsets = getVisualOffsets(element);
      rect = {
        x: clippingAncestor.x - visualOffsets.x,
        y: clippingAncestor.y - visualOffsets.y,
        width: clippingAncestor.width,
        height: clippingAncestor.height
      };
    }
    return rectToClientRect(rect);
  }
  function hasFixedPositionAncestor(element, stopNode) {
    const parentNode2 = getParentNode(element);
    if (parentNode2 === stopNode || !isElement(parentNode2) || isLastTraversableNode(parentNode2)) {
      return false;
    }
    return getComputedStyle$1(parentNode2).position === "fixed" || hasFixedPositionAncestor(parentNode2, stopNode);
  }
  function getClippingElementAncestors(element, cache) {
    const cachedResult2 = cache.get(element);
    if (cachedResult2) {
      return cachedResult2;
    }
    let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = getComputedStyle$1(element).position === "fixed";
    let currentNode = elementIsFixed ? getParentNode(element) : element;
    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
      const computedStyle = getComputedStyle$1(currentNode);
      const currentNodeIsContaining = isContainingBlock(currentNode);
      if (!currentNodeIsContaining && computedStyle.position === "fixed") {
        currentContainingBlockComputedStyle = null;
      }
      const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
      if (shouldDropCurrentNode) {
        result = result.filter((ancestor) => ancestor !== currentNode);
      } else {
        currentContainingBlockComputedStyle = computedStyle;
      }
      currentNode = getParentNode(currentNode);
    }
    cache.set(element, result);
    return result;
  }
  function getClippingRect(_ref) {
    let {
      element,
      boundary,
      rootBoundary,
      strategy
    } = _ref;
    const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
    const clippingAncestors = [...elementClippingAncestors, rootBoundary];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
      const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
    return {
      width: clippingRect.right - clippingRect.left,
      height: clippingRect.bottom - clippingRect.top,
      x: clippingRect.left,
      y: clippingRect.top
    };
  }
  function getDimensions(element) {
    const {
      width,
      height
    } = getCssDimensions(element);
    return {
      width,
      height
    };
  }
  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    const isFixed = strategy === "fixed";
    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const offsets = createCoords(0);
    function setLeftRTLScrollbarOffset() {
      offsets.x = getWindowScrollBarX(documentElement);
    }
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isOffsetParentAnElement) {
        const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      } else if (documentElement) {
        setLeftRTLScrollbarOffset();
      }
    }
    if (isFixed && !isOffsetParentAnElement && documentElement) {
      setLeftRTLScrollbarOffset();
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
    const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
    const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
    return {
      x: x2,
      y,
      width: rect.width,
      height: rect.height
    };
  }
  function isStaticPositioned(element) {
    return getComputedStyle$1(element).position === "static";
  }
  function getTrueOffsetParent(element, polyfill) {
    if (!isHTMLElement$1(element) || getComputedStyle$1(element).position === "fixed") {
      return null;
    }
    if (polyfill) {
      return polyfill(element);
    }
    let rawOffsetParent = element.offsetParent;
    if (getDocumentElement(element) === rawOffsetParent) {
      rawOffsetParent = rawOffsetParent.ownerDocument.body;
    }
    return rawOffsetParent;
  }
  function getOffsetParent(element, polyfill) {
    const win = getWindow(element);
    if (isTopLayer(element)) {
      return win;
    }
    if (!isHTMLElement$1(element)) {
      let svgOffsetParent = getParentNode(element);
      while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
        if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
          return svgOffsetParent;
        }
        svgOffsetParent = getParentNode(svgOffsetParent);
      }
      return win;
    }
    let offsetParent = getTrueOffsetParent(element, polyfill);
    while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
      offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
      return win;
    }
    return offsetParent || getContainingBlock(element) || win;
  }
  const getElementRects = async function(data) {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    const floatingDimensions = await getDimensionsFn(data.floating);
    return {
      reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
      floating: {
        x: 0,
        y: 0,
        width: floatingDimensions.width,
        height: floatingDimensions.height
      }
    };
  };
  function isRTL(element) {
    return getComputedStyle$1(element).direction === "rtl";
  }
  const platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement,
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement,
    isRTL
  };
  function rectsAreEqual(a, b2) {
    return a.x === b2.x && a.y === b2.y && a.width === b2.width && a.height === b2.height;
  }
  function observeMove(element, onMove) {
    let io = null;
    let timeoutId;
    const root = getDocumentElement(element);
    function cleanup() {
      var _io;
      clearTimeout(timeoutId);
      (_io = io) == null || _io.disconnect();
      io = null;
    }
    function refresh(skip, threshold) {
      if (skip === void 0) {
        skip = false;
      }
      if (threshold === void 0) {
        threshold = 1;
      }
      cleanup();
      const elementRectForRootMargin = element.getBoundingClientRect();
      const {
        left,
        top,
        width,
        height
      } = elementRectForRootMargin;
      if (!skip) {
        onMove();
      }
      if (!width || !height) {
        return;
      }
      const insetTop = floor(top);
      const insetRight = floor(root.clientWidth - (left + width));
      const insetBottom = floor(root.clientHeight - (top + height));
      const insetLeft = floor(left);
      const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
      const options = {
        rootMargin,
        threshold: max(0, min(1, threshold)) || 1
      };
      let isFirstUpdate = true;
      function handleObserve(entries2) {
        const ratio = entries2[0].intersectionRatio;
        if (ratio !== threshold) {
          if (!isFirstUpdate) {
            return refresh();
          }
          if (!ratio) {
            timeoutId = setTimeout(() => {
              refresh(false, 1e-7);
            }, 1e3);
          } else {
            refresh(false, ratio);
          }
        }
        if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
          refresh();
        }
        isFirstUpdate = false;
      }
      try {
        io = new IntersectionObserver(handleObserve, {
          ...options,
          // Handle <iframe>s
          root: root.ownerDocument
        });
      } catch (_e2) {
        io = new IntersectionObserver(handleObserve, options);
      }
      io.observe(element);
    }
    refresh(true);
    return cleanup;
  }
  function autoUpdate(reference, floating, update, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      ancestorScroll = true,
      ancestorResize = true,
      elementResize = typeof ResizeObserver === "function",
      layoutShift = typeof IntersectionObserver === "function",
      animationFrame = false
    } = options;
    const referenceEl = unwrapElement(reference);
    const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.addEventListener("scroll", update, {
        passive: true
      });
      ancestorResize && ancestor.addEventListener("resize", update);
    });
    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
    let reobserveFrame = -1;
    let resizeObserver = null;
    if (elementResize) {
      resizeObserver = new ResizeObserver((_ref) => {
        let [firstEntry] = _ref;
        if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
          resizeObserver.unobserve(floating);
          cancelAnimationFrame(reobserveFrame);
          reobserveFrame = requestAnimationFrame(() => {
            var _resizeObserver;
            (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
          });
        }
        update();
      });
      if (referenceEl && !animationFrame) {
        resizeObserver.observe(referenceEl);
      }
      resizeObserver.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    if (animationFrame) {
      frameLoop();
    }
    function frameLoop() {
      const nextRefRect = getBoundingClientRect(reference);
      if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
        update();
      }
      prevRefRect = nextRefRect;
      frameId = requestAnimationFrame(frameLoop);
    }
    update();
    return () => {
      var _resizeObserver2;
      ancestors.forEach((ancestor) => {
        ancestorScroll && ancestor.removeEventListener("scroll", update);
        ancestorResize && ancestor.removeEventListener("resize", update);
      });
      cleanupIo == null || cleanupIo();
      (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
      resizeObserver = null;
      if (animationFrame) {
        cancelAnimationFrame(frameId);
      }
    };
  }
  const offset = offset$1;
  const shift$1 = shift$2;
  const flip = flip$1;
  const arrow = arrow$1;
  const computePosition = (reference, floating, options) => {
    const cache = /* @__PURE__ */ new Map();
    const mergedOptions = {
      platform,
      ...options
    };
    const platformWithCache = {
      ...mergedOptions.platform,
      _c: cache
    };
    return computePosition$1(reference, floating, {
      ...mergedOptions,
      platform: platformWithCache
    });
  };
  var define_process_default$1 = {};
  var define_process_env_default$1 = {};
  const h = "react-tooltip-core-styles", w = "react-tooltip-base-styles", b = { core: false, base: false };
  function S({ css: e2, id: t2 = w, type: o2 = "base", ref: l2 }) {
    var r2, n2;
    if (!e2 || "undefined" == typeof document || b[o2]) return;
    if ("core" === o2 && "undefined" != typeof define_process_default$1 && (null === (r2 = null === define_process_default$1 || void 0 === define_process_default$1 ? void 0 : define_process_env_default$1) || void 0 === r2 ? void 0 : r2.REACT_TOOLTIP_DISABLE_CORE_STYLES)) return;
    if ("base" !== o2 && "undefined" != typeof define_process_default$1 && (null === (n2 = null === define_process_default$1 || void 0 === define_process_default$1 ? void 0 : define_process_env_default$1) || void 0 === n2 ? void 0 : n2.REACT_TOOLTIP_DISABLE_BASE_STYLES)) return;
    "core" === o2 && (t2 = h), l2 || (l2 = {});
    const { insertAt: i2 } = l2;
    if (document.getElementById(t2)) return;
    const c2 = document.head || document.getElementsByTagName("head")[0], s2 = document.createElement("style");
    s2.id = t2, s2.type = "text/css", "top" === i2 && c2.firstChild ? c2.insertBefore(s2, c2.firstChild) : c2.appendChild(s2), s2.styleSheet ? s2.styleSheet.cssText = e2 : s2.appendChild(document.createTextNode(e2)), b[o2] = true;
  }
  const E = async ({ elementReference: e2 = null, tooltipReference: t2 = null, tooltipArrowReference: o2 = null, place: l2 = "top", offset: r2 = 10, strategy: n2 = "absolute", middlewares: i2 = [offset(Number(r2)), flip({ fallbackAxisSideDirection: "start" }), shift$1({ padding: 5 })], border: c2, arrowSize: s2 = 8 }) => {
    if (!e2) return { tooltipStyles: {}, tooltipArrowStyles: {}, place: l2 };
    if (null === t2) return { tooltipStyles: {}, tooltipArrowStyles: {}, place: l2 };
    const a2 = i2;
    return o2 ? (a2.push(arrow({ element: o2, padding: 5 })), computePosition(e2, t2, { placement: l2, strategy: n2, middleware: a2 }).then(({ x: e3, y: t3, placement: o3, middlewareData: l3 }) => {
      var r3, n3;
      const i3 = { left: `${e3}px`, top: `${t3}px`, border: c2 }, { x: a3, y: u2 } = null !== (r3 = l3.arrow) && void 0 !== r3 ? r3 : { x: 0, y: 0 }, d2 = null !== (n3 = { top: "bottom", right: "left", bottom: "top", left: "right" }[o3.split("-")[0]]) && void 0 !== n3 ? n3 : "bottom", p2 = c2 && { borderBottom: c2, borderRight: c2 };
      let v2 = 0;
      if (c2) {
        const e4 = `${c2}`.match(/(\d+)px/);
        v2 = (null == e4 ? void 0 : e4[1]) ? Number(e4[1]) : 1;
      }
      return { tooltipStyles: i3, tooltipArrowStyles: { left: null != a3 ? `${a3}px` : "", top: null != u2 ? `${u2}px` : "", right: "", bottom: "", ...p2, [d2]: `-${s2 / 2 + v2}px` }, place: o3 };
    })) : computePosition(e2, t2, { placement: "bottom", strategy: n2, middleware: a2 }).then(({ x: e3, y: t3, placement: o3 }) => ({ tooltipStyles: { left: `${e3}px`, top: `${t3}px` }, tooltipArrowStyles: {}, place: o3 }));
  }, A = (e2, t2) => !("CSS" in window && "supports" in window.CSS) || window.CSS.supports(e2, t2), _ = (e2, t2, o2) => {
    let l2 = null;
    const r2 = function(...r3) {
      const n2 = () => {
        l2 = null;
      };
      !l2 && (e2.apply(this, r3), l2 = setTimeout(n2, t2));
    };
    return r2.cancel = () => {
      l2 && (clearTimeout(l2), l2 = null);
    }, r2;
  }, O = (e2) => null !== e2 && !Array.isArray(e2) && "object" == typeof e2, k = (e2, t2) => {
    if (e2 === t2) return true;
    if (Array.isArray(e2) && Array.isArray(t2)) return e2.length === t2.length && e2.every((e3, o3) => k(e3, t2[o3]));
    if (Array.isArray(e2) !== Array.isArray(t2)) return false;
    if (!O(e2) || !O(t2)) return e2 === t2;
    const o2 = Object.keys(e2), l2 = Object.keys(t2);
    return o2.length === l2.length && o2.every((o3) => k(e2[o3], t2[o3]));
  }, T = (e2) => {
    if (!(e2 instanceof HTMLElement || e2 instanceof SVGElement)) return false;
    const t2 = getComputedStyle(e2);
    return ["overflow", "overflow-x", "overflow-y"].some((e3) => {
      const o2 = t2.getPropertyValue(e3);
      return "auto" === o2 || "scroll" === o2;
    });
  }, L = (e2) => {
    if (!e2) return null;
    let t2 = e2.parentElement;
    for (; t2; ) {
      if (T(t2)) return t2;
      t2 = t2.parentElement;
    }
    return document.scrollingElement || document.documentElement;
  }, C = "undefined" != typeof window ? reactExports.useLayoutEffect : reactExports.useEffect, R = (e2) => {
    e2.current && (clearTimeout(e2.current), e2.current = null);
  }, x = "DEFAULT_TOOLTIP_ID", N = { anchorRefs: /* @__PURE__ */ new Set(), activeAnchor: { current: null }, attach: () => {
  }, detach: () => {
  }, setActiveAnchor: () => {
  } }, $ = reactExports.createContext({ getTooltipData: () => N });
  function z$1(e2 = x) {
    return reactExports.useContext($).getTooltipData(e2);
  }
  var B = { tooltip: "core-styles-module_tooltip__3vRRp", fixed: "core-styles-module_fixed__pcSol", arrow: "core-styles-module_arrow__cvMwQ", noArrow: "core-styles-module_noArrow__xock6", clickable: "core-styles-module_clickable__ZuTTB", show: "core-styles-module_show__Nt9eE", closing: "core-styles-module_closing__sGnxF" }, D = { tooltip: "styles-module_tooltip__mnnfp", arrow: "styles-module_arrow__K0L3T", dark: "styles-module_dark__xNqje", light: "styles-module_light__Z6W-X", success: "styles-module_success__A2AKt", warning: "styles-module_warning__SCK0X", error: "styles-module_error__JvumD", info: "styles-module_info__BWdHW" };
  const q = ({ forwardRef: t2, id: l2, className: i2, classNameArrow: c2, variant: u2 = "dark", anchorId: d2, anchorSelect: p2, place: v2 = "top", offset: m2 = 10, events: h2 = ["hover"], openOnClick: w2 = false, positionStrategy: b2 = "absolute", middlewares: S2, wrapper: g2, delayShow: A2 = 0, delayHide: O2 = 0, float: T2 = false, hidden: x2 = false, noArrow: N2 = false, clickable: $2 = false, closeOnEsc: I2 = false, closeOnScroll: j2 = false, closeOnResize: q2 = false, openEvents: H2, closeEvents: M2, globalCloseEvents: W, imperativeModeOnly: P, style: V, position: F, afterShow: K, afterHide: U, disableTooltip: X, content: Y, contentWrapperRef: G, isOpen: Z, defaultIsOpen: J = false, setIsOpen: Q, activeAnchor: ee, setActiveAnchor: te, border: oe, opacity: le, arrowColor: re, arrowSize: ne = 8, role: ie2 = "tooltip" }) => {
    var ce2;
    const se = reactExports.useRef(null), ae = reactExports.useRef(null), ue = reactExports.useRef(null), de = reactExports.useRef(null), pe = reactExports.useRef(null), [ve, me] = reactExports.useState({ tooltipStyles: {}, tooltipArrowStyles: {}, place: v2 }), [fe, ye] = reactExports.useState(false), [he, we] = reactExports.useState(false), [be, Se] = reactExports.useState(null), ge = reactExports.useRef(false), Ee = reactExports.useRef(null), { anchorRefs: Ae, setActiveAnchor: _e2 } = z$1(l2), Oe = reactExports.useRef(false), [ke, Te] = reactExports.useState([]), Le = reactExports.useRef(false), Ce = w2 || h2.includes("click"), Re = Ce || (null == H2 ? void 0 : H2.click) || (null == H2 ? void 0 : H2.dblclick) || (null == H2 ? void 0 : H2.mousedown), xe = H2 ? { ...H2 } : { mouseover: true, focus: true, mouseenter: false, click: false, dblclick: false, mousedown: false };
    !H2 && Ce && Object.assign(xe, { mouseenter: false, focus: false, mouseover: false, click: true });
    const Ne = M2 ? { ...M2 } : { mouseout: true, blur: true, mouseleave: false, click: false, dblclick: false, mouseup: false };
    !M2 && Ce && Object.assign(Ne, { mouseleave: false, blur: false, mouseout: false });
    const $e = W ? { ...W } : { escape: I2 || false, scroll: j2 || false, resize: q2 || false, clickOutsideAnchor: Re || false };
    P && (Object.assign(xe, { mouseover: false, focus: false, mouseenter: false, click: false, dblclick: false, mousedown: false }), Object.assign(Ne, { mouseout: false, blur: false, mouseleave: false, click: false, dblclick: false, mouseup: false }), Object.assign($e, { escape: false, scroll: false, resize: false, clickOutsideAnchor: false })), C(() => (Le.current = true, () => {
      Le.current = false;
    }), []);
    const Ie = (e2) => {
      Le.current && (e2 && we(true), setTimeout(() => {
        Le.current && (null == Q || Q(e2), void 0 === Z && ye(e2));
      }, 10));
    };
    reactExports.useEffect(() => {
      if (void 0 === Z) return () => null;
      Z && we(true);
      const e2 = setTimeout(() => {
        ye(Z);
      }, 10);
      return () => {
        clearTimeout(e2);
      };
    }, [Z]), reactExports.useEffect(() => {
      if (fe !== ge.current) if (R(pe), ge.current = fe, fe) null == K || K();
      else {
        const e2 = ((e3) => {
          const t3 = e3.match(/^([\d.]+)(ms|s)$/);
          if (!t3) return 0;
          const [, o2, l3] = t3;
          return Number(o2) * ("ms" === l3 ? 1 : 1e3);
        })(getComputedStyle(document.body).getPropertyValue("--rt-transition-show-delay"));
        pe.current = setTimeout(() => {
          we(false), Se(null), null == U || U();
        }, e2 + 25);
      }
    }, [fe]);
    const ze = (e2) => {
      me((t3) => k(t3, e2) ? t3 : e2);
    }, je = (e2 = A2) => {
      R(ue), he ? Ie(true) : ue.current = setTimeout(() => {
        Ie(true);
      }, e2);
    }, Be = (e2 = O2) => {
      R(de), de.current = setTimeout(() => {
        Oe.current || Ie(false);
      }, e2);
    }, De = (e2) => {
      var t3;
      if (!e2) return;
      const o2 = null !== (t3 = e2.currentTarget) && void 0 !== t3 ? t3 : e2.target;
      if (!(null == o2 ? void 0 : o2.isConnected)) return te(null), void _e2({ current: null });
      A2 ? je() : Ie(true), te(o2), _e2({ current: o2 }), R(de);
    }, qe = () => {
      $2 ? Be(O2 || 100) : O2 ? Be() : Ie(false), R(ue);
    }, He = ({ x: e2, y: t3 }) => {
      var o2;
      const l3 = { getBoundingClientRect: () => ({ x: e2, y: t3, width: 0, height: 0, top: t3, left: e2, right: e2, bottom: t3 }) };
      E({ place: null !== (o2 = null == be ? void 0 : be.place) && void 0 !== o2 ? o2 : v2, offset: m2, elementReference: l3, tooltipReference: se.current, tooltipArrowReference: ae.current, strategy: b2, middlewares: S2, border: oe, arrowSize: ne }).then((e3) => {
        ze(e3);
      });
    }, Me = (e2) => {
      if (!e2) return;
      const t3 = e2, o2 = { x: t3.clientX, y: t3.clientY };
      He(o2), Ee.current = o2;
    }, We = (e2) => {
      var t3;
      if (!fe) return;
      const o2 = e2.target;
      if (!o2.isConnected) return;
      if (null === (t3 = se.current) || void 0 === t3 ? void 0 : t3.contains(o2)) return;
      [document.querySelector(`[id='${d2}']`), ...ke].some((e3) => null == e3 ? void 0 : e3.contains(o2)) || (Ie(false), R(ue));
    }, Pe = _(De, 50), Ve = _(qe, 50), Fe = (e2) => {
      Ve.cancel(), Pe(e2);
    }, Ke = () => {
      Pe.cancel(), Ve();
    }, Ue = reactExports.useCallback(() => {
      var e2, t3;
      const o2 = null !== (e2 = null == be ? void 0 : be.position) && void 0 !== e2 ? e2 : F;
      o2 ? He(o2) : T2 ? Ee.current && He(Ee.current) : (null == ee ? void 0 : ee.isConnected) && E({ place: null !== (t3 = null == be ? void 0 : be.place) && void 0 !== t3 ? t3 : v2, offset: m2, elementReference: ee, tooltipReference: se.current, tooltipArrowReference: ae.current, strategy: b2, middlewares: S2, border: oe, arrowSize: ne }).then((e3) => {
        Le.current && ze(e3);
      });
    }, [fe, ee, Y, V, v2, null == be ? void 0 : be.place, m2, b2, F, null == be ? void 0 : be.position, T2, ne]);
    reactExports.useEffect(() => {
      var e2, t3;
      const o2 = new Set(Ae);
      ke.forEach((e3) => {
        (null == X ? void 0 : X(e3)) || o2.add({ current: e3 });
      });
      const l3 = document.querySelector(`[id='${d2}']`);
      l3 && !(null == X ? void 0 : X(l3)) && o2.add({ current: l3 });
      const r2 = () => {
        Ie(false);
      }, n2 = L(ee), i3 = L(se.current);
      $e.scroll && (window.addEventListener("scroll", r2), null == n2 || n2.addEventListener("scroll", r2), null == i3 || i3.addEventListener("scroll", r2));
      let c3 = null;
      $e.resize ? window.addEventListener("resize", r2) : ee && se.current && (c3 = autoUpdate(ee, se.current, Ue, { ancestorResize: true, elementResize: true, layoutShift: true }));
      const s2 = (e3) => {
        "Escape" === e3.key && Ie(false);
      };
      $e.escape && window.addEventListener("keydown", s2), $e.clickOutsideAnchor && window.addEventListener("click", We);
      const a2 = [], u3 = (e3) => Boolean((null == e3 ? void 0 : e3.target) && (null == ee ? void 0 : ee.contains(e3.target))), p3 = (e3) => {
        fe && u3(e3) || De(e3);
      }, v3 = (e3) => {
        fe && u3(e3) && qe();
      }, m3 = ["mouseover", "mouseout", "mouseenter", "mouseleave", "focus", "blur"], y2 = ["click", "dblclick", "mousedown", "mouseup"];
      Object.entries(xe).forEach(([e3, t4]) => {
        t4 && (m3.includes(e3) ? a2.push({ event: e3, listener: Fe }) : y2.includes(e3) && a2.push({ event: e3, listener: p3 }));
      }), Object.entries(Ne).forEach(([e3, t4]) => {
        t4 && (m3.includes(e3) ? a2.push({ event: e3, listener: Ke }) : y2.includes(e3) && a2.push({ event: e3, listener: v3 }));
      }), T2 && a2.push({ event: "pointermove", listener: Me });
      const h3 = () => {
        Oe.current = true;
      }, w3 = () => {
        Oe.current = false, qe();
      }, b3 = $2 && (Ne.mouseout || Ne.mouseleave);
      return b3 && (null === (e2 = se.current) || void 0 === e2 || e2.addEventListener("mouseover", h3), null === (t3 = se.current) || void 0 === t3 || t3.addEventListener("mouseout", w3)), a2.forEach(({ event: e3, listener: t4 }) => {
        o2.forEach((o3) => {
          var l4;
          null === (l4 = o3.current) || void 0 === l4 || l4.addEventListener(e3, t4);
        });
      }), () => {
        var e3, t4;
        $e.scroll && (window.removeEventListener("scroll", r2), null == n2 || n2.removeEventListener("scroll", r2), null == i3 || i3.removeEventListener("scroll", r2)), $e.resize ? window.removeEventListener("resize", r2) : null == c3 || c3(), $e.clickOutsideAnchor && window.removeEventListener("click", We), $e.escape && window.removeEventListener("keydown", s2), b3 && (null === (e3 = se.current) || void 0 === e3 || e3.removeEventListener("mouseover", h3), null === (t4 = se.current) || void 0 === t4 || t4.removeEventListener("mouseout", w3)), a2.forEach(({ event: e4, listener: t5 }) => {
          o2.forEach((o3) => {
            var l4;
            null === (l4 = o3.current) || void 0 === l4 || l4.removeEventListener(e4, t5);
          });
        });
      };
    }, [ee, Ue, he, Ae, ke, H2, M2, W, Ce, A2, O2]), reactExports.useEffect(() => {
      var e2, t3;
      let o2 = null !== (t3 = null !== (e2 = null == be ? void 0 : be.anchorSelect) && void 0 !== e2 ? e2 : p2) && void 0 !== t3 ? t3 : "";
      !o2 && l2 && (o2 = `[data-tooltip-id='${l2.replace(/'/g, "\\'")}']`);
      const r2 = new MutationObserver((e3) => {
        const t4 = [], r3 = [];
        e3.forEach((e4) => {
          if ("attributes" === e4.type && "data-tooltip-id" === e4.attributeName) {
            e4.target.getAttribute("data-tooltip-id") === l2 ? t4.push(e4.target) : e4.oldValue === l2 && r3.push(e4.target);
          }
          if ("childList" === e4.type) {
            if (ee) {
              const t5 = [...e4.removedNodes].filter((e5) => 1 === e5.nodeType);
              if (o2) try {
                r3.push(...t5.filter((e5) => e5.matches(o2))), r3.push(...t5.flatMap((e5) => [...e5.querySelectorAll(o2)]));
              } catch (e5) {
              }
              t5.some((e5) => {
                var t6;
                return !!(null === (t6 = null == e5 ? void 0 : e5.contains) || void 0 === t6 ? void 0 : t6.call(e5, ee)) && (we(false), Ie(false), te(null), R(ue), R(de), true);
              });
            }
            if (o2) try {
              const l3 = [...e4.addedNodes].filter((e5) => 1 === e5.nodeType);
              t4.push(...l3.filter((e5) => e5.matches(o2))), t4.push(...l3.flatMap((e5) => [...e5.querySelectorAll(o2)]));
            } catch (e5) {
            }
          }
        }), (t4.length || r3.length) && Te((e4) => [...e4.filter((e5) => !r3.includes(e5)), ...t4]);
      });
      return r2.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ["data-tooltip-id"], attributeOldValue: true }), () => {
        r2.disconnect();
      };
    }, [l2, p2, null == be ? void 0 : be.anchorSelect, ee]), reactExports.useEffect(() => {
      Ue();
    }, [Ue]), reactExports.useEffect(() => {
      if (!(null == G ? void 0 : G.current)) return () => null;
      const e2 = new ResizeObserver(() => {
        setTimeout(() => Ue());
      });
      return e2.observe(G.current), () => {
        e2.disconnect();
      };
    }, [Y, null == G ? void 0 : G.current]), reactExports.useEffect(() => {
      var e2;
      const t3 = document.querySelector(`[id='${d2}']`), o2 = [...ke, t3];
      ee && o2.includes(ee) || te(null !== (e2 = ke[0]) && void 0 !== e2 ? e2 : t3);
    }, [d2, ke, ee]), reactExports.useEffect(() => (J && Ie(true), () => {
      R(ue), R(de);
    }), []), reactExports.useEffect(() => {
      var e2;
      let t3 = null !== (e2 = null == be ? void 0 : be.anchorSelect) && void 0 !== e2 ? e2 : p2;
      if (!t3 && l2 && (t3 = `[data-tooltip-id='${l2.replace(/'/g, "\\'")}']`), t3) try {
        const e3 = Array.from(document.querySelectorAll(t3));
        Te(e3);
      } catch (e3) {
        Te([]);
      }
    }, [l2, p2, null == be ? void 0 : be.anchorSelect]), reactExports.useEffect(() => {
      ue.current && (R(ue), je(A2));
    }, [A2]);
    const Xe = null !== (ce2 = null == be ? void 0 : be.content) && void 0 !== ce2 ? ce2 : Y, Ye = fe && Object.keys(ve.tooltipStyles).length > 0;
    return reactExports.useImperativeHandle(t2, () => ({ open: (e2) => {
      if (null == e2 ? void 0 : e2.anchorSelect) try {
        document.querySelector(e2.anchorSelect);
      } catch (t3) {
        return void console.warn(`[react-tooltip] "${e2.anchorSelect}" is not a valid CSS selector`);
      }
      Se(null != e2 ? e2 : null), (null == e2 ? void 0 : e2.delay) ? je(e2.delay) : Ie(true);
    }, close: (e2) => {
      (null == e2 ? void 0 : e2.delay) ? Be(e2.delay) : Ie(false);
    }, activeAnchor: ee, place: ve.place, isOpen: Boolean(he && !x2 && Xe && Ye) })), he && !x2 && Xe ? React.createElement(g2, { id: l2, role: ie2, className: classNames("react-tooltip", B.tooltip, D.tooltip, D[u2], i2, `react-tooltip__place-${ve.place}`, B[Ye ? "show" : "closing"], Ye ? "react-tooltip__show" : "react-tooltip__closing", "fixed" === b2 && B.fixed, $2 && B.clickable), onTransitionEnd: (e2) => {
      R(pe), fe || "opacity" !== e2.propertyName || (we(false), Se(null), null == U || U());
    }, style: { ...V, ...ve.tooltipStyles, opacity: void 0 !== le && Ye ? le : void 0 }, ref: se }, Xe, React.createElement(g2, { className: classNames("react-tooltip-arrow", B.arrow, D.arrow, c2, N2 && B.noArrow), style: { ...ve.tooltipArrowStyles, background: re ? `linear-gradient(to right bottom, transparent 50%, ${re} 50%)` : void 0, "--rt-arrow-size": `${ne}px` }, ref: ae })) : null;
  }, H = ({ content: t2 }) => React.createElement("span", { dangerouslySetInnerHTML: { __html: t2 } }), M = React.forwardRef(({ id: t2, anchorId: l2, anchorSelect: n2, content: i2, html: c2, render: a2, className: u2, classNameArrow: d2, variant: p2 = "dark", place: v2 = "top", offset: m2 = 10, wrapper: f2 = "div", children: h2 = null, events: w2 = ["hover"], openOnClick: b2 = false, positionStrategy: S2 = "absolute", middlewares: g2, delayShow: E2 = 0, delayHide: _2 = 0, float: O2 = false, hidden: k2 = false, noArrow: T2 = false, clickable: L2 = false, closeOnEsc: C2 = false, closeOnScroll: R2 = false, closeOnResize: x2 = false, openEvents: N2, closeEvents: $2, globalCloseEvents: I2, imperativeModeOnly: j2 = false, style: B2, position: D2, isOpen: M2, defaultIsOpen: W = false, disableStyleInjection: P = false, border: V, opacity: F, arrowColor: K, arrowSize: U, setIsOpen: X, afterShow: Y, afterHide: G, disableTooltip: Z, role: J = "tooltip" }, Q) => {
    const [ee, te] = reactExports.useState(i2), [oe, le] = reactExports.useState(c2), [re, ne] = reactExports.useState(v2), [ie2, ce2] = reactExports.useState(p2), [se, ae] = reactExports.useState(m2), [ue, de] = reactExports.useState(E2), [pe, ve] = reactExports.useState(_2), [me, fe] = reactExports.useState(O2), [ye, he] = reactExports.useState(k2), [we, be] = reactExports.useState(f2), [Se, ge] = reactExports.useState(w2), [Ee, Ae] = reactExports.useState(S2), [_e2, Oe] = reactExports.useState(null), [ke, Te] = reactExports.useState(null), Le = reactExports.useRef(P), { anchorRefs: Ce, activeAnchor: Re } = z$1(t2), xe = (e2) => null == e2 ? void 0 : e2.getAttributeNames().reduce((t3, o2) => {
      var l3;
      if (o2.startsWith("data-tooltip-")) {
        t3[o2.replace(/^data-tooltip-/, "")] = null !== (l3 = null == e2 ? void 0 : e2.getAttribute(o2)) && void 0 !== l3 ? l3 : null;
      }
      return t3;
    }, {}), Ne = (e2) => {
      const t3 = { place: (e3) => {
        var t4;
        ne(null !== (t4 = e3) && void 0 !== t4 ? t4 : v2);
      }, content: (e3) => {
        te(null != e3 ? e3 : i2);
      }, html: (e3) => {
        le(null != e3 ? e3 : c2);
      }, variant: (e3) => {
        var t4;
        ce2(null !== (t4 = e3) && void 0 !== t4 ? t4 : p2);
      }, offset: (e3) => {
        ae(null === e3 ? m2 : Number(e3));
      }, wrapper: (e3) => {
        var t4;
        be(null !== (t4 = e3) && void 0 !== t4 ? t4 : f2);
      }, events: (e3) => {
        const t4 = null == e3 ? void 0 : e3.split(" ");
        ge(null != t4 ? t4 : w2);
      }, "position-strategy": (e3) => {
        var t4;
        Ae(null !== (t4 = e3) && void 0 !== t4 ? t4 : S2);
      }, "delay-show": (e3) => {
        de(null === e3 ? E2 : Number(e3));
      }, "delay-hide": (e3) => {
        ve(null === e3 ? _2 : Number(e3));
      }, float: (e3) => {
        fe(null === e3 ? O2 : "true" === e3);
      }, hidden: (e3) => {
        he(null === e3 ? k2 : "true" === e3);
      }, "class-name": (e3) => {
        Oe(e3);
      } };
      Object.values(t3).forEach((e3) => e3(null)), Object.entries(e2).forEach(([e3, o2]) => {
        var l3;
        null === (l3 = t3[e3]) || void 0 === l3 || l3.call(t3, o2);
      });
    };
    reactExports.useEffect(() => {
      te(i2);
    }, [i2]), reactExports.useEffect(() => {
      le(c2);
    }, [c2]), reactExports.useEffect(() => {
      ne(v2);
    }, [v2]), reactExports.useEffect(() => {
      ce2(p2);
    }, [p2]), reactExports.useEffect(() => {
      ae(m2);
    }, [m2]), reactExports.useEffect(() => {
      de(E2);
    }, [E2]), reactExports.useEffect(() => {
      ve(_2);
    }, [_2]), reactExports.useEffect(() => {
      fe(O2);
    }, [O2]), reactExports.useEffect(() => {
      he(k2);
    }, [k2]), reactExports.useEffect(() => {
      Ae(S2);
    }, [S2]), reactExports.useEffect(() => {
      Le.current !== P && console.warn("[react-tooltip] Do not change `disableStyleInjection` dynamically.");
    }, [P]), reactExports.useEffect(() => {
      "undefined" != typeof window && window.dispatchEvent(new CustomEvent("react-tooltip-inject-styles", { detail: { disableCore: "core" === P, disableBase: P } }));
    }, []), reactExports.useEffect(() => {
      var e2;
      const o2 = new Set(Ce);
      let r2 = n2;
      if (!r2 && t2 && (r2 = `[data-tooltip-id='${t2.replace(/'/g, "\\'")}']`), r2) try {
        document.querySelectorAll(r2).forEach((e3) => {
          o2.add({ current: e3 });
        });
      } catch (e3) {
        console.warn(`[react-tooltip] "${r2}" is not a valid CSS selector`);
      }
      const i3 = document.querySelector(`[id='${l2}']`);
      if (i3 && o2.add({ current: i3 }), !o2.size) return () => null;
      const c3 = null !== (e2 = null != ke ? ke : i3) && void 0 !== e2 ? e2 : Re.current, s2 = new MutationObserver((e3) => {
        e3.forEach((e4) => {
          var t3;
          if (!c3 || "attributes" !== e4.type || !(null === (t3 = e4.attributeName) || void 0 === t3 ? void 0 : t3.startsWith("data-tooltip-"))) return;
          const o3 = xe(c3);
          Ne(o3);
        });
      }), a3 = { attributes: true, childList: false, subtree: false };
      if (c3) {
        const e3 = xe(c3);
        Ne(e3), s2.observe(c3, a3);
      }
      return () => {
        s2.disconnect();
      };
    }, [Ce, Re, ke, l2, n2]), reactExports.useEffect(() => {
      (null == B2 ? void 0 : B2.border) && console.warn("[react-tooltip] Do not set `style.border`. Use `border` prop instead."), V && !A("border", `${V}`) && console.warn(`[react-tooltip] "${V}" is not a valid \`border\`.`), (null == B2 ? void 0 : B2.opacity) && console.warn("[react-tooltip] Do not set `style.opacity`. Use `opacity` prop instead."), F && !A("opacity", `${F}`) && console.warn(`[react-tooltip] "${F}" is not a valid \`opacity\`.`);
    }, []);
    let $e = h2;
    const Ie = reactExports.useRef(null);
    if (a2) {
      const t3 = a2({ content: (null == ke ? void 0 : ke.getAttribute("data-tooltip-content")) || ee || null, activeAnchor: ke });
      $e = t3 ? React.createElement("div", { ref: Ie, className: "react-tooltip-content-wrapper" }, t3) : null;
    } else ee && ($e = ee);
    oe && ($e = React.createElement(H, { content: oe }));
    const ze = { forwardRef: Q, id: t2, anchorId: l2, anchorSelect: n2, className: classNames(u2, _e2), classNameArrow: d2, content: $e, contentWrapperRef: Ie, place: re, variant: ie2, offset: se, wrapper: we, events: Se, openOnClick: b2, positionStrategy: Ee, middlewares: g2, delayShow: ue, delayHide: pe, float: me, hidden: ye, noArrow: T2, clickable: L2, closeOnEsc: C2, closeOnScroll: R2, closeOnResize: x2, openEvents: N2, closeEvents: $2, globalCloseEvents: I2, imperativeModeOnly: j2, style: B2, position: D2, isOpen: M2, defaultIsOpen: W, border: V, opacity: F, arrowColor: K, arrowSize: U, setIsOpen: X, afterShow: Y, afterHide: G, disableTooltip: Z, activeAnchor: ke, setActiveAnchor: (e2) => Te(e2), role: J };
    return React.createElement(q, { ...ze });
  });
  "undefined" != typeof window && window.addEventListener("react-tooltip-inject-styles", (e2) => {
    e2.detail.disableCore || S({ css: `:root{--rt-color-white:#fff;--rt-color-dark:#222;--rt-color-success:#8dc572;--rt-color-error:#be6464;--rt-color-warning:#f0ad4e;--rt-color-info:#337ab7;--rt-opacity:0.9;--rt-transition-show-delay:0.15s;--rt-transition-closing-delay:0.15s;--rt-arrow-size:8px}.core-styles-module_tooltip__3vRRp{position:absolute;top:0;left:0;pointer-events:none;opacity:0;will-change:opacity}.core-styles-module_fixed__pcSol{position:fixed}.core-styles-module_arrow__cvMwQ{position:absolute;background:inherit;z-index:-1}.core-styles-module_noArrow__xock6{display:none}.core-styles-module_clickable__ZuTTB{pointer-events:auto}.core-styles-module_show__Nt9eE{opacity:var(--rt-opacity);transition:opacity var(--rt-transition-show-delay)ease-out}.core-styles-module_closing__sGnxF{opacity:0;transition:opacity var(--rt-transition-closing-delay)ease-in}`, type: "core" }), e2.detail.disableBase || S({ css: `
.styles-module_tooltip__mnnfp{padding:8px 16px;border-radius:3px;font-size:90%;width:max-content}.styles-module_arrow__K0L3T{width:var(--rt-arrow-size);height:var(--rt-arrow-size)}[class*='react-tooltip__place-top']>.styles-module_arrow__K0L3T{transform:rotate(45deg)}[class*='react-tooltip__place-right']>.styles-module_arrow__K0L3T{transform:rotate(135deg)}[class*='react-tooltip__place-bottom']>.styles-module_arrow__K0L3T{transform:rotate(225deg)}[class*='react-tooltip__place-left']>.styles-module_arrow__K0L3T{transform:rotate(315deg)}.styles-module_dark__xNqje{background:var(--rt-color-dark);color:var(--rt-color-white)}.styles-module_light__Z6W-X{background-color:var(--rt-color-white);color:var(--rt-color-dark)}.styles-module_success__A2AKt{background-color:var(--rt-color-success);color:var(--rt-color-white)}.styles-module_warning__SCK0X{background-color:var(--rt-color-warning);color:var(--rt-color-white)}.styles-module_error__JvumD{background-color:var(--rt-color-error);color:var(--rt-color-white)}.styles-module_info__BWdHW{background-color:var(--rt-color-info);color:var(--rt-color-white)}`, type: "base" });
  });
  const Tooltip = ({
    children = "text-xs",
    content,
    id,
    place,
    className = "",
    variant = "dark",
    clickable = false
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          "data-tooltip-id": id,
          "data-tooltip-content": typeof content === "string" ? content : void 0,
          className,
          children
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        M,
        {
          id,
          place,
          variant,
          clickable,
          children: typeof content !== "string" && content
        }
      )
    ] });
  };
  function useSync() {
    const [sync, setSyncStatus] = useAtom(syncState);
    const [isSyncLoading, setLoader] = useAtom(syncLoadingState);
    const [isSyncDisable, setSyncDisable] = useAtom(syncDisableState);
    const setIsSyncLoading = (status) => {
      setLoader(status);
      setSyncStatus(status);
    };
    const setSync = (status) => {
      setLoader(status);
      setSyncStatus(status);
    };
    return {
      sync,
      setSync,
      isSyncLoading,
      setIsSyncLoading,
      isSyncDisable,
      setSyncDisable
    };
  }
  const SyncButton = () => {
    const { setSync, isSyncLoading, isSyncDisable } = useSync();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: `text-[var(--sidebar-text-color)] dark:text-white  p-3 text-center
        ${isSyncLoading || isSyncDisable ? "cursor-not-allowed " : "cursor-pointer"}
      `,
        onClick: () => {
          if (!isSyncLoading && !isSyncDisable) {
            setSync(true);
          }
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            className: `h-4 w-4 ${isSyncLoading ? "rotate" : ""}`,
            fill: "currentColor",
            viewBox: "0 -960 960 960",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M160-160v-80h110l-16-14q-52-46-73-105t-21-119q0-111 66.5-197.5T400-790v84q-72 26-116 88.5T240-478q0 45 17 87.5t53 78.5l10 10v-98h80v240H160Zm400-10v-84q72-26 116-88.5T720-482q0-45-17-87.5T650-648l-10-10v98h-80v-240h240v80H690l16 14q49 49 71.5 106.5T800-482q0 111-66.5 197.5T560-170Z" })
          }
        )
      }
    );
  };
  const ThemeSwitcher = () => {
    const [theme, setTheme] = reactExports.useState(() => {
      const urlTheme = getParam$1("theme");
      switch (urlTheme) {
        case "dark":
          return "dark";
        case "light":
          return "light";
        default:
          return localStorage.getItem("theme") === "dark" || !("theme" in localStorage) && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
      }
    });
    reactExports.useEffect(() => {
      switch (theme) {
        case "dark":
          document.documentElement.classList.add("dark");
          localStorage.setItem("theme", "dark");
          break;
        case "light":
        default:
          document.documentElement.classList.remove("dark");
          localStorage.setItem("theme", "light");
          break;
      }
    }, [theme]);
    const toggleTheme = () => {
      setTheme((prevTheme) => prevTheme === "dark" ? "light" : "dark");
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { id: "themeSwitcher", content: `Switch to ${theme === "dark" ? "light" : "dark"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "text-[var(--sidebar-text-color)] dark:text-white p-3 text-center cursor-pointer",
        onClick: () => toggleTheme(),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: theme === "dark" ? "hidden" : "block", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "svg",
            {
              viewBox: "0 0 20 20",
              fill: "none",
              xmlns: "http://www.w3.org/2000/svg",
              className: "h-4 w-4",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "M13.545 6.45505C12.6455 5.55558 11.3757 4.97357 10 4.97357C8.62437 4.97357 7.35452 5.52913 6.45505 6.45505C5.55558 7.35452 4.97357 8.62437 4.97357 10C4.97357 11.3757 5.55558 12.6455 6.45505 13.545C7.35452 14.4445 8.62437 15.0265 10 15.0265C11.3757 15.0265 12.6455 14.4709 13.545 13.545C14.4445 12.6455 15.0265 11.3757 15.0265 10C15.0265 8.62437 14.4709 7.35452 13.545 6.45505Z",
                    fill: "currentColor"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "M10 3.41269C10.3704 3.41269 10.6879 3.09523 10.6879 2.72486V0.68783C10.6879 0.31746 10.3704 0 10 0C9.62965 0 9.31219 0.31746 9.31219 0.68783V2.72486C9.31219 3.09523 9.62965 3.41269 10 3.41269Z",
                    fill: "currentColor"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "M15.6349 5.34392L17.0899 3.88889C17.3545 3.62434 17.3545 3.20106 17.0899 2.93651C16.8254 2.67196 16.4021 2.67196 16.1376 2.93651L14.6825 4.39154C14.418 4.65609 14.418 5.07937 14.6825 5.34392C14.9206 5.60847 15.3439 5.60847 15.6349 5.34392Z",
                    fill: "currentColor"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "M19.3122 9.31219H17.2751C16.9047 9.31219 16.5873 9.62965 16.5873 10C16.5873 10.3704 16.9047 10.6879 17.2751 10.6879H19.3122C19.6825 10.6879 20 10.3704 20 10C20 9.62965 19.6825 9.31219 19.3122 9.31219Z",
                    fill: "currentColor"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "M15.6085 14.6561C15.3439 14.3916 14.9207 14.3916 14.6561 14.6561C14.3916 14.9207 14.3916 15.3439 14.6561 15.6085L16.1111 17.0635C16.3757 17.3281 16.799 17.3281 17.0635 17.0635C17.3281 16.799 17.3281 16.3757 17.0635 16.1111L15.6085 14.6561Z",
                    fill: "currentColor"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "M10 16.5873C9.62965 16.5873 9.31219 16.9047 9.31219 17.2751V19.3122C9.31219 19.6825 9.62965 20 10 20C10.3704 20 10.6879 19.6825 10.6879 19.3122V17.2751C10.6879 16.9047 10.3704 16.5873 10 16.5873Z",
                    fill: "currentColor"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "M4.36511 14.6561L2.91008 16.1111C2.64553 16.3757 2.64553 16.799 2.91008 17.0635C3.17463 17.3281 3.59791 17.3281 3.86246 17.0635L5.31749 15.6085C5.58204 15.3439 5.58204 14.9207 5.31749 14.6561C5.07939 14.3916 4.65611 14.3916 4.36511 14.6561Z",
                    fill: "currentColor"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "M3.41269 10C3.41269 9.62965 3.09523 9.31219 2.72486 9.31219H0.68783C0.31746 9.31219 0 9.62965 0 10C0 10.3704 0.31746 10.6879 0.68783 10.6879H2.72486C3.09523 10.6879 3.41269 10.3704 3.41269 10Z",
                    fill: "currentColor"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "M4.36511 5.34392C4.62966 5.60847 5.05294 5.60847 5.31749 5.34392C5.58204 5.07937 5.58204 4.65609 5.31749 4.39154L3.86246 2.93651C3.59791 2.67196 3.17463 2.67196 2.91008 2.93651C2.64553 3.20106 2.64553 3.62434 2.91008 3.88889L4.36511 5.34392Z",
                    fill: "currentColor"
                  }
                )
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: theme === "dark" ? "block" : "hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "svg",
            {
              viewBox: "0 0 20 20",
              fill: "none",
              xmlns: "http://www.w3.org/2000/svg",
              className: "h-4 w-4",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: "M18.0246 11.1731C17.8521 11.13 17.6795 11.1731 17.5285 11.281C16.9676 11.7556 16.3204 12.1439 15.6085 12.4028C14.9398 12.6616 14.2063 12.7911 13.4297 12.7911C11.6823 12.7911 10.086 12.0792 8.94261 10.9358C7.79927 9.79248 7.08738 8.19612 7.08738 6.44875C7.08738 5.71528 7.21681 5.00339 7.43254 4.35622C7.66984 3.6659 8.015 3.04029 8.46802 2.50098C8.66217 2.26368 8.61903 1.91852 8.38173 1.72437C8.23072 1.61651 8.05814 1.57336 7.88556 1.61651C6.0519 2.11268 4.45553 3.21287 3.31219 4.6798C2.21199 6.12516 1.56482 7.91568 1.56482 9.8572C1.56482 12.2086 2.51401 14.3443 4.06723 15.8975C5.62045 17.4507 7.73455 18.3999 10.1075 18.3999C12.0922 18.3999 13.9259 17.7096 15.3928 16.5662C16.8813 15.4013 17.9599 13.7403 18.4129 11.8419C18.4992 11.5399 18.3267 11.2378 18.0246 11.1731Z",
                  fill: "currentColor"
                }
              )
            }
          ) })
        ]
      }
    ) });
  };
  const NewAvater = (props) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        viewBox: "0 0 1024 1024",
        fill: "currentColor",
        height: "1em",
        width: "1em",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M858.5 763.6a374 374 0 00-80.6-119.5 375.63 375.63 0 00-119.5-80.6c-.4-.2-.8-.3-1.2-.5C719.5 518 760 444.7 760 362c0-137-111-248-248-248S264 225 264 362c0 82.7 40.5 156 102.8 201.1-.4.2-.8.3-1.2.5-44.8 18.9-85 46-119.5 80.6a375.63 375.63 0 00-80.6 119.5A371.7 371.7 0 00136 901.8a8 8 0 008 8.2h60c4.4 0 7.9-3.5 8-7.8 2-77.2 33-149.5 87.8-204.3 56.7-56.7 132-87.9 212.2-87.9s155.5 31.2 212.2 87.9C779 752.7 810 825 812 902.2c.1 4.4 3.6 7.8 8 7.8h60a8 8 0 008-8.2c-1-47.8-10.9-94.3-29.5-138.2zM512 534c-45.9 0-89.1-17.9-121.6-50.4S340 407.9 340 362c0-45.9 17.9-89.1 50.4-121.6S466.1 190 512 190s89.1 17.9 121.6 50.4S684 316.1 684 362c0 45.9-17.9 89.1-50.4 121.6S557.9 534 512 534z" })
      }
    );
  };
  const LogOutIcon = (props) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { fill: "none", viewBox: "0 0 15 15", height: "1em", width: "1em", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M1 1h7v1H2v11h6v1H1V1zm9.854 3.146l3.34 3.34-3.327 3.603-.734-.678L12.358 8H4V7h8.293l-2.147-2.146.708-.708z",
        clipRule: "evenodd"
      }
    ) });
  };
  let globalNavHeight = 0;
  const HeaderLayout = (props) => {
    const [dropdownOpen, setDropdownOpen] = reactExports.useState(false);
    const dropdownRef = reactExports.useRef(null);
    const toggleButtonRef = reactExports.useRef(null);
    const navRef = reactExports.useRef(null);
    const { sidebarOpen, setSidebarOpen, sidebarCollapsed } = useCollapsible();
    const { setLogoutDialog } = useAuth();
    const firstName = getFirstName();
    const email = getEmail();
    reactExports.useEffect(() => {
      if (navRef.current) {
        globalNavHeight = navRef.current.offsetHeight;
      }
      document.documentElement.style.setProperty(
        "--nav-height",
        `${globalNavHeight}px`
      );
    }, [globalNavHeight]);
    const toggleDropdown = () => {
      setDropdownOpen((prevState) => !prevState);
    };
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target) && toggleButtonRef.current && !toggleButtonRef.current.contains(event.target)) {
        setDropdownOpen(false);
      }
    };
    const toggleDrawer = () => {
      setSidebarOpen(!sidebarOpen);
    };
    reactExports.useEffect(() => {
      document.addEventListener("mousedown", handleClickOutside);
      return () => {
        document.removeEventListener("mousedown", handleClickOutside);
      };
    }, []);
    const lastName = getLastName() || "";
    const initials = profileInitial(firstName, lastName);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { ref: navRef, className: `before:bg-[var(--sidebar-background-color)] before:dark:bg-dark-300 after:bg-[var(--sidebar-background-color)] after:dark:bg-dark-300 after:hidden max-lg:after:block bg-[var(--sidebar-background-color)] dark:bg-dark-300 lg:px-0 px-3 flex gap-1 flex-col py-1 z-[49] duration-200 fixed top-0 right-0 w-full nav-rounded ${sidebarCollapsed ? "lg:w-[calc(100%_-_75px)]" : "lg:w-[calc(100%_-_250px)]"}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-end items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lg:hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "cursor-pointer", onClick: toggleDrawer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-[var(--sidebar-text-color)] font-semibold  dark:text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx(HamburgerMenu, {}) }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "max-lg:hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Breadcrumb, { ...props }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-[var(--sidebar-text-color)]  dark:border-white dark:text-white rounded-md hover:bg-gray-600 dark:hover:bg-dark-400", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { id: "clearCacheTooltip", content: `Clear cache`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SyncButton, {}) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-[var(--sidebar-text-color)]  dark:border-white dark:text-white  rounded-md hover:bg-gray-600 dark:hover:bg-dark-400", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeSwitcher, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-px h-6 bg-gray-600 dark:bg-dark-400" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: " px-3 py-1 text-[var(--sidebar-text-color)]  dark:border-white dark:text-white rounded-md hover:bg-gray-600 dark:hover:bg-dark-400  cursor-pointer  profile-section mr-1",
                onClick: toggleDropdown,
                ref: toggleButtonRef,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { id: "profileBtn", place: "left", content: `My profile`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 items-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-full h-[30px] w-[30px] flex items-center justify-center bg-gray-400 text-white text-xs font-medium", children: initials }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-start flex-col", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "font-medium text-xs dark:text-white break-all", children: [
                    firstName ? firstName : "",
                    " ",
                    lastName ? lastName : ""
                  ] }) })
                ] }) })
              }
            )
          ] }),
          dropdownOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              ref: dropdownRef,
              className: "absolute right-8 border dark:border-gray-600 w-[280px] bg-cleanWhite rounded-md shadow-lg dark:bg-dark-400 z-[53]",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 items-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-full h-[50px] w-[50px] flex items-center justify-center bg-gray-400 text-white text-lg font-medium", children: initials }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: " flex items-start flex-col", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-semibold dark:text-white break-all", children: firstName }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-secondary dark:text-gray-400 break-all", children: email })
                  ] })
                ] }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "border-t border-gray-200 dark:border-gray-600" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-y-1  p-2", children: [
                  env$1.VITE_DATA_SOURCE_SET === "false" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Link,
                    {
                      to: "/profile",
                      className: "block hover:bg-gray-100 dark:hover:bg-dark-300 dark:hover:text-white px-3 py-2.5 rounded-md no-underline",
                      activeClassName: "dark:bg-dark-300 dark:text-white bg-gray-100",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-x-4", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dark:text-white text-black", children: /* @__PURE__ */ jsxRuntimeExports.jsx(NewAvater, {}) }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "p",
                          {
                            className: `
                       text-black text-sm font-medium dark:text-white`,
                            children: "My Profile"
                          }
                        )
                      ] })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      className: "block hover:bg-gray-100 dark:hover:bg-dark-300 dark:hover:text-white px-3 py-2.5 rounded-md no-underline cursor-pointer",
                      onClick: () => setLogoutDialog(true),
                      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-x-4", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dark:text-white text-black", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LogOutIcon, {}) }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "p",
                          {
                            className: `
                       text-black text-sm font-medium  dark:text-white`,
                            children: "Logout"
                          }
                        )
                      ] })
                    }
                  )
                ] })
              ]
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lg:hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Breadcrumb, { ...props }) })
    ] });
  };
  const MainLayout = ({ children }) => {
    const { sidebarCollapsed } = useCollapsible();
    const { setRoutes } = useRoute$1();
    setRoutes(apiRoutes);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dark:bg-dark-200 bg-cleanWhite lg:flex-col flex lg:h-[100vh] h-[100vh]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Drawer,
        {
          className: `relative lg:fixed min-h-screen w-full inset-0 ${sidebarCollapsed ? "lg:w-[75px]" : "lg:w-[250px]"}`
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `dark:bg-dark-200  lg:h-[100vh] h-[100vh] bg-cleanWhite ml-auto w-full ${sidebarCollapsed ? "lg:w-[calc(100%_-_75px)]" : "lg:w-[calc(100%_-_250px)]"}`,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(HeaderLayout, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-[var(--sidebar-background-color)] mt-[calc(var(--nav-height)-1px)] dark:bg-dark-300", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `bg-cleanWhite dark:bg-dark-200`, children }) })
          ]
        }
      )
    ] });
  };
  function AuthLayout({ children }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children });
  }
  function DefaultLayout({ children }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  }
  const layoutMap = {
    MainLayout,
    AuthLayout,
    DefaultLayout
  };
  const CLASS_PART_SEPARATOR = "-";
  function createClassUtils(config) {
    const classMap = createClassMap(config);
    const {
      conflictingClassGroups,
      conflictingClassGroupModifiers
    } = config;
    function getClassGroupId(className) {
      const classParts = className.split(CLASS_PART_SEPARATOR);
      if (classParts[0] === "" && classParts.length !== 1) {
        classParts.shift();
      }
      return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
    }
    function getConflictingClassGroupIds(classGroupId, hasPostfixModifier) {
      const conflicts = conflictingClassGroups[classGroupId] || [];
      if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
        return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
      }
      return conflicts;
    }
    return {
      getClassGroupId,
      getConflictingClassGroupIds
    };
  }
  function getGroupRecursive(classParts, classPartObject) {
    var _a2;
    if (classParts.length === 0) {
      return classPartObject.classGroupId;
    }
    const currentClassPart = classParts[0];
    const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
    const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
    if (classGroupFromNextClassPart) {
      return classGroupFromNextClassPart;
    }
    if (classPartObject.validators.length === 0) {
      return void 0;
    }
    const classRest = classParts.join(CLASS_PART_SEPARATOR);
    return (_a2 = classPartObject.validators.find(({
      validator: validator2
    }) => validator2(classRest))) == null ? void 0 : _a2.classGroupId;
  }
  const arbitraryPropertyRegex = /^\[(.+)\]$/;
  function getGroupIdForArbitraryProperty(className) {
    if (arbitraryPropertyRegex.test(className)) {
      const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
      const property = arbitraryPropertyClassName == null ? void 0 : arbitraryPropertyClassName.substring(0, arbitraryPropertyClassName.indexOf(":"));
      if (property) {
        return "arbitrary.." + property;
      }
    }
  }
  function createClassMap(config) {
    const {
      theme,
      prefix: prefix2
    } = config;
    const classMap = {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    };
    const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix2);
    prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
      processClassesRecursively(classGroup, classMap, classGroupId, theme);
    });
    return classMap;
  }
  function processClassesRecursively(classGroup, classPartObject, classGroupId, theme) {
    classGroup.forEach((classDefinition) => {
      if (typeof classDefinition === "string") {
        const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
        classPartObjectToEdit.classGroupId = classGroupId;
        return;
      }
      if (typeof classDefinition === "function") {
        if (isThemeGetter(classDefinition)) {
          processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
          return;
        }
        classPartObject.validators.push({
          validator: classDefinition,
          classGroupId
        });
        return;
      }
      Object.entries(classDefinition).forEach(([key2, classGroup2]) => {
        processClassesRecursively(classGroup2, getPart(classPartObject, key2), classGroupId, theme);
      });
    });
  }
  function getPart(classPartObject, path) {
    let currentClassPartObject = classPartObject;
    path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
      if (!currentClassPartObject.nextPart.has(pathPart)) {
        currentClassPartObject.nextPart.set(pathPart, {
          nextPart: /* @__PURE__ */ new Map(),
          validators: []
        });
      }
      currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
    });
    return currentClassPartObject;
  }
  function isThemeGetter(func) {
    return func.isThemeGetter;
  }
  function getPrefixedClassGroupEntries(classGroupEntries, prefix2) {
    if (!prefix2) {
      return classGroupEntries;
    }
    return classGroupEntries.map(([classGroupId, classGroup]) => {
      const prefixedClassGroup = classGroup.map((classDefinition) => {
        if (typeof classDefinition === "string") {
          return prefix2 + classDefinition;
        }
        if (typeof classDefinition === "object") {
          return Object.fromEntries(Object.entries(classDefinition).map(([key2, value]) => [prefix2 + key2, value]));
        }
        return classDefinition;
      });
      return [classGroupId, prefixedClassGroup];
    });
  }
  function createLruCache(maxCacheSize) {
    if (maxCacheSize < 1) {
      return {
        get: () => void 0,
        set: () => {
        }
      };
    }
    let cacheSize = 0;
    let cache = /* @__PURE__ */ new Map();
    let previousCache = /* @__PURE__ */ new Map();
    function update(key2, value) {
      cache.set(key2, value);
      cacheSize++;
      if (cacheSize > maxCacheSize) {
        cacheSize = 0;
        previousCache = cache;
        cache = /* @__PURE__ */ new Map();
      }
    }
    return {
      get(key2) {
        let value = cache.get(key2);
        if (value !== void 0) {
          return value;
        }
        if ((value = previousCache.get(key2)) !== void 0) {
          update(key2, value);
          return value;
        }
      },
      set(key2, value) {
        if (cache.has(key2)) {
          cache.set(key2, value);
        } else {
          update(key2, value);
        }
      }
    };
  }
  const IMPORTANT_MODIFIER = "!";
  function createSplitModifiers(config) {
    const separator2 = config.separator;
    const isSeparatorSingleCharacter = separator2.length === 1;
    const firstSeparatorCharacter = separator2[0];
    const separatorLength = separator2.length;
    return function splitModifiers(className) {
      const modifiers2 = [];
      let bracketDepth = 0;
      let modifierStart = 0;
      let postfixModifierPosition;
      for (let index = 0; index < className.length; index++) {
        let currentCharacter = className[index];
        if (bracketDepth === 0) {
          if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index, index + separatorLength) === separator2)) {
            modifiers2.push(className.slice(modifierStart, index));
            modifierStart = index + separatorLength;
            continue;
          }
          if (currentCharacter === "/") {
            postfixModifierPosition = index;
            continue;
          }
        }
        if (currentCharacter === "[") {
          bracketDepth++;
        } else if (currentCharacter === "]") {
          bracketDepth--;
        }
      }
      const baseClassNameWithImportantModifier = modifiers2.length === 0 ? className : className.substring(modifierStart);
      const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
      const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
      const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
      return {
        modifiers: modifiers2,
        hasImportantModifier,
        baseClassName,
        maybePostfixModifierPosition
      };
    };
  }
  function sortModifiers(modifiers2) {
    if (modifiers2.length <= 1) {
      return modifiers2;
    }
    const sortedModifiers = [];
    let unsortedModifiers = [];
    modifiers2.forEach((modifier) => {
      const isArbitraryVariant = modifier[0] === "[";
      if (isArbitraryVariant) {
        sortedModifiers.push(...unsortedModifiers.sort(), modifier);
        unsortedModifiers = [];
      } else {
        unsortedModifiers.push(modifier);
      }
    });
    sortedModifiers.push(...unsortedModifiers.sort());
    return sortedModifiers;
  }
  function createConfigUtils(config) {
    return {
      cache: createLruCache(config.cacheSize),
      splitModifiers: createSplitModifiers(config),
      ...createClassUtils(config)
    };
  }
  const SPLIT_CLASSES_REGEX = /\s+/;
  function mergeClassList(classList, configUtils) {
    const {
      splitModifiers,
      getClassGroupId,
      getConflictingClassGroupIds
    } = configUtils;
    const classGroupsInConflict = /* @__PURE__ */ new Set();
    return classList.trim().split(SPLIT_CLASSES_REGEX).map((originalClassName) => {
      const {
        modifiers: modifiers2,
        hasImportantModifier,
        baseClassName,
        maybePostfixModifierPosition
      } = splitModifiers(originalClassName);
      let classGroupId = getClassGroupId(maybePostfixModifierPosition ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
      let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
      if (!classGroupId) {
        if (!maybePostfixModifierPosition) {
          return {
            isTailwindClass: false,
            originalClassName
          };
        }
        classGroupId = getClassGroupId(baseClassName);
        if (!classGroupId) {
          return {
            isTailwindClass: false,
            originalClassName
          };
        }
        hasPostfixModifier = false;
      }
      const variantModifier = sortModifiers(modifiers2).join(":");
      const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
      return {
        isTailwindClass: true,
        modifierId,
        classGroupId,
        originalClassName,
        hasPostfixModifier
      };
    }).reverse().filter((parsed) => {
      if (!parsed.isTailwindClass) {
        return true;
      }
      const {
        modifierId,
        classGroupId,
        hasPostfixModifier
      } = parsed;
      const classId = modifierId + classGroupId;
      if (classGroupsInConflict.has(classId)) {
        return false;
      }
      classGroupsInConflict.add(classId);
      getConflictingClassGroupIds(classGroupId, hasPostfixModifier).forEach((group) => classGroupsInConflict.add(modifierId + group));
      return true;
    }).reverse().map((parsed) => parsed.originalClassName).join(" ");
  }
  function twJoin() {
    let index = 0;
    let argument;
    let resolvedValue;
    let string = "";
    while (index < arguments.length) {
      if (argument = arguments[index++]) {
        if (resolvedValue = toValue(argument)) {
          string && (string += " ");
          string += resolvedValue;
        }
      }
    }
    return string;
  }
  function toValue(mix) {
    if (typeof mix === "string") {
      return mix;
    }
    let resolvedValue;
    let string = "";
    for (let k2 = 0; k2 < mix.length; k2++) {
      if (mix[k2]) {
        if (resolvedValue = toValue(mix[k2])) {
          string && (string += " ");
          string += resolvedValue;
        }
      }
    }
    return string;
  }
  function createTailwindMerge(createConfigFirst, ...createConfigRest) {
    let configUtils;
    let cacheGet;
    let cacheSet;
    let functionToCall = initTailwindMerge;
    function initTailwindMerge(classList) {
      const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
      configUtils = createConfigUtils(config);
      cacheGet = configUtils.cache.get;
      cacheSet = configUtils.cache.set;
      functionToCall = tailwindMerge;
      return tailwindMerge(classList);
    }
    function tailwindMerge(classList) {
      const cachedResult2 = cacheGet(classList);
      if (cachedResult2) {
        return cachedResult2;
      }
      const result = mergeClassList(classList, configUtils);
      cacheSet(classList, result);
      return result;
    }
    return function callTailwindMerge() {
      return functionToCall(twJoin.apply(null, arguments));
    };
  }
  function fromTheme(key2) {
    const themeGetter = (theme) => theme[key2] || [];
    themeGetter.isThemeGetter = true;
    return themeGetter;
  }
  const arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
  const fractionRegex = /^\d+\/\d+$/;
  const stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
  const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
  const lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
  const shadowRegex = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
  const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
  function isLength(value) {
    return isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);
  }
  function isArbitraryLength(value) {
    return getIsArbitraryValue(value, "length", isLengthOnly);
  }
  function isNumber(value) {
    return Boolean(value) && !Number.isNaN(Number(value));
  }
  function isArbitraryNumber(value) {
    return getIsArbitraryValue(value, "number", isNumber);
  }
  function isInteger(value) {
    return Boolean(value) && Number.isInteger(Number(value));
  }
  function isPercent(value) {
    return value.endsWith("%") && isNumber(value.slice(0, -1));
  }
  function isArbitraryValue(value) {
    return arbitraryValueRegex.test(value);
  }
  function isTshirtSize(value) {
    return tshirtUnitRegex.test(value);
  }
  const sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
  function isArbitrarySize(value) {
    return getIsArbitraryValue(value, sizeLabels, isNever);
  }
  function isArbitraryPosition(value) {
    return getIsArbitraryValue(value, "position", isNever);
  }
  const imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
  function isArbitraryImage(value) {
    return getIsArbitraryValue(value, imageLabels, isImage);
  }
  function isArbitraryShadow(value) {
    return getIsArbitraryValue(value, "", isShadow);
  }
  function isAny() {
    return true;
  }
  function getIsArbitraryValue(value, label, testValue) {
    const result = arbitraryValueRegex.exec(value);
    if (result) {
      if (result[1]) {
        return typeof label === "string" ? result[1] === label : label.has(result[1]);
      }
      return testValue(result[2]);
    }
    return false;
  }
  function isLengthOnly(value) {
    return lengthUnitRegex.test(value);
  }
  function isNever() {
    return false;
  }
  function isShadow(value) {
    return shadowRegex.test(value);
  }
  function isImage(value) {
    return imageRegex.test(value);
  }
  function getDefaultConfig() {
    const colors = fromTheme("colors");
    const spacing = fromTheme("spacing");
    const blur = fromTheme("blur");
    const brightness = fromTheme("brightness");
    const borderColor = fromTheme("borderColor");
    const borderRadius = fromTheme("borderRadius");
    const borderSpacing = fromTheme("borderSpacing");
    const borderWidth = fromTheme("borderWidth");
    const contrast = fromTheme("contrast");
    const grayscale = fromTheme("grayscale");
    const hueRotate = fromTheme("hueRotate");
    const invert = fromTheme("invert");
    const gap = fromTheme("gap");
    const gradientColorStops = fromTheme("gradientColorStops");
    const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
    const inset = fromTheme("inset");
    const margin = fromTheme("margin");
    const opacity = fromTheme("opacity");
    const padding = fromTheme("padding");
    const saturate = fromTheme("saturate");
    const scale = fromTheme("scale");
    const sepia = fromTheme("sepia");
    const skew = fromTheme("skew");
    const space = fromTheme("space");
    const translate2 = fromTheme("translate");
    const getOverscroll = () => ["auto", "contain", "none"];
    const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
    const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
    const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
    const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
    const getNumberWithAutoAndArbitrary = () => ["auto", isNumber, isArbitraryValue];
    const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
    const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
    const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"];
    const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
    const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
    const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
    const getNumber = () => [isNumber, isArbitraryNumber];
    const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
    return {
      cacheSize: 500,
      separator: ":",
      theme: {
        colors: [isAny],
        spacing: [isLength, isArbitraryLength],
        blur: ["none", "", isTshirtSize, isArbitraryValue],
        brightness: getNumber(),
        borderColor: [colors],
        borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
        borderSpacing: getSpacingWithArbitrary(),
        borderWidth: getLengthWithEmptyAndArbitrary(),
        contrast: getNumber(),
        grayscale: getZeroAndEmpty(),
        hueRotate: getNumberAndArbitrary(),
        invert: getZeroAndEmpty(),
        gap: getSpacingWithArbitrary(),
        gradientColorStops: [colors],
        gradientColorStopPositions: [isPercent, isArbitraryLength],
        inset: getSpacingWithAutoAndArbitrary(),
        margin: getSpacingWithAutoAndArbitrary(),
        opacity: getNumber(),
        padding: getSpacingWithArbitrary(),
        saturate: getNumber(),
        scale: getNumber(),
        sepia: getZeroAndEmpty(),
        skew: getNumberAndArbitrary(),
        space: getSpacingWithArbitrary(),
        translate: getSpacingWithArbitrary()
      },
      classGroups: {
        // Layout
        /**
         * Aspect Ratio
         * @see https://tailwindcss.com/docs/aspect-ratio
         */
        aspect: [{
          aspect: ["auto", "square", "video", isArbitraryValue]
        }],
        /**
         * Container
         * @see https://tailwindcss.com/docs/container
         */
        container: ["container"],
        /**
         * Columns
         * @see https://tailwindcss.com/docs/columns
         */
        columns: [{
          columns: [isTshirtSize]
        }],
        /**
         * Break After
         * @see https://tailwindcss.com/docs/break-after
         */
        "break-after": [{
          "break-after": getBreaks()
        }],
        /**
         * Break Before
         * @see https://tailwindcss.com/docs/break-before
         */
        "break-before": [{
          "break-before": getBreaks()
        }],
        /**
         * Break Inside
         * @see https://tailwindcss.com/docs/break-inside
         */
        "break-inside": [{
          "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
        }],
        /**
         * Box Decoration Break
         * @see https://tailwindcss.com/docs/box-decoration-break
         */
        "box-decoration": [{
          "box-decoration": ["slice", "clone"]
        }],
        /**
         * Box Sizing
         * @see https://tailwindcss.com/docs/box-sizing
         */
        box: [{
          box: ["border", "content"]
        }],
        /**
         * Display
         * @see https://tailwindcss.com/docs/display
         */
        display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
        /**
         * Floats
         * @see https://tailwindcss.com/docs/float
         */
        float: [{
          float: ["right", "left", "none"]
        }],
        /**
         * Clear
         * @see https://tailwindcss.com/docs/clear
         */
        clear: [{
          clear: ["left", "right", "both", "none"]
        }],
        /**
         * Isolation
         * @see https://tailwindcss.com/docs/isolation
         */
        isolation: ["isolate", "isolation-auto"],
        /**
         * Object Fit
         * @see https://tailwindcss.com/docs/object-fit
         */
        "object-fit": [{
          object: ["contain", "cover", "fill", "none", "scale-down"]
        }],
        /**
         * Object Position
         * @see https://tailwindcss.com/docs/object-position
         */
        "object-position": [{
          object: [...getPositions(), isArbitraryValue]
        }],
        /**
         * Overflow
         * @see https://tailwindcss.com/docs/overflow
         */
        overflow: [{
          overflow: getOverflow()
        }],
        /**
         * Overflow X
         * @see https://tailwindcss.com/docs/overflow
         */
        "overflow-x": [{
          "overflow-x": getOverflow()
        }],
        /**
         * Overflow Y
         * @see https://tailwindcss.com/docs/overflow
         */
        "overflow-y": [{
          "overflow-y": getOverflow()
        }],
        /**
         * Overscroll Behavior
         * @see https://tailwindcss.com/docs/overscroll-behavior
         */
        overscroll: [{
          overscroll: getOverscroll()
        }],
        /**
         * Overscroll Behavior X
         * @see https://tailwindcss.com/docs/overscroll-behavior
         */
        "overscroll-x": [{
          "overscroll-x": getOverscroll()
        }],
        /**
         * Overscroll Behavior Y
         * @see https://tailwindcss.com/docs/overscroll-behavior
         */
        "overscroll-y": [{
          "overscroll-y": getOverscroll()
        }],
        /**
         * Position
         * @see https://tailwindcss.com/docs/position
         */
        position: ["static", "fixed", "absolute", "relative", "sticky"],
        /**
         * Top / Right / Bottom / Left
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        inset: [{
          inset: [inset]
        }],
        /**
         * Right / Left
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        "inset-x": [{
          "inset-x": [inset]
        }],
        /**
         * Top / Bottom
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        "inset-y": [{
          "inset-y": [inset]
        }],
        /**
         * Start
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        start: [{
          start: [inset]
        }],
        /**
         * End
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        end: [{
          end: [inset]
        }],
        /**
         * Top
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        top: [{
          top: [inset]
        }],
        /**
         * Right
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        right: [{
          right: [inset]
        }],
        /**
         * Bottom
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        bottom: [{
          bottom: [inset]
        }],
        /**
         * Left
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        left: [{
          left: [inset]
        }],
        /**
         * Visibility
         * @see https://tailwindcss.com/docs/visibility
         */
        visibility: ["visible", "invisible", "collapse"],
        /**
         * Z-Index
         * @see https://tailwindcss.com/docs/z-index
         */
        z: [{
          z: ["auto", isInteger, isArbitraryValue]
        }],
        // Flexbox and Grid
        /**
         * Flex Basis
         * @see https://tailwindcss.com/docs/flex-basis
         */
        basis: [{
          basis: getSpacingWithAutoAndArbitrary()
        }],
        /**
         * Flex Direction
         * @see https://tailwindcss.com/docs/flex-direction
         */
        "flex-direction": [{
          flex: ["row", "row-reverse", "col", "col-reverse"]
        }],
        /**
         * Flex Wrap
         * @see https://tailwindcss.com/docs/flex-wrap
         */
        "flex-wrap": [{
          flex: ["wrap", "wrap-reverse", "nowrap"]
        }],
        /**
         * Flex
         * @see https://tailwindcss.com/docs/flex
         */
        flex: [{
          flex: ["1", "auto", "initial", "none", isArbitraryValue]
        }],
        /**
         * Flex Grow
         * @see https://tailwindcss.com/docs/flex-grow
         */
        grow: [{
          grow: getZeroAndEmpty()
        }],
        /**
         * Flex Shrink
         * @see https://tailwindcss.com/docs/flex-shrink
         */
        shrink: [{
          shrink: getZeroAndEmpty()
        }],
        /**
         * Order
         * @see https://tailwindcss.com/docs/order
         */
        order: [{
          order: ["first", "last", "none", isInteger, isArbitraryValue]
        }],
        /**
         * Grid Template Columns
         * @see https://tailwindcss.com/docs/grid-template-columns
         */
        "grid-cols": [{
          "grid-cols": [isAny]
        }],
        /**
         * Grid Column Start / End
         * @see https://tailwindcss.com/docs/grid-column
         */
        "col-start-end": [{
          col: ["auto", {
            span: ["full", isInteger, isArbitraryValue]
          }, isArbitraryValue]
        }],
        /**
         * Grid Column Start
         * @see https://tailwindcss.com/docs/grid-column
         */
        "col-start": [{
          "col-start": getNumberWithAutoAndArbitrary()
        }],
        /**
         * Grid Column End
         * @see https://tailwindcss.com/docs/grid-column
         */
        "col-end": [{
          "col-end": getNumberWithAutoAndArbitrary()
        }],
        /**
         * Grid Template Rows
         * @see https://tailwindcss.com/docs/grid-template-rows
         */
        "grid-rows": [{
          "grid-rows": [isAny]
        }],
        /**
         * Grid Row Start / End
         * @see https://tailwindcss.com/docs/grid-row
         */
        "row-start-end": [{
          row: ["auto", {
            span: [isInteger, isArbitraryValue]
          }, isArbitraryValue]
        }],
        /**
         * Grid Row Start
         * @see https://tailwindcss.com/docs/grid-row
         */
        "row-start": [{
          "row-start": getNumberWithAutoAndArbitrary()
        }],
        /**
         * Grid Row End
         * @see https://tailwindcss.com/docs/grid-row
         */
        "row-end": [{
          "row-end": getNumberWithAutoAndArbitrary()
        }],
        /**
         * Grid Auto Flow
         * @see https://tailwindcss.com/docs/grid-auto-flow
         */
        "grid-flow": [{
          "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
        }],
        /**
         * Grid Auto Columns
         * @see https://tailwindcss.com/docs/grid-auto-columns
         */
        "auto-cols": [{
          "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
        }],
        /**
         * Grid Auto Rows
         * @see https://tailwindcss.com/docs/grid-auto-rows
         */
        "auto-rows": [{
          "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
        }],
        /**
         * Gap
         * @see https://tailwindcss.com/docs/gap
         */
        gap: [{
          gap: [gap]
        }],
        /**
         * Gap X
         * @see https://tailwindcss.com/docs/gap
         */
        "gap-x": [{
          "gap-x": [gap]
        }],
        /**
         * Gap Y
         * @see https://tailwindcss.com/docs/gap
         */
        "gap-y": [{
          "gap-y": [gap]
        }],
        /**
         * Justify Content
         * @see https://tailwindcss.com/docs/justify-content
         */
        "justify-content": [{
          justify: ["normal", ...getAlign()]
        }],
        /**
         * Justify Items
         * @see https://tailwindcss.com/docs/justify-items
         */
        "justify-items": [{
          "justify-items": ["start", "end", "center", "stretch"]
        }],
        /**
         * Justify Self
         * @see https://tailwindcss.com/docs/justify-self
         */
        "justify-self": [{
          "justify-self": ["auto", "start", "end", "center", "stretch"]
        }],
        /**
         * Align Content
         * @see https://tailwindcss.com/docs/align-content
         */
        "align-content": [{
          content: ["normal", ...getAlign(), "baseline"]
        }],
        /**
         * Align Items
         * @see https://tailwindcss.com/docs/align-items
         */
        "align-items": [{
          items: ["start", "end", "center", "baseline", "stretch"]
        }],
        /**
         * Align Self
         * @see https://tailwindcss.com/docs/align-self
         */
        "align-self": [{
          self: ["auto", "start", "end", "center", "stretch", "baseline"]
        }],
        /**
         * Place Content
         * @see https://tailwindcss.com/docs/place-content
         */
        "place-content": [{
          "place-content": [...getAlign(), "baseline"]
        }],
        /**
         * Place Items
         * @see https://tailwindcss.com/docs/place-items
         */
        "place-items": [{
          "place-items": ["start", "end", "center", "baseline", "stretch"]
        }],
        /**
         * Place Self
         * @see https://tailwindcss.com/docs/place-self
         */
        "place-self": [{
          "place-self": ["auto", "start", "end", "center", "stretch"]
        }],
        // Spacing
        /**
         * Padding
         * @see https://tailwindcss.com/docs/padding
         */
        p: [{
          p: [padding]
        }],
        /**
         * Padding X
         * @see https://tailwindcss.com/docs/padding
         */
        px: [{
          px: [padding]
        }],
        /**
         * Padding Y
         * @see https://tailwindcss.com/docs/padding
         */
        py: [{
          py: [padding]
        }],
        /**
         * Padding Start
         * @see https://tailwindcss.com/docs/padding
         */
        ps: [{
          ps: [padding]
        }],
        /**
         * Padding End
         * @see https://tailwindcss.com/docs/padding
         */
        pe: [{
          pe: [padding]
        }],
        /**
         * Padding Top
         * @see https://tailwindcss.com/docs/padding
         */
        pt: [{
          pt: [padding]
        }],
        /**
         * Padding Right
         * @see https://tailwindcss.com/docs/padding
         */
        pr: [{
          pr: [padding]
        }],
        /**
         * Padding Bottom
         * @see https://tailwindcss.com/docs/padding
         */
        pb: [{
          pb: [padding]
        }],
        /**
         * Padding Left
         * @see https://tailwindcss.com/docs/padding
         */
        pl: [{
          pl: [padding]
        }],
        /**
         * Margin
         * @see https://tailwindcss.com/docs/margin
         */
        m: [{
          m: [margin]
        }],
        /**
         * Margin X
         * @see https://tailwindcss.com/docs/margin
         */
        mx: [{
          mx: [margin]
        }],
        /**
         * Margin Y
         * @see https://tailwindcss.com/docs/margin
         */
        my: [{
          my: [margin]
        }],
        /**
         * Margin Start
         * @see https://tailwindcss.com/docs/margin
         */
        ms: [{
          ms: [margin]
        }],
        /**
         * Margin End
         * @see https://tailwindcss.com/docs/margin
         */
        me: [{
          me: [margin]
        }],
        /**
         * Margin Top
         * @see https://tailwindcss.com/docs/margin
         */
        mt: [{
          mt: [margin]
        }],
        /**
         * Margin Right
         * @see https://tailwindcss.com/docs/margin
         */
        mr: [{
          mr: [margin]
        }],
        /**
         * Margin Bottom
         * @see https://tailwindcss.com/docs/margin
         */
        mb: [{
          mb: [margin]
        }],
        /**
         * Margin Left
         * @see https://tailwindcss.com/docs/margin
         */
        ml: [{
          ml: [margin]
        }],
        /**
         * Space Between X
         * @see https://tailwindcss.com/docs/space
         */
        "space-x": [{
          "space-x": [space]
        }],
        /**
         * Space Between X Reverse
         * @see https://tailwindcss.com/docs/space
         */
        "space-x-reverse": ["space-x-reverse"],
        /**
         * Space Between Y
         * @see https://tailwindcss.com/docs/space
         */
        "space-y": [{
          "space-y": [space]
        }],
        /**
         * Space Between Y Reverse
         * @see https://tailwindcss.com/docs/space
         */
        "space-y-reverse": ["space-y-reverse"],
        // Sizing
        /**
         * Width
         * @see https://tailwindcss.com/docs/width
         */
        w: [{
          w: ["auto", "min", "max", "fit", isArbitraryValue, spacing]
        }],
        /**
         * Min-Width
         * @see https://tailwindcss.com/docs/min-width
         */
        "min-w": [{
          "min-w": ["min", "max", "fit", isArbitraryValue, isLength]
        }],
        /**
         * Max-Width
         * @see https://tailwindcss.com/docs/max-width
         */
        "max-w": [{
          "max-w": ["0", "none", "full", "min", "max", "fit", "prose", {
            screen: [isTshirtSize]
          }, isTshirtSize, isArbitraryValue]
        }],
        /**
         * Height
         * @see https://tailwindcss.com/docs/height
         */
        h: [{
          h: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
        }],
        /**
         * Min-Height
         * @see https://tailwindcss.com/docs/min-height
         */
        "min-h": [{
          "min-h": ["min", "max", "fit", isLength, isArbitraryValue]
        }],
        /**
         * Max-Height
         * @see https://tailwindcss.com/docs/max-height
         */
        "max-h": [{
          "max-h": [isArbitraryValue, spacing, "min", "max", "fit"]
        }],
        // Typography
        /**
         * Font Size
         * @see https://tailwindcss.com/docs/font-size
         */
        "font-size": [{
          text: ["base", isTshirtSize, isArbitraryLength]
        }],
        /**
         * Font Smoothing
         * @see https://tailwindcss.com/docs/font-smoothing
         */
        "font-smoothing": ["antialiased", "subpixel-antialiased"],
        /**
         * Font Style
         * @see https://tailwindcss.com/docs/font-style
         */
        "font-style": ["italic", "not-italic"],
        /**
         * Font Weight
         * @see https://tailwindcss.com/docs/font-weight
         */
        "font-weight": [{
          font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
        }],
        /**
         * Font Family
         * @see https://tailwindcss.com/docs/font-family
         */
        "font-family": [{
          font: [isAny]
        }],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-normal": ["normal-nums"],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-ordinal": ["ordinal"],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-slashed-zero": ["slashed-zero"],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-figure": ["lining-nums", "oldstyle-nums"],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-spacing": ["proportional-nums", "tabular-nums"],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
        /**
         * Letter Spacing
         * @see https://tailwindcss.com/docs/letter-spacing
         */
        tracking: [{
          tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
        }],
        /**
         * Line Clamp
         * @see https://tailwindcss.com/docs/line-clamp
         */
        "line-clamp": [{
          "line-clamp": ["none", isNumber, isArbitraryNumber]
        }],
        /**
         * Line Height
         * @see https://tailwindcss.com/docs/line-height
         */
        leading: [{
          leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
        }],
        /**
         * List Style Image
         * @see https://tailwindcss.com/docs/list-style-image
         */
        "list-image": [{
          "list-image": ["none", isArbitraryValue]
        }],
        /**
         * List Style Type
         * @see https://tailwindcss.com/docs/list-style-type
         */
        "list-style-type": [{
          list: ["none", "disc", "decimal", isArbitraryValue]
        }],
        /**
         * List Style Position
         * @see https://tailwindcss.com/docs/list-style-position
         */
        "list-style-position": [{
          list: ["inside", "outside"]
        }],
        /**
         * Placeholder Color
         * @deprecated since Tailwind CSS v3.0.0
         * @see https://tailwindcss.com/docs/placeholder-color
         */
        "placeholder-color": [{
          placeholder: [colors]
        }],
        /**
         * Placeholder Opacity
         * @see https://tailwindcss.com/docs/placeholder-opacity
         */
        "placeholder-opacity": [{
          "placeholder-opacity": [opacity]
        }],
        /**
         * Text Alignment
         * @see https://tailwindcss.com/docs/text-align
         */
        "text-alignment": [{
          text: ["left", "center", "right", "justify", "start", "end"]
        }],
        /**
         * Text Color
         * @see https://tailwindcss.com/docs/text-color
         */
        "text-color": [{
          text: [colors]
        }],
        /**
         * Text Opacity
         * @see https://tailwindcss.com/docs/text-opacity
         */
        "text-opacity": [{
          "text-opacity": [opacity]
        }],
        /**
         * Text Decoration
         * @see https://tailwindcss.com/docs/text-decoration
         */
        "text-decoration": ["underline", "overline", "line-through", "no-underline"],
        /**
         * Text Decoration Style
         * @see https://tailwindcss.com/docs/text-decoration-style
         */
        "text-decoration-style": [{
          decoration: [...getLineStyles(), "wavy"]
        }],
        /**
         * Text Decoration Thickness
         * @see https://tailwindcss.com/docs/text-decoration-thickness
         */
        "text-decoration-thickness": [{
          decoration: ["auto", "from-font", isLength, isArbitraryLength]
        }],
        /**
         * Text Underline Offset
         * @see https://tailwindcss.com/docs/text-underline-offset
         */
        "underline-offset": [{
          "underline-offset": ["auto", isLength, isArbitraryValue]
        }],
        /**
         * Text Decoration Color
         * @see https://tailwindcss.com/docs/text-decoration-color
         */
        "text-decoration-color": [{
          decoration: [colors]
        }],
        /**
         * Text Transform
         * @see https://tailwindcss.com/docs/text-transform
         */
        "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
        /**
         * Text Overflow
         * @see https://tailwindcss.com/docs/text-overflow
         */
        "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
        /**
         * Text Indent
         * @see https://tailwindcss.com/docs/text-indent
         */
        indent: [{
          indent: getSpacingWithArbitrary()
        }],
        /**
         * Vertical Alignment
         * @see https://tailwindcss.com/docs/vertical-align
         */
        "vertical-align": [{
          align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
        }],
        /**
         * Whitespace
         * @see https://tailwindcss.com/docs/whitespace
         */
        whitespace: [{
          whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
        }],
        /**
         * Word Break
         * @see https://tailwindcss.com/docs/word-break
         */
        break: [{
          break: ["normal", "words", "all", "keep"]
        }],
        /**
         * Hyphens
         * @see https://tailwindcss.com/docs/hyphens
         */
        hyphens: [{
          hyphens: ["none", "manual", "auto"]
        }],
        /**
         * Content
         * @see https://tailwindcss.com/docs/content
         */
        content: [{
          content: ["none", isArbitraryValue]
        }],
        // Backgrounds
        /**
         * Background Attachment
         * @see https://tailwindcss.com/docs/background-attachment
         */
        "bg-attachment": [{
          bg: ["fixed", "local", "scroll"]
        }],
        /**
         * Background Clip
         * @see https://tailwindcss.com/docs/background-clip
         */
        "bg-clip": [{
          "bg-clip": ["border", "padding", "content", "text"]
        }],
        /**
         * Background Opacity
         * @deprecated since Tailwind CSS v3.0.0
         * @see https://tailwindcss.com/docs/background-opacity
         */
        "bg-opacity": [{
          "bg-opacity": [opacity]
        }],
        /**
         * Background Origin
         * @see https://tailwindcss.com/docs/background-origin
         */
        "bg-origin": [{
          "bg-origin": ["border", "padding", "content"]
        }],
        /**
         * Background Position
         * @see https://tailwindcss.com/docs/background-position
         */
        "bg-position": [{
          bg: [...getPositions(), isArbitraryPosition]
        }],
        /**
         * Background Repeat
         * @see https://tailwindcss.com/docs/background-repeat
         */
        "bg-repeat": [{
          bg: ["no-repeat", {
            repeat: ["", "x", "y", "round", "space"]
          }]
        }],
        /**
         * Background Size
         * @see https://tailwindcss.com/docs/background-size
         */
        "bg-size": [{
          bg: ["auto", "cover", "contain", isArbitrarySize]
        }],
        /**
         * Background Image
         * @see https://tailwindcss.com/docs/background-image
         */
        "bg-image": [{
          bg: ["none", {
            "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, isArbitraryImage]
        }],
        /**
         * Background Color
         * @see https://tailwindcss.com/docs/background-color
         */
        "bg-color": [{
          bg: [colors]
        }],
        /**
         * Gradient Color Stops From Position
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-from-pos": [{
          from: [gradientColorStopPositions]
        }],
        /**
         * Gradient Color Stops Via Position
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-via-pos": [{
          via: [gradientColorStopPositions]
        }],
        /**
         * Gradient Color Stops To Position
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-to-pos": [{
          to: [gradientColorStopPositions]
        }],
        /**
         * Gradient Color Stops From
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-from": [{
          from: [gradientColorStops]
        }],
        /**
         * Gradient Color Stops Via
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-via": [{
          via: [gradientColorStops]
        }],
        /**
         * Gradient Color Stops To
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-to": [{
          to: [gradientColorStops]
        }],
        // Borders
        /**
         * Border Radius
         * @see https://tailwindcss.com/docs/border-radius
         */
        rounded: [{
          rounded: [borderRadius]
        }],
        /**
         * Border Radius Start
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-s": [{
          "rounded-s": [borderRadius]
        }],
        /**
         * Border Radius End
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-e": [{
          "rounded-e": [borderRadius]
        }],
        /**
         * Border Radius Top
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-t": [{
          "rounded-t": [borderRadius]
        }],
        /**
         * Border Radius Right
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-r": [{
          "rounded-r": [borderRadius]
        }],
        /**
         * Border Radius Bottom
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-b": [{
          "rounded-b": [borderRadius]
        }],
        /**
         * Border Radius Left
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-l": [{
          "rounded-l": [borderRadius]
        }],
        /**
         * Border Radius Start Start
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-ss": [{
          "rounded-ss": [borderRadius]
        }],
        /**
         * Border Radius Start End
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-se": [{
          "rounded-se": [borderRadius]
        }],
        /**
         * Border Radius End End
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-ee": [{
          "rounded-ee": [borderRadius]
        }],
        /**
         * Border Radius End Start
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-es": [{
          "rounded-es": [borderRadius]
        }],
        /**
         * Border Radius Top Left
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-tl": [{
          "rounded-tl": [borderRadius]
        }],
        /**
         * Border Radius Top Right
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-tr": [{
          "rounded-tr": [borderRadius]
        }],
        /**
         * Border Radius Bottom Right
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-br": [{
          "rounded-br": [borderRadius]
        }],
        /**
         * Border Radius Bottom Left
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-bl": [{
          "rounded-bl": [borderRadius]
        }],
        /**
         * Border Width
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w": [{
          border: [borderWidth]
        }],
        /**
         * Border Width X
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-x": [{
          "border-x": [borderWidth]
        }],
        /**
         * Border Width Y
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-y": [{
          "border-y": [borderWidth]
        }],
        /**
         * Border Width Start
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-s": [{
          "border-s": [borderWidth]
        }],
        /**
         * Border Width End
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-e": [{
          "border-e": [borderWidth]
        }],
        /**
         * Border Width Top
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-t": [{
          "border-t": [borderWidth]
        }],
        /**
         * Border Width Right
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-r": [{
          "border-r": [borderWidth]
        }],
        /**
         * Border Width Bottom
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-b": [{
          "border-b": [borderWidth]
        }],
        /**
         * Border Width Left
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-l": [{
          "border-l": [borderWidth]
        }],
        /**
         * Border Opacity
         * @see https://tailwindcss.com/docs/border-opacity
         */
        "border-opacity": [{
          "border-opacity": [opacity]
        }],
        /**
         * Border Style
         * @see https://tailwindcss.com/docs/border-style
         */
        "border-style": [{
          border: [...getLineStyles(), "hidden"]
        }],
        /**
         * Divide Width X
         * @see https://tailwindcss.com/docs/divide-width
         */
        "divide-x": [{
          "divide-x": [borderWidth]
        }],
        /**
         * Divide Width X Reverse
         * @see https://tailwindcss.com/docs/divide-width
         */
        "divide-x-reverse": ["divide-x-reverse"],
        /**
         * Divide Width Y
         * @see https://tailwindcss.com/docs/divide-width
         */
        "divide-y": [{
          "divide-y": [borderWidth]
        }],
        /**
         * Divide Width Y Reverse
         * @see https://tailwindcss.com/docs/divide-width
         */
        "divide-y-reverse": ["divide-y-reverse"],
        /**
         * Divide Opacity
         * @see https://tailwindcss.com/docs/divide-opacity
         */
        "divide-opacity": [{
          "divide-opacity": [opacity]
        }],
        /**
         * Divide Style
         * @see https://tailwindcss.com/docs/divide-style
         */
        "divide-style": [{
          divide: getLineStyles()
        }],
        /**
         * Border Color
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color": [{
          border: [borderColor]
        }],
        /**
         * Border Color X
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-x": [{
          "border-x": [borderColor]
        }],
        /**
         * Border Color Y
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-y": [{
          "border-y": [borderColor]
        }],
        /**
         * Border Color Top
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-t": [{
          "border-t": [borderColor]
        }],
        /**
         * Border Color Right
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-r": [{
          "border-r": [borderColor]
        }],
        /**
         * Border Color Bottom
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-b": [{
          "border-b": [borderColor]
        }],
        /**
         * Border Color Left
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-l": [{
          "border-l": [borderColor]
        }],
        /**
         * Divide Color
         * @see https://tailwindcss.com/docs/divide-color
         */
        "divide-color": [{
          divide: [borderColor]
        }],
        /**
         * Outline Style
         * @see https://tailwindcss.com/docs/outline-style
         */
        "outline-style": [{
          outline: ["", ...getLineStyles()]
        }],
        /**
         * Outline Offset
         * @see https://tailwindcss.com/docs/outline-offset
         */
        "outline-offset": [{
          "outline-offset": [isLength, isArbitraryValue]
        }],
        /**
         * Outline Width
         * @see https://tailwindcss.com/docs/outline-width
         */
        "outline-w": [{
          outline: [isLength, isArbitraryLength]
        }],
        /**
         * Outline Color
         * @see https://tailwindcss.com/docs/outline-color
         */
        "outline-color": [{
          outline: [colors]
        }],
        /**
         * Ring Width
         * @see https://tailwindcss.com/docs/ring-width
         */
        "ring-w": [{
          ring: getLengthWithEmptyAndArbitrary()
        }],
        /**
         * Ring Width Inset
         * @see https://tailwindcss.com/docs/ring-width
         */
        "ring-w-inset": ["ring-inset"],
        /**
         * Ring Color
         * @see https://tailwindcss.com/docs/ring-color
         */
        "ring-color": [{
          ring: [colors]
        }],
        /**
         * Ring Opacity
         * @see https://tailwindcss.com/docs/ring-opacity
         */
        "ring-opacity": [{
          "ring-opacity": [opacity]
        }],
        /**
         * Ring Offset Width
         * @see https://tailwindcss.com/docs/ring-offset-width
         */
        "ring-offset-w": [{
          "ring-offset": [isLength, isArbitraryLength]
        }],
        /**
         * Ring Offset Color
         * @see https://tailwindcss.com/docs/ring-offset-color
         */
        "ring-offset-color": [{
          "ring-offset": [colors]
        }],
        // Effects
        /**
         * Box Shadow
         * @see https://tailwindcss.com/docs/box-shadow
         */
        shadow: [{
          shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
        }],
        /**
         * Box Shadow Color
         * @see https://tailwindcss.com/docs/box-shadow-color
         */
        "shadow-color": [{
          shadow: [isAny]
        }],
        /**
         * Opacity
         * @see https://tailwindcss.com/docs/opacity
         */
        opacity: [{
          opacity: [opacity]
        }],
        /**
         * Mix Blend Mode
         * @see https://tailwindcss.com/docs/mix-blend-mode
         */
        "mix-blend": [{
          "mix-blend": getBlendModes()
        }],
        /**
         * Background Blend Mode
         * @see https://tailwindcss.com/docs/background-blend-mode
         */
        "bg-blend": [{
          "bg-blend": getBlendModes()
        }],
        // Filters
        /**
         * Filter
         * @deprecated since Tailwind CSS v3.0.0
         * @see https://tailwindcss.com/docs/filter
         */
        filter: [{
          filter: ["", "none"]
        }],
        /**
         * Blur
         * @see https://tailwindcss.com/docs/blur
         */
        blur: [{
          blur: [blur]
        }],
        /**
         * Brightness
         * @see https://tailwindcss.com/docs/brightness
         */
        brightness: [{
          brightness: [brightness]
        }],
        /**
         * Contrast
         * @see https://tailwindcss.com/docs/contrast
         */
        contrast: [{
          contrast: [contrast]
        }],
        /**
         * Drop Shadow
         * @see https://tailwindcss.com/docs/drop-shadow
         */
        "drop-shadow": [{
          "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
        }],
        /**
         * Grayscale
         * @see https://tailwindcss.com/docs/grayscale
         */
        grayscale: [{
          grayscale: [grayscale]
        }],
        /**
         * Hue Rotate
         * @see https://tailwindcss.com/docs/hue-rotate
         */
        "hue-rotate": [{
          "hue-rotate": [hueRotate]
        }],
        /**
         * Invert
         * @see https://tailwindcss.com/docs/invert
         */
        invert: [{
          invert: [invert]
        }],
        /**
         * Saturate
         * @see https://tailwindcss.com/docs/saturate
         */
        saturate: [{
          saturate: [saturate]
        }],
        /**
         * Sepia
         * @see https://tailwindcss.com/docs/sepia
         */
        sepia: [{
          sepia: [sepia]
        }],
        /**
         * Backdrop Filter
         * @deprecated since Tailwind CSS v3.0.0
         * @see https://tailwindcss.com/docs/backdrop-filter
         */
        "backdrop-filter": [{
          "backdrop-filter": ["", "none"]
        }],
        /**
         * Backdrop Blur
         * @see https://tailwindcss.com/docs/backdrop-blur
         */
        "backdrop-blur": [{
          "backdrop-blur": [blur]
        }],
        /**
         * Backdrop Brightness
         * @see https://tailwindcss.com/docs/backdrop-brightness
         */
        "backdrop-brightness": [{
          "backdrop-brightness": [brightness]
        }],
        /**
         * Backdrop Contrast
         * @see https://tailwindcss.com/docs/backdrop-contrast
         */
        "backdrop-contrast": [{
          "backdrop-contrast": [contrast]
        }],
        /**
         * Backdrop Grayscale
         * @see https://tailwindcss.com/docs/backdrop-grayscale
         */
        "backdrop-grayscale": [{
          "backdrop-grayscale": [grayscale]
        }],
        /**
         * Backdrop Hue Rotate
         * @see https://tailwindcss.com/docs/backdrop-hue-rotate
         */
        "backdrop-hue-rotate": [{
          "backdrop-hue-rotate": [hueRotate]
        }],
        /**
         * Backdrop Invert
         * @see https://tailwindcss.com/docs/backdrop-invert
         */
        "backdrop-invert": [{
          "backdrop-invert": [invert]
        }],
        /**
         * Backdrop Opacity
         * @see https://tailwindcss.com/docs/backdrop-opacity
         */
        "backdrop-opacity": [{
          "backdrop-opacity": [opacity]
        }],
        /**
         * Backdrop Saturate
         * @see https://tailwindcss.com/docs/backdrop-saturate
         */
        "backdrop-saturate": [{
          "backdrop-saturate": [saturate]
        }],
        /**
         * Backdrop Sepia
         * @see https://tailwindcss.com/docs/backdrop-sepia
         */
        "backdrop-sepia": [{
          "backdrop-sepia": [sepia]
        }],
        // Tables
        /**
         * Border Collapse
         * @see https://tailwindcss.com/docs/border-collapse
         */
        "border-collapse": [{
          border: ["collapse", "separate"]
        }],
        /**
         * Border Spacing
         * @see https://tailwindcss.com/docs/border-spacing
         */
        "border-spacing": [{
          "border-spacing": [borderSpacing]
        }],
        /**
         * Border Spacing X
         * @see https://tailwindcss.com/docs/border-spacing
         */
        "border-spacing-x": [{
          "border-spacing-x": [borderSpacing]
        }],
        /**
         * Border Spacing Y
         * @see https://tailwindcss.com/docs/border-spacing
         */
        "border-spacing-y": [{
          "border-spacing-y": [borderSpacing]
        }],
        /**
         * Table Layout
         * @see https://tailwindcss.com/docs/table-layout
         */
        "table-layout": [{
          table: ["auto", "fixed"]
        }],
        /**
         * Caption Side
         * @see https://tailwindcss.com/docs/caption-side
         */
        caption: [{
          caption: ["top", "bottom"]
        }],
        // Transitions and Animation
        /**
         * Tranisition Property
         * @see https://tailwindcss.com/docs/transition-property
         */
        transition: [{
          transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
        }],
        /**
         * Transition Duration
         * @see https://tailwindcss.com/docs/transition-duration
         */
        duration: [{
          duration: getNumberAndArbitrary()
        }],
        /**
         * Transition Timing Function
         * @see https://tailwindcss.com/docs/transition-timing-function
         */
        ease: [{
          ease: ["linear", "in", "out", "in-out", isArbitraryValue]
        }],
        /**
         * Transition Delay
         * @see https://tailwindcss.com/docs/transition-delay
         */
        delay: [{
          delay: getNumberAndArbitrary()
        }],
        /**
         * Animation
         * @see https://tailwindcss.com/docs/animation
         */
        animate: [{
          animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
        }],
        // Transforms
        /**
         * Transform
         * @see https://tailwindcss.com/docs/transform
         */
        transform: [{
          transform: ["", "gpu", "none"]
        }],
        /**
         * Scale
         * @see https://tailwindcss.com/docs/scale
         */
        scale: [{
          scale: [scale]
        }],
        /**
         * Scale X
         * @see https://tailwindcss.com/docs/scale
         */
        "scale-x": [{
          "scale-x": [scale]
        }],
        /**
         * Scale Y
         * @see https://tailwindcss.com/docs/scale
         */
        "scale-y": [{
          "scale-y": [scale]
        }],
        /**
         * Rotate
         * @see https://tailwindcss.com/docs/rotate
         */
        rotate: [{
          rotate: [isInteger, isArbitraryValue]
        }],
        /**
         * Translate X
         * @see https://tailwindcss.com/docs/translate
         */
        "translate-x": [{
          "translate-x": [translate2]
        }],
        /**
         * Translate Y
         * @see https://tailwindcss.com/docs/translate
         */
        "translate-y": [{
          "translate-y": [translate2]
        }],
        /**
         * Skew X
         * @see https://tailwindcss.com/docs/skew
         */
        "skew-x": [{
          "skew-x": [skew]
        }],
        /**
         * Skew Y
         * @see https://tailwindcss.com/docs/skew
         */
        "skew-y": [{
          "skew-y": [skew]
        }],
        /**
         * Transform Origin
         * @see https://tailwindcss.com/docs/transform-origin
         */
        "transform-origin": [{
          origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
        }],
        // Interactivity
        /**
         * Accent Color
         * @see https://tailwindcss.com/docs/accent-color
         */
        accent: [{
          accent: ["auto", colors]
        }],
        /**
         * Appearance
         * @see https://tailwindcss.com/docs/appearance
         */
        appearance: ["appearance-none"],
        /**
         * Cursor
         * @see https://tailwindcss.com/docs/cursor
         */
        cursor: [{
          cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
        }],
        /**
         * Caret Color
         * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
         */
        "caret-color": [{
          caret: [colors]
        }],
        /**
         * Pointer Events
         * @see https://tailwindcss.com/docs/pointer-events
         */
        "pointer-events": [{
          "pointer-events": ["none", "auto"]
        }],
        /**
         * Resize
         * @see https://tailwindcss.com/docs/resize
         */
        resize: [{
          resize: ["none", "y", "x", ""]
        }],
        /**
         * Scroll Behavior
         * @see https://tailwindcss.com/docs/scroll-behavior
         */
        "scroll-behavior": [{
          scroll: ["auto", "smooth"]
        }],
        /**
         * Scroll Margin
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-m": [{
          "scroll-m": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin X
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-mx": [{
          "scroll-mx": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Y
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-my": [{
          "scroll-my": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Start
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-ms": [{
          "scroll-ms": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin End
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-me": [{
          "scroll-me": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Top
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-mt": [{
          "scroll-mt": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Right
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-mr": [{
          "scroll-mr": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Bottom
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-mb": [{
          "scroll-mb": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Left
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-ml": [{
          "scroll-ml": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-p": [{
          "scroll-p": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding X
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-px": [{
          "scroll-px": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Y
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-py": [{
          "scroll-py": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Start
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-ps": [{
          "scroll-ps": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding End
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-pe": [{
          "scroll-pe": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Top
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-pt": [{
          "scroll-pt": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Right
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-pr": [{
          "scroll-pr": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Bottom
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-pb": [{
          "scroll-pb": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Left
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-pl": [{
          "scroll-pl": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Snap Align
         * @see https://tailwindcss.com/docs/scroll-snap-align
         */
        "snap-align": [{
          snap: ["start", "end", "center", "align-none"]
        }],
        /**
         * Scroll Snap Stop
         * @see https://tailwindcss.com/docs/scroll-snap-stop
         */
        "snap-stop": [{
          snap: ["normal", "always"]
        }],
        /**
         * Scroll Snap Type
         * @see https://tailwindcss.com/docs/scroll-snap-type
         */
        "snap-type": [{
          snap: ["none", "x", "y", "both"]
        }],
        /**
         * Scroll Snap Type Strictness
         * @see https://tailwindcss.com/docs/scroll-snap-type
         */
        "snap-strictness": [{
          snap: ["mandatory", "proximity"]
        }],
        /**
         * Touch Action
         * @see https://tailwindcss.com/docs/touch-action
         */
        touch: [{
          touch: ["auto", "none", "manipulation"]
        }],
        /**
         * Touch Action X
         * @see https://tailwindcss.com/docs/touch-action
         */
        "touch-x": [{
          "touch-pan": ["x", "left", "right"]
        }],
        /**
         * Touch Action Y
         * @see https://tailwindcss.com/docs/touch-action
         */
        "touch-y": [{
          "touch-pan": ["y", "up", "down"]
        }],
        /**
         * Touch Action Pinch Zoom
         * @see https://tailwindcss.com/docs/touch-action
         */
        "touch-pz": ["touch-pinch-zoom"],
        /**
         * User Select
         * @see https://tailwindcss.com/docs/user-select
         */
        select: [{
          select: ["none", "text", "all", "auto"]
        }],
        /**
         * Will Change
         * @see https://tailwindcss.com/docs/will-change
         */
        "will-change": [{
          "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
        }],
        // SVG
        /**
         * Fill
         * @see https://tailwindcss.com/docs/fill
         */
        fill: [{
          fill: [colors, "none"]
        }],
        /**
         * Stroke Width
         * @see https://tailwindcss.com/docs/stroke-width
         */
        "stroke-w": [{
          stroke: [isLength, isArbitraryLength, isArbitraryNumber]
        }],
        /**
         * Stroke
         * @see https://tailwindcss.com/docs/stroke
         */
        stroke: [{
          stroke: [colors, "none"]
        }],
        // Accessibility
        /**
         * Screen Readers
         * @see https://tailwindcss.com/docs/screen-readers
         */
        sr: ["sr-only", "not-sr-only"]
      },
      conflictingClassGroups: {
        overflow: ["overflow-x", "overflow-y"],
        overscroll: ["overscroll-x", "overscroll-y"],
        inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
        "inset-x": ["right", "left"],
        "inset-y": ["top", "bottom"],
        flex: ["basis", "grow", "shrink"],
        gap: ["gap-x", "gap-y"],
        p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
        px: ["pr", "pl"],
        py: ["pt", "pb"],
        m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
        mx: ["mr", "ml"],
        my: ["mt", "mb"],
        "font-size": ["leading"],
        "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
        "fvn-ordinal": ["fvn-normal"],
        "fvn-slashed-zero": ["fvn-normal"],
        "fvn-figure": ["fvn-normal"],
        "fvn-spacing": ["fvn-normal"],
        "fvn-fraction": ["fvn-normal"],
        rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
        "rounded-s": ["rounded-ss", "rounded-es"],
        "rounded-e": ["rounded-se", "rounded-ee"],
        "rounded-t": ["rounded-tl", "rounded-tr"],
        "rounded-r": ["rounded-tr", "rounded-br"],
        "rounded-b": ["rounded-br", "rounded-bl"],
        "rounded-l": ["rounded-tl", "rounded-bl"],
        "border-spacing": ["border-spacing-x", "border-spacing-y"],
        "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
        "border-w-x": ["border-w-r", "border-w-l"],
        "border-w-y": ["border-w-t", "border-w-b"],
        "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
        "border-color-x": ["border-color-r", "border-color-l"],
        "border-color-y": ["border-color-t", "border-color-b"],
        "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
        "scroll-mx": ["scroll-mr", "scroll-ml"],
        "scroll-my": ["scroll-mt", "scroll-mb"],
        "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
        "scroll-px": ["scroll-pr", "scroll-pl"],
        "scroll-py": ["scroll-pt", "scroll-pb"],
        touch: ["touch-x", "touch-y", "touch-pz"],
        "touch-x": ["touch"],
        "touch-y": ["touch"],
        "touch-pz": ["touch"]
      },
      conflictingClassGroupModifiers: {
        "font-size": ["leading"]
      }
    };
  }
  const twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
  const loading = "_loading_kgptv_55";
  const simple_loading = "_simple_loading_kgptv_77";
  const styles = {
    loading,
    simple_loading
  };
  const Loader = (props) => {
    const { className, showText = true, text: text2 = "Loading...", simple } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: simple ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames(className, styles.simple_loading) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: twMerge(
          classNames("w-full flex flex-col items-center justify-center", className)
        ),
        style: { height: "calc(100vh - 200px)" },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles.loading }),
          showText && /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-body italic", children: text2 })
        ]
      }
    ) });
  };
  const Routes = {
    //Auth
    login: "/login",
    register: "/register",
    forgotPassword: "/forgot-password",
    resetPassword: "/reset-password",
    verifyEmail: "/verify-email",
    ResendEmail: "/resend-email",
    //Common
    app: "/"
  };
  const PrivateRoute = ({ children }) => {
    const router2 = useRouter();
    const token = getAuthCredentials();
    const isUser = !!token;
    React.useEffect(() => {
      if (!isUser) {
        router2.history.replace(Routes.login);
      }
    }, [isUser]);
    if (isAuthenticated()) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Loader, { showText: false });
  };
  const PublicRoute = ({ children }) => {
    const router2 = useRouter();
    const token = getAuthCredentials();
    const routeState2 = useRouterState();
    const currentRoute = routeState2.location.pathname;
    React.useEffect(() => {
      const isPublicPath = [
        Routes.login,
        Routes.register,
        Routes.forgotPassword,
        Routes.resetPassword,
        Routes.verifyEmail,
        Routes.ResendEmail
      ].includes(currentRoute);
      if (!isAuthenticated() && !isPublicPath) {
        router2.history.replace(Routes.login);
      }
      if (isAuthenticated() && isPublicPath) {
        router2.history.replace(Routes.app);
      }
    }, [token, router2, isAuthenticated]);
    if (!isAuthenticated()) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Loader, { showText: false });
  };
  function AppLayoutWrapper() {
    var _a2, _b2;
    const matches2 = useMatches();
    const component = [...matches2].reverse().find((m) => {
      var _a3;
      return (_a3 = m.context) == null ? void 0 : _a3.layout;
    });
    const requiresAuth = ((_a2 = component == null ? void 0 : component.context) == null ? void 0 : _a2.requiresAuth) || false;
    const RoteComponent = requiresAuth ? PrivateRoute : PublicRoute;
    const LayoutComponent = layoutMap[(_b2 = component == null ? void 0 : component.context) == null ? void 0 : _b2.layout] || layoutMap.DefaultLayout;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RoteComponent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(LayoutComponent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Outlet, {}) }) });
  }
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        refetchOnWindowFocus: false,
        //  disable refetch on tab focus
        refetchOnReconnect: false,
        // (optional) disable refetch on network reconnect
        retry: false
        // (optional) stop auto-retry if failing
      }
    }
  });
  const Route$d = createRootRouteWithContext()({
    component: () => /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(QueryClientProvider, { client: queryClient, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AppLayoutWrapper, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ce, { position: "top-center" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TanStackRouterDevtools, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(LayoutAddition, {})
    ] }) })
  });
  function useToaster$1() {
    const [toaster, setToaster] = useAtom(toasterState);
    return {
      toaster,
      setToaster
    };
  }
  const AUTH_TOKEN_KEY = "testToken";
  const AUTH_USER_KEY = "testUser";
  const COOKIE_EXPIRE = 7;
  const ClientSession = () => {
    const {
      setToaster
    } = useToaster$1();
    const accessToken = getParam$1("accessToken");
    console.log(accessToken, "accessToken");
    const [progressMessage, setProgressMessage] = reactExports.useState("");
    const router2 = useRouter();
    const setItemAsync = async (key2, value, days = COOKIE_EXPIRE) => {
      return new Promise((resolve) => {
        setCookie(key2, value);
        resolve();
      });
    };
    const {
      mutate: clientSession,
      isLoading
    } = useMutation({
      mutationKey: ["clientSession"],
      // mutationFn: async () => {
      //     // Instead of making an API call, return the mock data
      //     return data;
      // },
      mutationFn: async () => {
        try {
          const response = await axios.post(
            `${env$1.VITE_PUBLIC_REST_API_ENDPOINT}${API_ENDPOINTS.CLIENT_SESSION}`,
            // Replace with your API endpoint
            {},
            // Request body (if needed)
            {
              headers: {
                Authorization: `Bearer ${accessToken}`,
                "Content-Type": "application/json"
              }
            }
          );
          return response.data;
        } catch (error) {
          throw error;
        }
      },
      onSuccess: async (data) => {
        if (!data.data.tokenData.token) {
          setToaster({
            message: "Wrong email or password",
            type: "error"
          });
          return;
        }
        const currentDomain = window.location.origin;
        const portal = data.data.loggedInDetails.portals.find((item) => item.portalUrl === currentDomain);
        setPortal(portal);
        setProgressMessage("Logged in successfully!");
        if (data.data.loggedInDetails && data.data.loggedInDetails.hubspots && data.data.loggedInDetails.hubspots.some((hub) => hub.twoFa)) {
          setLoggedInDetails(data.data);
          setTwoFa({
            twoFa: true
          });
          window.location.hash = "/login/two-fa";
        } else {
          await setItemAsync(AUTH_USER_KEY, JSON.stringify(data.data));
          await setItemAsync(AUTH_TOKEN_KEY, data.data.tokenData.token);
          router2.history.replace(`/dashboard`);
        }
        setToaster({
          message: "Logged in successfull!",
          type: "success"
        });
      },
      onError: (error) => {
        if (error.response && error.response.data) {
          const errorData = error.response.data.detailedMessage;
          error.response.data.validationErrors;
          typeof errorData === "object" ? JSON.stringify(errorData) : errorData;
        }
        setProgressMessage("You are not authorized!");
        setToaster({
          message: "You are not authorized",
          type: "error"
        });
      }
    });
    reactExports.useEffect(() => {
      clientSession();
    }, [clientSession]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "loader", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-[100vh] w-[100vw] flex items-center justify-center text-primary", children: progressMessage }) });
  };
  const Route$c = createFileRoute("/client-session")({
    component: ClientSession,
    beforeLoad: () => {
      return {
        layout: "AuthLayout",
        requiresAuth: false
      };
    }
  });
  const Arrow = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      viewBox: "0 0 1024 1024",
      fill: "currentColor",
      height: "1em",
      width: "1em",
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M869 487.8L491.2 159.9c-2.9-2.5-6.6-3.9-10.5-3.9h-88.5c-7.4 0-10.8 9.2-5.2 14l350.2 304H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h585.1L386.9 854c-5.6 4.9-2.2 14 5.2 14h91.5c1.9 0 3.8-.7 5.2-2L869 536.2a32.07 32.07 0 000-48.4z" })
    }
  );
  const DetailsIcon = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      viewBox: "0 0 64 64",
      fill: "currentColor",
      height: "1.5em",
      width: "1.5em",
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "none",
          stroke: "currentColor",
          strokeMiterlimit: 20,
          strokeWidth: 3,
          d: "M0 21h6M16 21h48M0 33h6M16 33h48M0 45h6M16 45h48"
        }
      )
    }
  );
  const getGreeting = () => {
    const hours = (/* @__PURE__ */ new Date()).getHours();
    if (hours < 12) return "Good morning";
    if (hours < 18) return "Good afternoon";
    return "Good evening";
  };
  const formatGreetingDate = (date = /* @__PURE__ */ new Date()) => {
    const options = { weekday: "long", day: "numeric", month: "long", year: "numeric" };
    const formattedDate = new Intl.DateTimeFormat("en-US", options).format(date);
    const getOrdinalSuffix = (day2) => {
      if (day2 > 3 && day2 < 21) return "th";
      const suffixes = ["st", "nd", "rd"];
      return suffixes[day2 % 10 - 1] || "th";
    };
    const day = date.getDate();
    const ordinalSuffix = getOrdinalSuffix(day);
    return formattedDate && typeof formattedDate === "string" ? formattedDate == null ? void 0 : formattedDate.replace(/\d+/, `${day}${ordinalSuffix}`) : "";
  };
  function replacePlaceholders(description, filteredDetails) {
    return description == null ? void 0 : description.replace(/\*\*(\w+)\*\*/g, (match, key2) => {
      const foundItem = filteredDetails.find(([k2]) => k2 === key2);
      return foundItem ? foundItem[1].value : "--";
    });
  }
  const HomeBanner = ({ moduleBannerDetailsOption, userData: userData2 }) => {
    const { me } = useMe$1();
    const { profileDetails: loggedInDetails } = useAuth();
    const [userDetails, setUserDetails] = reactExports.useState({});
    reactExports.useEffect(() => {
      if (userData2 == null ? void 0 : userData2.response) {
        setUserDetails(userData2.response);
      }
    }, [userData2]);
    const description = moduleBannerDetailsOption == null ? void 0 : moduleBannerDetailsOption.description;
    const header = moduleBannerDetailsOption == null ? void 0 : moduleBannerDetailsOption.title;
    const filteredDetails = Object.entries(userDetails).filter(
      ([key2, value]) => (value == null ? void 0 : value.label) && !["hs_object_id"].includes(key2)
    );
    const updatedDescription = replacePlaceholders(description, filteredDetails);
    const updatedHeader = replacePlaceholders(header, filteredDetails);
    hubSpotUserDetails.hubspotPortals.portalSettings.brandName;
    if (loggedInDetails && loggedInDetails.email) {
      loggedInDetails.email;
    } else if (me && me.email) {
      me.email;
    }
    if (me && me.hubspotPortals && me.hubspotPortals.portalSettings && me.hubspotPortals.portalSettings.brandName) {
      me.hubspotPortals.portalSettings.brandName;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex justify-center flex-col items-start md:p-4 p-3 z-2 relative`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${moduleBannerDetailsOption.show_title || (moduleBannerDetailsOption == null ? void 0 : moduleBannerDetailsOption.show_date) ? "mb-6" : "mb-0"}`, children: [
        moduleBannerDetailsOption.show_title && /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: `text-xl md:text-2xl font-bold text-[var(--home-tab-heading-color)] dark:text-white mb-1`, children: moduleBannerDetailsOption && moduleBannerDetailsOption.title ? updatedHeader : /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          getGreeting(),
          ", ",
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-primary dark:text-white dark:opacity-70", children: [
            getFirstName() || "",
            " ",
            getLastName() || ""
          ] })
        ] }) }),
        (moduleBannerDetailsOption == null ? void 0 : moduleBannerDetailsOption.show_date) && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: `opacity-70 text-[var(--home-tab-description-color)] dark:text-white text-sm`, children: [
          "Its ",
          formatGreetingDate()
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `text-[var(--home-tab-description-color)] dark:text-white  words-break`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(HtmlParser, { html: purify.sanitize(updatedDescription) }) })
    ] }) });
  };
  const CautionCircle = ({ width = "80px", height = "80px", ...props }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 14 14",
        width,
        height,
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "g",
          {
            fill: "none",
            stroke: "currentColor",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "7", cy: "7", r: "6.5" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 3.5v3" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "7", cy: "9.5", r: ".5" })
            ]
          }
        )
      }
    );
  };
  const IframeIcon = ({ width = "14px", height = "14px", ...props }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        width,
        height,
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            fill: "currentColor",
            d: "M11.192 13.808h5.616v-2.616h-5.616zm-.076.884q-.349 0-.578-.23t-.23-.578v-2.768q0-.349.23-.578t.577-.23h5.77q.348 0 .577.23t.23.578v2.769q0 .348-.23.578t-.578.23zM4.616 19q-.691 0-1.153-.462T3 17.384V6.616q0-.691.463-1.153T4.615 5h14.77q.69 0 1.152.463T21 6.616v10.769q0 .69-.463 1.153T19.385 19zm0-1h14.769q.23 0 .423-.192t.192-.424V8H4v9.385q0 .23.192.423t.423.192"
          }
        )
      }
    );
  };
  const IframeViewDialog = ({
    open,
    onClose,
    iframeUrls = [],
    currentIframeIndex,
    handleNext,
    handlePrevious,
    isImageUrl
  }) => {
    const getEmbedUrl = (url) => {
      try {
        if (url.includes("youtube.com") || url.includes("youtu.be")) {
          const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
          const match = url.match(regExp);
          const videoId = match && match[2].length === 11 ? match[2] : null;
          return videoId ? `https://www.youtube.com/embed/${videoId}` : url;
        }
        if (url.includes("vimeo.com")) {
          const regExp = /(?:vimeo\.com\/)(?:channels\/|groups\/[^\/]*\/videos\/|album\/\d+\/video\/|video\/|)(\d+)(?:$|\/|\?)/;
          const match = url.match(regExp);
          const videoId = match ? match[1] : null;
          return videoId ? `https://player.vimeo.com/video/${videoId}` : url;
        }
        if (url.includes("drive.google.com")) {
          if (url.includes("/file/d/")) {
            const fileId = url.split("/file/d/")[1].split("/")[0];
            return `https://drive.google.com/file/d/${fileId}/preview`;
          }
        }
        return url;
      } catch (e) {
        console.error("Error converting to embed URL:", e);
        return url;
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative bg-cleanWhite dark:bg-dark-200 dark:text-white rounded-md flex-col justify-between flex w-[90vw] full-height-fix", children: [
      iframeUrls.length > 0 && isImageUrl(iframeUrls[0]) ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid lg:grid-cols-4 grid-cols-2 gap-4 w-full h-auto overflow-auto", children: iframeUrls.map((url, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center items-start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: url,
          alt: `Gallery Image ${index + 1}`,
          className: "w-full h-auto object-contain"
        }
      ) }, index)) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: " h-full w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "iframe",
        {
          id: "frame",
          src: iframeUrls.length > 0 && getEmbedUrl(iframeUrls[currentIframeIndex]),
          width: "100%",
          height: "100%",
          title: `iframe-${currentIframeIndex}`,
          allowFullScreen: true,
          allow: "autoplay; fullscreen",
          sandbox: "allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation-by-user-activation allow-presentation",
          referrerPolicy: "strict-origin-when-cross-origin"
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3 pt-4 justify-between  bg-cleanWhite dark:bg-dark-200 sticky bottom-0 w-full", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "outline",
            size: "sm",
            onClick: onClose,
            children: "Close"
          }
        ),
        iframeUrls.length > 1 && !isImageUrl(iframeUrls[currentIframeIndex]) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end gap-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              className: "bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:text-cleanWhite",
              variant: "outline",
              size: "sm",
              onClick: handlePrevious,
              disabled: currentIframeIndex === 0,
              children: "Previous"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              className: "bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:text-cleanWhite",
              variant: "outline",
              size: "sm",
              onClick: handleNext,
              disabled: currentIframeIndex === iframeUrls.length - 1,
              children: "Next"
            }
          )
        ] })
      ] })
    ] }) });
  };
  const HomeCompanyCardSkeleton = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-lg animate-pulse relative overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full dark:border-gray-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-2 relative z-[2] text-xs dark:text-white transition-all duration-500 md:p-4 p-3", children: Array.from({ length: 4 }).map((_2, i2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-start gap-1 text-xs", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold", children: /* @__PURE__ */ jsxRuntimeExports.jsx("sapn", { className: "h-3 bg-gray-300 dark:bg-dark-white rounded-sm w-[120px] inline-block" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "h-3 bg-gray-300 dark:bg-dark-white rounded-sm w-[100px] inline-block" })
    ] }, i2)) }) }) });
  };
  const HomeCompanyCard = ({ companyDetailsModalOption, userData: userData2, isLoading, isLoadedFirstTime, propertiesList, iframePropertyName, className, usedInDynamicComponent = false, viewStyle }) => {
    const [userAssociatedDetails, setUserAssociatedDetails] = reactExports.useState({});
    const [userAssociatedDetailsModal, setUserAssociatedDetailsModal] = reactExports.useState({});
    const [openModal, setOpenModal] = reactExports.useState(false);
    const [expandDialog, setExpandDialog] = reactExports.useState(false);
    const { sync } = useSync();
    const [iframeViewDialog, setIframeViewDialog] = reactExports.useState(false);
    const [iframeUrls, setIframeUrls] = reactExports.useState([]);
    const [currentIframeIndex, setCurrentIframeIndex] = reactExports.useState(0);
    const processProperties = (propertiesList2, data) => {
      if (!propertiesList2 || !Array.isArray(propertiesList2)) return {};
      const result = {};
      propertiesList2.forEach((item) => {
        var _a2;
        const { properties_value, property_type } = item;
        let source;
        if (property_type === "company") {
          source = ((_a2 = data == null ? void 0 : data.associations) == null ? void 0 : _a2.COMPANY) || {};
        } else {
          source = data || {};
        }
        if (source[properties_value]) {
          result[properties_value] = source[properties_value];
        }
      });
      return result;
    };
    reactExports.useEffect(() => {
      var _a2;
      if (userData2) {
        const associatedDetails = processProperties(propertiesList, userData2);
        setUserAssociatedDetails(associatedDetails);
        const allCompanyProps = ((_a2 = userData2 == null ? void 0 : userData2.associations) == null ? void 0 : _a2.COMPANY) || {};
        const filtered = Object.entries(allCompanyProps).filter(
          ([key2]) => !["configurations", "objectTypeId", "labels", "name", "hs_object_id"].includes(key2)
        );
        setUserAssociatedDetailsModal(Object.fromEntries(filtered));
      }
    }, [userData2, propertiesList]);
    if (!isLoadedFirstTime || sync === true) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(HomeCompanyCardSkeleton, {});
    }
    const visibleAssociatedDetails = userAssociatedDetails;
    const iframeSettings = Array.isArray(iframePropertyName) ? iframePropertyName : [];
    const getDisplayType = (key2) => {
      const setting = iframeSettings.find((setting2) => setting2.properties_value === key2);
      return (setting == null ? void 0 : setting.property_value_show_as) || "simpleText";
    };
    const getActionType = (key2) => {
      const setting = iframeSettings.find((setting2) => setting2.properties_value === key2);
      return (setting == null ? void 0 : setting.on_click_action) || "showIframe";
    };
    const isButtonEnabled = (key2) => {
      const displayType = getDisplayType(key2);
      return displayType === "button";
    };
    const isLinkEnabled = (key2) => {
      const displayType = getDisplayType(key2);
      return displayType === "link";
    };
    const isValidUrl2 = (url) => {
      try {
        new URL(url);
        return true;
      } catch (e) {
        return false;
      }
    };
    const getPropertyValueType = (key2, value = "") => {
      const setting = iframeSettings.find((setting2) => setting2.properties_value === key2);
      const displayType = getDisplayType(key2);
      const actionType = getActionType(key2);
      if (!value) {
        return "--";
      }
      if (displayType === "button") {
        const isValid2 = isValidUrl2(value);
        return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm dark:text-white", children: actionType === "showIframe" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            className: " break-all",
            size: "xsm",
            onClick: () => handleViewClick(value),
            children: (setting == null ? void 0 : setting.button_name) || "View"
          }
        ) : isValid2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: "", size: "xsm", children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { target: "_blank", href: value, rel: "noopener noreferrer", className: " break-all", children: (setting == null ? void 0 : setting.button_name) || "View" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dark:text-white flex gap-1 relative items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-yellow-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CautionCircle, { width: "14px", height: "14px" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red-700 text-xs", children: "Please add a valid link" })
        ] }) });
      }
      if (displayType === "link") {
        const isValid2 = isValidUrl2(value);
        return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm dark:text-white", children: actionType === "showIframe" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "span",
          {
            className: "text-secondary text-xs dark:text-white flex gap-1 relative items-center cursor-pointer break-all hover:underline",
            onClick: () => handleViewClick(value),
            children: [
              value,
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(IframeIcon, {})
            ]
          }
        ) : isValid2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "a",
          {
            target: "_blank",
            href: value,
            rel: "noopener noreferrer",
            className: "text-secondary text-xs dark:text-white flex gap-1 relative items-center break-all",
            children: [
              value,
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(OpenIcon, {})
            ]
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dark:text-white flex gap-1 relative items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-yellow-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CautionCircle, { width: "14px", height: "14px" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red-700 text-xs", children: "Please add a valid link" })
        ] }) });
      }
      return null;
    };
    const isImageUrl = (url) => {
      const imageExtensions = [".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp"];
      const hasImageExtension = imageExtensions.some(
        (ext) => {
          var _a2;
          return (_a2 = url.toLowerCase()) == null ? void 0 : _a2.endsWith(ext);
        }
      );
      const containsImagePattern = url.includes("images.unsplash.com") || url.includes("photo");
      return hasImageExtension || containsImagePattern;
    };
    const handleViewClick = (urls) => {
      const urlArray = urls.split(",").map((url) => url.trim());
      setIframeUrls(urlArray);
      setCurrentIframeIndex(0);
      setIframeViewDialog(true);
    };
    const handleNext = () => {
      setCurrentIframeIndex(
        (prevIndex) => prevIndex < iframeUrls.length - 1 ? prevIndex + 1 : prevIndex
      );
    };
    const handlePrevious = () => {
      setCurrentIframeIndex(
        (prevIndex) => prevIndex > 0 ? prevIndex - 1 : prevIndex
      );
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg relative overflow-hidden", children: [
      visibleAssociatedDetails && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `grid ${viewStyle != "list" ? "grid-cols-2" : "grid-cols-1"}  gap-2 relative z-[2] text-xs dark:text-white transition-all duration-500 md:pb-4 pb-3 md:px-4 px-3 ${className}`, children: Object.entries(visibleAssociatedDetails).map(([key2, value]) => {
        if (isButtonEnabled(key2)) {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex ${viewStyle == "list" ? "flex-row items-center" : "flex-col items-start"} gap-2 text-xs`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-semibold", children: [
              value == null ? void 0 : value.label,
              ":"
            ] }),
            (value == null ? void 0 : value.value) ? getPropertyValueType(key2, value == null ? void 0 : value.value) : "--"
          ] }, key2);
        } else if (isLinkEnabled(key2)) {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex ${viewStyle == "list" ? "flex-row items-center" : "flex-col items-start"} gap-2 text-xs`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-semibold", children: [
              value == null ? void 0 : value.label,
              ":"
            ] }),
            (value == null ? void 0 : value.value) ? getPropertyValueType(key2, value == null ? void 0 : value.value) : "--"
          ] }, key2);
        } else {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex ${viewStyle == "list" ? "flex-row items-center" : "flex-col items-start"} gap-2 text-xs`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-semibold", children: [
              value == null ? void 0 : value.label,
              ":"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: " break-all", children: (value == null ? void 0 : value.value) ? value == null ? void 0 : value.value : "--" })
          ] }, key2);
        }
      }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IframeViewDialog,
        {
          open: iframeViewDialog,
          onClose: () => setIframeViewDialog(false),
          iframeUrls,
          currentIframeIndex,
          handleNext,
          handlePrevious,
          isImageUrl
        }
      )
    ] });
  };
  const DetailsGallery = ({ images, setGalleryDialog }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-3 dark:bg-dark-300 bg-cleanWhite rounded-md mt-5 dark:text-white", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm font-semibold pb-5", children: "Images" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-3 gap-4", children: images.slice(0, 3).map(
        (url, index) => index === 2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `relative items-center overflow-hidden bg-[url('${url}')] bg-no-repeat bg-center bg-cover cursor-pointer`,
            onClick: () => setGalleryDialog(true),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-black opacity-40" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative flex flex-col justify-center items-center px-4 text-white z-10 h-full", children: "View More" })
            ]
          },
          index
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: url,
            alt: `Image ${index + 1}`,
            className: "w-full h-auto"
          },
          index
        )
      ) })
    ] });
  };
  function IconPlus(props) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        viewBox: "0 0 1024 1024",
        fill: "currentColor",
        height: "1rem",
        width: "1rem",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("style", {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M176 474h672q8 0 8 8v60q0 8-8 8H176q-8 0-8-8v-60q0-8 8-8z" })
        ]
      }
    );
  }
  const SearchIcon = ({
    width = "1rem",
    height = "1rem",
    ...props
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { fill: "none", stroke: "currentColor", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "11", cy: "11", r: "5.5" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              strokeLinecap: "round",
              strokeLinejoin: "round",
              d: "m15 15l4 4"
            }
          )
        ] })
      }
    );
  };
  const Pagination = ({ numOfPages, currentPage, setCurrentPage }) => {
    const [arrOfCurrButtons, setArrOfCurrButtons] = reactExports.useState([]);
    reactExports.useEffect(() => {
      if (!Number.isInteger(numOfPages) || numOfPages < 1) return;
      let tempNumberOfButtons = [];
      const dots = "...";
      if (numOfPages <= 3) {
        tempNumberOfButtons = Array.from({ length: numOfPages }, (_2, i2) => i2 + 1);
      } else if (currentPage === 1) {
        tempNumberOfButtons = [1, dots, numOfPages];
      } else if (currentPage === numOfPages) {
        tempNumberOfButtons = [1, dots, numOfPages];
      } else {
        tempNumberOfButtons = [1, dots, currentPage, dots, numOfPages];
      }
      setArrOfCurrButtons(tempNumberOfButtons);
    }, [currentPage, numOfPages]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-end items-center py-6 px-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "flex items-center space-x-2 list-none", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dark:bg-dark-500 bg-gray-200 p-2 rounded-md", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "li",
        {
          className: `dark:text-white text-secondary ${currentPage === 1 ? "cursor-not-allowed" : "cursor-pointer"}`,
          onClick: () => currentPage > 1 && setCurrentPage(currentPage - 1),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Chevron, {})
        }
      ) }),
      arrOfCurrButtons.map((data, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "li",
        {
          className: `cursor-pointer text-sm px-2 py-1 rounded-md ${currentPage === data ? " bg-secondary dark:bg-dark-400 text-white" : ""} ${data === "..." ? "cursor-default" : ""}`,
          onClick: () => data !== "..." && setCurrentPage(data),
          children: data
        },
        index
      )),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dark:bg-dark-500 bg-gray-200 p-2 rounded-md", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "li",
        {
          className: `dark:text-white text-secondary ${currentPage === numOfPages ? "cursor-not-allowed" : "cursor-pointer"}`,
          onClick: () => currentPage < numOfPages && setCurrentPage(currentPage + 1),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Chevron, { className: "rotate-180 origin-center -webkit-transform" })
        }
      ) })
    ] }) });
  };
  var isCheckBoxInput = (element) => element.type === "checkbox";
  var isDateObject = (value) => value instanceof Date;
  var isNullOrUndefined = (value) => value == null;
  const isObjectType = (value) => typeof value === "object";
  var isObject = (value) => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !isDateObject(value);
  var getEventValue = (event) => isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;
  var getNodeParentName = (name) => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;
  var isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));
  var isPlainObject = (tempObject) => {
    const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
    return isObject(prototypeCopy) && prototypeCopy.hasOwnProperty("isPrototypeOf");
  };
  var isWeb = typeof window !== "undefined" && typeof window.HTMLElement !== "undefined" && typeof document !== "undefined";
  function cloneObject(data) {
    let copy2;
    const isArray2 = Array.isArray(data);
    const isFileListInstance = typeof FileList !== "undefined" ? data instanceof FileList : false;
    if (data instanceof Date) {
      copy2 = new Date(data);
    } else if (!(isWeb && (data instanceof Blob || isFileListInstance)) && (isArray2 || isObject(data))) {
      copy2 = isArray2 ? [] : {};
      if (!isArray2 && !isPlainObject(data)) {
        copy2 = data;
      } else {
        for (const key2 in data) {
          if (data.hasOwnProperty(key2)) {
            copy2[key2] = cloneObject(data[key2]);
          }
        }
      }
    } else {
      return data;
    }
    return copy2;
  }
  var isKey = (value) => /^\w*$/.test(value);
  var isUndefined = (val) => val === void 0;
  var compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];
  var stringToPath = (input) => compact(input.replace(/["|']|\]/g, "").split(/\.|\[/));
  var get = (object, path, defaultValue) => {
    if (!path || !isObject(object)) {
      return defaultValue;
    }
    const result = (isKey(path) ? [path] : stringToPath(path)).reduce((result2, key2) => isNullOrUndefined(result2) ? result2 : result2[key2], object);
    return isUndefined(result) || result === object ? isUndefined(object[path]) ? defaultValue : object[path] : result;
  };
  var isBoolean = (value) => typeof value === "boolean";
  var set = (object, path, value) => {
    let index = -1;
    const tempPath = isKey(path) ? [path] : stringToPath(path);
    const length = tempPath.length;
    const lastIndex = length - 1;
    while (++index < length) {
      const key2 = tempPath[index];
      let newValue = value;
      if (index !== lastIndex) {
        const objValue = object[key2];
        newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};
      }
      if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
        return;
      }
      object[key2] = newValue;
      object = object[key2];
    }
  };
  const EVENTS = {
    BLUR: "blur",
    FOCUS_OUT: "focusout",
    CHANGE: "change"
  };
  const VALIDATION_MODE = {
    onBlur: "onBlur",
    onChange: "onChange",
    onSubmit: "onSubmit",
    onTouched: "onTouched",
    all: "all"
  };
  const INPUT_VALIDATION_RULES = {
    max: "max",
    min: "min",
    maxLength: "maxLength",
    minLength: "minLength",
    pattern: "pattern",
    required: "required",
    validate: "validate"
  };
  const HookFormContext = React.createContext(null);
  HookFormContext.displayName = "HookFormContext";
  const useFormContext = () => React.useContext(HookFormContext);
  var getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
    const result = {
      defaultValues: control._defaultValues
    };
    for (const key2 in formState) {
      Object.defineProperty(result, key2, {
        get: () => {
          const _key = key2;
          if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
            control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
          }
          localProxyFormState && (localProxyFormState[_key] = true);
          return formState[_key];
        }
      });
    }
    return result;
  };
  const useIsomorphicLayoutEffect = typeof window !== "undefined" ? React.useLayoutEffect : React.useEffect;
  function useFormState(props) {
    const methods = useFormContext();
    const { control = methods.control, disabled, name, exact } = props || {};
    const [formState, updateFormState] = React.useState(control._formState);
    const _localProxyFormState = React.useRef({
      isDirty: false,
      isLoading: false,
      dirtyFields: false,
      touchedFields: false,
      validatingFields: false,
      isValidating: false,
      isValid: false,
      errors: false
    });
    useIsomorphicLayoutEffect(() => control._subscribe({
      name,
      formState: _localProxyFormState.current,
      exact,
      callback: (formState2) => {
        !disabled && updateFormState({
          ...control._formState,
          ...formState2
        });
      }
    }), [name, disabled, exact]);
    React.useEffect(() => {
      _localProxyFormState.current.isValid && control._setValid(true);
    }, [control]);
    return React.useMemo(() => getProxyFormState(formState, control, _localProxyFormState.current, false), [formState, control]);
  }
  var isString = (value) => typeof value === "string";
  var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {
    if (isString(names)) {
      isGlobal && _names.watch.add(names);
      return get(formValues, names, defaultValue);
    }
    if (Array.isArray(names)) {
      return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));
    }
    isGlobal && (_names.watchAll = true);
    return formValues;
  };
  var isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);
  function deepEqual(object1, object2, _internal_visited = /* @__PURE__ */ new WeakSet()) {
    if (isPrimitive(object1) || isPrimitive(object2)) {
      return object1 === object2;
    }
    if (isDateObject(object1) && isDateObject(object2)) {
      return object1.getTime() === object2.getTime();
    }
    const keys1 = Object.keys(object1);
    const keys2 = Object.keys(object2);
    if (keys1.length !== keys2.length) {
      return false;
    }
    if (_internal_visited.has(object1) || _internal_visited.has(object2)) {
      return true;
    }
    _internal_visited.add(object1);
    _internal_visited.add(object2);
    for (const key2 of keys1) {
      const val1 = object1[key2];
      if (!keys2.includes(key2)) {
        return false;
      }
      if (key2 !== "ref") {
        const val2 = object2[key2];
        if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual(val1, val2, _internal_visited) : val1 !== val2) {
          return false;
        }
      }
    }
    return true;
  }
  function useWatch(props) {
    const methods = useFormContext();
    const { control = methods.control, name, defaultValue, disabled, exact, compute } = props || {};
    const _defaultValue = React.useRef(defaultValue);
    const _compute = React.useRef(compute);
    const _computeFormValues = React.useRef(void 0);
    _compute.current = compute;
    const defaultValueMemo = React.useMemo(() => control._getWatch(name, _defaultValue.current), [control, name]);
    const [value, updateValue] = React.useState(_compute.current ? _compute.current(defaultValueMemo) : defaultValueMemo);
    useIsomorphicLayoutEffect(() => control._subscribe({
      name,
      formState: {
        values: true
      },
      exact,
      callback: (formState) => {
        if (!disabled) {
          const formValues = generateWatchOutput(name, control._names, formState.values || control._formValues, false, _defaultValue.current);
          if (_compute.current) {
            const computedFormValues = _compute.current(formValues);
            if (!deepEqual(computedFormValues, _computeFormValues.current)) {
              updateValue(computedFormValues);
              _computeFormValues.current = computedFormValues;
            }
          } else {
            updateValue(formValues);
          }
        }
      }
    }), [control, disabled, name, exact]);
    React.useEffect(() => control._removeUnmounted());
    return value;
  }
  function useController(props) {
    const methods = useFormContext();
    const { name, disabled, control = methods.control, shouldUnregister, defaultValue } = props;
    const isArrayField = isNameInFieldArray(control._names.array, name);
    const defaultValueMemo = React.useMemo(() => get(control._formValues, name, get(control._defaultValues, name, defaultValue)), [control, name, defaultValue]);
    const value = useWatch({
      control,
      name,
      defaultValue: defaultValueMemo,
      exact: true
    });
    const formState = useFormState({
      control,
      name,
      exact: true
    });
    const _props = React.useRef(props);
    const _registerProps = React.useRef(control.register(name, {
      ...props.rules,
      value,
      ...isBoolean(props.disabled) ? { disabled: props.disabled } : {}
    }));
    _props.current = props;
    const fieldState = React.useMemo(() => Object.defineProperties({}, {
      invalid: {
        enumerable: true,
        get: () => !!get(formState.errors, name)
      },
      isDirty: {
        enumerable: true,
        get: () => !!get(formState.dirtyFields, name)
      },
      isTouched: {
        enumerable: true,
        get: () => !!get(formState.touchedFields, name)
      },
      isValidating: {
        enumerable: true,
        get: () => !!get(formState.validatingFields, name)
      },
      error: {
        enumerable: true,
        get: () => get(formState.errors, name)
      }
    }), [formState, name]);
    const onChange = React.useCallback((event) => _registerProps.current.onChange({
      target: {
        value: getEventValue(event),
        name
      },
      type: EVENTS.CHANGE
    }), [name]);
    const onBlur = React.useCallback(() => _registerProps.current.onBlur({
      target: {
        value: get(control._formValues, name),
        name
      },
      type: EVENTS.BLUR
    }), [name, control._formValues]);
    const ref = React.useCallback((elm) => {
      const field2 = get(control._fields, name);
      if (field2 && elm) {
        field2._f.ref = {
          focus: () => elm.focus && elm.focus(),
          select: () => elm.select && elm.select(),
          setCustomValidity: (message) => elm.setCustomValidity(message),
          reportValidity: () => elm.reportValidity()
        };
      }
    }, [control._fields, name]);
    const field = React.useMemo(() => ({
      name,
      value,
      ...isBoolean(disabled) || formState.disabled ? { disabled: formState.disabled || disabled } : {},
      onChange,
      onBlur,
      ref
    }), [name, disabled, formState.disabled, onChange, onBlur, ref, value]);
    React.useEffect(() => {
      const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
      control.register(name, {
        ..._props.current.rules,
        ...isBoolean(_props.current.disabled) ? { disabled: _props.current.disabled } : {}
      });
      const updateMounted = (name2, value2) => {
        const field2 = get(control._fields, name2);
        if (field2 && field2._f) {
          field2._f.mount = value2;
        }
      };
      updateMounted(name, true);
      if (_shouldUnregisterField) {
        const value2 = cloneObject(get(control._options.defaultValues, name));
        set(control._defaultValues, name, value2);
        if (isUndefined(get(control._formValues, name))) {
          set(control._formValues, name, value2);
        }
      }
      !isArrayField && control.register(name);
      return () => {
        (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);
      };
    }, [name, control, isArrayField, shouldUnregister]);
    React.useEffect(() => {
      control._setDisabledField({
        disabled,
        name
      });
    }, [disabled, name, control]);
    return React.useMemo(() => ({
      field,
      formState,
      fieldState
    }), [field, formState, fieldState]);
  }
  const Controller = (props) => props.render(useController(props));
  var appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria ? {
    ...errors[name],
    types: {
      ...errors[name] && errors[name].types ? errors[name].types : {},
      [type]: message || true
    }
  } : {};
  var convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];
  var createSubject = () => {
    let _observers = [];
    const next = (value) => {
      for (const observer of _observers) {
        observer.next && observer.next(value);
      }
    };
    const subscribe2 = (observer) => {
      _observers.push(observer);
      return {
        unsubscribe: () => {
          _observers = _observers.filter((o) => o !== observer);
        }
      };
    };
    const unsubscribe = () => {
      _observers = [];
    };
    return {
      get observers() {
        return _observers;
      },
      next,
      subscribe: subscribe2,
      unsubscribe
    };
  };
  var isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;
  var isFileInput = (element) => element.type === "file";
  var isFunction = (value) => typeof value === "function";
  var isHTMLElement = (value) => {
    if (!isWeb) {
      return false;
    }
    const owner = value ? value.ownerDocument : 0;
    return value instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);
  };
  var isMultipleSelect = (element) => element.type === `select-multiple`;
  var isRadioInput = (element) => element.type === "radio";
  var isRadioOrCheckbox = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);
  var live = (ref) => isHTMLElement(ref) && ref.isConnected;
  function baseGet(object, updatePath) {
    const length = updatePath.slice(0, -1).length;
    let index = 0;
    while (index < length) {
      object = isUndefined(object) ? index++ : object[updatePath[index++]];
    }
    return object;
  }
  function isEmptyArray(obj) {
    for (const key2 in obj) {
      if (obj.hasOwnProperty(key2) && !isUndefined(obj[key2])) {
        return false;
      }
    }
    return true;
  }
  function unset(object, path) {
    const paths = Array.isArray(path) ? path : isKey(path) ? [path] : stringToPath(path);
    const childObject = paths.length === 1 ? object : baseGet(object, paths);
    const index = paths.length - 1;
    const key2 = paths[index];
    if (childObject) {
      delete childObject[key2];
    }
    if (index !== 0 && (isObject(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {
      unset(object, paths.slice(0, -1));
    }
    return object;
  }
  var objectHasFunction = (data) => {
    for (const key2 in data) {
      if (isFunction(data[key2])) {
        return true;
      }
    }
    return false;
  };
  function markFieldsDirty(data, fields = {}) {
    const isParentNodeArray = Array.isArray(data);
    if (isObject(data) || isParentNodeArray) {
      for (const key2 in data) {
        if (Array.isArray(data[key2]) || isObject(data[key2]) && !objectHasFunction(data[key2])) {
          fields[key2] = Array.isArray(data[key2]) ? [] : {};
          markFieldsDirty(data[key2], fields[key2]);
        } else if (!isNullOrUndefined(data[key2])) {
          fields[key2] = true;
        }
      }
    }
    return fields;
  }
  function getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {
    const isParentNodeArray = Array.isArray(data);
    if (isObject(data) || isParentNodeArray) {
      for (const key2 in data) {
        if (Array.isArray(data[key2]) || isObject(data[key2]) && !objectHasFunction(data[key2])) {
          if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key2])) {
            dirtyFieldsFromValues[key2] = Array.isArray(data[key2]) ? markFieldsDirty(data[key2], []) : { ...markFieldsDirty(data[key2]) };
          } else {
            getDirtyFieldsFromDefaultValues(data[key2], isNullOrUndefined(formValues) ? {} : formValues[key2], dirtyFieldsFromValues[key2]);
          }
        } else {
          dirtyFieldsFromValues[key2] = !deepEqual(data[key2], formValues[key2]);
        }
      }
    }
    return dirtyFieldsFromValues;
  }
  var getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));
  const defaultResult = {
    value: false,
    isValid: false
  };
  const validResult = { value: true, isValid: true };
  var getCheckboxValue = (options) => {
    if (Array.isArray(options)) {
      if (options.length > 1) {
        const values = options.filter((option) => option && option.checked && !option.disabled).map((option) => option.value);
        return { value: values, isValid: !!values.length };
      }
      return options[0].checked && !options[0].disabled ? (
        // @ts-expect-error expected to work in the browser
        options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === "" ? validResult : { value: options[0].value, isValid: true } : validResult
      ) : defaultResult;
    }
    return defaultResult;
  };
  var getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value) ? value : valueAsNumber ? value === "" ? NaN : value ? +value : value : valueAsDate && isString(value) ? new Date(value) : setValueAs ? setValueAs(value) : value;
  const defaultReturn = {
    isValid: false,
    value: null
  };
  var getRadioValue = (options) => Array.isArray(options) ? options.reduce((previous, option) => option && option.checked && !option.disabled ? {
    isValid: true,
    value: option.value
  } : previous, defaultReturn) : defaultReturn;
  function getFieldValue(_f2) {
    const ref = _f2.ref;
    if (isFileInput(ref)) {
      return ref.files;
    }
    if (isRadioInput(ref)) {
      return getRadioValue(_f2.refs).value;
    }
    if (isMultipleSelect(ref)) {
      return [...ref.selectedOptions].map(({ value }) => value);
    }
    if (isCheckBoxInput(ref)) {
      return getCheckboxValue(_f2.refs).value;
    }
    return getFieldValueAs(isUndefined(ref.value) ? _f2.ref.value : ref.value, _f2);
  }
  var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
    const fields = {};
    for (const name of fieldsNames) {
      const field = get(_fields, name);
      field && set(fields, name, field._f);
    }
    return {
      criteriaMode,
      names: [...fieldsNames],
      fields,
      shouldUseNativeValidation
    };
  };
  var isRegex = (value) => value instanceof RegExp;
  var getRuleValue = (rule) => isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;
  var getValidationModes = (mode) => ({
    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
    isOnBlur: mode === VALIDATION_MODE.onBlur,
    isOnChange: mode === VALIDATION_MODE.onChange,
    isOnAll: mode === VALIDATION_MODE.all,
    isOnTouch: mode === VALIDATION_MODE.onTouched
  });
  const ASYNC_FUNCTION = "AsyncFunction";
  var hasPromiseValidation = (fieldReference) => !!fieldReference && !!fieldReference.validate && !!(isFunction(fieldReference.validate) && fieldReference.validate.constructor.name === ASYNC_FUNCTION || isObject(fieldReference.validate) && Object.values(fieldReference.validate).find((validateFunction) => validateFunction.constructor.name === ASYNC_FUNCTION));
  var hasValidation = (options) => options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);
  var isWatched = (name, _names, isBlurEvent) => !isBlurEvent && (_names.watchAll || _names.watch.has(name) || [..._names.watch].some((watchName) => name.startsWith(watchName) && /^\.\w+/.test(name.slice(watchName.length))));
  const iterateFieldsByAction = (fields, action, fieldsNames, abortEarly) => {
    for (const key2 of fieldsNames || Object.keys(fields)) {
      const field = get(fields, key2);
      if (field) {
        const { _f: _f2, ...currentField } = field;
        if (_f2) {
          if (_f2.refs && _f2.refs[0] && action(_f2.refs[0], key2) && !abortEarly) {
            return true;
          } else if (_f2.ref && action(_f2.ref, _f2.name) && !abortEarly) {
            return true;
          } else {
            if (iterateFieldsByAction(currentField, action)) {
              break;
            }
          }
        } else if (isObject(currentField)) {
          if (iterateFieldsByAction(currentField, action)) {
            break;
          }
        }
      }
    }
    return;
  };
  function schemaErrorLookup(errors, _fields, name) {
    const error = get(errors, name);
    if (error || isKey(name)) {
      return {
        error,
        name
      };
    }
    const names = name.split(".");
    while (names.length) {
      const fieldName = names.join(".");
      const field = get(_fields, fieldName);
      const foundError = get(errors, fieldName);
      if (field && !Array.isArray(field) && name !== fieldName) {
        return { name };
      }
      if (foundError && foundError.type) {
        return {
          name: fieldName,
          error: foundError
        };
      }
      if (foundError && foundError.root && foundError.root.type) {
        return {
          name: `${fieldName}.root`,
          error: foundError.root
        };
      }
      names.pop();
    }
    return {
      name
    };
  }
  var shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {
    updateFormState(formStateData);
    const { name, ...formState } = formStateData;
    return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key2) => _proxyFormState[key2] === (!isRoot || VALIDATION_MODE.all));
  };
  var shouldSubscribeByName = (name, signalName, exact) => !name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName) => currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));
  var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
    if (mode.isOnAll) {
      return false;
    } else if (!isSubmitted && mode.isOnTouch) {
      return !(isTouched || isBlurEvent);
    } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
      return !isBlurEvent;
    } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
      return isBlurEvent;
    }
    return true;
  };
  var unsetEmptyArray = (ref, name) => !compact(get(ref, name)).length && unset(ref, name);
  var updateFieldArrayRootError = (errors, error, name) => {
    const fieldArrayErrors = convertToArrayPayload(get(errors, name));
    set(fieldArrayErrors, "root", error[name]);
    set(errors, name, fieldArrayErrors);
    return errors;
  };
  var isMessage = (value) => isString(value);
  function getValidateError(result, ref, type = "validate") {
    if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean(result) && !result) {
      return {
        type,
        message: isMessage(result) ? result : "",
        ref
      };
    }
  }
  var getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData) ? validationData : {
    value: validationData,
    message: ""
  };
  var validateField = async (field, disabledFieldNames, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
    const { ref, refs, required, maxLength, minLength, min: min2, max: max2, pattern, validate, name, valueAsNumber, mount } = field._f;
    const inputValue = get(formValues, name);
    if (!mount || disabledFieldNames.has(name)) {
      return {};
    }
    const inputRef = refs ? refs[0] : ref;
    const setCustomValidity = (message) => {
      if (shouldUseNativeValidation && inputRef.reportValidity) {
        inputRef.setCustomValidity(isBoolean(message) ? "" : message || "");
        inputRef.reportValidity();
      }
    };
    const error = {};
    const isRadio = isRadioInput(ref);
    const isCheckBox = isCheckBoxInput(ref);
    const isRadioOrCheckbox2 = isRadio || isCheckBox;
    const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement(ref) && ref.value === "" || inputValue === "" || Array.isArray(inputValue) && !inputValue.length;
    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);
    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
      const message = exceedMax ? maxLengthMessage : minLengthMessage;
      error[name] = {
        type: exceedMax ? maxType : minType,
        message,
        ref,
        ...appendErrorsCurry(exceedMax ? maxType : minType, message)
      };
    };
    if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox2 && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {
      const { value, message } = isMessage(required) ? { value: !!required, message: required } : getValueAndMessage(required);
      if (value) {
        error[name] = {
          type: INPUT_VALIDATION_RULES.required,
          message,
          ref: inputRef,
          ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message)
        };
        if (!validateAllFieldCriteria) {
          setCustomValidity(message);
          return error;
        }
      }
    }
    if (!isEmpty && (!isNullOrUndefined(min2) || !isNullOrUndefined(max2))) {
      let exceedMax;
      let exceedMin;
      const maxOutput = getValueAndMessage(max2);
      const minOutput = getValueAndMessage(min2);
      if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
        const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);
        if (!isNullOrUndefined(maxOutput.value)) {
          exceedMax = valueNumber > maxOutput.value;
        }
        if (!isNullOrUndefined(minOutput.value)) {
          exceedMin = valueNumber < minOutput.value;
        }
      } else {
        const valueDate = ref.valueAsDate || new Date(inputValue);
        const convertTimeToDate = (time) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + time);
        const isTime = ref.type == "time";
        const isWeek = ref.type == "week";
        if (isString(maxOutput.value) && inputValue) {
          exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);
        }
        if (isString(minOutput.value) && inputValue) {
          exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);
        }
      }
      if (exceedMax || exceedMin) {
        getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
        if (!validateAllFieldCriteria) {
          setCustomValidity(error[name].message);
          return error;
        }
      }
    }
    if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {
      const maxLengthOutput = getValueAndMessage(maxLength);
      const minLengthOutput = getValueAndMessage(minLength);
      const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;
      const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;
      if (exceedMax || exceedMin) {
        getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
        if (!validateAllFieldCriteria) {
          setCustomValidity(error[name].message);
          return error;
        }
      }
    }
    if (pattern && !isEmpty && isString(inputValue)) {
      const { value: patternValue, message } = getValueAndMessage(pattern);
      if (isRegex(patternValue) && !inputValue.match(patternValue)) {
        error[name] = {
          type: INPUT_VALIDATION_RULES.pattern,
          message,
          ref,
          ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message)
        };
        if (!validateAllFieldCriteria) {
          setCustomValidity(message);
          return error;
        }
      }
    }
    if (validate) {
      if (isFunction(validate)) {
        const result = await validate(inputValue, formValues);
        const validateError = getValidateError(result, inputRef);
        if (validateError) {
          error[name] = {
            ...validateError,
            ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)
          };
          if (!validateAllFieldCriteria) {
            setCustomValidity(validateError.message);
            return error;
          }
        }
      } else if (isObject(validate)) {
        let validationResult = {};
        for (const key2 in validate) {
          if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
            break;
          }
          const validateError = getValidateError(await validate[key2](inputValue, formValues), inputRef, key2);
          if (validateError) {
            validationResult = {
              ...validateError,
              ...appendErrorsCurry(key2, validateError.message)
            };
            setCustomValidity(validateError.message);
            if (validateAllFieldCriteria) {
              error[name] = validationResult;
            }
          }
        }
        if (!isEmptyObject(validationResult)) {
          error[name] = {
            ref: inputRef,
            ...validationResult
          };
          if (!validateAllFieldCriteria) {
            return error;
          }
        }
      }
    }
    setCustomValidity(true);
    return error;
  };
  const defaultOptions = {
    mode: VALIDATION_MODE.onSubmit,
    reValidateMode: VALIDATION_MODE.onChange,
    shouldFocusError: true
  };
  function createFormControl(props = {}) {
    let _options = {
      ...defaultOptions,
      ...props
    };
    let _formState = {
      submitCount: 0,
      isDirty: false,
      isReady: false,
      isLoading: isFunction(_options.defaultValues),
      isValidating: false,
      isSubmitted: false,
      isSubmitting: false,
      isSubmitSuccessful: false,
      isValid: false,
      touchedFields: {},
      dirtyFields: {},
      validatingFields: {},
      errors: _options.errors || {},
      disabled: _options.disabled || false
    };
    let _fields = {};
    let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};
    let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);
    let _state = {
      action: false,
      mount: false,
      watch: false
    };
    let _names = {
      mount: /* @__PURE__ */ new Set(),
      disabled: /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set()
    };
    let delayErrorCallback;
    let timer = 0;
    const _proxyFormState = {
      isDirty: false,
      dirtyFields: false,
      validatingFields: false,
      touchedFields: false,
      isValidating: false,
      isValid: false,
      errors: false
    };
    let _proxySubscribeFormState = {
      ..._proxyFormState
    };
    const _subjects = {
      array: createSubject(),
      state: createSubject()
    };
    const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
    const debounce = (callback) => (wait2) => {
      clearTimeout(timer);
      timer = setTimeout(callback, wait2);
    };
    const _setValid = async (shouldUpdateValid) => {
      if (!_options.disabled && (_proxyFormState.isValid || _proxySubscribeFormState.isValid || shouldUpdateValid)) {
        const isValid2 = _options.resolver ? isEmptyObject((await _runSchema()).errors) : await executeBuiltInValidation(_fields, true);
        if (isValid2 !== _formState.isValid) {
          _subjects.state.next({
            isValid: isValid2
          });
        }
      }
    };
    const _updateIsValidating = (names, isValidating) => {
      if (!_options.disabled && (_proxyFormState.isValidating || _proxyFormState.validatingFields || _proxySubscribeFormState.isValidating || _proxySubscribeFormState.validatingFields)) {
        (names || Array.from(_names.mount)).forEach((name) => {
          if (name) {
            isValidating ? set(_formState.validatingFields, name, isValidating) : unset(_formState.validatingFields, name);
          }
        });
        _subjects.state.next({
          validatingFields: _formState.validatingFields,
          isValidating: !isEmptyObject(_formState.validatingFields)
        });
      }
    };
    const _setFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
      if (args && method && !_options.disabled) {
        _state.action = true;
        if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {
          const fieldValues = method(get(_fields, name), args.argA, args.argB);
          shouldSetValues && set(_fields, name, fieldValues);
        }
        if (shouldUpdateFieldsAndState && Array.isArray(get(_formState.errors, name))) {
          const errors = method(get(_formState.errors, name), args.argA, args.argB);
          shouldSetValues && set(_formState.errors, name, errors);
          unsetEmptyArray(_formState.errors, name);
        }
        if ((_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && shouldUpdateFieldsAndState && Array.isArray(get(_formState.touchedFields, name))) {
          const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);
          shouldSetValues && set(_formState.touchedFields, name, touchedFields);
        }
        if (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) {
          _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
        }
        _subjects.state.next({
          name,
          isDirty: _getDirty(name, values),
          dirtyFields: _formState.dirtyFields,
          errors: _formState.errors,
          isValid: _formState.isValid
        });
      } else {
        set(_formValues, name, values);
      }
    };
    const updateErrors = (name, error) => {
      set(_formState.errors, name, error);
      _subjects.state.next({
        errors: _formState.errors
      });
    };
    const _setErrors = (errors) => {
      _formState.errors = errors;
      _subjects.state.next({
        errors: _formState.errors,
        isValid: false
      });
    };
    const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {
      const field = get(_fields, name);
      if (field) {
        const defaultValue = get(_formValues, name, isUndefined(value) ? get(_defaultValues, name) : value);
        isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);
        _state.mount && _setValid();
      }
    };
    const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
      let shouldUpdateField = false;
      let isPreviousDirty = false;
      const output = {
        name
      };
      if (!_options.disabled) {
        if (!isBlurEvent || shouldDirty) {
          if (_proxyFormState.isDirty || _proxySubscribeFormState.isDirty) {
            isPreviousDirty = _formState.isDirty;
            _formState.isDirty = output.isDirty = _getDirty();
            shouldUpdateField = isPreviousDirty !== output.isDirty;
          }
          const isCurrentFieldPristine = deepEqual(get(_defaultValues, name), fieldValue);
          isPreviousDirty = !!get(_formState.dirtyFields, name);
          isCurrentFieldPristine ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);
          output.dirtyFields = _formState.dirtyFields;
          shouldUpdateField = shouldUpdateField || (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) && isPreviousDirty !== !isCurrentFieldPristine;
        }
        if (isBlurEvent) {
          const isPreviousFieldTouched = get(_formState.touchedFields, name);
          if (!isPreviousFieldTouched) {
            set(_formState.touchedFields, name, isBlurEvent);
            output.touchedFields = _formState.touchedFields;
            shouldUpdateField = shouldUpdateField || (_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && isPreviousFieldTouched !== isBlurEvent;
          }
        }
        shouldUpdateField && shouldRender && _subjects.state.next(output);
      }
      return shouldUpdateField ? output : {};
    };
    const shouldRenderByError = (name, isValid2, error, fieldState) => {
      const previousFieldError = get(_formState.errors, name);
      const shouldUpdateValid = (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isBoolean(isValid2) && _formState.isValid !== isValid2;
      if (_options.delayError && error) {
        delayErrorCallback = debounce(() => updateErrors(name, error));
        delayErrorCallback(_options.delayError);
      } else {
        clearTimeout(timer);
        delayErrorCallback = null;
        error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
      }
      if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {
        const updatedFormState = {
          ...fieldState,
          ...shouldUpdateValid && isBoolean(isValid2) ? { isValid: isValid2 } : {},
          errors: _formState.errors,
          name
        };
        _formState = {
          ..._formState,
          ...updatedFormState
        };
        _subjects.state.next(updatedFormState);
      }
    };
    const _runSchema = async (name) => {
      _updateIsValidating(name, true);
      const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));
      _updateIsValidating(name);
      return result;
    };
    const executeSchemaAndUpdateState = async (names) => {
      const { errors } = await _runSchema(names);
      if (names) {
        for (const name of names) {
          const error = get(errors, name);
          error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
        }
      } else {
        _formState.errors = errors;
      }
      return errors;
    };
    const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {
      valid: true
    }) => {
      for (const name in fields) {
        const field = fields[name];
        if (field) {
          const { _f: _f2, ...fieldValue } = field;
          if (_f2) {
            const isFieldArrayRoot = _names.array.has(_f2.name);
            const isPromiseFunction = field._f && hasPromiseValidation(field._f);
            if (isPromiseFunction && _proxyFormState.validatingFields) {
              _updateIsValidating([name], true);
            }
            const fieldError = await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);
            if (isPromiseFunction && _proxyFormState.validatingFields) {
              _updateIsValidating([name]);
            }
            if (fieldError[_f2.name]) {
              context.valid = false;
              if (shouldOnlyCheckValid) {
                break;
              }
            }
            !shouldOnlyCheckValid && (get(fieldError, _f2.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f2.name) : set(_formState.errors, _f2.name, fieldError[_f2.name]) : unset(_formState.errors, _f2.name));
          }
          !isEmptyObject(fieldValue) && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);
        }
      }
      return context.valid;
    };
    const _removeUnmounted = () => {
      for (const name of _names.unMount) {
        const field = get(_fields, name);
        field && (field._f.refs ? field._f.refs.every((ref) => !live(ref)) : !live(field._f.ref)) && unregister(name);
      }
      _names.unMount = /* @__PURE__ */ new Set();
    };
    const _getDirty = (name, data) => !_options.disabled && (name && data && set(_formValues, name, data), !deepEqual(getValues(), _defaultValues));
    const _getWatch = (names, defaultValue, isGlobal) => generateWatchOutput(names, _names, {
      ..._state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? { [names]: defaultValue } : defaultValue
    }, isGlobal, defaultValue);
    const _getFieldArray = (name) => compact(get(_state.mount ? _formValues : _defaultValues, name, _options.shouldUnregister ? get(_defaultValues, name, []) : []));
    const setFieldValue = (name, value, options = {}) => {
      const field = get(_fields, name);
      let fieldValue = value;
      if (field) {
        const fieldReference = field._f;
        if (fieldReference) {
          !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value, fieldReference));
          fieldValue = isHTMLElement(fieldReference.ref) && isNullOrUndefined(value) ? "" : value;
          if (isMultipleSelect(fieldReference.ref)) {
            [...fieldReference.ref.options].forEach((optionRef) => optionRef.selected = fieldValue.includes(optionRef.value));
          } else if (fieldReference.refs) {
            if (isCheckBoxInput(fieldReference.ref)) {
              fieldReference.refs.forEach((checkboxRef) => {
                if (!checkboxRef.defaultChecked || !checkboxRef.disabled) {
                  if (Array.isArray(fieldValue)) {
                    checkboxRef.checked = !!fieldValue.find((data) => data === checkboxRef.value);
                  } else {
                    checkboxRef.checked = fieldValue === checkboxRef.value || !!fieldValue;
                  }
                }
              });
            } else {
              fieldReference.refs.forEach((radioRef) => radioRef.checked = radioRef.value === fieldValue);
            }
          } else if (isFileInput(fieldReference.ref)) {
            fieldReference.ref.value = "";
          } else {
            fieldReference.ref.value = fieldValue;
            if (!fieldReference.ref.type) {
              _subjects.state.next({
                name,
                values: cloneObject(_formValues)
              });
            }
          }
        }
      }
      (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);
      options.shouldValidate && trigger(name);
    };
    const setValues = (name, value, options) => {
      for (const fieldKey in value) {
        if (!value.hasOwnProperty(fieldKey)) {
          return;
        }
        const fieldValue = value[fieldKey];
        const fieldName = name + "." + fieldKey;
        const field = get(_fields, fieldName);
        (_names.array.has(name) || isObject(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);
      }
    };
    const setValue = (name, value, options = {}) => {
      const field = get(_fields, name);
      const isFieldArray = _names.array.has(name);
      const cloneValue = cloneObject(value);
      set(_formValues, name, cloneValue);
      if (isFieldArray) {
        _subjects.array.next({
          name,
          values: cloneObject(_formValues)
        });
        if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields || _proxySubscribeFormState.isDirty || _proxySubscribeFormState.dirtyFields) && options.shouldDirty) {
          _subjects.state.next({
            name,
            dirtyFields: getDirtyFields(_defaultValues, _formValues),
            isDirty: _getDirty(name, cloneValue)
          });
        }
      } else {
        field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);
      }
      isWatched(name, _names) && _subjects.state.next({ ..._formState, name });
      _subjects.state.next({
        name: _state.mount ? name : void 0,
        values: cloneObject(_formValues)
      });
    };
    const onChange = async (event) => {
      _state.mount = true;
      const target = event.target;
      let name = target.name;
      let isFieldValueUpdated = true;
      const field = get(_fields, name);
      const _updateIsFieldValueUpdated = (fieldValue) => {
        isFieldValueUpdated = Number.isNaN(fieldValue) || isDateObject(fieldValue) && isNaN(fieldValue.getTime()) || deepEqual(fieldValue, get(_formValues, name, fieldValue));
      };
      const validationModeBeforeSubmit = getValidationModes(_options.mode);
      const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
      if (field) {
        let error;
        let isValid2;
        const fieldValue = target.type ? getFieldValue(field._f) : getEventValue(event);
        const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
        const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
        const watched = isWatched(name, _names, isBlurEvent);
        set(_formValues, name, fieldValue);
        if (isBlurEvent) {
          field._f.onBlur && field._f.onBlur(event);
          delayErrorCallback && delayErrorCallback(0);
        } else if (field._f.onChange) {
          field._f.onChange(event);
        }
        const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent);
        const shouldRender = !isEmptyObject(fieldState) || watched;
        !isBlurEvent && _subjects.state.next({
          name,
          type: event.type,
          values: cloneObject(_formValues)
        });
        if (shouldSkipValidation) {
          if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {
            if (_options.mode === "onBlur") {
              if (isBlurEvent) {
                _setValid();
              }
            } else if (!isBlurEvent) {
              _setValid();
            }
          }
          return shouldRender && _subjects.state.next({ name, ...watched ? {} : fieldState });
        }
        !isBlurEvent && watched && _subjects.state.next({ ..._formState });
        if (_options.resolver) {
          const { errors } = await _runSchema([name]);
          _updateIsFieldValueUpdated(fieldValue);
          if (isFieldValueUpdated) {
            const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
            const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
            error = errorLookupResult.error;
            name = errorLookupResult.name;
            isValid2 = isEmptyObject(errors);
          }
        } else {
          _updateIsValidating([name], true);
          error = (await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];
          _updateIsValidating([name]);
          _updateIsFieldValueUpdated(fieldValue);
          if (isFieldValueUpdated) {
            if (error) {
              isValid2 = false;
            } else if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {
              isValid2 = await executeBuiltInValidation(_fields, true);
            }
          }
        }
        if (isFieldValueUpdated) {
          field._f.deps && trigger(field._f.deps);
          shouldRenderByError(name, isValid2, error, fieldState);
        }
      }
    };
    const _focusInput = (ref, key2) => {
      if (get(_formState.errors, key2) && ref.focus) {
        ref.focus();
        return 1;
      }
      return;
    };
    const trigger = async (name, options = {}) => {
      let isValid2;
      let validationResult;
      const fieldNames = convertToArrayPayload(name);
      if (_options.resolver) {
        const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);
        isValid2 = isEmptyObject(errors);
        validationResult = name ? !fieldNames.some((name2) => get(errors, name2)) : isValid2;
      } else if (name) {
        validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {
          const field = get(_fields, fieldName);
          return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);
        }))).every(Boolean);
        !(!validationResult && !_formState.isValid) && _setValid();
      } else {
        validationResult = isValid2 = await executeBuiltInValidation(_fields);
      }
      _subjects.state.next({
        ...!isString(name) || (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isValid2 !== _formState.isValid ? {} : { name },
        ..._options.resolver || !name ? { isValid: isValid2 } : {},
        errors: _formState.errors
      });
      options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);
      return validationResult;
    };
    const getValues = (fieldNames) => {
      const values = {
        ..._state.mount ? _formValues : _defaultValues
      };
      return isUndefined(fieldNames) ? values : isString(fieldNames) ? get(values, fieldNames) : fieldNames.map((name) => get(values, name));
    };
    const getFieldState = (name, formState) => ({
      invalid: !!get((formState || _formState).errors, name),
      isDirty: !!get((formState || _formState).dirtyFields, name),
      error: get((formState || _formState).errors, name),
      isValidating: !!get(_formState.validatingFields, name),
      isTouched: !!get((formState || _formState).touchedFields, name)
    });
    const clearErrors = (name) => {
      name && convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName));
      _subjects.state.next({
        errors: name ? _formState.errors : {}
      });
    };
    const setError = (name, error, options) => {
      const ref = (get(_fields, name, { _f: {} })._f || {}).ref;
      const currentError = get(_formState.errors, name) || {};
      const { ref: currentRef, message, type, ...restOfErrorTree } = currentError;
      set(_formState.errors, name, {
        ...restOfErrorTree,
        ...error,
        ref
      });
      _subjects.state.next({
        name,
        errors: _formState.errors,
        isValid: false
      });
      options && options.shouldFocus && ref && ref.focus && ref.focus();
    };
    const watch = (name, defaultValue) => isFunction(name) ? _subjects.state.subscribe({
      next: (payload) => "values" in payload && name(_getWatch(void 0, defaultValue), payload)
    }) : _getWatch(name, defaultValue, true);
    const _subscribe = (props2) => _subjects.state.subscribe({
      next: (formState) => {
        if (shouldSubscribeByName(props2.name, formState.name, props2.exact) && shouldRenderFormState(formState, props2.formState || _proxyFormState, _setFormState, props2.reRenderRoot)) {
          props2.callback({
            values: { ..._formValues },
            ..._formState,
            ...formState,
            defaultValues: _defaultValues
          });
        }
      }
    }).unsubscribe;
    const subscribe2 = (props2) => {
      _state.mount = true;
      _proxySubscribeFormState = {
        ..._proxySubscribeFormState,
        ...props2.formState
      };
      return _subscribe({
        ...props2,
        formState: _proxySubscribeFormState
      });
    };
    const unregister = (name, options = {}) => {
      for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {
        _names.mount.delete(fieldName);
        _names.array.delete(fieldName);
        if (!options.keepValue) {
          unset(_fields, fieldName);
          unset(_formValues, fieldName);
        }
        !options.keepError && unset(_formState.errors, fieldName);
        !options.keepDirty && unset(_formState.dirtyFields, fieldName);
        !options.keepTouched && unset(_formState.touchedFields, fieldName);
        !options.keepIsValidating && unset(_formState.validatingFields, fieldName);
        !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);
      }
      _subjects.state.next({
        values: cloneObject(_formValues)
      });
      _subjects.state.next({
        ..._formState,
        ...!options.keepDirty ? {} : { isDirty: _getDirty() }
      });
      !options.keepIsValid && _setValid();
    };
    const _setDisabledField = ({ disabled, name }) => {
      if (isBoolean(disabled) && _state.mount || !!disabled || _names.disabled.has(name)) {
        disabled ? _names.disabled.add(name) : _names.disabled.delete(name);
      }
    };
    const register = (name, options = {}) => {
      let field = get(_fields, name);
      const disabledIsDefined = isBoolean(options.disabled) || isBoolean(_options.disabled);
      set(_fields, name, {
        ...field || {},
        _f: {
          ...field && field._f ? field._f : { ref: { name } },
          name,
          mount: true,
          ...options
        }
      });
      _names.mount.add(name);
      if (field) {
        _setDisabledField({
          disabled: isBoolean(options.disabled) ? options.disabled : _options.disabled,
          name
        });
      } else {
        updateValidAndValue(name, true, options.value);
      }
      return {
        ...disabledIsDefined ? { disabled: options.disabled || _options.disabled } : {},
        ..._options.progressive ? {
          required: !!options.required,
          min: getRuleValue(options.min),
          max: getRuleValue(options.max),
          minLength: getRuleValue(options.minLength),
          maxLength: getRuleValue(options.maxLength),
          pattern: getRuleValue(options.pattern)
        } : {},
        name,
        onChange,
        onBlur: onChange,
        ref: (ref) => {
          if (ref) {
            register(name, options);
            field = get(_fields, name);
            const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll("input,select,textarea")[0] || ref : ref : ref;
            const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
            const refs = field._f.refs || [];
            if (radioOrCheckbox ? refs.find((option) => option === fieldRef) : fieldRef === field._f.ref) {
              return;
            }
            set(_fields, name, {
              _f: {
                ...field._f,
                ...radioOrCheckbox ? {
                  refs: [
                    ...refs.filter(live),
                    fieldRef,
                    ...Array.isArray(get(_defaultValues, name)) ? [{}] : []
                  ],
                  ref: { type: fieldRef.type, name }
                } : { ref: fieldRef }
              }
            });
            updateValidAndValue(name, false, void 0, fieldRef);
          } else {
            field = get(_fields, name, {});
            if (field._f) {
              field._f.mount = false;
            }
            (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);
          }
        }
      };
    };
    const _focusError = () => _options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);
    const _disableForm = (disabled) => {
      if (isBoolean(disabled)) {
        _subjects.state.next({ disabled });
        iterateFieldsByAction(_fields, (ref, name) => {
          const currentField = get(_fields, name);
          if (currentField) {
            ref.disabled = currentField._f.disabled || disabled;
            if (Array.isArray(currentField._f.refs)) {
              currentField._f.refs.forEach((inputRef) => {
                inputRef.disabled = currentField._f.disabled || disabled;
              });
            }
          }
        }, 0, false);
      }
    };
    const handleSubmit = (onValid, onInvalid) => async (e) => {
      let onValidError = void 0;
      if (e) {
        e.preventDefault && e.preventDefault();
        e.persist && e.persist();
      }
      let fieldValues = cloneObject(_formValues);
      _subjects.state.next({
        isSubmitting: true
      });
      if (_options.resolver) {
        const { errors, values } = await _runSchema();
        _formState.errors = errors;
        fieldValues = cloneObject(values);
      } else {
        await executeBuiltInValidation(_fields);
      }
      if (_names.disabled.size) {
        for (const name of _names.disabled) {
          unset(fieldValues, name);
        }
      }
      unset(_formState.errors, "root");
      if (isEmptyObject(_formState.errors)) {
        _subjects.state.next({
          errors: {}
        });
        try {
          await onValid(fieldValues, e);
        } catch (error) {
          onValidError = error;
        }
      } else {
        if (onInvalid) {
          await onInvalid({ ..._formState.errors }, e);
        }
        _focusError();
        setTimeout(_focusError);
      }
      _subjects.state.next({
        isSubmitted: true,
        isSubmitting: false,
        isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,
        submitCount: _formState.submitCount + 1,
        errors: _formState.errors
      });
      if (onValidError) {
        throw onValidError;
      }
    };
    const resetField = (name, options = {}) => {
      if (get(_fields, name)) {
        if (isUndefined(options.defaultValue)) {
          setValue(name, cloneObject(get(_defaultValues, name)));
        } else {
          setValue(name, options.defaultValue);
          set(_defaultValues, name, cloneObject(options.defaultValue));
        }
        if (!options.keepTouched) {
          unset(_formState.touchedFields, name);
        }
        if (!options.keepDirty) {
          unset(_formState.dirtyFields, name);
          _formState.isDirty = options.defaultValue ? _getDirty(name, cloneObject(get(_defaultValues, name))) : _getDirty();
        }
        if (!options.keepError) {
          unset(_formState.errors, name);
          _proxyFormState.isValid && _setValid();
        }
        _subjects.state.next({ ..._formState });
      }
    };
    const _reset = (formValues, keepStateOptions = {}) => {
      const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;
      const cloneUpdatedValues = cloneObject(updatedValues);
      const isEmptyResetValues = isEmptyObject(formValues);
      const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;
      if (!keepStateOptions.keepDefaultValues) {
        _defaultValues = updatedValues;
      }
      if (!keepStateOptions.keepValues) {
        if (keepStateOptions.keepDirtyValues) {
          const fieldsToCheck = /* @__PURE__ */ new Set([
            ..._names.mount,
            ...Object.keys(getDirtyFields(_defaultValues, _formValues))
          ]);
          for (const fieldName of Array.from(fieldsToCheck)) {
            get(_formState.dirtyFields, fieldName) ? set(values, fieldName, get(_formValues, fieldName)) : setValue(fieldName, get(values, fieldName));
          }
        } else {
          if (isWeb && isUndefined(formValues)) {
            for (const name of _names.mount) {
              const field = get(_fields, name);
              if (field && field._f) {
                const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;
                if (isHTMLElement(fieldReference)) {
                  const form = fieldReference.closest("form");
                  if (form) {
                    form.reset();
                    break;
                  }
                }
              }
            }
          }
          if (keepStateOptions.keepFieldsRef) {
            for (const fieldName of _names.mount) {
              setValue(fieldName, get(values, fieldName));
            }
          } else {
            _fields = {};
          }
        }
        _formValues = _options.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneObject(values);
        _subjects.array.next({
          values: { ...values }
        });
        _subjects.state.next({
          values: { ...values }
        });
      }
      _names = {
        mount: keepStateOptions.keepDirtyValues ? _names.mount : /* @__PURE__ */ new Set(),
        unMount: /* @__PURE__ */ new Set(),
        array: /* @__PURE__ */ new Set(),
        disabled: /* @__PURE__ */ new Set(),
        watch: /* @__PURE__ */ new Set(),
        watchAll: false,
        focus: ""
      };
      _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues;
      _state.watch = !!_options.shouldUnregister;
      _subjects.state.next({
        submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,
        isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual(formValues, _defaultValues)),
        isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,
        dirtyFields: isEmptyResetValues ? {} : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : keepStateOptions.keepDirty ? _formState.dirtyFields : {},
        touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},
        errors: keepStateOptions.keepErrors ? _formState.errors : {},
        isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,
        isSubmitting: false
      });
    };
    const reset = (formValues, keepStateOptions) => _reset(isFunction(formValues) ? formValues(_formValues) : formValues, keepStateOptions);
    const setFocus = (name, options = {}) => {
      const field = get(_fields, name);
      const fieldReference = field && field._f;
      if (fieldReference) {
        const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;
        if (fieldRef.focus) {
          fieldRef.focus();
          options.shouldSelect && isFunction(fieldRef.select) && fieldRef.select();
        }
      }
    };
    const _setFormState = (updatedFormState) => {
      _formState = {
        ..._formState,
        ...updatedFormState
      };
    };
    const _resetDefaultValues = () => isFunction(_options.defaultValues) && _options.defaultValues().then((values) => {
      reset(values, _options.resetOptions);
      _subjects.state.next({
        isLoading: false
      });
    });
    const methods = {
      control: {
        register,
        unregister,
        getFieldState,
        handleSubmit,
        setError,
        _subscribe,
        _runSchema,
        _focusError,
        _getWatch,
        _getDirty,
        _setValid,
        _setFieldArray,
        _setDisabledField,
        _setErrors,
        _getFieldArray,
        _reset,
        _resetDefaultValues,
        _removeUnmounted,
        _disableForm,
        _subjects,
        _proxyFormState,
        get _fields() {
          return _fields;
        },
        get _formValues() {
          return _formValues;
        },
        get _state() {
          return _state;
        },
        set _state(value) {
          _state = value;
        },
        get _defaultValues() {
          return _defaultValues;
        },
        get _names() {
          return _names;
        },
        set _names(value) {
          _names = value;
        },
        get _formState() {
          return _formState;
        },
        get _options() {
          return _options;
        },
        set _options(value) {
          _options = {
            ..._options,
            ...value
          };
        }
      },
      subscribe: subscribe2,
      trigger,
      register,
      handleSubmit,
      watch,
      setValue,
      getValues,
      reset,
      resetField,
      clearErrors,
      unregister,
      setError,
      setFocus,
      getFieldState
    };
    return {
      ...methods,
      formControl: methods
    };
  }
  function useForm(props = {}) {
    const _formControl = React.useRef(void 0);
    const _values = React.useRef(void 0);
    const [formState, updateFormState] = React.useState({
      isDirty: false,
      isValidating: false,
      isLoading: isFunction(props.defaultValues),
      isSubmitted: false,
      isSubmitting: false,
      isSubmitSuccessful: false,
      isValid: false,
      submitCount: 0,
      dirtyFields: {},
      touchedFields: {},
      validatingFields: {},
      errors: props.errors || {},
      disabled: props.disabled || false,
      isReady: false,
      defaultValues: isFunction(props.defaultValues) ? void 0 : props.defaultValues
    });
    if (!_formControl.current) {
      if (props.formControl) {
        _formControl.current = {
          ...props.formControl,
          formState
        };
        if (props.defaultValues && !isFunction(props.defaultValues)) {
          props.formControl.reset(props.defaultValues, props.resetOptions);
        }
      } else {
        const { formControl, ...rest } = createFormControl(props);
        _formControl.current = {
          ...rest,
          formState
        };
      }
    }
    const control = _formControl.current.control;
    control._options = props;
    useIsomorphicLayoutEffect(() => {
      const sub = control._subscribe({
        formState: control._proxyFormState,
        callback: () => updateFormState({ ...control._formState }),
        reRenderRoot: true
      });
      updateFormState((data) => ({
        ...data,
        isReady: true
      }));
      control._formState.isReady = true;
      return sub;
    }, [control]);
    React.useEffect(() => control._disableForm(props.disabled), [control, props.disabled]);
    React.useEffect(() => {
      if (props.mode) {
        control._options.mode = props.mode;
      }
      if (props.reValidateMode) {
        control._options.reValidateMode = props.reValidateMode;
      }
    }, [control, props.mode, props.reValidateMode]);
    React.useEffect(() => {
      if (props.errors) {
        control._setErrors(props.errors);
        control._focusError();
      }
    }, [control, props.errors]);
    React.useEffect(() => {
      props.shouldUnregister && control._subjects.state.next({
        values: control._getWatch()
      });
    }, [control, props.shouldUnregister]);
    React.useEffect(() => {
      if (control._proxyFormState.isDirty) {
        const isDirty2 = control._getDirty();
        if (isDirty2 !== formState.isDirty) {
          control._subjects.state.next({
            isDirty: isDirty2
          });
        }
      }
    }, [control, formState.isDirty]);
    React.useEffect(() => {
      if (props.values && !deepEqual(props.values, _values.current)) {
        control._reset(props.values, {
          keepFieldsRef: true,
          ...control._options.resetOptions
        });
        _values.current = props.values;
        updateFormState((state) => ({ ...state }));
      } else {
        control._resetDefaultValues();
      }
    }, [control, props.values]);
    React.useEffect(() => {
      if (!control._state.mount) {
        control._setValid();
        control._state.mount = true;
      }
      if (control._state.watch) {
        control._state.watch = false;
        control._subjects.state.next({ ...control._formState });
      }
      control._removeUnmounted();
    });
    _formControl.current.formState = getProxyFormState(formState, control);
    return _formControl.current;
  }
  const Form = ({
    onSubmit,
    children,
    useFormProps,
    validationSchema,
    serverError,
    resetFields,
    initialValues = {},
    formName = "",
    ...formProps
  }) => {
    const zodResolver = (schema2) => async (data) => {
      try {
        const values = schema2.parse(data);
        return { values, errors: {} };
      } catch (e) {
        return {
          values: {},
          errors: e.errors.reduce((acc, error) => {
            acc[error.path[0]] = { type: error.code, message: error.message };
            return acc;
          }, {})
        };
      }
    };
    const methods = useForm({
      ...useFormProps,
      ...validationSchema && {
        resolver: zodResolver(validationSchema),
        defaultValues: initialValues
      }
    });
    reactExports.useEffect(() => {
      if (serverError) {
        Object.entries(serverError).forEach(([key2, value]) => {
          methods.setError(key2, {
            type: "manual",
            message: value
          });
        });
      }
    }, [serverError, methods]);
    reactExports.useEffect(() => {
      if (resetFields) {
        methods.reset(resetFields);
      }
    }, [resetFields, methods]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "form",
      {
        noValidate: true,
        onSubmit: methods.handleSubmit(onSubmit),
        id: `${formName}`,
        children: children(methods)
      }
    );
  };
  const FormItem = ({ children, className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `mb-5 ${className}`, children });
  const FormLabel = ({ children, className }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "label",
    {
      className: `block mb-2 text-sm font-medium dark:text-white ${className}`,
      children
    }
  );
  const FormControl = ({ children, className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: ` ${className}`, children });
  const FormMessage = ({ children, className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-sm text-red-600 dark:text-red-500", children });
  const Input = reactExports.forwardRef(
    ({
      className,
      type = "text",
      placeholder = "Search",
      height = "medium",
      icon: Icon = "",
      variant = "normal",
      ...rest
    }, ref) => {
      const heightClasses = {
        small: "py-1",
        semiMedium: "py-2",
        medium: "py-2",
        large: "py-5"
      };
      const classes2 = {
        root: "w-full rounded-md bg-cleanWhite px-2 text-base transition-colors border border-2 dark:border-gray-600 focus:ring-0 focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 dark:bg-gray-700 dark:text-gray-200 dark:placeholder-gray-400 py-2",
        normal: ""
      };
      const rootClassName = classNames(
        classes2.root,
        {
          [classes2.normal]: variant === "normal"
        },
        Icon && "pl-8",
        heightClasses[height],
        className
      );
      delete rest.className;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative dark:bg-dark-300 flex items-center rounded-lg max-sm:w-full", children: [
        Icon && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute left-2 top-1/2 -translate-y-1/2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "h-6 w-6 text-gray-500" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type,
            placeholder,
            className: rootClassName,
            ref,
            ...rest
          }
        )
      ] });
    }
  );
  const Textarea = reactExports.forwardRef(
    ({ className, placeholder = "Leave a comment...", rows = 4, ...rest }, ref) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "textarea",
        {
          rows,
          className: classNames(
            "w-full rounded-md bg-cleanWhite px-2 text-sm transition-colors border-2 dark:border-gray-600 focus:ring-0 focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 dark:bg-gray-700 dark:text-gray-200 dark:placeholder-gray-400 py-2",
            className
          ),
          placeholder,
          ref,
          ...rest
        }
      );
    }
  );
  const Table = React.forwardRef(
    ({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "table",
      {
        ref,
        className: classNames("caption-bottom dark:bg-[#2a2a2a] text-sm", className),
        ...props
      }
    ) })
  );
  Table.displayName = "Table";
  const TableHeader = React.forwardRef(
    ({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { ref, className: classNames("[&_tr]:border-b", className), ...props })
  );
  TableHeader.displayName = "TableHeader";
  const TableBody = React.forwardRef(
    ({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "tbody",
      {
        ref,
        className: classNames("[&_tr:last-child]:border-0", className),
        ...props
      }
    )
  );
  TableBody.displayName = "TableBody";
  const TableFooter = React.forwardRef(
    ({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "tfoot",
      {
        ref,
        className: classNames(
          "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
          className
        ),
        ...props
      }
    )
  );
  TableFooter.displayName = "TableFooter";
  const TableRow = React.forwardRef(
    ({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "tr",
      {
        ref,
        className: classNames(
          "border-b dark:border-gray-600 py-4 transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
          className
        ),
        ...props
      }
    )
  );
  TableRow.displayName = "TableRow";
  const TableHead = React.forwardRef(
    ({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "th",
      {
        ref,
        className: classNames(
          " px-4 text-left align-middle font-[600] text-muted-foreground [&:has([role=checkbox])]:pr-0",
          className
        ),
        ...props
      }
    )
  );
  TableHead.displayName = "TableHead";
  const TableCell = React.forwardRef(
    ({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "td",
      {
        ref,
        className: classNames("px-4 py-3 align-middle [&:has([role=checkbox])]:pr-0 border-b", className),
        ...props
      }
    )
  );
  TableCell.displayName = "TableCell";
  const TableCaption = React.forwardRef(
    ({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "caption",
      {
        ref,
        className: classNames("mt-4 text-sm text-muted-foreground", className),
        ...props
      }
    )
  );
  TableCaption.displayName = "TableCaption";
  const FilesSkeleton = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg mt-2 border dark:border-none  bg-cleanWhite dark:bg-dark-300 md:p-4 p-2 !pb-0", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between mb-6 items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            placeholder: "Search...",
            height: "semiMedium",
            value: "",
            icon: SearchIcon
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { variant: !recorBtnCustom ? "default" : "create", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "mr-2", children: [
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(IconPlus, { className: "!w-3 !h-3" }),
              " "
            ] }),
            " New Folder"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { variant: !recorBtnCustom ? "default" : "create", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "mr-2", children: [
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(IconPlus, { className: "!w-3 !h-3" }),
              " "
            ] }),
            " New File"
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex md:flex-row text-xs dark:text-white flex-col-reverse justify-between gap-2 md:items-center ", children: "Home" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-xl font-semibold mb-4 dark:text-white", children: "Home" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "table-container  overflow-auto  rounded-md ", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { className: "w-full dark:bg-[#2a2a2a]", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableHeader, { className: "bg-gray-100 text-left dark:bg-dark-500", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { className: "px-4 py-2 dark:border-gray-600 whitespace-nowrap dark:text-white dark:bg-dark-500 text-xs" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { className: "px-4 py-2 dark:border-gray-600 whitespace-nowrap dark:text-white dark:bg-dark-500 text-xs", children: "Name" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { className: "px-4 py-2 dark:border-gray-600 whitespace-nowrap dark:text-white dark:bg-dark-500 text-xs text-left", children: "File Type" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { className: "px-4 py-2 dark:border-gray-600 whitespace-nowrap dark:text-white dark:bg-dark-500 text-xs text-left", children: "Size" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { className: "px-4 py-2 dark:border-gray-600 whitespace-nowrap dark:text-white dark:bg-dark-500 text-xs" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { children: [...Array(10)].map((_2, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx(TableRow, { className: `animate-pulse border-t dark:border-gray-600 relative cursor-pointer hover:bg-gray-200 dark:hover:bg-dark-300`, children: [...Array(5)].map((_22, j2) => /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "px-4 py-2 dark:border-gray-600 whitespace-nowrap text-xs dark:text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-4 w-full bg-gray-200 dark:bg-dark-white dark:bg-opacity-20 rounded-md" }) }, j2)) })) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-4 w-48 bg-gray-200 rounded-md animate-pulse" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-8 w-8 bg-gray-300 dark:bg-dark-white dark:bg-opacity-20 rounded-md animate-pulse" }),
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-6 w-6 bg-gray-300 dark:bg-dark-white dark:bg-opacity-20 rounded-md animate-pulse" }),
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-8 w-8 bg-gray-300 dark:bg-dark-white dark:bg-opacity-20 rounded-md animate-pulse" }),
            " "
          ] })
        ] })
      ] })
    ] }) });
  };
  const FileBreadcrumb = ({ id, folderStack, onClick }) => /* @__PURE__ */ jsxRuntimeExports.jsx("nav", { className: "text-xs", children: /* @__PURE__ */ jsxRuntimeExports.jsx("ol", { className: "flex flex-wrap", children: folderStack && folderStack.length > 0 ? folderStack.map((folder, index) => {
    if (folder && folder.name) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: `dark:text-white ${index !== folderStack.length - 1 ? "hover:text-secondary hover:underline underline-offset-4 cursor-pointer" : ""}`,
            onClick: () => onClick(index),
            children: folder.name != id ? folder.name : "Home"
          }
        ),
        index < folderStack.length - 1 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mx-1 dark:text-cleanWhite", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "svg",
          {
            width: "8",
            height: "10",
            viewBox: "0 0 5 7",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M1 6.5L4 3.5L1 0.5",
                stroke: "currentcolor",
                strokeLinecap: "round",
                strokeLinejoin: "round"
              }
            )
          }
        ) })
      ] }, index);
    } else {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dark:text-cleanWhite cursor-default", children: "No Folder" }),
        index < folderStack.length - 1 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mx-1 dark:text-cleanWhite", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "svg",
          {
            width: "8",
            height: "10",
            viewBox: "0 0 5 7",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M1 6.5L4 3.5L1 0.5",
                stroke: "currentcolor",
                strokeLinecap: "round",
                strokeLinejoin: "round"
              }
            )
          }
        ) })
      ] }, index);
    }
  }) : /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "text-gray-500", children: "Root" }) }) });
  const getIcon$1 = (filename, heightInPx = "24px", widthInPx = "24px") => {
    const extension = filename.split(".").pop().toLowerCase();
    switch (extension) {
      case "pdf":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "svg",
          {
            height: heightInPx,
            width: widthInPx,
            fill: "currentColor",
            viewBox: "0 0 16 16",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                fillRule: "evenodd",
                d: "M14 4.5V14a2 2 0 0 1-2 2h-1v-1h1a1 1 0 0 0 1-1V4.5h-2A1.5 1.5 0 0 1 9.5 3V1H4a1 1 0 0 0-1 1v9H2V2a2 2 0 0 1 2-2h5.5zM1.6 11.85H0v3.999h.791v-1.342h.803q.43 0 .732-.173.305-.175.463-.474a1.4 1.4 0 0 0 .161-.677q0-.375-.158-.677a1.2 1.2 0 0 0-.46-.477q-.3-.18-.732-.179m.545 1.333a.8.8 0 0 1-.085.38.57.57 0 0 1-.238.241.8.8 0 0 1-.375.082H.788V12.48h.66q.327 0 .512.181.185.183.185.522m1.217-1.333v3.999h1.46q.602 0 .998-.237a1.45 1.45 0 0 0 .595-.689q.196-.45.196-1.084 0-.63-.196-1.075a1.43 1.43 0 0 0-.589-.68q-.396-.234-1.005-.234zm.791.645h.563q.371 0 .609.152a.9.9 0 0 1 .354.454q.118.302.118.753a2.3 2.3 0 0 1-.068.592 1.1 1.1 0 0 1-.196.422.8.8 0 0 1-.334.252 1.3 1.3 0 0 1-.483.082h-.563zm3.743 1.763v1.591h-.79V11.85h2.548v.653H7.896v1.117h1.606v.638z"
              }
            )
          }
        );
      case "doc":
      case "docx":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "svg",
          {
            height: heightInPx,
            width: widthInPx,
            fill: "currentColor",
            viewBox: "0 0 16 16",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                fillRule: "evenodd",
                d: "M14 4.5V14a2 2 0 0 1-2 2v-1a1 1 0 0 0 1-1V4.5h-2A1.5 1.5 0 0 1 9.5 3V1H4a1 1 0 0 0-1 1v9H2V2a2 2 0 0 1 2-2h5.5zm-7.839 9.166v.522q0 .384-.117.641a.86.86 0 0 1-.322.387.9.9 0 0 1-.469.126.9.9 0 0 1-.471-.126.87.87 0 0 1-.32-.386 1.55 1.55 0 0 1-.117-.642v-.522q0-.386.117-.641a.87.87 0 0 1 .32-.387.87.87 0 0 1 .471-.129q.264 0 .469.13a.86.86 0 0 1 .322.386q.117.255.117.641m.803.519v-.513q0-.565-.205-.972a1.46 1.46 0 0 0-.589-.63q-.381-.22-.917-.22-.533 0-.92.22a1.44 1.44 0 0 0-.589.627q-.204.406-.205.975v.513q0 .563.205.973.205.406.59.627.386.216.92.216.535 0 .916-.216.383-.22.59-.627.204-.41.204-.973M0 11.926v4h1.459q.603 0 .999-.238a1.45 1.45 0 0 0 .595-.689q.196-.45.196-1.084 0-.63-.196-1.075a1.43 1.43 0 0 0-.59-.68q-.395-.234-1.004-.234zm.791.645h.563q.371 0 .609.152a.9.9 0 0 1 .354.454q.118.302.118.753a2.3 2.3 0 0 1-.068.592 1.1 1.1 0 0 1-.196.422.8.8 0 0 1-.334.252 1.3 1.3 0 0 1-.483.082H.79V12.57zm7.422.483a1.7 1.7 0 0 0-.103.633v.495q0 .369.103.627a.83.83 0 0 0 .298.393.85.85 0 0 0 .478.131.9.9 0 0 0 .401-.088.7.7 0 0 0 .273-.248.8.8 0 0 0 .117-.364h.765v.076a1.27 1.27 0 0 1-.226.674q-.205.29-.55.454a1.8 1.8 0 0 1-.786.164q-.54 0-.914-.216a1.4 1.4 0 0 1-.571-.627q-.194-.408-.194-.976v-.498q0-.568.197-.978.195-.411.571-.633.378-.223.911-.223.328 0 .607.097.28.093.489.272a1.33 1.33 0 0 1 .466.964v.073H9.78a.85.85 0 0 0-.12-.38.7.7 0 0 0-.273-.261.8.8 0 0 0-.398-.097.8.8 0 0 0-.475.138.87.87 0 0 0-.301.398"
              }
            )
          }
        );
      case "xls":
      case "xlsx":
      case "xlsm":
      case "xltx":
      case "csv":
      case "xltm":
      case "xlsb":
      case "xlam":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "svg",
          {
            height: heightInPx,
            width: widthInPx,
            fill: "currentColor",
            viewBox: "0 0 16 16",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                fillRule: "evenodd",
                d: "M14 4.5V14a2 2 0 0 1-2 2h-1v-1h1a1 1 0 0 0 1-1V4.5h-2A1.5 1.5 0 0 1 9.5 3V1H4a1 1 0 0 0-1 1v9H2V2a2 2 0 0 1 2-2h5.5zM6.472 15.29a1.2 1.2 0 0 1-.111-.449h.765a.58.58 0 0 0 .254.384q.106.073.25.114.143.041.319.041.246 0 .413-.07a.56.56 0 0 0 .255-.193.5.5 0 0 0 .085-.29.39.39 0 0 0-.153-.326q-.152-.12-.462-.193l-.619-.143a1.7 1.7 0 0 1-.539-.214 1 1 0 0 1-.351-.367 1.1 1.1 0 0 1-.123-.524q0-.366.19-.639.19-.272.527-.422.338-.15.777-.149.457 0 .78.152.324.153.5.41.18.255.2.566h-.75a.56.56 0 0 0-.12-.258.6.6 0 0 0-.247-.181.9.9 0 0 0-.369-.068q-.325 0-.513.152a.47.47 0 0 0-.184.384q0 .18.143.3a1 1 0 0 0 .405.175l.62.143q.326.075.566.211a1 1 0 0 1 .375.358q.135.222.135.56 0 .37-.188.656a1.2 1.2 0 0 1-.539.439q-.351.158-.858.158-.381 0-.665-.09a1.4 1.4 0 0 1-.478-.252 1.1 1.1 0 0 1-.29-.375m-2.945-3.358h-.893L1.81 13.37h-.036l-.832-1.438h-.93l1.227 1.983L0 15.931h.861l.853-1.415h.035l.85 1.415h.908L2.253 13.94zm2.727 3.325H4.557v-3.325h-.79v4h2.487z"
              }
            )
          }
        );
      case "ppt":
      case "pptx":
      case "potx":
      case "pot":
      case "pptm":
      case "potm":
      case "ppsx":
      case "pps":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "svg",
          {
            height: heightInPx,
            width: widthInPx,
            fill: "currentColor",
            viewBox: "0 0 16 16",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 5.5a1 1 0 0 0-1 1V13a.5.5 0 0 0 1 0v-2h1.188a2.75 2.75 0 0 0 0-5.5zM8.188 10H7V6.5h1.188a1.75 1.75 0 1 1 0 3.5" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14 4.5V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h5.5zm-3 0A1.5 1.5 0 0 1 9.5 3V1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4.5z" })
            ]
          }
        );
      case "jpg":
      case "jpeg":
      case "png":
      case "jfif":
      case "webp":
      case "gif":
      case "bmp":
      case "tiff":
      case "heif":
      case "svg":
      case "eps":
      case "raw":
      case "psd":
      case "ico":
      case "exr":
      case "ai":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "svg",
          {
            height: heightInPx,
            width: widthInPx,
            fill: "currentColor",
            viewBox: "0 0 16 16",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M6.502 7a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14 14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h5.5L14 4.5zM4 1a1 1 0 0 0-1 1v10l2.224-2.224a.5.5 0 0 1 .61-.075L8 11l2.157-3.02a.5.5 0 0 1 .76-.063L13 10V4.5h-2A1.5 1.5 0 0 1 9.5 3V1z" })
            ]
          }
        );
      case "mp3":
      case "aac":
      case "ogg":
      case "wma":
      case "m4a":
      case "flac":
      case "wv":
      case "wav":
      case "aiff":
      case "opus":
      case "amr":
      case "dts":
      case "ac3":
      case "mid":
      case "midi":
      case "pcm":
      case "au":
      case "caf":
      case "bwf":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "svg",
          {
            height: heightInPx,
            width: widthInPx,
            fill: "currentColor",
            viewBox: "0 0 384 512",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M64 464h256c8.8 0 16-7.2 16-16V160h-80c-17.7 0-32-14.3-32-32V48H64c-8.8 0-16 7.2-16 16v384c0 8.8 7.2 16 16 16zM0 64C0 28.7 28.7 0 64 0h165.5c17 0 33.3 6.7 45.3 18.7l90.5 90.5c12 12 18.7 28.3 18.7 45.3V448c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V64zm192 208v128c0 6.5-3.9 12.3-9.9 14.8s-12.9 1.1-17.4-3.5L129.4 376H112c-8.8 0-16-7.2-16-16v-48c0-8.8 7.2-16 16-16h17.4l35.3-35.3c4.6-4.6 11.5-5.9 17.4-3.5s9.9 8.3 9.9 14.8zm85.8-4c11.6 20 18.2 43.3 18.2 68s-6.6 48-18.2 68c-6.6 11.5-21.3 15.4-32.8 8.8s-15.4-21.3-8.8-32.8c7.5-12.9 11.8-27.9 11.8-44s-4.3-31.1-11.8-44c-6.6-11.5-2.7-26.2 8.8-32.8s26.2-2.7 32.8 8.8z" })
          }
        );
      case "mp4":
      case "wmv":
      case "flv":
      case "m4v":
      case "avi":
      case "mov":
      case "mxf":
      case "mpg":
      case "mpeg":
      case "asf":
      case "ogv":
      case "swf":
      case "mkv":
      case "webm":
      case "yuv":
      case "dpx":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "svg",
          {
            height: heightInPx,
            width: widthInPx,
            fill: "currentColor",
            viewBox: "0 0 16 16",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                fillRule: "evenodd",
                d: "M0 5a2 2 0 0 1 2-2h7.5a2 2 0 0 1 1.983 1.738l3.11-1.382A1 1 0 0 1 16 4.269v7.462a1 1 0 0 1-1.406.913l-3.111-1.382A2 2 0 0 1 9.5 13H2a2 2 0 0 1-2-2zm11.5 5.175 3.5 1.556V4.269l-3.5 1.556zM2 4a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h7.5a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1z"
              }
            )
          }
        );
      case "folder":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "svg",
          {
            height: heightInPx,
            width: widthInPx,
            fill: "currentColor",
            viewBox: "0 0 16 16",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1 3.5A1.5 1.5 0 0 1 2.5 2h2.764c.958 0 1.76.56 2.311 1.184C7.985 3.648 8.48 4 9 4h4.5A1.5 1.5 0 0 1 15 5.5v.64c.57.265.94.876.856 1.546l-.64 5.124A2.5 2.5 0 0 1 12.733 15H3.266a2.5 2.5 0 0 1-2.481-2.19l-.64-5.124A1.5 1.5 0 0 1 1 6.14zM2 6h12v-.5a.5.5 0 0 0-.5-.5H9c-.964 0-1.71-.629-2.174-1.154C6.374 3.334 5.82 3 5.264 3H2.5a.5.5 0 0 0-.5.5zm-.367 1a.5.5 0 0 0-.496.562l.64 5.124A1.5 1.5 0 0 0 3.266 14h9.468a1.5 1.5 0 0 0 1.489-1.314l.64-5.124A.5.5 0 0 0 14.367 7z" })
          }
        );
      default:
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "svg",
          {
            height: heightInPx,
            width: widthInPx,
            fill: "currentColor",
            viewBox: "0 0 16 16",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 4a.5.5 0 0 0 0 1h6a.5.5 0 0 0 0-1zm-.5 2.5A.5.5 0 0 1 5 6h6a.5.5 0 0 1 0 1H5a.5.5 0 0 1-.5-.5M5 8a.5.5 0 0 0 0 1h6a.5.5 0 0 0 0-1zm0 2a.5.5 0 0 0 0 1h3a.5.5 0 0 0 0-1z" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2zm10-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1" })
            ]
          }
        );
    }
  };
  const FileUpload = ({ fileId, refetch, folderId, onClose, setToaster, objectId, id }) => {
    var _a2;
    const [selectedFile, setSelectedFile] = reactExports.useState([]);
    const [files, setFiles] = reactExports.useState([]);
    const [isUploading, setIsUploading] = reactExports.useState(false);
    useMe$1();
    const [file, setFile] = reactExports.useState(null);
    const [uploadProgress, setUploadProgress] = reactExports.useState(0);
    const [uploadStatus, setUploadStatus] = reactExports.useState("");
    const generateUniqueId = () => {
      return `${Date.now()}-${Math.floor(Math.random() * 1e3)}`;
    };
    const inputChange = (e) => {
      const file2 = e.target.files[0];
      setFile(file2);
      let validFilesArray = [];
      validFilesArray.push(file2);
      const reader = new FileReader();
      reader.onloadend = () => {
        setSelectedFile((prevValue) => [
          // ...prevValue,
          {
            id: generateUniqueId(),
            filename: file2.name,
            filetype: file2.type,
            fileimage: reader.result
          }
        ]);
      };
      if (file2) {
        reader.readAsDataURL(file2);
      }
      if (validFilesArray.length > 0) {
        e.target.value = "";
      }
      return;
    };
    const deleteSelectFile = (id2) => {
      if (window.confirm("Are you sure you want to delete this file?")) {
        const result = selectedFile.filter((data) => data.id !== id2);
        setSelectedFile(result);
      }
    };
    const portalId = (_a2 = getPortal()) == null ? void 0 : _a2.portalId;
    useMutation({
      mutationFn: async (fileData) => {
        const parentFolder = folderId === fileId ? "obj-root" : folderId;
        const payload = {
          parentFolderId: parentFolder,
          fileName: fileData.fileName,
          fileData: fileData.fileData
        };
        await Client.files.uploadFile({
          objectId,
          id,
          portalId,
          fileData: payload
        });
      },
      onSuccess: () => {
        setFiles((prevValue) => [...prevValue, ...selectedFile]);
        setSelectedFile([]);
        setIsUploading(false);
        setToaster({
          message: "Files uploaded successfully!",
          type: "success",
          show: true
        });
        refetch();
        onClose();
      },
      onError: (error) => {
        console.error("Error uploading files:", error);
        setIsUploading(false);
        setToaster({
          message: "Error uploading files!",
          type: "error",
          show: true
        });
        onClose();
      }
    });
    const fileUploadSubmit = async (e) => {
      setIsUploading(true);
      e.preventDefault();
      if (!file) {
        alert("Please select a file to upload.");
        return;
      }
      const token = getAuthToken();
      const formData = new FormData();
      formData.append("file", file);
      const parentFolder = folderId === fileId ? "obj-root" : folderId;
      const url = env$1.VITE_PUBLIC_REST_API_ENDPOINT + `/api/${hubId}/${portalId}/hubspot-object-files/${objectId}/${id}?parentFolderId=${parentFolder}`;
      try {
        const response = await axios.post(url, formData, {
          headers: {
            "Content-Type": "multipart/form-data",
            Authorization: `Bearer ${token}`
          },
          onUploadProgress: (progressEvent) => {
            const percentCompleted = Math.round(
              progressEvent.loaded * 100 / progressEvent.total
            );
            setUploadProgress(percentCompleted);
          }
        });
        setFiles((prevValue) => [...prevValue, ...selectedFile]);
        setSelectedFile([]);
        setIsUploading(false);
        setToaster({
          message: "Files uploaded successfully!",
          type: "success",
          show: true
        });
        refetch();
        onClose();
      } catch (error) {
        console.error("Upload Error:", error);
        setIsUploading(false);
        setToaster({
          message: "Error uploading files!",
          type: "error",
          show: true
        });
        onClose();
      }
      return;
    };
    const truncateText = (text2, maxLength) => {
      if (text2.length > maxLength) {
        return text2.substring(0, maxLength) + "...";
      }
      return text2;
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fileupload-view relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row justify-center m-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-md-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card-body", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "kb-data-box lg:w-[480px] md:w-[410px] w-[calc(100vw-60px)] flex flex-col justify-start", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "kb-modal-data-title", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "kb-data-title", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg text-start font-semibold dark:text-white", children: "File Upload" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: fileUploadSubmit, className: `max-w-screen !mb-0  ${isUploading ? "cursor-not-allowed ..." : "cursor-auto"}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `kb-file-upload  ${isUploading ? "cursor-not-allowed ..." : "cursor-auto"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `file-upload-box dark:bg-dark-300 dark:text-white ${isUploading ? "cursor-not-allowed ..." : "cursor-auto"}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "file",
              id: "fileupload",
              className: "file-upload-input",
              onChange: inputChange,
              disabled: isUploading
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: " Drag and drop " }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: " or " }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `px-6 py-2 text-sm font-medium rounded-md !mt-3 ${isUploading ? `border border-gray-300 text-gray-300 dark:border-gray-300 dark:text-gray-300 cursor-not-allowed ...` : `border border-secondary text-secondary dark:border-white dark:text-white`}`, children: "Browse" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "kb-attach-box mb-3  scrollbar", children: selectedFile.map((data) => {
          const { id: id2, filename } = data;
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: "file-atc-box border border-gray-300 rounded-sm shadow-md p-2 mb-2 flex-col",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "file-detail flex items-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dark:text-white", children: getIcon$1(filename) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mx-2 text-sm dark:text-white font-medium text-left", children: truncateText(filename, 80) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "file-actions ml-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      type: "button",
                      className: `file-action-btn dark:text-white text-red-600 mr-0 ${isUploading ? "hidden" : ""}`,
                      onClick: () => deleteSelectFile(id2),
                      disabled: isUploading,
                      children: "Delete"
                    }
                  ) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `transition-all w-[100%] duration-300 ${isUploading ? "opacity-100" : "opacity-0"} overflow-hidden`, children: [
                  isUploading && uploadProgress < 90 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full bg-gray-200 rounded-sm overflow-hidden h-3 mt-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      className: `h-3 bg-secondary dark:bg-dark-400 transition-all duration-300 w-[${uploadProgress + 10}%]`
                    }
                  ) }) : null,
                  isUploading && uploadProgress > 90 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "meter", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {}) }) : null
                ] })
              ]
            },
            id2
          );
        }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3 justify-end", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "outline",
              onClick: onClose,
              disabled: isUploading,
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "submit",
              disabled: selectedFile.length === 0 || isUploading,
              isLoading: isUploading,
              children: "Upload"
            }
          )
        ] })
      ] })
    ] }) }) }) }) }) });
  };
  const FolderUpload = ({
    isOpen,
    onClose,
    refetch,
    folderId,
    fileId,
    setToaster,
    objectId,
    id
  }) => {
    var _a2;
    useMe$1();
    const [newFolderName, setNewFolderName] = reactExports.useState("");
    const portalId = (_a2 = getPortal()) == null ? void 0 : _a2.portalId;
    const createFolderMutation = useMutation({
      mutationFn: async (payload) => {
        await Client.files.createAfolder({
          objectId,
          id,
          portalId,
          fileData: payload
        });
      },
      onSuccess: () => {
        setToaster({
          message: "Folder created successfully!",
          type: "success",
          show: true
        });
        refetch();
        setNewFolderName("");
        onClose();
      },
      onError: (error) => {
        console.error("Error creating folder:", error);
        setToaster({
          message: "Error creating folder!",
          type: "error",
          show: true
        });
        onClose();
      }
    });
    const handleCreateFolder = () => {
      if (newFolderName.trim() === "") {
        setToaster({
          message: "Folder name cannot be empty!",
          type: "error",
          show: true
        });
        return;
      }
      const parentFolder = fileId === folderId ? "obj-root" : folderId;
      const payload = {
        parentFolderId: parentFolder,
        folderName: newFolderName
      };
      createFolderMutation.mutate(payload);
    };
    const isValidFolderName = (name) => {
      const regex = /^[a-zA-Z0-9 ]+$/;
      return regex.test(name);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Dialog,
      {
        open: isOpen,
        onClose: () => {
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "flex relative items-center justify-center",
            onClick: (e) => e.stopPropagation(),
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-cleanWhite lg:w-[480px] md:w-[410px] w-[calc(100vw-60px)] flex flex-col justify-start dark:bg-dark-200", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg text-start font-semibold mb-4 dark:text-white", children: "New Folder" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: newFolderName,
                  onChange: (e) => setNewFolderName(e.target.value),
                  className: "w-full rounded-md bg-cleanWhite px-2 text-sm transition-colors border-2 dark:border-gray-600 focus:ring-0 focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 dark:bg-gray-700 dark:text-gray-200 dark:placeholder-gray-400 py-2",
                  placeholder: "Folder Name"
                }
              ),
              newFolderName && !isValidFolderName(newFolderName) && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mt-2 text-sm text-red-600 dark:text-red-500", children: "Only allow letters, numbers, and spaces" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4 flex items-center gap-3 justify-end", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    className: "dark:text-white",
                    onClick: onClose,
                    variant: "outline",
                    disabled: createFolderMutation.isLoading,
                    children: "Cancel"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    onClick: handleCreateFolder,
                    disabled: createFolderMutation.isLoading || newFolderName.trim() === "" || !isValidFolderName(newFolderName),
                    isLoading: createFolderMutation.isLoading,
                    children: "Create"
                  }
                )
              ] })
            ] })
          }
        )
      }
    );
  };
  const EmptyDeal = ({ width = "150px", height = "150px", ...props }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { ...props, viewBox: "0 0 190 97", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M122.783 63H41.2264C37.7616 63 34.9528 60.1794 34.9528 56.7C34.9528 53.2206 37.7616 50.4 41.2264 50.4H6.27358C2.80878 50.4 0 47.5794 0 44.1C0 40.6206 2.80878 37.8 6.27358 37.8H42.1226C45.5874 37.8 48.3962 34.9794 48.3962 31.5C48.3962 28.0206 45.5874 25.2 42.1226 25.2H19.717C16.2522 25.2 13.4434 22.3794 13.4434 18.9C13.4434 15.4206 16.2522 12.6 19.717 12.6H55.566C52.1012 12.6 49.2925 9.77939 49.2925 6.3C49.2925 2.82061 52.1012 0 55.566 0L106.651 0C110.116 0 112.925 2.82061 112.925 6.3C112.925 9.77939 110.116 12.6 106.651 12.6H164.009C167.474 12.6 170.283 15.4206 170.283 18.9C170.283 22.3794 167.474 25.2 164.009 25.2H183.726C187.191 25.2 190 28.0206 190 31.5C190 34.9794 187.191 37.8 183.726 37.8H166.698C163.233 37.8 160.425 40.6206 160.425 44.1C160.425 47.5794 163.233 50.4 166.698 50.4H172.075C175.54 50.4 178.349 53.2206 178.349 56.7C178.349 60.1794 175.54 63 172.075 63H125.472C125.01 63 124.56 62.95 124.127 62.855C123.694 62.95 123.244 63 122.783 63Z", fill: "url(#paint0_radial_6748_3935)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { filter: "url(#filter0_d_6748_3935)", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "131", y: "5", width: "21", height: "19", rx: "5", fill: "white" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "137.455", y: "11.6221", width: "1.46656", height: "9.53263", transform: "rotate(-45 137.455 11.6221)", fill: "#AE1D00" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "144.418", y: "10.4409", width: "1.46656", height: "9.53263", transform: "rotate(45 144.418 10.4409)", fill: "#AE1D00" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M131 25.2338V18.5L136 24L132.514 26.0913C131.848 26.4912 131 26.0111 131 25.2338Z", fill: "white" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M137.5 37.5V40.9513C137.5 42.5524 136.733 44.0567 135.438 44.9974L65.8139 95.5461C64.9599 96.1661 63.9317 96.5 62.8763 96.5H62C59.2386 96.5 57 94.2614 57 91.5V29C57 26.2386 59.2386 24 62 24H84.705C87.4664 24 89.705 26.2386 89.705 29V29.5C89.705 31.1569 91.0481 32.5 92.705 32.5H132.5C135.261 32.5 137.5 34.7386 137.5 37.5Z", fill: "url(#paint1_linear_6748_3935)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M133.228 96.5H63.6896C60.3494 96.5 57.9484 93.2877 58.8942 90.0842L71.4418 47.5842C72.0693 45.4588 74.021 44 76.2372 44H145.371C148.693 44 151.092 47.1795 150.179 50.3736L138.036 92.8736C137.423 95.0201 135.461 96.5 133.228 96.5Z", fill: "url(#paint2_linear_6748_3935)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("filter", { id: "filter0_d_6748_3935", x: "129", y: "5", width: "23", height: "25.2354", filterUnits: "userSpaceOnUse", "color-interpolation-filters": "sRGB", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("feFlood", { "flood-opacity": "0", result: "BackgroundImageFix" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feColorMatrix", { in: "SourceAlpha", type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0", result: "hardAlpha" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feOffset", { dx: "-2", dy: "4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feComposite", { in2: "hardAlpha", operator: "out" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feColorMatrix", { type: "matrix", values: "0 0 0 0 0.988235 0 0 0 0 0.466667 0 0 0 0 0.337255 0 0 0 0.25 0" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feBlend", { mode: "normal", in2: "BackgroundImageFix", result: "effect1_dropShadow_6748_3935" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feBlend", { mode: "normal", in: "SourceGraphic", in2: "effect1_dropShadow_6748_3935", result: "shape" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("radialGradient", { id: "paint0_radial_6748_3935", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(43.3696 48.2087) rotate(-11.2805) scale(107.822 35.8345)", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { "stop-color": "#FC7756" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", "stop-color": "#FFCE78" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "paint1_linear_6748_3935", x1: "97.25", y1: "24", x2: "97.25", y2: "96.5", gradientUnits: "userSpaceOnUse", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { "stop-color": "#98D9E4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", "stop-color": "#0091AE" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "paint2_linear_6748_3935", x1: "104.5", y1: "44", x2: "104.5", y2: "96.5", gradientUnits: "userSpaceOnUse", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { "stop-color": "#E5F5F8" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", "stop-color": "#98D9E4" })
        ] })
      ] })
    ] });
  };
  const EmptyIcon = ({ width = "1em", height = "1em", ...props }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { ...props, viewBox: "0 0 190 141", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M122.783 63H41.2264C37.7616 63 34.9528 60.1794 34.9528 56.7C34.9528 53.2206 37.7616 50.4 41.2264 50.4H6.27358C2.80878 50.4 0 47.5794 0 44.1C0 40.6206 2.80878 37.8 6.27358 37.8H42.1226C45.5874 37.8 48.3962 34.9794 48.3962 31.5C48.3962 28.0206 45.5874 25.2 42.1226 25.2H19.717C16.2522 25.2 13.4434 22.3794 13.4434 18.9C13.4434 15.4206 16.2522 12.6 19.717 12.6H55.566C52.1012 12.6 49.2925 9.77939 49.2925 6.3C49.2925 2.82061 52.1012 0 55.566 0L106.651 0C110.116 0 112.925 2.82061 112.925 6.3C112.925 9.77939 110.116 12.6 106.651 12.6H164.009C167.474 12.6 170.283 15.4206 170.283 18.9C170.283 22.3794 167.474 25.2 164.009 25.2H183.726C187.191 25.2 190 28.0206 190 31.5C190 34.9794 187.191 37.8 183.726 37.8H166.698C163.233 37.8 160.425 40.6206 160.425 44.1C160.425 47.5794 163.233 50.4 166.698 50.4H172.075C175.54 50.4 178.349 53.2206 178.349 56.7C178.349 60.1794 175.54 63 172.075 63H125.472C125.01 63 124.56 62.95 124.127 62.855C123.694 62.95 123.244 63 122.783 63Z", fill: "url(#paint0_radial_6748_4684)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { filter: "url(#filter0_d_6748_4684)", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "131", y: "5", width: "21", height: "19", rx: "5", fill: "white" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "137.455", y: "11.6221", width: "1.46656", height: "9.53263", transform: "rotate(-45 137.455 11.6221)", fill: "#AE1D00" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "144.418", y: "10.4409", width: "1.46656", height: "9.53263", transform: "rotate(45 144.418 10.4409)", fill: "#AE1D00" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M131 25.2338V18.5L136 24L132.514 26.0913C131.848 26.4912 131 26.0111 131 25.2338Z", fill: "white" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "86.5508", y: "92.1035", width: "7", height: "11.0713", transform: "rotate(29.1386 86.5508 92.1035)", fill: "#0091AE" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "105.462", cy: "61.2526", r: "37.2526", fill: "url(#paint1_radial_6748_4684)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "105.461", cy: "61.2526", r: "31.3185", fill: "url(#paint2_linear_6748_4684)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M60.1638 129.325C60.7644 128.33 78.3068 100.75 78.3068 100.75C78.6946 100.352 79.795 99.5418 81.0947 99.4871C83.4666 99.6494 88.5212 100.92 89.764 104.704C89.764 104.704 75.0408 136.822 74.5353 137.952C74.0298 139.082 72.6249 139.164 72.6249 139.164C69.9189 139.393 63.3351 135.187 60.3815 133.055C59.6327 131.803 59.5631 130.321 60.1638 129.325Z", fill: "url(#paint3_linear_6748_4684)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("filter", { id: "filter0_d_6748_4684", x: "129", y: "5", width: "23", height: "25.2354", filterUnits: "userSpaceOnUse", "color-interpolation-filters": "sRGB", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("feFlood", { "flood-opacity": "0", result: "BackgroundImageFix" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feColorMatrix", { in: "SourceAlpha", type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0", result: "hardAlpha" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feOffset", { dx: "-2", dy: "4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feComposite", { in2: "hardAlpha", operator: "out" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feColorMatrix", { type: "matrix", values: "0 0 0 0 0.988235 0 0 0 0 0.466667 0 0 0 0 0.337255 0 0 0 0.25 0" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feBlend", { mode: "normal", in2: "BackgroundImageFix", result: "effect1_dropShadow_6748_4684" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feBlend", { mode: "normal", in: "SourceGraphic", in2: "effect1_dropShadow_6748_4684", result: "shape" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("radialGradient", { id: "paint0_radial_6748_4684", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(43.3696 48.2087) rotate(-11.2805) scale(107.822 81.7792)", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { "stop-color": "#FC7756" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", "stop-color": "#FFCE78" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("radialGradient", { id: "paint1_radial_6748_4684", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(105.462 61.2526) rotate(90) scale(37.2526 37.4615)", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0.699227", "stop-color": "#98D9E4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0.934", "stop-color": "#0091AE" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "paint2_linear_6748_4684", x1: "123.263", y1: "29.9341", x2: "90.2963", y2: "92.5711", gradientUnits: "userSpaceOnUse", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { "stop-color": "#98D9E4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", "stop-color": "#F1F3FF" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "paint3_linear_6748_4684", x1: "86.2322", y1: "125.258", x2: "70.4709", y2: "112.655", gradientUnits: "userSpaceOnUse", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { "stop-color": "#0091AE" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", "stop-color": "#98D9E4" })
        ] })
      ] })
    ] });
  };
  const EmptyThree = ({ width = "1em", height = "1em", ...props }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { ...props, viewBox: "0 0 190 125", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M122.783 63H41.2264C37.7616 63 34.9528 60.1794 34.9528 56.7C34.9528 53.2206 37.7616 50.4 41.2264 50.4H6.27358C2.80878 50.4 0 47.5794 0 44.1C0 40.6206 2.80878 37.8 6.27358 37.8H42.1226C45.5874 37.8 48.3962 34.9794 48.3962 31.5C48.3962 28.0206 45.5874 25.2 42.1226 25.2H19.717C16.2522 25.2 13.4434 22.3794 13.4434 18.9C13.4434 15.4206 16.2522 12.6 19.717 12.6H55.566C52.1012 12.6 49.2925 9.77939 49.2925 6.3C49.2925 2.82061 52.1012 0 55.566 0L106.651 0C110.116 0 112.925 2.82061 112.925 6.3C112.925 9.77939 110.116 12.6 106.651 12.6H164.009C167.474 12.6 170.283 15.4206 170.283 18.9C170.283 22.3794 167.474 25.2 164.009 25.2H183.726C187.191 25.2 190 28.0206 190 31.5C190 34.9794 187.191 37.8 183.726 37.8H166.698C163.233 37.8 160.425 40.6206 160.425 44.1C160.425 47.5794 163.233 50.4 166.698 50.4H172.075C175.54 50.4 178.349 53.2206 178.349 56.7C178.349 60.1794 175.54 63 172.075 63H125.472C125.01 63 124.56 62.95 124.127 62.855C123.694 62.95 123.244 63 122.783 63Z", fill: "url(#paint0_radial_6750_4805)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { filter: "url(#filter0_d_6750_4805)", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "131", y: "5", width: "21", height: "19", rx: "5", fill: "white" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "137.455", y: "11.6221", width: "1.46656", height: "9.53263", transform: "rotate(-45 137.455 11.6221)", fill: "#AE1D00" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "144.418", y: "10.4409", width: "1.46656", height: "9.53263", transform: "rotate(45 144.418 10.4409)", fill: "#AE1D00" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M131 25.2338V18.5L136 24L132.514 26.0913C131.848 26.4912 131 26.0111 131 25.2338Z", fill: "white" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M122.623 38.0002L131.924 105.843L132.76 112.649C133.029 114.842 131.47 116.838 129.277 117.107L70.7172 124.297C68.5245 124.566 66.5287 123.007 66.2595 120.814L57.2437 47.3869C57.1091 46.2906 57.8888 45.2927 58.9851 45.1581C58.992 45.1573 58.9989 45.1565 59.0059 45.1557L63.8642 44.6107", fill: "url(#paint1_linear_6750_4805)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M126.5 24L79.6221 24C77.4129 24 75.6221 25.7909 75.6221 28V104C75.6221 106.209 77.4129 108 79.6221 108H138.622C140.831 108 142.622 106.209 142.622 104V40L133.832 44.6344C130.502 46.3899 126.5 43.9756 126.5 40.2115V24Z", fill: "url(#paint2_linear_6750_4805)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M142.622 40L126.5 24V40.2115C126.5 43.9756 130.502 46.3899 133.832 44.6344L142.622 40Z", fill: "url(#paint3_linear_6750_4805)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M86.9502 92H112.95M86.9502 41H112.95H86.9502ZM86.9502 53H129.95H86.9502ZM86.9502 66H129.95H86.9502ZM86.9502 79H129.95H86.9502Z", stroke: "#E5F5F8", "stroke-width": "2.5", "stroke-linecap": "round", "stroke-linejoin": "round" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M130.5 40H142.621L126.5 24V36C126.5 38.2091 128.291 40 130.5 40Z", fill: "#E5F5F8" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { filter: "url(#filter1_d_6750_4805)", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "99", y: "58.9531", width: "3.66639", height: "23.8316", transform: "rotate(-45 99 58.9531)", fill: "#AE1D00" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "116.407", y: "56", width: "3.66639", height: "23.8316", transform: "rotate(45 116.407 56)", fill: "#AE1D00" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("filter", { id: "filter0_d_6750_4805", x: "129", y: "5", width: "23", height: "25.2354", filterUnits: "userSpaceOnUse", "color-interpolation-filters": "sRGB", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("feFlood", { "flood-opacity": "0", result: "BackgroundImageFix" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feColorMatrix", { in: "SourceAlpha", type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0", result: "hardAlpha" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feOffset", { dx: "-2", dy: "4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feComposite", { in2: "hardAlpha", operator: "out" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feColorMatrix", { type: "matrix", values: "0 0 0 0 0.988235 0 0 0 0 0.466667 0 0 0 0 0.337255 0 0 0 0.25 0" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feBlend", { mode: "normal", in2: "BackgroundImageFix", result: "effect1_dropShadow_6750_4805" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feBlend", { mode: "normal", in: "SourceGraphic", in2: "effect1_dropShadow_6750_4805", result: "shape" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("filter", { id: "filter1_d_6750_4805", x: "97", y: "56", width: "22", height: "23.8047", filterUnits: "userSpaceOnUse", "color-interpolation-filters": "sRGB", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("feFlood", { "flood-opacity": "0", result: "BackgroundImageFix" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feColorMatrix", { in: "SourceAlpha", type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0", result: "hardAlpha" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feOffset", { dx: "-2", dy: "4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feComposite", { in2: "hardAlpha", operator: "out" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feColorMatrix", { type: "matrix", values: "0 0 0 0 0.988235 0 0 0 0 0.466667 0 0 0 0 0.337255 0 0 0 0.25 0" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feBlend", { mode: "normal", in2: "BackgroundImageFix", result: "effect1_dropShadow_6750_4805" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feBlend", { mode: "normal", in: "SourceGraphic", in2: "effect1_dropShadow_6750_4805", result: "shape" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("radialGradient", { id: "paint0_radial_6750_4805", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(43.3696 48.2087) rotate(-11.2805) scale(107.822 81.7792)", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { "stop-color": "#FC7756" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", "stop-color": "#FFCE78" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "paint1_linear_6750_4805", x1: "143.5", y1: "19", x2: "71", y2: "125", gradientUnits: "userSpaceOnUse", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { "stop-color": "#0091AE" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", "stop-color": "#98D9E4" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "paint2_linear_6750_4805", x1: "109.122", y1: "24", x2: "109.122", y2: "108", gradientUnits: "userSpaceOnUse", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { "stop-color": "#E5F5F8" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0.949583", "stop-color": "#98D9E4" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "paint3_linear_6750_4805", x1: "135", y1: "32", x2: "131.5", y2: "46", gradientUnits: "userSpaceOnUse", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { "stop-color": "#0091AE" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", "stop-color": "#98D9E4" })
        ] })
      ] })
    ] });
  };
  const bulletPointData = [
    '<span class="inline-block font-semibold">Refresh Data:</span> Click the Clear Cache button to update system data. This may fix issues with visibility of new records or associations.',
    '<span class="inline-block font-semibold">Check Associations:</span> Ensure the necessary associations are correctly created for this operation.'
  ];
  const EmptyMessageCard = ({
    name = "item",
    type = "row",
    className = "p-6",
    bulletPoints = bulletPointData,
    imgWidth = "150px"
  }) => {
    const [RandomComponent, setRandomComponent] = reactExports.useState(
      /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyDeal, { width: imgWidth, height: imgWidth }, "deal")
    );
    reactExports.useEffect(() => {
      const components = [
        /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyDeal, { className: `dark:text-white w-[${imgWidth}]` }, "deal"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyIcon, { className: `dark:text-white w-[${imgWidth}]` }, "icon"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyThree, { className: `dark:text-white w-[${imgWidth}]` }, "three")
      ];
      setRandomComponent(
        components[Math.floor(Math.random() * components.length)]
      );
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `w-fit max-w-[600px] mx-auto min-h-48 flex text-[#33475b] ${type === "row" ? "max-sm:flex-col" : "flex-col"} items-center justify-center text-center gap-2 dark:bg-dark-300 rounded-md ${className} `,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `md:min-w-[${imgWidth}] flex items-center justify-center`, children: RandomComponent }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "h2",
              {
                className: `md:text-xl ${type === "row" ? "text-start max-sm:text-center" : "text-center"} text-lg font-semibold dark:text-white capitalize`,
                children: [
                  name,
                  " not found"
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "p",
              {
                className: `md:text-xs ${type === "row" ? "text-start max-sm:text-center" : "text-center"} text-xs dark:text-white font-thin`,
                children: [
                  "You havent created any ",
                  name.toLowerCase(),
                  " yet. Please create one to proceed. For help, check our documentation or contact support."
                ]
              }
            ),
            bulletPoints.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "ul",
              {
                className: `mt-3 text-xs dark:text-white font-thin ${type === "row" ? "list-disc list-inside flex flex-col gap-1" : "list-disc list-inside"}`,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mb-1 text-start font-semibold block", children: "Steps to Resolve:" }),
                  bulletPoints.map((point, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "li",
                    {
                      className: type === "row" ? "text-start" : "text-start",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(HtmlParser, { html: purify.sanitize(point) })
                    },
                    index
                  ))
                ]
              }
            )
          ] })
        ]
      }
    );
  };
  const FileViewer = ({ file }) => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
    const [loading2, setLoading] = reactExports.useState(true);
    const officeViewerUrl = `https://view.officeapps.live.com/op/view.aspx?src=${encodeURIComponent(
      (_a2 = file == null ? void 0 : file.data) == null ? void 0 : _a2.url
    )}`;
    if (!file) return null;
    const fileExtension = (_b2 = file == null ? void 0 : file.data) == null ? void 0 : _b2.extension;
    const handleLoad = () => setLoading(false);
    const LoadingIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 flex items-center justify-center z-50", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "w-14 h-14 rounded-full animate-spin\r\n              border-y-4 border-solid border-t-transparent \r\n              "
      }
    ) });
    if (fileExtension === "mp3" || fileExtension === "wav" || fileExtension === "aac" || fileExtension === "aiff" || fileExtension === "flac" || fileExtension === "ogg") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full  flex justify-center align-center relative", children: [
        loading2 && /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingIcon, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("audio", { controls: true, className: "w-full relative", onLoadedData: handleLoad, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: (_c2 = file == null ? void 0 : file.data) == null ? void 0 : _c2.url, type: "audio/mpeg" }),
          "Your browser does not support the audio element."
        ] })
      ] });
    }
    if (fileExtension === "mp4" || fileExtension === "mov" || fileExtension === "wmv" || fileExtension === "mkv" || fileExtension === "avi") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full flex justify-center ", children: [
        loading2 && /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingIcon, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "video",
          {
            playsInline: true,
            "webkit-playsinline": true,
            controls: true,
            className: "w-auto relative",
            onLoadedData: handleLoad,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: (_d2 = file == null ? void 0 : file.data) == null ? void 0 : _d2.url, type: "video/mp4" }),
              "Your browser does not support the video element."
            ]
          }
        )
      ] });
    }
    if (fileExtension === "doc" || fileExtension === "docx" || fileExtension === "ppt" || fileExtension === "pptx" || fileExtension === "xls" || fileExtension === "xlsx") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        loading2 && /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingIcon, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "iframe",
          {
            src: officeViewerUrl,
            className: "w-full h-full",
            onLoad: handleLoad,
            allowFullScreen: true,
            allow: "autoplay; fullscreen",
            sandbox: "allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation-by-user-activation allow-presentation",
            referrerPolicy: "strict-origin-when-cross-origin"
          }
        )
      ] });
    }
    if (fileExtension === "jpg" || fileExtension === "jpeg" || fileExtension === "png" || fileExtension === "gif" || fileExtension === "webp" || fileExtension === "bmp" || fileExtension === "tiff" || fileExtension === "svg") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full flex relative justify-center ", children: [
        loading2 && /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingIcon, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: (_e2 = file == null ? void 0 : file.data) == null ? void 0 : _e2.url,
            alt: (_f2 = file == null ? void 0 : file.data) == null ? void 0 : _f2.name,
            className: "h-full w-auto object-contain",
            onLoad: handleLoad,
            allowFullScreen: true,
            allow: "autoplay; fullscreen",
            sandbox: "allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation-by-user-activation allow-presentation",
            referrerPolicy: "strict-origin-when-cross-origin"
          }
        )
      ] });
    }
    if (fileExtension === "pdf") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        loading2 && /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingIcon, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "iframe",
          {
            src: (_g2 = file == null ? void 0 : file.data) == null ? void 0 : _g2.url,
            className: "w-full",
            onLoad: handleLoad,
            allowFullScreen: true
          }
        )
      ] });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center text-red-500 font-semibold space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center w-24 h-24  bg-red-100 rounded-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          height: "60px",
          width: "60px",
          version: "1.1",
          id: "Capa_1",
          xmlns: "http://www.w3.org/2000/svg",
          xmlnsXlink: "http://www.w3.org/1999/xlink",
          viewBox: "0 0 38.762 38.762",
          xmlSpace: "preserve",
          fill: "currentColor",
          className: "text-red-500",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("g", { id: "SVGRepo_bgCarrier", strokeWidth: "0" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "g",
              {
                id: "SVGRepo_tracerCarrier",
                strokeLinecap: "round",
                strokeLinejoin: "round"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("g", { id: "SVGRepo_iconCarrier", children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M32.724,0H6.038C5.174,0,4.472,0.703,4.472,1.565v35.633c-0.001,0.861,0.701,1.564,1.566,1.564 h17.268c0.545,0,1.152-0.26,1.587-0.641c0.097-0.075,0.196-0.168,0.294-0.297l8.472-11.228c0.365-0.483,0.632-1.272,0.632-1.88 V1.565C34.291,0.703,33.587,0,32.724,0z M30.563,28.1l-5.69,7.544v-9.359h7.062L30.563,28.1z M32.723,24.719h-7.851 c-0.865,0-1.566,0.702-1.566,1.565v10.912H6.038V1.565h26.685C32.722,1.565,32.722,24.719,32.723,24.719z" }) }) })
          ]
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-lg", children: "Unsupported file type" })
    ] });
  };
  const FileDetailsModal = ({ file, onClose }) => {
    var _a2, _b2, _c2, _d2;
    const handleCopyLink = () => {
      navigator.clipboard.writeText(file.data.url).then(() => {
        setCopyMessage("URL copied!");
        setTimeout(() => setCopyMessage(""), 2e3);
      }).catch((err2) => {
        console.error("Failed to copy: ", err2);
      });
    };
    const [copyMessage, setCopyMessage] = reactExports.useState("");
    const handleDownload = async (url, filename) => {
      try {
        const downloadFilename = filename || url.split("/").pop().split("?")[0] || "download";
        try {
          const response = await fetch(url);
          if (!response.ok) throw new Error("Network response was not ok");
          const blob = await response.blob();
          const blobUrl = window.URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = blobUrl;
          a.download = downloadFilename;
          document.body.appendChild(a);
          a.click();
          setTimeout(() => {
            window.URL.revokeObjectURL(blobUrl);
            document.body.removeChild(a);
          }, 100);
        } catch (fetchError) {
          console.log("Fetch failed, using alternative method:", fetchError);
          const a = document.createElement("a");
          a.href = url;
          a.download = downloadFilename;
          a.target = "_blank";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
        }
      } catch (error) {
        console.error("Download failed:", error);
        window.open(url, "_blank");
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Dialog,
      {
        open: file !== null,
        onClose,
        className: `!p-0 relative mx-auto !bg-white overflow-y-auto transition-all  duration-500 ease-in-out lg:w-[95vw] md:w-[95vw] w-[calc(100vw-20px)] min-h-[85vh] h-auto`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center bg-[#516f90] p-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-white font-medium text-lg break-all mb-0", children: (file == null ? void 0 : file.data.name.length) > 25 ? `${(file == null ? void 0 : file.data.name.slice(0, 25)) + "..."}` : file == null ? void 0 : file.data.name }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-2 items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: onClose, className: "text-xl font-bold text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                xmlns: "http://www.w3.org/2000/svg",
                height: "24px",
                viewBox: "0 -960 960 960",
                width: "24px",
                className: "fill-white",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z" })
              }
            ) }) })
          ] }),
          file ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `rounded-lg p-4 bg-white flex md:flex-row flex-col justify-between gap-4`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `md:w-8/12 w-full flex justify-center md:h-[76vh] h-[47vh]`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FileViewer, { file }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `md:w-4/12 w-full py-4 pr-4`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: " text-secondary font-semibold break-all text-lg mb-2", children: (_a2 = file == null ? void 0 : file.data) == null ? void 0 : _a2.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-gray-600 text-sm mb-2 break-all", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Type:" }),
                " ",
                (_b2 = file == null ? void 0 : file.data) == null ? void 0 : _b2.type
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-gray-600 text-sm mb-2 break-all", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Size:" }),
                " ",
                (_c2 = file == null ? void 0 : file.data) == null ? void 0 : _c2.size
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-gray-600 text-sm mb-4 break-all", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Extension:" }),
                " ",
                (_d2 = file == null ? void 0 : file.data) == null ? void 0 : _d2.extension
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Button,
                  {
                    onClick: handleCopyLink,
                    className: "flex items-center",
                    size: "sm",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "svg",
                        {
                          xmlns: "http://www.w3.org/2000/svg",
                          height: "20px",
                          viewBox: "0 -960 960 960",
                          width: "20px",
                          className: "fill-white mr-2",
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M362.31-260q-27.01 0-45.66-18.65Q298-297.3 298-324.31v-455.38q0-27.01 18.65-45.66Q335.3-844 362.31-844h359.38q27.01 0 45.66 18.65Q786-806.7 786-779.69v455.38q0 27.01-18.65 45.66Q748.7-260 721.69-260H362.31Zm0-52h359.38q4.62 0 8.46-3.85 3.85-3.84 3.85-8.46v-455.38q0-4.62-3.85-8.46-3.84-3.85-8.46-3.85H362.31q-4.62 0-8.46 3.85-3.85 3.84-3.85 8.46v455.38q0 4.62 3.85 8.46 3.84 3.85 8.46 3.85Zm-124 176q-27.01 0-45.66-18.65Q174-173.3 174-200.31v-507.38h52v507.38q0 4.62 3.85 8.46 3.84 3.85 8.46 3.85h411.38v52H238.31ZM350-312v-480 480Z" })
                        }
                      ),
                      copyMessage ? "Copied!" : "Copy Link"
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Button,
                  {
                    onClick: () => {
                      var _a3, _b3;
                      return handleDownload((_a3 = file == null ? void 0 : file.data) == null ? void 0 : _a3.url, (_b3 = file == null ? void 0 : file.data) == null ? void 0 : _b3.name);
                    },
                    className: "flex items-center",
                    size: "sm",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "svg",
                        {
                          xmlns: "http://www.w3.org/2000/svg",
                          height: "20px",
                          viewBox: "0 -960 960 960",
                          width: "20px",
                          className: "fill-white mr-2",
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M240-212q-71.92 0-121.96-51.12Q68-314.23 68-386.15q0-74.39 52-126.54 52-52.16 123.92-45.62 16.54-78.15 80.31-131.8Q388-743.77 454-743.77q21.24 0 36.62 13.73Q506-716.31 506-693.77v270.62l66.23-67L609.38-453 480-323.62 350.62-453l37.15-37.15 66.23 67v-270.62q-70.61 11.62-118.31 65.96Q288-573.46 283-504h-43q-49.71 0-84.86 35.2-35.14 35.2-35.14 85t35.14 84.8q35.15 35 84.86 35h504q40.32 0 68.16-27.77 27.84-27.78 27.84-68Q840-400 812.16-428q-27.84-28-68.16-28h-72v-72q0-35.77-17-68.77-17-33-49-59.23v-60.31q54.15 28.08 86.08 78.61Q724-587.17 724-528v20h12.31q64.23-3.08 109.96 40.35Q892-424.23 892-361q0 62.92-43.54 105.96Q804.92-212 744-212H240Zm240-297.38Z" })
                        }
                      ),
                      "Download"
                    ]
                  }
                )
              ] })
            ] })
          ] }) : null
        ]
      }
    );
  };
  const FileTable = ({ fileId, files, toggleFolder, path, refetch, objectId, id }) => {
    var _a2;
    const [selectedFileId, setSelectedFileId] = reactExports.useState(null);
    const [activeDropdown, setActiveDropdown] = reactExports.useState(null);
    const [showDeleteDialog, setShowDeleteDialog] = reactExports.useState(false);
    const [deleteInput, setDeleteInput] = reactExports.useState("");
    const [fileToDelete, setFileToDelete] = reactExports.useState(null);
    useToaster$1();
    const { me } = useMe$1();
    const portalId = (_a2 = getPortal()) == null ? void 0 : _a2.portalId;
    const {
      data: fileDetails,
      isLoading,
      isError: isError2
    } = useQuery(
      ["fileDetails", selectedFileId, path, me],
      () => Client.files.getDetails({
        objectId,
        id,
        portalId,
        rowId: selectedFileId
      }),
      {
        enabled: !!selectedFileId,
        onSuccess: (data) => {
        },
        onError: (error) => {
          console.error("Error fetching file details:", error);
        }
      }
    );
    const handleRowClick = (file) => {
      if (file.type === "folder") {
        toggleFolder(file);
      } else {
        setSelectedFileId(file.id);
      }
    };
    const closeModal = () => {
      setSelectedFileId(null);
    };
    const dropdownRef = reactExports.useRef(null);
    reactExports.useEffect(() => {
      const handleClickOutside = (event) => {
        if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
          setActiveDropdown(null);
        }
      };
      document.addEventListener("mousedown", handleClickOutside);
      return () => {
        document.removeEventListener("mousedown", handleClickOutside);
      };
    }, []);
    const renderFiles = (files2) => {
      if (!files2 || files2.length === 0) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(TableRow, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { colSpan: 5, className: "text-center dark:border-gray-600 dark:text-white text-gray-500", children: /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyMessageCard, { name: "file" }) }) });
      }
      return files2.map((file, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        TableRow,
        {
          className: `border-t dark:border-gray-600 relative cursor-pointer hover:bg-gray-200 dark:hover:bg-dark-300`,
          onClick: () => handleRowClick(file),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "px-4 py-2 dark:border-gray-600  whitespace-nowrap text-xs dark:text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[24px]", children: getIcon$1(file.type == "folder" ? ".folder" : file.name) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "px-4 py-2 dark:border-gray-600  whitespace-nowrap text-xs dark:text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { id: "fileNane", content: file.name, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dark:text-white", children: truncatedText(file.name, "100") }) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "px-4 py-2 dark:border-gray-600  whitespace-nowrap text-left text-xs dark:text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: file.type }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "px-4 py-2 dark:border-gray-600  whitespace-nowrap text-left text-xs dark:text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: file.size }) })
          ]
        }
      ) }, file.id));
    };
    if (isLoading && !files) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(FilesSkeleton, {});
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "table-container overflow-x-auto rounded-md ", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { className: "w-full dark:bg-[#2a2a2a]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableHeader, { className: "bg-gray-100 text-left dark:bg-dark-500", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { className: "px-4 py-2 whitespace-nowrap dark:text-white dark:bg-dark-500 text-xs" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { className: "px-4 py-2 whitespace-nowrap dark:text-white dark:bg-dark-500 text-xs", children: "Name" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { className: "px-4 py-2 whitespace-nowrap dark:text-white dark:bg-dark-500 text-xs text-left", children: "File Type" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { className: "px-4 py-2 whitespace-nowrap dark:text-white dark:bg-dark-500 text-xs text-left", children: "Size" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { children: renderFiles(files) })
      ] }),
      selectedFileId && /* @__PURE__ */ jsxRuntimeExports.jsx(
        FileDetailsModal,
        {
          file: fileDetails,
          onClose: closeModal,
          loading: isLoading,
          error: isError2
        }
      )
    ] });
  };
  const Files = ({ tabName = "", fileId, path, objectId, id, permissions }) => {
    var _a2, _b2, _c2;
    const [currentFiles, setCurrentFiles] = reactExports.useState({ child: [] });
    const [folderStack, setFolderStack] = reactExports.useState([]);
    const [isDialogOpen, setIsDialogOpen] = reactExports.useState(false);
    const [isCreateFolderOpen, setIsCreateFolderOpen] = reactExports.useState(false);
    const [rightClickedFolder, setRightClickedFolder] = reactExports.useState(null);
    const [newFolderName, setNewFolderName] = reactExports.useState("");
    const [searchTerm, setSearchTerm] = reactExports.useState("");
    const { sync, setSync } = useSync();
    const { setToaster } = useToaster$1();
    const [currentPage, setCurrentPage] = reactExports.useState(1);
    const itemsPerPage = 10;
    const portalId = (_a2 = getPortal()) == null ? void 0 : _a2.portalId;
    const findObjectById = (data2, id2) => {
      if (data2.id === id2) {
        return data2;
      }
      if (data2.child && data2.child.length > 0) {
        for (let child of data2.child) {
          const result = findObjectById(child, id2);
          if (result) {
            return result;
          }
        }
      }
      return null;
    };
    reactExports.useEffect(() => {
      setCurrentFiles({ child: [] });
      setFolderStack([]);
      setCurrentPage(1);
      setSearchTerm("");
    }, [id, fileId, objectId]);
    const { data, error, isLoading, refetch } = useQuery({
      queryKey: ["FilesData", fileId],
      queryFn: async () => await Client.files.all({
        objectId,
        id,
        portalId,
        cache: sync ? false : true
      }),
      onSuccess: (data2) => {
        if (data2 && data2.data) {
          if (folderStack.length > 0 && currentFiles.name != id) {
            const foundObject = findObjectById(data2.data, currentFiles.id);
            setCurrentFiles(foundObject);
            const updatedFolderStack = updateFolderStack(
              folderStack,
              foundObject
            );
            setFolderStack(updatedFolderStack);
          } else {
            setCurrentFiles(data2.data);
            setFolderStack([data2.data]);
          }
        }
        setSync(false);
      },
      onError: (error2) => {
        setSync(false);
        console.error("Error fetching file details:", error2);
      }
    });
    reactExports.useEffect(() => {
      if (sync) {
        refetch();
      }
    }, [sync]);
    reactExports.useEffect(() => {
      refetch();
    }, [id, fileId, objectId]);
    if (isLoading) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(FilesSkeleton, {});
    }
    if (error && !id && objectId == "0-2" && tabName === "home" && !fileId) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center text-center p-4 min-h-[300px] max-h-[400px]  justify-center gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-yellow-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CautionCircle, {}) }),
        "Primary Company not found."
      ] });
    }
    if (error) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center text-center p-4 min-h-[300px] max-h-[400px]  justify-center gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-yellow-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CautionCircle, {}) }),
        (_c2 = (_b2 = error == null ? void 0 : error.response) == null ? void 0 : _b2.data) == null ? void 0 : _c2.detailedMessage
      ] });
    }
    const filteredFiles = ((currentFiles == null ? void 0 : currentFiles.child) || []).filter(
      (file) => file.name.toLowerCase().includes(searchTerm.toLowerCase())
    ).sort((a, b2) => new Date(b2.createdAt).getTime() - new Date(a.createdAt).getTime());
    const totalFiles = filteredFiles.length;
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = currentPage * itemsPerPage;
    const paginatedFiles = filteredFiles.slice(startIndex, endIndex);
    const numOfPages = Math.ceil(totalFiles / itemsPerPage);
    const toggleFolder = (folder) => {
      setFolderStack([...folderStack, folder]);
      setCurrentFiles(folder);
      setCurrentPage(1);
    };
    const updateFolderStack = (folderStack2, currentFolder) => {
      const updateRecursive = (folders) => {
        return folders.map((folder) => {
          if (folder.id === currentFolder.id) {
            return {
              ...folder,
              // Copy the current folder properties
              name: currentFolder.name,
              // Update the name
              size: currentFolder.size,
              // Update the size
              child: currentFolder.child || folder.child
              // Update the children if provided
            };
          }
          if (folder.child && folder.child.length > 0) {
            return {
              ...folder,
              child: updateRecursive(folder.child)
              // Recursively update children
            };
          }
          return folder;
        });
      };
      return updateRecursive(folderStack2);
    };
    const handleBreadcrumbClick = (index) => {
      if (!Array.isArray(folderStack) || folderStack.length <= index) {
        console.log("Hello hweekly");
        return;
      }
      updateFolderStack(folderStack, currentFiles);
      const selectedFolder = folderStack[index];
      setCurrentPage(1);
      setCurrentFiles(selectedFolder);
      setFolderStack(folderStack.slice(0, index + 1));
    };
    const createFolder = (folderName) => {
      const newFolder = {
        id: Date.now().toString(),
        name: folderName,
        type: "folder",
        child: []
      };
      if (rightClickedFolder && rightClickedFolder.child) {
        rightClickedFolder.child.push(newFolder);
      } else if (currentFiles && currentFiles.child) {
        currentFiles.child.push(newFolder);
      }
      setCurrentFiles({ ...currentFiles });
      setNewFolderName("");
      setIsCreateFolderOpen(false);
    };
    const closeContextMenu = () => {
      document.getElementById("contextMenu");
    };
    const closeDialog = () => {
      setIsDialogOpen(false);
    };
    const handleOverlayClick = (e) => {
      if (e.target.id === "dialog-overlay") {
        closeDialog();
      }
    };
    const getCurrentFolderId = () => {
      return currentFiles && currentFiles.id || "obj-root";
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: closeContextMenu, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg mt-2 bg-cleanWhite border dark:border-none dark:bg-dark-300 md:p-4 p-2 !pb-0", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between mb-6 items-center max-sm:flex-col-reverse max-sm:items-end gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              placeholder: "Search...",
              height: "semiMedium",
              value: searchTerm,
              onChange: (e) => setSearchTerm(e.target.value),
              icon: SearchIcon
            }
          ),
          permissions && permissions.create && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end space-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Button,
              {
                variant: !recorBtnCustom ? "default" : "create",
                onClick: () => setIsCreateFolderOpen(true),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "mr-2", children: [
                    " ",
                    /* @__PURE__ */ jsxRuntimeExports.jsx(IconPlus, { className: "!w-3 !h-3" }),
                    " "
                  ] }),
                  " ",
                  "New Folder"
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { variant: !recorBtnCustom ? "default" : "create", onClick: () => setIsDialogOpen(true), children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "mr-2", children: [
                " ",
                /* @__PURE__ */ jsxRuntimeExports.jsx(IconPlus, { className: "!w-3 !h-3" }),
                " "
              ] }),
              " ",
              "New File"
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex md:flex-row flex-col-reverse justify-between gap-2 md:items-center ", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FileBreadcrumb,
          {
            id,
            folderStack,
            onClick: handleBreadcrumbClick
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-xl font-semibold mb-4 dark:text-white", children: currentFiles && currentFiles.name != id ? currentFiles.name : "Home" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          FileTable,
          {
            fileId,
            path,
            files: paginatedFiles,
            toggleFolder,
            refetch,
            objectId,
            id,
            componentName: "files"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex md:flex-row flex-col gap-2 justify-between items-center ", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-x-2 pt-3 text-sm", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-secondary leading-5 text-sm dark:text-gray-300", children: "Showing" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "border dark:text-white border-secondary font-medium w-8 h-8 flex items-center justify-center rounded-md dark:border-white", children: Math.min(endIndex, totalFiles) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dark:text-white", children: "/" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "rounded-md dark:text-white font-medium", children: totalFiles }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-secondary font-normal text-sm dark:text-gray-300", children: "Results" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Pagination,
            {
              numOfPages,
              currentPage,
              setCurrentPage
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FolderUpload,
        {
          isOpen: isCreateFolderOpen,
          onClose: () => setIsCreateFolderOpen(false),
          onCreate: createFolder,
          newFolderName,
          setNewFolderName,
          folderId: getCurrentFolderId(),
          fileId,
          refetch,
          setToaster,
          objectId,
          id
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: isDialogOpen, onClose: closeDialog, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "dialog-overlay", onClick: handleOverlayClick, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        FileUpload,
        {
          folderId: getCurrentFolderId(),
          fileId,
          refetch,
          onClose: closeDialog,
          setToaster,
          objectId,
          id
        }
      ) }) })
    ] });
  };
  const OverviewSkeleton = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full animate-pulse p-4 bg-white dark:bg-dark-500 rounded-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: Array(6).fill("").map((_2, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-6 animate-pulse", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bg-gray-300 dark:bg-dark-white w-32 h-4 rounded-sm" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bg-gray-300 dark:bg-dark-white w-40 h-4 rounded-sm" })
    ] }, index)) }) });
  };
  const DetailsSkeleton = ({ header = true, tabs = 4, active = "overview" }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `animate-pulse flex flex-col items-start gap-4 rounded-lg`, children: [
      header ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative h-36 rounded-lg w-full p-4 flex flex-col items-start justify-center overflow-hidden bg-custom-gradient", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-300 dark:bg-dark-white w-36 h-5 rounded-sm animate-pulse" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-300 dark:bg-dark-white w-48 h-5 rounded-sm mt-2 animate-pulse" })
      ] }) : null,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-2 bg-white dark:bg-dark-500 p-1 animate-pulse rounded-lg", children: Array(tabs).fill("").map((_2, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-4 py-2 bg-gray-300 dark:bg-dark-white text-white rounded-md w-20 h-8 animate-pulse" }, index)) }),
      active === "overview" && /* @__PURE__ */ jsxRuntimeExports.jsx(OverviewSkeleton, {}),
      active === "file" && /* @__PURE__ */ jsxRuntimeExports.jsx(FilesSkeleton, {})
    ] });
  };
  const pageLimit = env$1.VITE_TABLE_PAGE_LIMIT;
  function useTable() {
    const [data, setData] = useAtom(gridDataState);
    const [sort, setSort] = useAtom(tableSortState);
    const [limit, setLimit] = useAtom(tableLimitState);
    const [after, setAfter] = useAtom(tableAfterState);
    const [page, setPage] = useAtom(tablePageState);
    const [totalItems, setTotalItems] = useAtom(tableTotalItemsState);
    const [numOfPages, setNumOfPages] = useAtom(tableNumOfPagesState);
    const [currentPage, setCurrentPage] = useAtom(tableCurrentPageState);
    const [search, setSearch] = useAtom(tableSearchState);
    const [filterPropertyName, setFilterPropertyName] = useAtom(tableFilterPropertyNameState);
    const [filterOperator, setFilterOperator] = useAtom(tableFilterPropertyOperatorState);
    const [filterValue, setFilterValue] = useAtom(tableFilterPropertyValueState);
    const [isPrimaryCompany, setIsPrimaryCompany] = useAtom(tableIsPrimaryCompanyState);
    const [view, changeView] = useAtom(tableViewState);
    const [selectedPipeline, changePipeline] = useAtom(tableSelectedPipelineState);
    const [tableParam, setTableFilterData] = useAtom(tableParamState);
    const { sync } = useSync();
    const setView = (mView) => {
      setPage(1);
      changeView(mView);
    };
    const resetTableParam = () => {
      setSort("-hs_createdate");
      setLimit(pageLimit);
      setAfter("");
      setPage(1);
      setTotalItems(1);
      setNumOfPages(1);
      setCurrentPage(1);
      setSearch("");
      setFilterPropertyName("hs_pipeline");
      setFilterOperator("eq");
      setFilterValue("");
      setIsPrimaryCompany(null);
      changePipeline("");
    };
    const getTableParam = (companyAsMediator, currentPageOverride) => ({
      limit,
      page: currentPageOverride || page,
      ...after && after.length > 0 && { after },
      sort,
      search,
      filterPropertyName,
      filterOperator,
      filterValue: selectedPipeline,
      cache: sync ? false : true,
      isPrimaryCompany: companyAsMediator ? companyAsMediator : false,
      view
    });
    const setDefaultPipeline = async (data2, hubspotObjectTypeId, companyAsMediator) => {
      var _a2;
      if (data2) {
        const routeMenuConfigs = getRouteMenuConfig();
        let mFilterValue = "";
        const defaultPipeline = (_a2 = data2 == null ? void 0 : data2.data) == null ? void 0 : _a2.find(
          (pipeline) => pipeline.pipelineId === data2.data[0].pipelineId
        );
        if (routeMenuConfigs && routeMenuConfigs.hasOwnProperty(hubspotObjectTypeId) && routeMenuConfigs[hubspotObjectTypeId].activePipeline) {
          mFilterValue = routeMenuConfigs[hubspotObjectTypeId].activePipeline;
        } else {
          if (view === "BOARD" && !selectedPipeline) {
            mFilterValue = defaultPipeline.pipelineId;
            const routeMenuConfig = {
              [hubspotObjectTypeId]: {
                activePipeline: defaultPipeline.pipelineId
              }
            };
            setSelectRouteMenuConfig(routeMenuConfig);
          } else {
            mFilterValue = data2.data.length === 1 ? defaultPipeline.pipelineId : selectedPipeline;
          }
        }
        changePipeline(mFilterValue);
      } else {
        changePipeline("");
      }
    };
    const setSelectedPipeline = (hubspotObjectTypeId, pipelines, pipeLineId) => {
      let filterValue2 = "";
      if (pipeLineId) {
        const pipelineSingle = pipelines.find(
          (pipeline) => pipeline.pipelineId === pipeLineId
        );
        setFilterPropertyName("hs_pipeline");
        setFilterOperator("eq");
        filterValue2 = pipelineSingle.pipelineId;
        setFilterValue(filterValue2);
      } else {
        setFilterPropertyName("hs_pipeline");
        setFilterOperator("eq");
        filterValue2 = "";
        setFilterValue(filterValue2);
      }
      const routeMenuConfig = {
        [hubspotObjectTypeId]: {
          activePipeline: filterValue2
        }
      };
      changePipeline(filterValue2);
      setSelectRouteMenuConfig(routeMenuConfig);
    };
    const setSelectRouteMenuConfig = (routeMenuConfig) => {
      let routeMenuConfigs = getRouteMenuConfig();
      Object.keys(routeMenuConfig).forEach((key2) => {
        var _a2, _b2;
        if (!routeMenuConfigs) routeMenuConfigs = {};
        if (routeMenuConfigs && !routeMenuConfigs.hasOwnProperty(key2)) {
          routeMenuConfigs[key2] = routeMenuConfig[key2];
        } else {
          if ((_a2 = routeMenuConfig[key2]) == null ? void 0 : _a2.activeTab)
            routeMenuConfigs[key2].activeTab = routeMenuConfig[key2].activeTab;
          if ((_b2 = routeMenuConfig[key2]) == null ? void 0 : _b2.activePipeline) {
            routeMenuConfigs[key2].activePipeline = routeMenuConfig[key2].activePipeline;
          } else {
            routeMenuConfigs[key2].activePipeline = "";
          }
        }
      });
      setRouteMenuConfig(routeMenuConfigs);
    };
    const setGridData = async (type, deals) => {
      if (type === "reset") return setData([]);
      if (type === "directly") return setData(deals);
      const finalData = deals.map((deal) => {
        var _a2, _b2, _c2, _d2;
        const cards = ((_c2 = (_b2 = (_a2 = deal == null ? void 0 : deal.data) == null ? void 0 : _a2.results) == null ? void 0 : _b2.rows) == null ? void 0 : _c2.map((row) => ({
          id: row == null ? void 0 : row.hs_object_id,
          ...row,
          hubspotObjectTypeId: type === "deals" ? "0-3" : "0-5"
        }))) || [];
        return {
          id: deal.id,
          name: deal.label,
          count: (_d2 = deal == null ? void 0 : deal.data) == null ? void 0 : _d2.total,
          ...deal,
          cards
        };
      });
      setData(finalData);
    };
    return {
      sort,
      setSort,
      limit,
      setLimit,
      after,
      setAfter,
      page,
      setPage,
      totalItems,
      setTotalItems,
      numOfPages,
      setNumOfPages,
      currentPage,
      setCurrentPage,
      search,
      setSearch,
      filterPropertyName,
      setFilterPropertyName,
      filterOperator,
      setFilterOperator,
      filterValue,
      setFilterValue,
      isPrimaryCompany,
      setIsPrimaryCompany,
      view,
      setView,
      tableParam,
      setTableFilterData,
      selectedPipeline,
      setSelectedPipeline,
      setDefaultPipeline,
      setSelectRouteMenuConfig,
      resetTableParam,
      getTableParam,
      gridData: data,
      setGridData
    };
  }
  const DashboardTableHeaderSkeleton = ({
    title,
    hubspotObjectTypeId
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between mb-6 items-center max-sm:flex-col-reverse max-sm:items-end gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 justify-between max-sm:flex-col-reverse max-sm:w-full", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 justify-between", children: [
          (hubspotObjectTypeId === "0-3" || hubspotObjectTypeId === "0-5") && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex p-1 bg-graySecondary dark:bg-dark-200 rounded-md gap-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                className: `py-1 px-3 inline-flex dark:text-gray-200 items-center gap-x-2 -ms-px first:ms-0 first:rounded-s-md hover:bg-gray-50 dark:hover:bg-dark-500 last:rounded-e-md text-sm font-medium text-gray-800`,
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "svg",
                  {
                    fill: "currentcolor",
                    width: "20px",
                    height: "23px",
                    viewBox: "0 0 32 32",
                    version: "1.1",
                    xmlns: "http://www.w3.org/2000/svg",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: "list" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8 8v4h16v-4h-16zM8 18h16v-4h-16v4zM8 24h16v-4h-16v4z" })
                    ]
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                className: `py-1 px-3 inline-flex dark:text-gray-200 items-center gap-x-2 -ms-px first:ms-0 hover:bg-gray-50 dark:hover:bg-dark-500 first:rounded-s-md last:rounded-e-md text-sm font-medium text-gray-800`,
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "svg",
                  {
                    width: "15px",
                    height: "15px",
                    viewBox: "0 0 16 16",
                    fill: "none",
                    xmlns: "http://www.w3.org/2000/svg",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("g", { id: "SVGRepo_bgCarrier", "stroke-width": "0" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "g",
                        {
                          id: "SVGRepo_tracerCarrier",
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "SVGRepo_iconCarrier", children: [
                        " ",
                        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 1H1V5H7V1Z", fill: "currentcolor" }),
                        " ",
                        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 7H1V15H7V7Z", fill: "currentcolor" }),
                        " ",
                        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 1H15V9H9V1Z", fill: "currentcolor" }),
                        " ",
                        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15 11H9V15H15V11Z", fill: "currentcolor" }),
                        " "
                      ] })
                    ]
                  }
                )
              }
            )
          ] }),
          (hubspotObjectTypeId === "0-3" || hubspotObjectTypeId === "0-5") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[180px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "select",
            {
              className: "w-full rounded-md bg-cleanWhite px-2 text-sm transition-colors border-2 dark:border-gray-600 focus:ring-0 focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 dark:bg-gray-700 dark:text-gray-200 dark:placeholder-gray-400 py-2",
              value: "",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", selected: true, children: "All Pipelines" })
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: " md:flex md:items-center md:gap-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { id: "searchInputSkeleton", content: "Press enter to search ", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            placeholder: "Search...",
            height: "semiMedium",
            icon: SearchIcon,
            className: "pr-12"
          }
        ) }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-end", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { variant: !recorBtnCustom ? "default" : "create", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconPlus, { className: "!w-3 !h-3" }) }),
        "Create ",
        title
      ] }) })
    ] });
  };
  const BoardViewSkeleton = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-5 md:mb-4 mb-3 h-[66vh]", children: Array(5).fill(0).map((_2, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `relative flex flex-col h-full bg-[#f5f8fa] dark:bg-dark-500 border dark:border-gray-600 overflow-y-auto hide-scrollbar first:border-r-0 last:border-l-0 first:rounded-s-md last:rounded-e-md`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-3 py-3 border-b dark:border-b-gray-600 sticky top-0 z-[2] bg-[#f5f8fa] dark:bg-dark-500", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-4 w-2/4 bg-gray-300 dark:bg-white dark:opacity-20 rounded-sm animate-pulse" }) }),
      Array(3).fill(0).map((_22, i2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-md bg-white border border-gray-300 dark:border-gray-600 shadow-sm p-3 mx-3 my-2 dark:bg-dark-300 dark:text-white", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-3 w-3/5 bg-secondary dark:bg-white opacity-10 rounded-sm animate-pulse mb-2" }, i2),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-3 w-2/4 bg-gray-200 dark:bg-white opacity-30 rounded-sm animate-pulse" }, i2)
      ] }))
    ] }, index)) });
  };
  const TableSkeleton = ({ row = 10, col = 5 }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "table-container rounded-md ", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { className: "w-full animate-pulse dark:bg-[#2a2a2a]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableHeader, { className: "bg-gray-100 text-left dark:bg-dark-500", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableRow, { children: [...Array(col)].map((_2, j2) => /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { className: "px-4 py-2 whitespace-nowrap dark:text-white dark:bg-dark-500 text-xs", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-4 w-full bg-gray-200 dark:bg-dark-white dark:bg-opacity-20 rounded-md" }) }, j2)) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { children: [...Array(row)].map((_2, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx(TableRow, { className: `animate-pulse border-t dark:border-gray-600 relative cursor-pointer hover:bg-gray-200 dark:hover:bg-dark-300`, children: [...Array(col)].map((_22, j2) => /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "px-4 py-2 whitespace-nowrap text-xs dark:text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-4 w-full bg-gray-200 dark:bg-dark-white dark:bg-opacity-20 rounded-md" }) }, j2)) })) })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-4 w-48 bg-gray-200 rounded-md animate-pulse" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-8 w-8 bg-gray-300 dark:bg-dark-white dark:bg-opacity-20 rounded-md animate-pulse" }),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-6 w-6 bg-gray-300 dark:bg-dark-white dark:bg-opacity-20 rounded-md animate-pulse" }),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-8 w-8 bg-gray-300 dark:bg-dark-white dark:bg-opacity-20 rounded-md animate-pulse" }),
          " "
        ] })
      ] })
    ] });
  };
  function OrderedMap(content) {
    this.content = content;
  }
  OrderedMap.prototype = {
    constructor: OrderedMap,
    find: function(key2) {
      for (var i2 = 0; i2 < this.content.length; i2 += 2)
        if (this.content[i2] === key2) return i2;
      return -1;
    },
    // :: (string)  ?any
    // Retrieve the value stored under `key`, or return undefined when
    // no such key exists.
    get: function(key2) {
      var found2 = this.find(key2);
      return found2 == -1 ? void 0 : this.content[found2 + 1];
    },
    // :: (string, any, ?string)  OrderedMap
    // Create a new map by replacing the value of `key` with a new
    // value, or adding a binding to the end of the map. If `newKey` is
    // given, the key of the binding will be replaced with that key.
    update: function(key2, value, newKey) {
      var self2 = newKey && newKey != key2 ? this.remove(newKey) : this;
      var found2 = self2.find(key2), content = self2.content.slice();
      if (found2 == -1) {
        content.push(newKey || key2, value);
      } else {
        content[found2 + 1] = value;
        if (newKey) content[found2] = newKey;
      }
      return new OrderedMap(content);
    },
    // :: (string)  OrderedMap
    // Return a map with the given key removed, if it existed.
    remove: function(key2) {
      var found2 = this.find(key2);
      if (found2 == -1) return this;
      var content = this.content.slice();
      content.splice(found2, 2);
      return new OrderedMap(content);
    },
    // :: (string, any)  OrderedMap
    // Add a new key to the start of the map.
    addToStart: function(key2, value) {
      return new OrderedMap([key2, value].concat(this.remove(key2).content));
    },
    // :: (string, any)  OrderedMap
    // Add a new key to the end of the map.
    addToEnd: function(key2, value) {
      var content = this.remove(key2).content.slice();
      content.push(key2, value);
      return new OrderedMap(content);
    },
    // :: (string, string, any)  OrderedMap
    // Add a key after the given key. If `place` is not found, the new
    // key is added to the end.
    addBefore: function(place, key2, value) {
      var without = this.remove(key2), content = without.content.slice();
      var found2 = without.find(place);
      content.splice(found2 == -1 ? content.length : found2, 0, key2, value);
      return new OrderedMap(content);
    },
    // :: ((key: string, value: any))
    // Call the given function for each key/value pair in the map, in
    // order.
    forEach: function(f) {
      for (var i2 = 0; i2 < this.content.length; i2 += 2)
        f(this.content[i2], this.content[i2 + 1]);
    },
    // :: (union<Object, OrderedMap>)  OrderedMap
    // Create a new map by prepending the keys in this map that don't
    // appear in `map` before the keys in `map`.
    prepend: function(map) {
      map = OrderedMap.from(map);
      if (!map.size) return this;
      return new OrderedMap(map.content.concat(this.subtract(map).content));
    },
    // :: (union<Object, OrderedMap>)  OrderedMap
    // Create a new map by appending the keys in this map that don't
    // appear in `map` after the keys in `map`.
    append: function(map) {
      map = OrderedMap.from(map);
      if (!map.size) return this;
      return new OrderedMap(this.subtract(map).content.concat(map.content));
    },
    // :: (union<Object, OrderedMap>)  OrderedMap
    // Create a map containing all the keys in this map that don't
    // appear in `map`.
    subtract: function(map) {
      var result = this;
      map = OrderedMap.from(map);
      for (var i2 = 0; i2 < map.content.length; i2 += 2)
        result = result.remove(map.content[i2]);
      return result;
    },
    // :: ()  Object
    // Turn ordered map into a plain object.
    toObject: function() {
      var result = {};
      this.forEach(function(key2, value) {
        result[key2] = value;
      });
      return result;
    },
    // :: number
    // The amount of keys in this map.
    get size() {
      return this.content.length >> 1;
    }
  };
  OrderedMap.from = function(value) {
    if (value instanceof OrderedMap) return value;
    var content = [];
    if (value) for (var prop in value) content.push(prop, value[prop]);
    return new OrderedMap(content);
  };
  function findDiffStart(a, b2, pos) {
    for (let i2 = 0; ; i2++) {
      if (i2 == a.childCount || i2 == b2.childCount)
        return a.childCount == b2.childCount ? null : pos;
      let childA = a.child(i2), childB = b2.child(i2);
      if (childA == childB) {
        pos += childA.nodeSize;
        continue;
      }
      if (!childA.sameMarkup(childB))
        return pos;
      if (childA.isText && childA.text != childB.text) {
        for (let j2 = 0; childA.text[j2] == childB.text[j2]; j2++)
          pos++;
        return pos;
      }
      if (childA.content.size || childB.content.size) {
        let inner = findDiffStart(childA.content, childB.content, pos + 1);
        if (inner != null)
          return inner;
      }
      pos += childA.nodeSize;
    }
  }
  function findDiffEnd(a, b2, posA, posB) {
    for (let iA = a.childCount, iB = b2.childCount; ; ) {
      if (iA == 0 || iB == 0)
        return iA == iB ? null : { a: posA, b: posB };
      let childA = a.child(--iA), childB = b2.child(--iB), size = childA.nodeSize;
      if (childA == childB) {
        posA -= size;
        posB -= size;
        continue;
      }
      if (!childA.sameMarkup(childB))
        return { a: posA, b: posB };
      if (childA.isText && childA.text != childB.text) {
        let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
        while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
          same++;
          posA--;
          posB--;
        }
        return { a: posA, b: posB };
      }
      if (childA.content.size || childB.content.size) {
        let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
        if (inner)
          return inner;
      }
      posA -= size;
      posB -= size;
    }
  }
  class Fragment {
    /**
    @internal
    */
    constructor(content, size) {
      this.content = content;
      this.size = size || 0;
      if (size == null)
        for (let i2 = 0; i2 < content.length; i2++)
          this.size += content[i2].nodeSize;
    }
    /**
    Invoke a callback for all descendant nodes between the given two
    positions (relative to start of this fragment). Doesn't descend
    into a node when the callback returns `false`.
    */
    nodesBetween(from, to, f, nodeStart = 0, parent) {
      for (let i2 = 0, pos = 0; pos < to; i2++) {
        let child = this.content[i2], end = pos + child.nodeSize;
        if (end > from && f(child, nodeStart + pos, parent || null, i2) !== false && child.content.size) {
          let start = pos + 1;
          child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);
        }
        pos = end;
      }
    }
    /**
    Call the given callback for every descendant node. `pos` will be
    relative to the start of the fragment. The callback may return
    `false` to prevent traversal of a given node's children.
    */
    descendants(f) {
      this.nodesBetween(0, this.size, f);
    }
    /**
    Extract the text between `from` and `to`. See the same method on
    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
    */
    textBetween(from, to, blockSeparator, leafText) {
      let text2 = "", first = true;
      this.nodesBetween(from, to, (node, pos) => {
        let nodeText = node.isText ? node.text.slice(Math.max(from, pos) - pos, to - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
        if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
          if (first)
            first = false;
          else
            text2 += blockSeparator;
        }
        text2 += nodeText;
      }, 0);
      return text2;
    }
    /**
    Create a new fragment containing the combined content of this
    fragment and the other.
    */
    append(other) {
      if (!other.size)
        return this;
      if (!this.size)
        return other;
      let last2 = this.lastChild, first = other.firstChild, content = this.content.slice(), i2 = 0;
      if (last2.isText && last2.sameMarkup(first)) {
        content[content.length - 1] = last2.withText(last2.text + first.text);
        i2 = 1;
      }
      for (; i2 < other.content.length; i2++)
        content.push(other.content[i2]);
      return new Fragment(content, this.size + other.size);
    }
    /**
    Cut out the sub-fragment between the two given positions.
    */
    cut(from, to = this.size) {
      if (from == 0 && to == this.size)
        return this;
      let result = [], size = 0;
      if (to > from)
        for (let i2 = 0, pos = 0; pos < to; i2++) {
          let child = this.content[i2], end = pos + child.nodeSize;
          if (end > from) {
            if (pos < from || end > to) {
              if (child.isText)
                child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));
              else
                child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));
            }
            result.push(child);
            size += child.nodeSize;
          }
          pos = end;
        }
      return new Fragment(result, size);
    }
    /**
    @internal
    */
    cutByIndex(from, to) {
      if (from == to)
        return Fragment.empty;
      if (from == 0 && to == this.content.length)
        return this;
      return new Fragment(this.content.slice(from, to));
    }
    /**
    Create a new fragment in which the node at the given index is
    replaced by the given node.
    */
    replaceChild(index, node) {
      let current = this.content[index];
      if (current == node)
        return this;
      let copy2 = this.content.slice();
      let size = this.size + node.nodeSize - current.nodeSize;
      copy2[index] = node;
      return new Fragment(copy2, size);
    }
    /**
    Create a new fragment by prepending the given node to this
    fragment.
    */
    addToStart(node) {
      return new Fragment([node].concat(this.content), this.size + node.nodeSize);
    }
    /**
    Create a new fragment by appending the given node to this
    fragment.
    */
    addToEnd(node) {
      return new Fragment(this.content.concat(node), this.size + node.nodeSize);
    }
    /**
    Compare this fragment to another one.
    */
    eq(other) {
      if (this.content.length != other.content.length)
        return false;
      for (let i2 = 0; i2 < this.content.length; i2++)
        if (!this.content[i2].eq(other.content[i2]))
          return false;
      return true;
    }
    /**
    The first child of the fragment, or `null` if it is empty.
    */
    get firstChild() {
      return this.content.length ? this.content[0] : null;
    }
    /**
    The last child of the fragment, or `null` if it is empty.
    */
    get lastChild() {
      return this.content.length ? this.content[this.content.length - 1] : null;
    }
    /**
    The number of child nodes in this fragment.
    */
    get childCount() {
      return this.content.length;
    }
    /**
    Get the child node at the given index. Raise an error when the
    index is out of range.
    */
    child(index) {
      let found2 = this.content[index];
      if (!found2)
        throw new RangeError("Index " + index + " out of range for " + this);
      return found2;
    }
    /**
    Get the child node at the given index, if it exists.
    */
    maybeChild(index) {
      return this.content[index] || null;
    }
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
    forEach(f) {
      for (let i2 = 0, p = 0; i2 < this.content.length; i2++) {
        let child = this.content[i2];
        f(child, p, i2);
        p += child.nodeSize;
      }
    }
    /**
    Find the first position at which this fragment and another
    fragment differ, or `null` if they are the same.
    */
    findDiffStart(other, pos = 0) {
      return findDiffStart(this, other, pos);
    }
    /**
    Find the first position, searching from the end, at which this
    fragment and the given fragment differ, or `null` if they are
    the same. Since this position will not be the same in both
    nodes, an object with two separate positions is returned.
    */
    findDiffEnd(other, pos = this.size, otherPos = other.size) {
      return findDiffEnd(this, other, pos, otherPos);
    }
    /**
    Find the index and inner offset corresponding to a given relative
    position in this fragment. The result object will be reused
    (overwritten) the next time the function is called. @internal
    */
    findIndex(pos) {
      if (pos == 0)
        return retIndex(0, pos);
      if (pos == this.size)
        return retIndex(this.content.length, pos);
      if (pos > this.size || pos < 0)
        throw new RangeError(`Position ${pos} outside of fragment (${this})`);
      for (let i2 = 0, curPos = 0; ; i2++) {
        let cur = this.child(i2), end = curPos + cur.nodeSize;
        if (end >= pos) {
          if (end == pos)
            return retIndex(i2 + 1, end);
          return retIndex(i2, curPos);
        }
        curPos = end;
      }
    }
    /**
    Return a debugging string that describes this fragment.
    */
    toString() {
      return "<" + this.toStringInner() + ">";
    }
    /**
    @internal
    */
    toStringInner() {
      return this.content.join(", ");
    }
    /**
    Create a JSON-serializeable representation of this fragment.
    */
    toJSON() {
      return this.content.length ? this.content.map((n) => n.toJSON()) : null;
    }
    /**
    Deserialize a fragment from its JSON representation.
    */
    static fromJSON(schema2, value) {
      if (!value)
        return Fragment.empty;
      if (!Array.isArray(value))
        throw new RangeError("Invalid input for Fragment.fromJSON");
      return new Fragment(value.map(schema2.nodeFromJSON));
    }
    /**
    Build a fragment from an array of nodes. Ensures that adjacent
    text nodes with the same marks are joined together.
    */
    static fromArray(array) {
      if (!array.length)
        return Fragment.empty;
      let joined, size = 0;
      for (let i2 = 0; i2 < array.length; i2++) {
        let node = array[i2];
        size += node.nodeSize;
        if (i2 && node.isText && array[i2 - 1].sameMarkup(node)) {
          if (!joined)
            joined = array.slice(0, i2);
          joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
        } else if (joined) {
          joined.push(node);
        }
      }
      return new Fragment(joined || array, size);
    }
    /**
    Create a fragment from something that can be interpreted as a
    set of nodes. For `null`, it returns the empty fragment. For a
    fragment, the fragment itself. For a node or array of nodes, a
    fragment containing those nodes.
    */
    static from(nodes2) {
      if (!nodes2)
        return Fragment.empty;
      if (nodes2 instanceof Fragment)
        return nodes2;
      if (Array.isArray(nodes2))
        return this.fromArray(nodes2);
      if (nodes2.attrs)
        return new Fragment([nodes2], nodes2.nodeSize);
      throw new RangeError("Can not convert " + nodes2 + " to a Fragment" + (nodes2.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
    }
  }
  Fragment.empty = new Fragment([], 0);
  const found = { index: 0, offset: 0 };
  function retIndex(index, offset2) {
    found.index = index;
    found.offset = offset2;
    return found;
  }
  function compareDeep(a, b2) {
    if (a === b2)
      return true;
    if (!(a && typeof a == "object") || !(b2 && typeof b2 == "object"))
      return false;
    let array = Array.isArray(a);
    if (Array.isArray(b2) != array)
      return false;
    if (array) {
      if (a.length != b2.length)
        return false;
      for (let i2 = 0; i2 < a.length; i2++)
        if (!compareDeep(a[i2], b2[i2]))
          return false;
    } else {
      for (let p in a)
        if (!(p in b2) || !compareDeep(a[p], b2[p]))
          return false;
      for (let p in b2)
        if (!(p in a))
          return false;
    }
    return true;
  }
  class Mark {
    /**
    @internal
    */
    constructor(type, attrs) {
      this.type = type;
      this.attrs = attrs;
    }
    /**
    Given a set of marks, create a new set which contains this one as
    well, in the right position. If this mark is already in the set,
    the set itself is returned. If any marks that are set to be
    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
    those are replaced by this one.
    */
    addToSet(set2) {
      let copy2, placed = false;
      for (let i2 = 0; i2 < set2.length; i2++) {
        let other = set2[i2];
        if (this.eq(other))
          return set2;
        if (this.type.excludes(other.type)) {
          if (!copy2)
            copy2 = set2.slice(0, i2);
        } else if (other.type.excludes(this.type)) {
          return set2;
        } else {
          if (!placed && other.type.rank > this.type.rank) {
            if (!copy2)
              copy2 = set2.slice(0, i2);
            copy2.push(this);
            placed = true;
          }
          if (copy2)
            copy2.push(other);
        }
      }
      if (!copy2)
        copy2 = set2.slice();
      if (!placed)
        copy2.push(this);
      return copy2;
    }
    /**
    Remove this mark from the given set, returning a new set. If this
    mark is not in the set, the set itself is returned.
    */
    removeFromSet(set2) {
      for (let i2 = 0; i2 < set2.length; i2++)
        if (this.eq(set2[i2]))
          return set2.slice(0, i2).concat(set2.slice(i2 + 1));
      return set2;
    }
    /**
    Test whether this mark is in the given set of marks.
    */
    isInSet(set2) {
      for (let i2 = 0; i2 < set2.length; i2++)
        if (this.eq(set2[i2]))
          return true;
      return false;
    }
    /**
    Test whether this mark has the same type and attributes as
    another mark.
    */
    eq(other) {
      return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
    }
    /**
    Convert this mark to a JSON-serializeable representation.
    */
    toJSON() {
      let obj = { type: this.type.name };
      for (let _2 in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      return obj;
    }
    /**
    Deserialize a mark from JSON.
    */
    static fromJSON(schema2, json) {
      if (!json)
        throw new RangeError("Invalid input for Mark.fromJSON");
      let type = schema2.marks[json.type];
      if (!type)
        throw new RangeError(`There is no mark type ${json.type} in this schema`);
      let mark = type.create(json.attrs);
      type.checkAttrs(mark.attrs);
      return mark;
    }
    /**
    Test whether two sets of marks are identical.
    */
    static sameSet(a, b2) {
      if (a == b2)
        return true;
      if (a.length != b2.length)
        return false;
      for (let i2 = 0; i2 < a.length; i2++)
        if (!a[i2].eq(b2[i2]))
          return false;
      return true;
    }
    /**
    Create a properly sorted mark set from null, a single mark, or an
    unsorted array of marks.
    */
    static setFrom(marks2) {
      if (!marks2 || Array.isArray(marks2) && marks2.length == 0)
        return Mark.none;
      if (marks2 instanceof Mark)
        return [marks2];
      let copy2 = marks2.slice();
      copy2.sort((a, b2) => a.type.rank - b2.type.rank);
      return copy2;
    }
  }
  Mark.none = [];
  class ReplaceError extends Error {
  }
  class Slice {
    /**
    Create a slice. When specifying a non-zero open depth, you must
    make sure that there are nodes of at least that depth at the
    appropriate side of the fragmenti.e. if the fragment is an
    empty paragraph node, `openStart` and `openEnd` can't be greater
    than 1.
    
    It is not necessary for the content of open nodes to conform to
    the schema's content constraints, though it should be a valid
    start/end/middle for such a node, depending on which sides are
    open.
    */
    constructor(content, openStart, openEnd) {
      this.content = content;
      this.openStart = openStart;
      this.openEnd = openEnd;
    }
    /**
    The size this slice would add when inserted into a document.
    */
    get size() {
      return this.content.size - this.openStart - this.openEnd;
    }
    /**
    @internal
    */
    insertAt(pos, fragment) {
      let content = insertInto(this.content, pos + this.openStart, fragment);
      return content && new Slice(content, this.openStart, this.openEnd);
    }
    /**
    @internal
    */
    removeBetween(from, to) {
      return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);
    }
    /**
    Tests whether this slice is equal to another slice.
    */
    eq(other) {
      return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
    }
    /**
    @internal
    */
    toString() {
      return this.content + "(" + this.openStart + "," + this.openEnd + ")";
    }
    /**
    Convert a slice to a JSON-serializable representation.
    */
    toJSON() {
      if (!this.content.size)
        return null;
      let json = { content: this.content.toJSON() };
      if (this.openStart > 0)
        json.openStart = this.openStart;
      if (this.openEnd > 0)
        json.openEnd = this.openEnd;
      return json;
    }
    /**
    Deserialize a slice from its JSON representation.
    */
    static fromJSON(schema2, json) {
      if (!json)
        return Slice.empty;
      let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
      if (typeof openStart != "number" || typeof openEnd != "number")
        throw new RangeError("Invalid input for Slice.fromJSON");
      return new Slice(Fragment.fromJSON(schema2, json.content), openStart, openEnd);
    }
    /**
    Create a slice from a fragment by taking the maximum possible
    open value on both side of the fragment.
    */
    static maxOpen(fragment, openIsolating = true) {
      let openStart = 0, openEnd = 0;
      for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
        openStart++;
      for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
        openEnd++;
      return new Slice(fragment, openStart, openEnd);
    }
  }
  Slice.empty = new Slice(Fragment.empty, 0, 0);
  function removeRange(content, from, to) {
    let { index, offset: offset2 } = content.findIndex(from), child = content.maybeChild(index);
    let { index: indexTo, offset: offsetTo } = content.findIndex(to);
    if (offset2 == from || child.isText) {
      if (offsetTo != to && !content.child(indexTo).isText)
        throw new RangeError("Removing non-flat range");
      return content.cut(0, from).append(content.cut(to));
    }
    if (index != indexTo)
      throw new RangeError("Removing non-flat range");
    return content.replaceChild(index, child.copy(removeRange(child.content, from - offset2 - 1, to - offset2 - 1)));
  }
  function insertInto(content, dist, insert, parent) {
    let { index, offset: offset2 } = content.findIndex(dist), child = content.maybeChild(index);
    if (offset2 == dist || child.isText) {
      if (parent && !parent.canReplace(index, index, insert))
        return null;
      return content.cut(0, dist).append(insert).append(content.cut(dist));
    }
    let inner = insertInto(child.content, dist - offset2 - 1, insert, child);
    return inner && content.replaceChild(index, child.copy(inner));
  }
  function replace($from, $to, slice) {
    if (slice.openStart > $from.depth)
      throw new ReplaceError("Inserted content deeper than insertion position");
    if ($from.depth - slice.openStart != $to.depth - slice.openEnd)
      throw new ReplaceError("Inconsistent open depths");
    return replaceOuter($from, $to, slice, 0);
  }
  function replaceOuter($from, $to, slice, depth) {
    let index = $from.index(depth), node = $from.node(depth);
    if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {
      let inner = replaceOuter($from, $to, slice, depth + 1);
      return node.copy(node.content.replaceChild(index, inner));
    } else if (!slice.content.size) {
      return close(node, replaceTwoWay($from, $to, depth));
    } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {
      let parent = $from.parent, content = parent.content;
      return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));
    } else {
      let { start, end } = prepareSliceForReplace(slice, $from);
      return close(node, replaceThreeWay($from, start, end, $to, depth));
    }
  }
  function checkJoin(main, sub) {
    if (!sub.type.compatibleContent(main.type))
      throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
  }
  function joinable$1($before, $after, depth) {
    let node = $before.node(depth);
    checkJoin(node, $after.node(depth));
    return node;
  }
  function addNode(child, target) {
    let last2 = target.length - 1;
    if (last2 >= 0 && child.isText && child.sameMarkup(target[last2]))
      target[last2] = child.withText(target[last2].text + child.text);
    else
      target.push(child);
  }
  function addRange($start, $end, depth, target) {
    let node = ($end || $start).node(depth);
    let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
    if ($start) {
      startIndex = $start.index(depth);
      if ($start.depth > depth) {
        startIndex++;
      } else if ($start.textOffset) {
        addNode($start.nodeAfter, target);
        startIndex++;
      }
    }
    for (let i2 = startIndex; i2 < endIndex; i2++)
      addNode(node.child(i2), target);
    if ($end && $end.depth == depth && $end.textOffset)
      addNode($end.nodeBefore, target);
  }
  function close(node, content) {
    node.type.checkContent(content);
    return node.copy(content);
  }
  function replaceThreeWay($from, $start, $end, $to, depth) {
    let openStart = $from.depth > depth && joinable$1($from, $start, depth + 1);
    let openEnd = $to.depth > depth && joinable$1($end, $to, depth + 1);
    let content = [];
    addRange(null, $from, depth, content);
    if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
      checkJoin(openStart, openEnd);
      addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
    } else {
      if (openStart)
        addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
      addRange($start, $end, depth, content);
      if (openEnd)
        addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
    }
    addRange($to, null, depth, content);
    return new Fragment(content);
  }
  function replaceTwoWay($from, $to, depth) {
    let content = [];
    addRange(null, $from, depth, content);
    if ($from.depth > depth) {
      let type = joinable$1($from, $to, depth + 1);
      addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
    }
    addRange($to, null, depth, content);
    return new Fragment(content);
  }
  function prepareSliceForReplace(slice, $along) {
    let extra = $along.depth - slice.openStart, parent = $along.node(extra);
    let node = parent.copy(slice.content);
    for (let i2 = extra - 1; i2 >= 0; i2--)
      node = $along.node(i2).copy(Fragment.from(node));
    return {
      start: node.resolveNoCache(slice.openStart + extra),
      end: node.resolveNoCache(node.content.size - slice.openEnd - extra)
    };
  }
  class ResolvedPos {
    /**
    @internal
    */
    constructor(pos, path, parentOffset) {
      this.pos = pos;
      this.path = path;
      this.parentOffset = parentOffset;
      this.depth = path.length / 3 - 1;
    }
    /**
    @internal
    */
    resolveDepth(val) {
      if (val == null)
        return this.depth;
      if (val < 0)
        return this.depth + val;
      return val;
    }
    /**
    The parent node that the position points into. Note that even if
    a position points into a text node, that node is not considered
    the parenttext nodes are flat in this model, and have no content.
    */
    get parent() {
      return this.node(this.depth);
    }
    /**
    The root node in which the position was resolved.
    */
    get doc() {
      return this.node(0);
    }
    /**
    The ancestor node at the given level. `p.node(p.depth)` is the
    same as `p.parent`.
    */
    node(depth) {
      return this.path[this.resolveDepth(depth) * 3];
    }
    /**
    The index into the ancestor at the given level. If this points
    at the 3rd node in the 2nd paragraph on the top level, for
    example, `p.index(0)` is 1 and `p.index(1)` is 2.
    */
    index(depth) {
      return this.path[this.resolveDepth(depth) * 3 + 1];
    }
    /**
    The index pointing after this position into the ancestor at the
    given level.
    */
    indexAfter(depth) {
      depth = this.resolveDepth(depth);
      return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
    }
    /**
    The (absolute) position at the start of the node at the given
    level.
    */
    start(depth) {
      depth = this.resolveDepth(depth);
      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    }
    /**
    The (absolute) position at the end of the node at the given
    level.
    */
    end(depth) {
      depth = this.resolveDepth(depth);
      return this.start(depth) + this.node(depth).content.size;
    }
    /**
    The (absolute) position directly before the wrapping node at the
    given level, or, when `depth` is `this.depth + 1`, the original
    position.
    */
    before(depth) {
      depth = this.resolveDepth(depth);
      if (!depth)
        throw new RangeError("There is no position before the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
    }
    /**
    The (absolute) position directly after the wrapping node at the
    given level, or the original position when `depth` is `this.depth + 1`.
    */
    after(depth) {
      depth = this.resolveDepth(depth);
      if (!depth)
        throw new RangeError("There is no position after the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
    }
    /**
    When this position points into a text node, this returns the
    distance between the position and the start of the text node.
    Will be zero for positions that point between nodes.
    */
    get textOffset() {
      return this.pos - this.path[this.path.length - 1];
    }
    /**
    Get the node directly after the position, if any. If the position
    points into a text node, only the part of that node after the
    position is returned.
    */
    get nodeAfter() {
      let parent = this.parent, index = this.index(this.depth);
      if (index == parent.childCount)
        return null;
      let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
      return dOff ? parent.child(index).cut(dOff) : child;
    }
    /**
    Get the node directly before the position, if any. If the
    position points into a text node, only the part of that node
    before the position is returned.
    */
    get nodeBefore() {
      let index = this.index(this.depth);
      let dOff = this.pos - this.path[this.path.length - 1];
      if (dOff)
        return this.parent.child(index).cut(0, dOff);
      return index == 0 ? null : this.parent.child(index - 1);
    }
    /**
    Get the position at the given index in the parent node at the
    given depth (which defaults to `this.depth`).
    */
    posAtIndex(index, depth) {
      depth = this.resolveDepth(depth);
      let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
      for (let i2 = 0; i2 < index; i2++)
        pos += node.child(i2).nodeSize;
      return pos;
    }
    /**
    Get the marks at this position, factoring in the surrounding
    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
    position is at the start of a non-empty node, the marks of the
    node after it (if any) are returned.
    */
    marks() {
      let parent = this.parent, index = this.index();
      if (parent.content.size == 0)
        return Mark.none;
      if (this.textOffset)
        return parent.child(index).marks;
      let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);
      if (!main) {
        let tmp = main;
        main = other;
        other = tmp;
      }
      let marks2 = main.marks;
      for (var i2 = 0; i2 < marks2.length; i2++)
        if (marks2[i2].type.spec.inclusive === false && (!other || !marks2[i2].isInSet(other.marks)))
          marks2 = marks2[i2--].removeFromSet(marks2);
      return marks2;
    }
    /**
    Get the marks after the current position, if any, except those
    that are non-inclusive and not present at position `$end`. This
    is mostly useful for getting the set of marks to preserve after a
    deletion. Will return `null` if this position is at the end of
    its parent node or its parent node isn't a textblock (in which
    case no marks should be preserved).
    */
    marksAcross($end) {
      let after = this.parent.maybeChild(this.index());
      if (!after || !after.isInline)
        return null;
      let marks2 = after.marks, next = $end.parent.maybeChild($end.index());
      for (var i2 = 0; i2 < marks2.length; i2++)
        if (marks2[i2].type.spec.inclusive === false && (!next || !marks2[i2].isInSet(next.marks)))
          marks2 = marks2[i2--].removeFromSet(marks2);
      return marks2;
    }
    /**
    The depth up to which this position and the given (non-resolved)
    position share the same parent nodes.
    */
    sharedDepth(pos) {
      for (let depth = this.depth; depth > 0; depth--)
        if (this.start(depth) <= pos && this.end(depth) >= pos)
          return depth;
      return 0;
    }
    /**
    Returns a range based on the place where this position and the
    given position diverge around block content. If both point into
    the same textblock, for example, a range around that textblock
    will be returned. If they point into different blocks, the range
    around those blocks in their shared ancestor is returned. You can
    pass in an optional predicate that will be called with a parent
    node to see if a range into that parent is acceptable.
    */
    blockRange(other = this, pred) {
      if (other.pos < this.pos)
        return other.blockRange(this);
      for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
        if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
          return new NodeRange(this, other, d);
      return null;
    }
    /**
    Query whether the given position shares the same parent node.
    */
    sameParent(other) {
      return this.pos - this.parentOffset == other.pos - other.parentOffset;
    }
    /**
    Return the greater of this and the given position.
    */
    max(other) {
      return other.pos > this.pos ? other : this;
    }
    /**
    Return the smaller of this and the given position.
    */
    min(other) {
      return other.pos < this.pos ? other : this;
    }
    /**
    @internal
    */
    toString() {
      let str = "";
      for (let i2 = 1; i2 <= this.depth; i2++)
        str += (str ? "/" : "") + this.node(i2).type.name + "_" + this.index(i2 - 1);
      return str + ":" + this.parentOffset;
    }
    /**
    @internal
    */
    static resolve(doc2, pos) {
      if (!(pos >= 0 && pos <= doc2.content.size))
        throw new RangeError("Position " + pos + " out of range");
      let path = [];
      let start = 0, parentOffset = pos;
      for (let node = doc2; ; ) {
        let { index, offset: offset2 } = node.content.findIndex(parentOffset);
        let rem = parentOffset - offset2;
        path.push(node, index, start + offset2);
        if (!rem)
          break;
        node = node.child(index);
        if (node.isText)
          break;
        parentOffset = rem - 1;
        start += offset2 + 1;
      }
      return new ResolvedPos(pos, path, parentOffset);
    }
    /**
    @internal
    */
    static resolveCached(doc2, pos) {
      let cache = resolveCache.get(doc2);
      if (cache) {
        for (let i2 = 0; i2 < cache.elts.length; i2++) {
          let elt = cache.elts[i2];
          if (elt.pos == pos)
            return elt;
        }
      } else {
        resolveCache.set(doc2, cache = new ResolveCache());
      }
      let result = cache.elts[cache.i] = ResolvedPos.resolve(doc2, pos);
      cache.i = (cache.i + 1) % resolveCacheSize;
      return result;
    }
  }
  class ResolveCache {
    constructor() {
      this.elts = [];
      this.i = 0;
    }
  }
  const resolveCacheSize = 12, resolveCache = /* @__PURE__ */ new WeakMap();
  class NodeRange {
    /**
    Construct a node range. `$from` and `$to` should point into the
    same node until at least the given `depth`, since a node range
    denotes an adjacent set of nodes in a single parent node.
    */
    constructor($from, $to, depth) {
      this.$from = $from;
      this.$to = $to;
      this.depth = depth;
    }
    /**
    The position at the start of the range.
    */
    get start() {
      return this.$from.before(this.depth + 1);
    }
    /**
    The position at the end of the range.
    */
    get end() {
      return this.$to.after(this.depth + 1);
    }
    /**
    The parent node that the range points into.
    */
    get parent() {
      return this.$from.node(this.depth);
    }
    /**
    The start index of the range in the parent node.
    */
    get startIndex() {
      return this.$from.index(this.depth);
    }
    /**
    The end index of the range in the parent node.
    */
    get endIndex() {
      return this.$to.indexAfter(this.depth);
    }
  }
  const emptyAttrs = /* @__PURE__ */ Object.create(null);
  let Node$1 = class Node2 {
    /**
    @internal
    */
    constructor(type, attrs, content, marks2 = Mark.none) {
      this.type = type;
      this.attrs = attrs;
      this.marks = marks2;
      this.content = content || Fragment.empty;
    }
    /**
    The array of this node's child nodes.
    */
    get children() {
      return this.content.content;
    }
    /**
    The size of this node, as defined by the integer-based [indexing
    scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
    amount of characters. For other leaf nodes, it is one. For
    non-leaf nodes, it is the size of the content plus two (the
    start and end token).
    */
    get nodeSize() {
      return this.isLeaf ? 1 : 2 + this.content.size;
    }
    /**
    The number of children that the node has.
    */
    get childCount() {
      return this.content.childCount;
    }
    /**
    Get the child node at the given index. Raises an error when the
    index is out of range.
    */
    child(index) {
      return this.content.child(index);
    }
    /**
    Get the child node at the given index, if it exists.
    */
    maybeChild(index) {
      return this.content.maybeChild(index);
    }
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
    forEach(f) {
      this.content.forEach(f);
    }
    /**
    Invoke a callback for all descendant nodes recursively between
    the given two positions that are relative to start of this
    node's content. The callback is invoked with the node, its
    position relative to the original node (method receiver),
    its parent node, and its child index. When the callback returns
    false for a given node, that node's children will not be
    recursed over. The last parameter can be used to specify a
    starting position to count from.
    */
    nodesBetween(from, to, f, startPos = 0) {
      this.content.nodesBetween(from, to, f, startPos, this);
    }
    /**
    Call the given callback for every descendant node. Doesn't
    descend into a node when the callback returns `false`.
    */
    descendants(f) {
      this.nodesBetween(0, this.content.size, f);
    }
    /**
    Concatenates all the text nodes found in this fragment and its
    children.
    */
    get textContent() {
      return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
    }
    /**
    Get all text between positions `from` and `to`. When
    `blockSeparator` is given, it will be inserted to separate text
    from different block nodes. If `leafText` is given, it'll be
    inserted for every non-text leaf node encountered, otherwise
    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
    */
    textBetween(from, to, blockSeparator, leafText) {
      return this.content.textBetween(from, to, blockSeparator, leafText);
    }
    /**
    Returns this node's first child, or `null` if there are no
    children.
    */
    get firstChild() {
      return this.content.firstChild;
    }
    /**
    Returns this node's last child, or `null` if there are no
    children.
    */
    get lastChild() {
      return this.content.lastChild;
    }
    /**
    Test whether two nodes represent the same piece of document.
    */
    eq(other) {
      return this == other || this.sameMarkup(other) && this.content.eq(other.content);
    }
    /**
    Compare the markup (type, attributes, and marks) of this node to
    those of another. Returns `true` if both have the same markup.
    */
    sameMarkup(other) {
      return this.hasMarkup(other.type, other.attrs, other.marks);
    }
    /**
    Check whether this node's markup correspond to the given type,
    attributes, and marks.
    */
    hasMarkup(type, attrs, marks2) {
      return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks2 || Mark.none);
    }
    /**
    Create a new node with the same markup as this node, containing
    the given content (or empty, if no content is given).
    */
    copy(content = null) {
      if (content == this.content)
        return this;
      return new Node2(this.type, this.attrs, content, this.marks);
    }
    /**
    Create a copy of this node, with the given set of marks instead
    of the node's own marks.
    */
    mark(marks2) {
      return marks2 == this.marks ? this : new Node2(this.type, this.attrs, this.content, marks2);
    }
    /**
    Create a copy of this node with only the content between the
    given positions. If `to` is not given, it defaults to the end of
    the node.
    */
    cut(from, to = this.content.size) {
      if (from == 0 && to == this.content.size)
        return this;
      return this.copy(this.content.cut(from, to));
    }
    /**
    Cut out the part of the document between the given positions, and
    return it as a `Slice` object.
    */
    slice(from, to = this.content.size, includeParents = false) {
      if (from == to)
        return Slice.empty;
      let $from = this.resolve(from), $to = this.resolve(to);
      let depth = includeParents ? 0 : $from.sharedDepth(to);
      let start = $from.start(depth), node = $from.node(depth);
      let content = node.content.cut($from.pos - start, $to.pos - start);
      return new Slice(content, $from.depth - depth, $to.depth - depth);
    }
    /**
    Replace the part of the document between the given positions with
    the given slice. The slice must 'fit', meaning its open sides
    must be able to connect to the surrounding content, and its
    content nodes must be valid children for the node they are placed
    into. If any of this is violated, an error of type
    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
    */
    replace(from, to, slice) {
      return replace(this.resolve(from), this.resolve(to), slice);
    }
    /**
    Find the node directly after the given position.
    */
    nodeAt(pos) {
      for (let node = this; ; ) {
        let { index, offset: offset2 } = node.content.findIndex(pos);
        node = node.maybeChild(index);
        if (!node)
          return null;
        if (offset2 == pos || node.isText)
          return node;
        pos -= offset2 + 1;
      }
    }
    /**
    Find the (direct) child node after the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childAfter(pos) {
      let { index, offset: offset2 } = this.content.findIndex(pos);
      return { node: this.content.maybeChild(index), index, offset: offset2 };
    }
    /**
    Find the (direct) child node before the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childBefore(pos) {
      if (pos == 0)
        return { node: null, index: 0, offset: 0 };
      let { index, offset: offset2 } = this.content.findIndex(pos);
      if (offset2 < pos)
        return { node: this.content.child(index), index, offset: offset2 };
      let node = this.content.child(index - 1);
      return { node, index: index - 1, offset: offset2 - node.nodeSize };
    }
    /**
    Resolve the given position in the document, returning an
    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
    */
    resolve(pos) {
      return ResolvedPos.resolveCached(this, pos);
    }
    /**
    @internal
    */
    resolveNoCache(pos) {
      return ResolvedPos.resolve(this, pos);
    }
    /**
    Test whether a given mark or mark type occurs in this document
    between the two given positions.
    */
    rangeHasMark(from, to, type) {
      let found2 = false;
      if (to > from)
        this.nodesBetween(from, to, (node) => {
          if (type.isInSet(node.marks))
            found2 = true;
          return !found2;
        });
      return found2;
    }
    /**
    True when this is a block (non-inline node)
    */
    get isBlock() {
      return this.type.isBlock;
    }
    /**
    True when this is a textblock node, a block node with inline
    content.
    */
    get isTextblock() {
      return this.type.isTextblock;
    }
    /**
    True when this node allows inline content.
    */
    get inlineContent() {
      return this.type.inlineContent;
    }
    /**
    True when this is an inline node (a text node or a node that can
    appear among text).
    */
    get isInline() {
      return this.type.isInline;
    }
    /**
    True when this is a text node.
    */
    get isText() {
      return this.type.isText;
    }
    /**
    True when this is a leaf node.
    */
    get isLeaf() {
      return this.type.isLeaf;
    }
    /**
    True when this is an atom, i.e. when it does not have directly
    editable content. This is usually the same as `isLeaf`, but can
    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
    on a node's spec (typically used when the node is displayed as
    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
    */
    get isAtom() {
      return this.type.isAtom;
    }
    /**
    Return a string representation of this node for debugging
    purposes.
    */
    toString() {
      if (this.type.spec.toDebugString)
        return this.type.spec.toDebugString(this);
      let name = this.type.name;
      if (this.content.size)
        name += "(" + this.content.toStringInner() + ")";
      return wrapMarks(this.marks, name);
    }
    /**
    Get the content match in this node at the given index.
    */
    contentMatchAt(index) {
      let match = this.type.contentMatch.matchFragment(this.content, 0, index);
      if (!match)
        throw new Error("Called contentMatchAt on a node with invalid content");
      return match;
    }
    /**
    Test whether replacing the range between `from` and `to` (by
    child index) with the given replacement fragment (which defaults
    to the empty fragment) would leave the node's content valid. You
    can optionally pass `start` and `end` indices into the
    replacement fragment.
    */
    canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {
      let one = this.contentMatchAt(from).matchFragment(replacement, start, end);
      let two = one && one.matchFragment(this.content, to);
      if (!two || !two.validEnd)
        return false;
      for (let i2 = start; i2 < end; i2++)
        if (!this.type.allowsMarks(replacement.child(i2).marks))
          return false;
      return true;
    }
    /**
    Test whether replacing the range `from` to `to` (by index) with
    a node of the given type would leave the node's content valid.
    */
    canReplaceWith(from, to, type, marks2) {
      if (marks2 && !this.type.allowsMarks(marks2))
        return false;
      let start = this.contentMatchAt(from).matchType(type);
      let end = start && start.matchFragment(this.content, to);
      return end ? end.validEnd : false;
    }
    /**
    Test whether the given node's content could be appended to this
    node. If that node is empty, this will only return true if there
    is at least one node type that can appear in both nodes (to avoid
    merging completely incompatible nodes).
    */
    canAppend(other) {
      if (other.content.size)
        return this.canReplace(this.childCount, this.childCount, other.content);
      else
        return this.type.compatibleContent(other.type);
    }
    /**
    Check whether this node and its descendants conform to the
    schema, and raise an exception when they do not.
    */
    check() {
      this.type.checkContent(this.content);
      this.type.checkAttrs(this.attrs);
      let copy2 = Mark.none;
      for (let i2 = 0; i2 < this.marks.length; i2++) {
        let mark = this.marks[i2];
        mark.type.checkAttrs(mark.attrs);
        copy2 = mark.addToSet(copy2);
      }
      if (!Mark.sameSet(copy2, this.marks))
        throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
      this.content.forEach((node) => node.check());
    }
    /**
    Return a JSON-serializeable representation of this node.
    */
    toJSON() {
      let obj = { type: this.type.name };
      for (let _2 in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      if (this.content.size)
        obj.content = this.content.toJSON();
      if (this.marks.length)
        obj.marks = this.marks.map((n) => n.toJSON());
      return obj;
    }
    /**
    Deserialize a node from its JSON representation.
    */
    static fromJSON(schema2, json) {
      if (!json)
        throw new RangeError("Invalid input for Node.fromJSON");
      let marks2 = void 0;
      if (json.marks) {
        if (!Array.isArray(json.marks))
          throw new RangeError("Invalid mark data for Node.fromJSON");
        marks2 = json.marks.map(schema2.markFromJSON);
      }
      if (json.type == "text") {
        if (typeof json.text != "string")
          throw new RangeError("Invalid text node in JSON");
        return schema2.text(json.text, marks2);
      }
      let content = Fragment.fromJSON(schema2, json.content);
      let node = schema2.nodeType(json.type).create(json.attrs, content, marks2);
      node.type.checkAttrs(node.attrs);
      return node;
    }
  };
  Node$1.prototype.text = void 0;
  class TextNode extends Node$1 {
    /**
    @internal
    */
    constructor(type, attrs, content, marks2) {
      super(type, attrs, null, marks2);
      if (!content)
        throw new RangeError("Empty text nodes are not allowed");
      this.text = content;
    }
    toString() {
      if (this.type.spec.toDebugString)
        return this.type.spec.toDebugString(this);
      return wrapMarks(this.marks, JSON.stringify(this.text));
    }
    get textContent() {
      return this.text;
    }
    textBetween(from, to) {
      return this.text.slice(from, to);
    }
    get nodeSize() {
      return this.text.length;
    }
    mark(marks2) {
      return marks2 == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks2);
    }
    withText(text2) {
      if (text2 == this.text)
        return this;
      return new TextNode(this.type, this.attrs, text2, this.marks);
    }
    cut(from = 0, to = this.text.length) {
      if (from == 0 && to == this.text.length)
        return this;
      return this.withText(this.text.slice(from, to));
    }
    eq(other) {
      return this.sameMarkup(other) && this.text == other.text;
    }
    toJSON() {
      let base2 = super.toJSON();
      base2.text = this.text;
      return base2;
    }
  }
  function wrapMarks(marks2, str) {
    for (let i2 = marks2.length - 1; i2 >= 0; i2--)
      str = marks2[i2].type.name + "(" + str + ")";
    return str;
  }
  class ContentMatch {
    /**
    @internal
    */
    constructor(validEnd) {
      this.validEnd = validEnd;
      this.next = [];
      this.wrapCache = [];
    }
    /**
    @internal
    */
    static parse(string, nodeTypes) {
      let stream = new TokenStream(string, nodeTypes);
      if (stream.next == null)
        return ContentMatch.empty;
      let expr = parseExpr(stream);
      if (stream.next)
        stream.err("Unexpected trailing text");
      let match = dfa(nfa(expr));
      checkForDeadEnds(match, stream);
      return match;
    }
    /**
    Match a node type, returning a match after that node if
    successful.
    */
    matchType(type) {
      for (let i2 = 0; i2 < this.next.length; i2++)
        if (this.next[i2].type == type)
          return this.next[i2].next;
      return null;
    }
    /**
    Try to match a fragment. Returns the resulting match when
    successful.
    */
    matchFragment(frag, start = 0, end = frag.childCount) {
      let cur = this;
      for (let i2 = start; cur && i2 < end; i2++)
        cur = cur.matchType(frag.child(i2).type);
      return cur;
    }
    /**
    @internal
    */
    get inlineContent() {
      return this.next.length != 0 && this.next[0].type.isInline;
    }
    /**
    Get the first matching node type at this match position that can
    be generated.
    */
    get defaultType() {
      for (let i2 = 0; i2 < this.next.length; i2++) {
        let { type } = this.next[i2];
        if (!(type.isText || type.hasRequiredAttrs()))
          return type;
      }
      return null;
    }
    /**
    @internal
    */
    compatible(other) {
      for (let i2 = 0; i2 < this.next.length; i2++)
        for (let j2 = 0; j2 < other.next.length; j2++)
          if (this.next[i2].type == other.next[j2].type)
            return true;
      return false;
    }
    /**
    Try to match the given fragment, and if that fails, see if it can
    be made to match by inserting nodes in front of it. When
    successful, return a fragment of inserted nodes (which may be
    empty if nothing had to be inserted). When `toEnd` is true, only
    return a fragment if the resulting match goes to the end of the
    content expression.
    */
    fillBefore(after, toEnd = false, startIndex = 0) {
      let seen = [this];
      function search(match, types) {
        let finished = match.matchFragment(after, startIndex);
        if (finished && (!toEnd || finished.validEnd))
          return Fragment.from(types.map((tp) => tp.createAndFill()));
        for (let i2 = 0; i2 < match.next.length; i2++) {
          let { type, next } = match.next[i2];
          if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
            seen.push(next);
            let found2 = search(next, types.concat(type));
            if (found2)
              return found2;
          }
        }
        return null;
      }
      return search(this, []);
    }
    /**
    Find a set of wrapping node types that would allow a node of the
    given type to appear at this position. The result may be empty
    (when it fits directly) and will be null when no such wrapping
    exists.
    */
    findWrapping(target) {
      for (let i2 = 0; i2 < this.wrapCache.length; i2 += 2)
        if (this.wrapCache[i2] == target)
          return this.wrapCache[i2 + 1];
      let computed = this.computeWrapping(target);
      this.wrapCache.push(target, computed);
      return computed;
    }
    /**
    @internal
    */
    computeWrapping(target) {
      let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
      while (active.length) {
        let current = active.shift(), match = current.match;
        if (match.matchType(target)) {
          let result = [];
          for (let obj = current; obj.type; obj = obj.via)
            result.push(obj.type);
          return result.reverse();
        }
        for (let i2 = 0; i2 < match.next.length; i2++) {
          let { type, next } = match.next[i2];
          if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
            active.push({ match: type.contentMatch, type, via: current });
            seen[type.name] = true;
          }
        }
      }
      return null;
    }
    /**
    The number of outgoing edges this node has in the finite
    automaton that describes the content expression.
    */
    get edgeCount() {
      return this.next.length;
    }
    /**
    Get the _n_th outgoing edge from this node in the finite
    automaton that describes the content expression.
    */
    edge(n) {
      if (n >= this.next.length)
        throw new RangeError(`There's no ${n}th edge in this content match`);
      return this.next[n];
    }
    /**
    @internal
    */
    toString() {
      let seen = [];
      function scan(m) {
        seen.push(m);
        for (let i2 = 0; i2 < m.next.length; i2++)
          if (seen.indexOf(m.next[i2].next) == -1)
            scan(m.next[i2].next);
      }
      scan(this);
      return seen.map((m, i2) => {
        let out = i2 + (m.validEnd ? "*" : " ") + " ";
        for (let i3 = 0; i3 < m.next.length; i3++)
          out += (i3 ? ", " : "") + m.next[i3].type.name + "->" + seen.indexOf(m.next[i3].next);
        return out;
      }).join("\n");
    }
  }
  ContentMatch.empty = new ContentMatch(true);
  class TokenStream {
    constructor(string, nodeTypes) {
      this.string = string;
      this.nodeTypes = nodeTypes;
      this.inline = null;
      this.pos = 0;
      this.tokens = string.split(/\s*(?=\b|\W|$)/);
      if (this.tokens[this.tokens.length - 1] == "")
        this.tokens.pop();
      if (this.tokens[0] == "")
        this.tokens.shift();
    }
    get next() {
      return this.tokens[this.pos];
    }
    eat(tok) {
      return this.next == tok && (this.pos++ || true);
    }
    err(str) {
      throw new SyntaxError(str + " (in content expression '" + this.string + "')");
    }
  }
  function parseExpr(stream) {
    let exprs = [];
    do {
      exprs.push(parseExprSeq(stream));
    } while (stream.eat("|"));
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  }
  function parseExprSeq(stream) {
    let exprs = [];
    do {
      exprs.push(parseExprSubscript(stream));
    } while (stream.next && stream.next != ")" && stream.next != "|");
    return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
  }
  function parseExprSubscript(stream) {
    let expr = parseExprAtom(stream);
    for (; ; ) {
      if (stream.eat("+"))
        expr = { type: "plus", expr };
      else if (stream.eat("*"))
        expr = { type: "star", expr };
      else if (stream.eat("?"))
        expr = { type: "opt", expr };
      else if (stream.eat("{"))
        expr = parseExprRange(stream, expr);
      else
        break;
    }
    return expr;
  }
  function parseNum(stream) {
    if (/\D/.test(stream.next))
      stream.err("Expected number, got '" + stream.next + "'");
    let result = Number(stream.next);
    stream.pos++;
    return result;
  }
  function parseExprRange(stream, expr) {
    let min2 = parseNum(stream), max2 = min2;
    if (stream.eat(",")) {
      if (stream.next != "}")
        max2 = parseNum(stream);
      else
        max2 = -1;
    }
    if (!stream.eat("}"))
      stream.err("Unclosed braced range");
    return { type: "range", min: min2, max: max2, expr };
  }
  function resolveName(stream, name) {
    let types = stream.nodeTypes, type = types[name];
    if (type)
      return [type];
    let result = [];
    for (let typeName in types) {
      let type2 = types[typeName];
      if (type2.isInGroup(name))
        result.push(type2);
    }
    if (result.length == 0)
      stream.err("No node type or group '" + name + "' found");
    return result;
  }
  function parseExprAtom(stream) {
    if (stream.eat("(")) {
      let expr = parseExpr(stream);
      if (!stream.eat(")"))
        stream.err("Missing closing paren");
      return expr;
    } else if (!/\W/.test(stream.next)) {
      let exprs = resolveName(stream, stream.next).map((type) => {
        if (stream.inline == null)
          stream.inline = type.isInline;
        else if (stream.inline != type.isInline)
          stream.err("Mixing inline and block content");
        return { type: "name", value: type };
      });
      stream.pos++;
      return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
    } else {
      stream.err("Unexpected token '" + stream.next + "'");
    }
  }
  function nfa(expr) {
    let nfa2 = [[]];
    connect(compile(expr, 0), node());
    return nfa2;
    function node() {
      return nfa2.push([]) - 1;
    }
    function edge(from, to, term) {
      let edge2 = { term, to };
      nfa2[from].push(edge2);
      return edge2;
    }
    function connect(edges, to) {
      edges.forEach((edge2) => edge2.to = to);
    }
    function compile(expr2, from) {
      if (expr2.type == "choice") {
        return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from)), []);
      } else if (expr2.type == "seq") {
        for (let i2 = 0; ; i2++) {
          let next = compile(expr2.exprs[i2], from);
          if (i2 == expr2.exprs.length - 1)
            return next;
          connect(next, from = node());
        }
      } else if (expr2.type == "star") {
        let loop = node();
        edge(from, loop);
        connect(compile(expr2.expr, loop), loop);
        return [edge(loop)];
      } else if (expr2.type == "plus") {
        let loop = node();
        connect(compile(expr2.expr, from), loop);
        connect(compile(expr2.expr, loop), loop);
        return [edge(loop)];
      } else if (expr2.type == "opt") {
        return [edge(from)].concat(compile(expr2.expr, from));
      } else if (expr2.type == "range") {
        let cur = from;
        for (let i2 = 0; i2 < expr2.min; i2++) {
          let next = node();
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
        if (expr2.max == -1) {
          connect(compile(expr2.expr, cur), cur);
        } else {
          for (let i2 = expr2.min; i2 < expr2.max; i2++) {
            let next = node();
            edge(cur, next);
            connect(compile(expr2.expr, cur), next);
            cur = next;
          }
        }
        return [edge(cur)];
      } else if (expr2.type == "name") {
        return [edge(from, void 0, expr2.value)];
      } else {
        throw new Error("Unknown expr type");
      }
    }
  }
  function cmp(a, b2) {
    return b2 - a;
  }
  function nullFrom(nfa2, node) {
    let result = [];
    scan(node);
    return result.sort(cmp);
    function scan(node2) {
      let edges = nfa2[node2];
      if (edges.length == 1 && !edges[0].term)
        return scan(edges[0].to);
      result.push(node2);
      for (let i2 = 0; i2 < edges.length; i2++) {
        let { term, to } = edges[i2];
        if (!term && result.indexOf(to) == -1)
          scan(to);
      }
    }
  }
  function dfa(nfa2) {
    let labeled = /* @__PURE__ */ Object.create(null);
    return explore(nullFrom(nfa2, 0));
    function explore(states) {
      let out = [];
      states.forEach((node) => {
        nfa2[node].forEach(({ term, to }) => {
          if (!term)
            return;
          let set2;
          for (let i2 = 0; i2 < out.length; i2++)
            if (out[i2][0] == term)
              set2 = out[i2][1];
          nullFrom(nfa2, to).forEach((node2) => {
            if (!set2)
              out.push([term, set2 = []]);
            if (set2.indexOf(node2) == -1)
              set2.push(node2);
          });
        });
      });
      let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
      for (let i2 = 0; i2 < out.length; i2++) {
        let states2 = out[i2][1].sort(cmp);
        state.next.push({ type: out[i2][0], next: labeled[states2.join(",")] || explore(states2) });
      }
      return state;
    }
  }
  function checkForDeadEnds(match, stream) {
    for (let i2 = 0, work = [match]; i2 < work.length; i2++) {
      let state = work[i2], dead = !state.validEnd, nodes2 = [];
      for (let j2 = 0; j2 < state.next.length; j2++) {
        let { type, next } = state.next[j2];
        nodes2.push(type.name);
        if (dead && !(type.isText || type.hasRequiredAttrs()))
          dead = false;
        if (work.indexOf(next) == -1)
          work.push(next);
      }
      if (dead)
        stream.err("Only non-generatable nodes (" + nodes2.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
  function defaultAttrs(attrs) {
    let defaults2 = /* @__PURE__ */ Object.create(null);
    for (let attrName in attrs) {
      let attr = attrs[attrName];
      if (!attr.hasDefault)
        return null;
      defaults2[attrName] = attr.default;
    }
    return defaults2;
  }
  function computeAttrs(attrs, value) {
    let built = /* @__PURE__ */ Object.create(null);
    for (let name in attrs) {
      let given = value && value[name];
      if (given === void 0) {
        let attr = attrs[name];
        if (attr.hasDefault)
          given = attr.default;
        else
          throw new RangeError("No value supplied for attribute " + name);
      }
      built[name] = given;
    }
    return built;
  }
  function checkAttrs(attrs, values, type, name) {
    for (let name2 in values)
      if (!(name2 in attrs))
        throw new RangeError(`Unsupported attribute ${name2} for ${type} of type ${name2}`);
    for (let name2 in attrs) {
      let attr = attrs[name2];
      if (attr.validate)
        attr.validate(values[name2]);
    }
  }
  function initAttrs(typeName, attrs) {
    let result = /* @__PURE__ */ Object.create(null);
    if (attrs)
      for (let name in attrs)
        result[name] = new Attribute(typeName, name, attrs[name]);
    return result;
  }
  let NodeType$1 = class NodeType2 {
    /**
    @internal
    */
    constructor(name, schema2, spec) {
      this.name = name;
      this.schema = schema2;
      this.spec = spec;
      this.markSet = null;
      this.groups = spec.group ? spec.group.split(" ") : [];
      this.attrs = initAttrs(name, spec.attrs);
      this.defaultAttrs = defaultAttrs(this.attrs);
      this.contentMatch = null;
      this.inlineContent = null;
      this.isBlock = !(spec.inline || name == "text");
      this.isText = name == "text";
    }
    /**
    True if this is an inline type.
    */
    get isInline() {
      return !this.isBlock;
    }
    /**
    True if this is a textblock type, a block that contains inline
    content.
    */
    get isTextblock() {
      return this.isBlock && this.inlineContent;
    }
    /**
    True for node types that allow no content.
    */
    get isLeaf() {
      return this.contentMatch == ContentMatch.empty;
    }
    /**
    True when this node is an atom, i.e. when it does not have
    directly editable content.
    */
    get isAtom() {
      return this.isLeaf || !!this.spec.atom;
    }
    /**
    Return true when this node type is part of the given
    [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
    */
    isInGroup(group) {
      return this.groups.indexOf(group) > -1;
    }
    /**
    The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
    */
    get whitespace() {
      return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
    }
    /**
    Tells you whether this node type has any required attributes.
    */
    hasRequiredAttrs() {
      for (let n in this.attrs)
        if (this.attrs[n].isRequired)
          return true;
      return false;
    }
    /**
    Indicates whether this node allows some of the same content as
    the given node type.
    */
    compatibleContent(other) {
      return this == other || this.contentMatch.compatible(other.contentMatch);
    }
    /**
    @internal
    */
    computeAttrs(attrs) {
      if (!attrs && this.defaultAttrs)
        return this.defaultAttrs;
      else
        return computeAttrs(this.attrs, attrs);
    }
    /**
    Create a `Node` of this type. The given attributes are
    checked and defaulted (you can pass `null` to use the type's
    defaults entirely, if no required attributes exist). `content`
    may be a `Fragment`, a node, an array of nodes, or
    `null`. Similarly `marks` may be `null` to default to the empty
    set of marks.
    */
    create(attrs = null, content, marks2) {
      if (this.isText)
        throw new Error("NodeType.create can't construct text nodes");
      return new Node$1(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks2));
    }
    /**
    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
    against the node type's content restrictions, and throw an error
    if it doesn't match.
    */
    createChecked(attrs = null, content, marks2) {
      content = Fragment.from(content);
      this.checkContent(content);
      return new Node$1(this, this.computeAttrs(attrs), content, Mark.setFrom(marks2));
    }
    /**
    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
    necessary to add nodes to the start or end of the given fragment
    to make it fit the node. If no fitting wrapping can be found,
    return null. Note that, due to the fact that required nodes can
    always be created, this will always succeed if you pass null or
    `Fragment.empty` as content.
    */
    createAndFill(attrs = null, content, marks2) {
      attrs = this.computeAttrs(attrs);
      content = Fragment.from(content);
      if (content.size) {
        let before = this.contentMatch.fillBefore(content);
        if (!before)
          return null;
        content = before.append(content);
      }
      let matched = this.contentMatch.matchFragment(content);
      let after = matched && matched.fillBefore(Fragment.empty, true);
      if (!after)
        return null;
      return new Node$1(this, attrs, content.append(after), Mark.setFrom(marks2));
    }
    /**
    Returns true if the given fragment is valid content for this node
    type.
    */
    validContent(content) {
      let result = this.contentMatch.matchFragment(content);
      if (!result || !result.validEnd)
        return false;
      for (let i2 = 0; i2 < content.childCount; i2++)
        if (!this.allowsMarks(content.child(i2).marks))
          return false;
      return true;
    }
    /**
    Throws a RangeError if the given fragment is not valid content for this
    node type.
    @internal
    */
    checkContent(content) {
      if (!this.validContent(content))
        throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
    }
    /**
    @internal
    */
    checkAttrs(attrs) {
      checkAttrs(this.attrs, attrs, "node", this.name);
    }
    /**
    Check whether the given mark type is allowed in this node.
    */
    allowsMarkType(markType) {
      return this.markSet == null || this.markSet.indexOf(markType) > -1;
    }
    /**
    Test whether the given set of marks are allowed in this node.
    */
    allowsMarks(marks2) {
      if (this.markSet == null)
        return true;
      for (let i2 = 0; i2 < marks2.length; i2++)
        if (!this.allowsMarkType(marks2[i2].type))
          return false;
      return true;
    }
    /**
    Removes the marks that are not allowed in this node from the given set.
    */
    allowedMarks(marks2) {
      if (this.markSet == null)
        return marks2;
      let copy2;
      for (let i2 = 0; i2 < marks2.length; i2++) {
        if (!this.allowsMarkType(marks2[i2].type)) {
          if (!copy2)
            copy2 = marks2.slice(0, i2);
        } else if (copy2) {
          copy2.push(marks2[i2]);
        }
      }
      return !copy2 ? marks2 : copy2.length ? copy2 : Mark.none;
    }
    /**
    @internal
    */
    static compile(nodes2, schema2) {
      let result = /* @__PURE__ */ Object.create(null);
      nodes2.forEach((name, spec) => result[name] = new NodeType2(name, schema2, spec));
      let topType = schema2.spec.topNode || "doc";
      if (!result[topType])
        throw new RangeError("Schema is missing its top node type ('" + topType + "')");
      if (!result.text)
        throw new RangeError("Every schema needs a 'text' type");
      for (let _2 in result.text.attrs)
        throw new RangeError("The text node type should not have attributes");
      return result;
    }
  };
  function validateType(typeName, attrName, type) {
    let types = type.split("|");
    return (value) => {
      let name = value === null ? "null" : typeof value;
      if (types.indexOf(name) < 0)
        throw new RangeError(`Expected value of type ${types} for attribute ${attrName} on type ${typeName}, got ${name}`);
    };
  }
  class Attribute {
    constructor(typeName, attrName, options) {
      this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
      this.default = options.default;
      this.validate = typeof options.validate == "string" ? validateType(typeName, attrName, options.validate) : options.validate;
    }
    get isRequired() {
      return !this.hasDefault;
    }
  }
  class MarkType {
    /**
    @internal
    */
    constructor(name, rank, schema2, spec) {
      this.name = name;
      this.rank = rank;
      this.schema = schema2;
      this.spec = spec;
      this.attrs = initAttrs(name, spec.attrs);
      this.excluded = null;
      let defaults2 = defaultAttrs(this.attrs);
      this.instance = defaults2 ? new Mark(this, defaults2) : null;
    }
    /**
    Create a mark of this type. `attrs` may be `null` or an object
    containing only some of the mark's attributes. The others, if
    they have defaults, will be added.
    */
    create(attrs = null) {
      if (!attrs && this.instance)
        return this.instance;
      return new Mark(this, computeAttrs(this.attrs, attrs));
    }
    /**
    @internal
    */
    static compile(marks2, schema2) {
      let result = /* @__PURE__ */ Object.create(null), rank = 0;
      marks2.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema2, spec));
      return result;
    }
    /**
    When there is a mark of this type in the given set, a new set
    without it is returned. Otherwise, the input set is returned.
    */
    removeFromSet(set2) {
      for (var i2 = 0; i2 < set2.length; i2++)
        if (set2[i2].type == this) {
          set2 = set2.slice(0, i2).concat(set2.slice(i2 + 1));
          i2--;
        }
      return set2;
    }
    /**
    Tests whether there is a mark of this type in the given set.
    */
    isInSet(set2) {
      for (let i2 = 0; i2 < set2.length; i2++)
        if (set2[i2].type == this)
          return set2[i2];
    }
    /**
    @internal
    */
    checkAttrs(attrs) {
      checkAttrs(this.attrs, attrs, "mark", this.name);
    }
    /**
    Queries whether a given mark type is
    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
    */
    excludes(other) {
      return this.excluded.indexOf(other) > -1;
    }
  }
  class Schema {
    /**
    Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
    */
    constructor(spec) {
      this.linebreakReplacement = null;
      this.cached = /* @__PURE__ */ Object.create(null);
      let instanceSpec = this.spec = {};
      for (let prop in spec)
        instanceSpec[prop] = spec[prop];
      instanceSpec.nodes = OrderedMap.from(spec.nodes), instanceSpec.marks = OrderedMap.from(spec.marks || {}), this.nodes = NodeType$1.compile(this.spec.nodes, this);
      this.marks = MarkType.compile(this.spec.marks, this);
      let contentExprCache = /* @__PURE__ */ Object.create(null);
      for (let prop in this.nodes) {
        if (prop in this.marks)
          throw new RangeError(prop + " can not be both a node and a mark");
        let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
        type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
        type.inlineContent = type.contentMatch.inlineContent;
        if (type.spec.linebreakReplacement) {
          if (this.linebreakReplacement)
            throw new RangeError("Multiple linebreak nodes defined");
          if (!type.isInline || !type.isLeaf)
            throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
          this.linebreakReplacement = type;
        }
        type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
      }
      for (let prop in this.marks) {
        let type = this.marks[prop], excl = type.spec.excludes;
        type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
      }
      this.nodeFromJSON = (json) => Node$1.fromJSON(this, json);
      this.markFromJSON = (json) => Mark.fromJSON(this, json);
      this.topNodeType = this.nodes[this.spec.topNode || "doc"];
      this.cached.wrappings = /* @__PURE__ */ Object.create(null);
    }
    /**
    Create a node in this schema. The `type` may be a string or a
    `NodeType` instance. Attributes will be extended with defaults,
    `content` may be a `Fragment`, `null`, a `Node`, or an array of
    nodes.
    */
    node(type, attrs = null, content, marks2) {
      if (typeof type == "string")
        type = this.nodeType(type);
      else if (!(type instanceof NodeType$1))
        throw new RangeError("Invalid node type: " + type);
      else if (type.schema != this)
        throw new RangeError("Node type from different schema used (" + type.name + ")");
      return type.createChecked(attrs, content, marks2);
    }
    /**
    Create a text node in the schema. Empty text nodes are not
    allowed.
    */
    text(text2, marks2) {
      let type = this.nodes.text;
      return new TextNode(type, type.defaultAttrs, text2, Mark.setFrom(marks2));
    }
    /**
    Create a mark with the given type and attributes.
    */
    mark(type, attrs) {
      if (typeof type == "string")
        type = this.marks[type];
      return type.create(attrs);
    }
    /**
    @internal
    */
    nodeType(name) {
      let found2 = this.nodes[name];
      if (!found2)
        throw new RangeError("Unknown node type: " + name);
      return found2;
    }
  }
  function gatherMarks(schema2, marks2) {
    let found2 = [];
    for (let i2 = 0; i2 < marks2.length; i2++) {
      let name = marks2[i2], mark = schema2.marks[name], ok = mark;
      if (mark) {
        found2.push(mark);
      } else {
        for (let prop in schema2.marks) {
          let mark2 = schema2.marks[prop];
          if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
            found2.push(ok = mark2);
        }
      }
      if (!ok)
        throw new SyntaxError("Unknown mark type: '" + marks2[i2] + "'");
    }
    return found2;
  }
  function isTagRule(rule) {
    return rule.tag != null;
  }
  function isStyleRule(rule) {
    return rule.style != null;
  }
  let DOMParser$1 = class DOMParser2 {
    /**
    Create a parser that targets the given schema, using the given
    parsing rules.
    */
    constructor(schema2, rules) {
      this.schema = schema2;
      this.rules = rules;
      this.tags = [];
      this.styles = [];
      let matchedStyles = this.matchedStyles = [];
      rules.forEach((rule) => {
        if (isTagRule(rule)) {
          this.tags.push(rule);
        } else if (isStyleRule(rule)) {
          let prop = /[^=]*/.exec(rule.style)[0];
          if (matchedStyles.indexOf(prop) < 0)
            matchedStyles.push(prop);
          this.styles.push(rule);
        }
      });
      this.normalizeLists = !this.tags.some((r) => {
        if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
          return false;
        let node = schema2.nodes[r.node];
        return node.contentMatch.matchType(node);
      });
    }
    /**
    Parse a document from the content of a DOM node.
    */
    parse(dom, options = {}) {
      let context = new ParseContext(this, options, false);
      context.addAll(dom, Mark.none, options.from, options.to);
      return context.finish();
    }
    /**
    Parses the content of the given DOM node, like
    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
    options. But unlike that method, which produces a whole node,
    this one returns a slice that is open at the sides, meaning that
    the schema constraints aren't applied to the start of nodes to
    the left of the input and the end of nodes at the end.
    */
    parseSlice(dom, options = {}) {
      let context = new ParseContext(this, options, true);
      context.addAll(dom, Mark.none, options.from, options.to);
      return Slice.maxOpen(context.finish());
    }
    /**
    @internal
    */
    matchTag(dom, context, after) {
      for (let i2 = after ? this.tags.indexOf(after) + 1 : 0; i2 < this.tags.length; i2++) {
        let rule = this.tags[i2];
        if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
          if (rule.getAttrs) {
            let result = rule.getAttrs(dom);
            if (result === false)
              continue;
            rule.attrs = result || void 0;
          }
          return rule;
        }
      }
    }
    /**
    @internal
    */
    matchStyle(prop, value, context, after) {
      for (let i2 = after ? this.styles.indexOf(after) + 1 : 0; i2 < this.styles.length; i2++) {
        let rule = this.styles[i2], style = rule.style;
        if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
        // or has an '=' sign after the prop, followed by the given
        // value.
        style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value))
          continue;
        if (rule.getAttrs) {
          let result = rule.getAttrs(value);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
    /**
    @internal
    */
    static schemaRules(schema2) {
      let result = [];
      function insert(rule) {
        let priority = rule.priority == null ? 50 : rule.priority, i2 = 0;
        for (; i2 < result.length; i2++) {
          let next = result[i2], nextPriority = next.priority == null ? 50 : next.priority;
          if (nextPriority < priority)
            break;
        }
        result.splice(i2, 0, rule);
      }
      for (let name in schema2.marks) {
        let rules = schema2.marks[name].spec.parseDOM;
        if (rules)
          rules.forEach((rule) => {
            insert(rule = copy(rule));
            if (!(rule.mark || rule.ignore || rule.clearMark))
              rule.mark = name;
          });
      }
      for (let name in schema2.nodes) {
        let rules = schema2.nodes[name].spec.parseDOM;
        if (rules)
          rules.forEach((rule) => {
            insert(rule = copy(rule));
            if (!(rule.node || rule.ignore || rule.mark))
              rule.node = name;
          });
      }
      return result;
    }
    /**
    Construct a DOM parser using the parsing rules listed in a
    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
    [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
    */
    static fromSchema(schema2) {
      return schema2.cached.domParser || (schema2.cached.domParser = new DOMParser2(schema2, DOMParser2.schemaRules(schema2)));
    }
  };
  const blockTags = {
    address: true,
    article: true,
    aside: true,
    blockquote: true,
    canvas: true,
    dd: true,
    div: true,
    dl: true,
    fieldset: true,
    figcaption: true,
    figure: true,
    footer: true,
    form: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    header: true,
    hgroup: true,
    hr: true,
    li: true,
    noscript: true,
    ol: true,
    output: true,
    p: true,
    pre: true,
    section: true,
    table: true,
    tfoot: true,
    ul: true
  };
  const ignoreTags = {
    head: true,
    noscript: true,
    object: true,
    script: true,
    style: true,
    title: true
  };
  const listTags = { ol: true, ul: true };
  const OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;
  function wsOptionsFor(type, preserveWhitespace, base2) {
    if (preserveWhitespace != null)
      return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
    return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
  }
  class NodeContext {
    constructor(type, attrs, marks2, solid, match, options) {
      this.type = type;
      this.attrs = attrs;
      this.marks = marks2;
      this.solid = solid;
      this.options = options;
      this.content = [];
      this.activeMarks = Mark.none;
      this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
    }
    findWrapping(node) {
      if (!this.match) {
        if (!this.type)
          return [];
        let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
        if (fill) {
          this.match = this.type.contentMatch.matchFragment(fill);
        } else {
          let start = this.type.contentMatch, wrap2;
          if (wrap2 = start.findWrapping(node.type)) {
            this.match = start;
            return wrap2;
          } else {
            return null;
          }
        }
      }
      return this.match.findWrapping(node.type);
    }
    finish(openEnd) {
      if (!(this.options & OPT_PRESERVE_WS)) {
        let last2 = this.content[this.content.length - 1], m;
        if (last2 && last2.isText && (m = /[ \t\r\n\u000c]+$/.exec(last2.text))) {
          let text2 = last2;
          if (last2.text.length == m[0].length)
            this.content.pop();
          else
            this.content[this.content.length - 1] = text2.withText(text2.text.slice(0, text2.text.length - m[0].length));
        }
      }
      let content = Fragment.from(this.content);
      if (!openEnd && this.match)
        content = content.append(this.match.fillBefore(Fragment.empty, true));
      return this.type ? this.type.create(this.attrs, content, this.marks) : content;
    }
    inlineContext(node) {
      if (this.type)
        return this.type.inlineContent;
      if (this.content.length)
        return this.content[0].isInline;
      return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
    }
  }
  class ParseContext {
    constructor(parser, options, isOpen) {
      this.parser = parser;
      this.options = options;
      this.isOpen = isOpen;
      this.open = 0;
      this.localPreserveWS = false;
      let topNode = options.topNode, topContext;
      let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
      if (topNode)
        topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
      else if (isOpen)
        topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);
      else
        topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);
      this.nodes = [topContext];
      this.find = options.findPositions;
      this.needsBlock = false;
    }
    get top() {
      return this.nodes[this.open];
    }
    // Add a DOM node to the content. Text is inserted as text node,
    // otherwise, the node is passed to `addElement` or, if it has a
    // `style` attribute, `addElementWithStyles`.
    addDOM(dom, marks2) {
      if (dom.nodeType == 3)
        this.addTextNode(dom, marks2);
      else if (dom.nodeType == 1)
        this.addElement(dom, marks2);
    }
    addTextNode(dom, marks2) {
      let value = dom.nodeValue;
      let top = this.top, preserveWS = top.options & OPT_PRESERVE_WS_FULL ? "full" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;
      if (preserveWS === "full" || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
        if (!preserveWS) {
          value = value.replace(/[ \t\r\n\u000c]+/g, " ");
          if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
            let nodeBefore = top.content[top.content.length - 1];
            let domNodeBefore = dom.previousSibling;
            if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
              value = value.slice(1);
          }
        } else if (preserveWS !== "full") {
          value = value.replace(/\r?\n|\r/g, " ");
        } else {
          value = value.replace(/\r\n?/g, "\n");
        }
        if (value)
          this.insertNode(this.parser.schema.text(value), marks2, !/\S/.test(value));
        this.findInText(dom);
      } else {
        this.findInside(dom);
      }
    }
    // Try to find a handler for the given tag and use that to parse. If
    // none is found, the element's content nodes are added directly.
    addElement(dom, marks2, matchAfter) {
      let outerWS = this.localPreserveWS, top = this.top;
      if (dom.tagName == "PRE" || /pre/.test(dom.style && dom.style.whiteSpace))
        this.localPreserveWS = true;
      let name = dom.nodeName.toLowerCase(), ruleID;
      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
        normalizeList(dom);
      let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
      out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
        this.findInside(dom);
        this.ignoreFallback(dom, marks2);
      } else if (!rule || rule.skip || rule.closeParent) {
        if (rule && rule.closeParent)
          this.open = Math.max(0, this.open - 1);
        else if (rule && rule.skip.nodeType)
          dom = rule.skip;
        let sync, oldNeedsBlock = this.needsBlock;
        if (blockTags.hasOwnProperty(name)) {
          if (top.content.length && top.content[0].isInline && this.open) {
            this.open--;
            top = this.top;
          }
          sync = true;
          if (!top.type)
            this.needsBlock = true;
        } else if (!dom.firstChild) {
          this.leafFallback(dom, marks2);
          break out;
        }
        let innerMarks = rule && rule.skip ? marks2 : this.readStyles(dom, marks2);
        if (innerMarks)
          this.addAll(dom, innerMarks);
        if (sync)
          this.sync(top);
        this.needsBlock = oldNeedsBlock;
      } else {
        let innerMarks = this.readStyles(dom, marks2);
        if (innerMarks)
          this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : void 0);
      }
      this.localPreserveWS = outerWS;
    }
    // Called for leaf DOM nodes that would otherwise be ignored
    leafFallback(dom, marks2) {
      if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
        this.addTextNode(dom.ownerDocument.createTextNode("\n"), marks2);
    }
    // Called for ignored nodes
    ignoreFallback(dom, marks2) {
      if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
        this.findPlace(this.parser.schema.text("-"), marks2, true);
    }
    // Run any style parser associated with the node's styles. Either
    // return an updated array of marks, or null to indicate some of the
    // styles had a rule with `ignore` set.
    readStyles(dom, marks2) {
      let styles2 = dom.style;
      if (styles2 && styles2.length)
        for (let i2 = 0; i2 < this.parser.matchedStyles.length; i2++) {
          let name = this.parser.matchedStyles[i2], value = styles2.getPropertyValue(name);
          if (value)
            for (let after = void 0; ; ) {
              let rule = this.parser.matchStyle(name, value, this, after);
              if (!rule)
                break;
              if (rule.ignore)
                return null;
              if (rule.clearMark)
                marks2 = marks2.filter((m) => !rule.clearMark(m));
              else
                marks2 = marks2.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));
              if (rule.consuming === false)
                after = rule;
              else
                break;
            }
        }
      return marks2;
    }
    // Look up a handler for the given node. If none are found, return
    // false. Otherwise, apply it, use its return value to drive the way
    // the node's content is wrapped, and return true.
    addElementByRule(dom, rule, marks2, continueAfter) {
      let sync, nodeType;
      if (rule.node) {
        nodeType = this.parser.schema.nodes[rule.node];
        if (!nodeType.isLeaf) {
          let inner = this.enter(nodeType, rule.attrs || null, marks2, rule.preserveWhitespace);
          if (inner) {
            sync = true;
            marks2 = inner;
          }
        } else if (!this.insertNode(nodeType.create(rule.attrs), marks2, dom.nodeName == "BR")) {
          this.leafFallback(dom, marks2);
        }
      } else {
        let markType = this.parser.schema.marks[rule.mark];
        marks2 = marks2.concat(markType.create(rule.attrs));
      }
      let startIn = this.top;
      if (nodeType && nodeType.isLeaf) {
        this.findInside(dom);
      } else if (continueAfter) {
        this.addElement(dom, marks2, continueAfter);
      } else if (rule.getContent) {
        this.findInside(dom);
        rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node, marks2, false));
      } else {
        let contentDOM = dom;
        if (typeof rule.contentElement == "string")
          contentDOM = dom.querySelector(rule.contentElement);
        else if (typeof rule.contentElement == "function")
          contentDOM = rule.contentElement(dom);
        else if (rule.contentElement)
          contentDOM = rule.contentElement;
        this.findAround(dom, contentDOM, true);
        this.addAll(contentDOM, marks2);
        this.findAround(dom, contentDOM, false);
      }
      if (sync && this.sync(startIn))
        this.open--;
    }
    // Add all child nodes between `startIndex` and `endIndex` (or the
    // whole node, if not given). If `sync` is passed, use it to
    // synchronize after every block element.
    addAll(parent, marks2, startIndex, endIndex) {
      let index = startIndex || 0;
      for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {
        this.findAtPoint(parent, index);
        this.addDOM(dom, marks2);
      }
      this.findAtPoint(parent, index);
    }
    // Try to find a way to fit the given node type into the current
    // context. May add intermediate wrappers and/or leave non-solid
    // nodes that we're in.
    findPlace(node, marks2, cautious) {
      let route, sync;
      for (let depth = this.open, penalty = 0; depth >= 0; depth--) {
        let cx = this.nodes[depth];
        let found2 = cx.findWrapping(node);
        if (found2 && (!route || route.length > found2.length + penalty)) {
          route = found2;
          sync = cx;
          if (!found2.length)
            break;
        }
        if (cx.solid) {
          if (cautious)
            break;
          penalty += 2;
        }
      }
      if (!route)
        return null;
      this.sync(sync);
      for (let i2 = 0; i2 < route.length; i2++)
        marks2 = this.enterInner(route[i2], null, marks2, false);
      return marks2;
    }
    // Try to insert the given node, adjusting the context when needed.
    insertNode(node, marks2, cautious) {
      if (node.isInline && this.needsBlock && !this.top.type) {
        let block = this.textblockFromContext();
        if (block)
          marks2 = this.enterInner(block, null, marks2);
      }
      let innerMarks = this.findPlace(node, marks2, cautious);
      if (innerMarks) {
        this.closeExtra();
        let top = this.top;
        if (top.match)
          top.match = top.match.matchType(node.type);
        let nodeMarks = Mark.none;
        for (let m of innerMarks.concat(node.marks))
          if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, node.type))
            nodeMarks = m.addToSet(nodeMarks);
        top.content.push(node.mark(nodeMarks));
        return true;
      }
      return false;
    }
    // Try to start a node of the given type, adjusting the context when
    // necessary.
    enter(type, attrs, marks2, preserveWS) {
      let innerMarks = this.findPlace(type.create(attrs), marks2, false);
      if (innerMarks)
        innerMarks = this.enterInner(type, attrs, marks2, true, preserveWS);
      return innerMarks;
    }
    // Open a node of the given type
    enterInner(type, attrs, marks2, solid = false, preserveWS) {
      this.closeExtra();
      let top = this.top;
      top.match = top.match && top.match.matchType(type);
      let options = wsOptionsFor(type, preserveWS, top.options);
      if (top.options & OPT_OPEN_LEFT && top.content.length == 0)
        options |= OPT_OPEN_LEFT;
      let applyMarks = Mark.none;
      marks2 = marks2.filter((m) => {
        if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {
          applyMarks = m.addToSet(applyMarks);
          return false;
        }
        return true;
      });
      this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options));
      this.open++;
      return marks2;
    }
    // Make sure all nodes above this.open are finished and added to
    // their parents
    closeExtra(openEnd = false) {
      let i2 = this.nodes.length - 1;
      if (i2 > this.open) {
        for (; i2 > this.open; i2--)
          this.nodes[i2 - 1].content.push(this.nodes[i2].finish(openEnd));
        this.nodes.length = this.open + 1;
      }
    }
    finish() {
      this.open = 0;
      this.closeExtra(this.isOpen);
      return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
    }
    sync(to) {
      for (let i2 = this.open; i2 >= 0; i2--) {
        if (this.nodes[i2] == to) {
          this.open = i2;
          return true;
        } else if (this.localPreserveWS) {
          this.nodes[i2].options |= OPT_PRESERVE_WS;
        }
      }
      return false;
    }
    get currentPos() {
      this.closeExtra();
      let pos = 0;
      for (let i2 = this.open; i2 >= 0; i2--) {
        let content = this.nodes[i2].content;
        for (let j2 = content.length - 1; j2 >= 0; j2--)
          pos += content[j2].nodeSize;
        if (i2)
          pos++;
      }
      return pos;
    }
    findAtPoint(parent, offset2) {
      if (this.find)
        for (let i2 = 0; i2 < this.find.length; i2++) {
          if (this.find[i2].node == parent && this.find[i2].offset == offset2)
            this.find[i2].pos = this.currentPos;
        }
    }
    findInside(parent) {
      if (this.find)
        for (let i2 = 0; i2 < this.find.length; i2++) {
          if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node))
            this.find[i2].pos = this.currentPos;
        }
    }
    findAround(parent, content, before) {
      if (parent != content && this.find)
        for (let i2 = 0; i2 < this.find.length; i2++) {
          if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node)) {
            let pos = content.compareDocumentPosition(this.find[i2].node);
            if (pos & (before ? 2 : 4))
              this.find[i2].pos = this.currentPos;
          }
        }
    }
    findInText(textNode) {
      if (this.find)
        for (let i2 = 0; i2 < this.find.length; i2++) {
          if (this.find[i2].node == textNode)
            this.find[i2].pos = this.currentPos - (textNode.nodeValue.length - this.find[i2].offset);
        }
    }
    // Determines whether the given context string matches this context.
    matchesContext(context) {
      if (context.indexOf("|") > -1)
        return context.split(/\s*\|\s*/).some(this.matchesContext, this);
      let parts = context.split("/");
      let option = this.options.context;
      let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
      let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
      let match = (i2, depth) => {
        for (; i2 >= 0; i2--) {
          let part = parts[i2];
          if (part == "") {
            if (i2 == parts.length - 1 || i2 == 0)
              continue;
            for (; depth >= minDepth; depth--)
              if (match(i2 - 1, depth))
                return true;
            return false;
          } else {
            let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
            if (!next || next.name != part && !next.isInGroup(part))
              return false;
            depth--;
          }
        }
        return true;
      };
      return match(parts.length - 1, this.open);
    }
    textblockFromContext() {
      let $context = this.options.context;
      if ($context)
        for (let d = $context.depth; d >= 0; d--) {
          let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
          if (deflt && deflt.isTextblock && deflt.defaultAttrs)
            return deflt;
        }
      for (let name in this.parser.schema.nodes) {
        let type = this.parser.schema.nodes[name];
        if (type.isTextblock && type.defaultAttrs)
          return type;
      }
    }
  }
  function normalizeList(dom) {
    for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
      let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
      if (name && listTags.hasOwnProperty(name) && prevItem) {
        prevItem.appendChild(child);
        child = prevItem;
      } else if (name == "li") {
        prevItem = child;
      } else if (name) {
        prevItem = null;
      }
    }
  }
  function matches(dom, selector2) {
    return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector2);
  }
  function copy(obj) {
    let copy2 = {};
    for (let prop in obj)
      copy2[prop] = obj[prop];
    return copy2;
  }
  function markMayApply(markType, nodeType) {
    let nodes2 = nodeType.schema.nodes;
    for (let name in nodes2) {
      let parent = nodes2[name];
      if (!parent.allowsMarkType(markType))
        continue;
      let seen = [], scan = (match) => {
        seen.push(match);
        for (let i2 = 0; i2 < match.edgeCount; i2++) {
          let { type, next } = match.edge(i2);
          if (type == nodeType)
            return true;
          if (seen.indexOf(next) < 0 && scan(next))
            return true;
        }
      };
      if (scan(parent.contentMatch))
        return true;
    }
  }
  class DOMSerializer {
    /**
    Create a serializer. `nodes` should map node names to functions
    that take a node and return a description of the corresponding
    DOM. `marks` does the same for mark names, but also gets an
    argument that tells it whether the mark's content is block or
    inline content (for typical use, it'll always be inline). A mark
    serializer may be `null` to indicate that marks of that type
    should not be serialized.
    */
    constructor(nodes2, marks2) {
      this.nodes = nodes2;
      this.marks = marks2;
    }
    /**
    Serialize the content of this fragment to a DOM fragment. When
    not in the browser, the `document` option, containing a DOM
    document, should be passed so that the serializer can create
    nodes.
    */
    serializeFragment(fragment, options = {}, target) {
      if (!target)
        target = doc$1(options).createDocumentFragment();
      let top = target, active = [];
      fragment.forEach((node) => {
        if (active.length || node.marks.length) {
          let keep = 0, rendered = 0;
          while (keep < active.length && rendered < node.marks.length) {
            let next = node.marks[rendered];
            if (!this.marks[next.type.name]) {
              rendered++;
              continue;
            }
            if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
              break;
            keep++;
            rendered++;
          }
          while (keep < active.length)
            top = active.pop()[1];
          while (rendered < node.marks.length) {
            let add2 = node.marks[rendered++];
            let markDOM = this.serializeMark(add2, node.isInline, options);
            if (markDOM) {
              active.push([add2, top]);
              top.appendChild(markDOM.dom);
              top = markDOM.contentDOM || markDOM.dom;
            }
          }
        }
        top.appendChild(this.serializeNodeInner(node, options));
      });
      return target;
    }
    /**
    @internal
    */
    serializeNodeInner(node, options) {
      let { dom, contentDOM } = renderSpec(doc$1(options), this.nodes[node.type.name](node), null, node.attrs);
      if (contentDOM) {
        if (node.isLeaf)
          throw new RangeError("Content hole not allowed in a leaf node spec");
        this.serializeFragment(node.content, options, contentDOM);
      }
      return dom;
    }
    /**
    Serialize this node to a DOM node. This can be useful when you
    need to serialize a part of a document, as opposed to the whole
    document. To serialize a whole document, use
    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
    its [content](https://prosemirror.net/docs/ref/#model.Node.content).
    */
    serializeNode(node, options = {}) {
      let dom = this.serializeNodeInner(node, options);
      for (let i2 = node.marks.length - 1; i2 >= 0; i2--) {
        let wrap2 = this.serializeMark(node.marks[i2], node.isInline, options);
        if (wrap2) {
          (wrap2.contentDOM || wrap2.dom).appendChild(dom);
          dom = wrap2.dom;
        }
      }
      return dom;
    }
    /**
    @internal
    */
    serializeMark(mark, inline, options = {}) {
      let toDOM = this.marks[mark.type.name];
      return toDOM && renderSpec(doc$1(options), toDOM(mark, inline), null, mark.attrs);
    }
    static renderSpec(doc2, structure, xmlNS = null, blockArraysIn) {
      return renderSpec(doc2, structure, xmlNS, blockArraysIn);
    }
    /**
    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
    properties in a schema's node and mark specs.
    */
    static fromSchema(schema2) {
      return schema2.cached.domSerializer || (schema2.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema2), this.marksFromSchema(schema2)));
    }
    /**
    Gather the serializers in a schema's node specs into an object.
    This can be useful as a base to build a custom serializer from.
    */
    static nodesFromSchema(schema2) {
      let result = gatherToDOM(schema2.nodes);
      if (!result.text)
        result.text = (node) => node.text;
      return result;
    }
    /**
    Gather the serializers in a schema's mark specs into an object.
    */
    static marksFromSchema(schema2) {
      return gatherToDOM(schema2.marks);
    }
  }
  function gatherToDOM(obj) {
    let result = {};
    for (let name in obj) {
      let toDOM = obj[name].spec.toDOM;
      if (toDOM)
        result[name] = toDOM;
    }
    return result;
  }
  function doc$1(options) {
    return options.document || window.document;
  }
  const suspiciousAttributeCache = /* @__PURE__ */ new WeakMap();
  function suspiciousAttributes(attrs) {
    let value = suspiciousAttributeCache.get(attrs);
    if (value === void 0)
      suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));
    return value;
  }
  function suspiciousAttributesInner(attrs) {
    let result = null;
    function scan(value) {
      if (value && typeof value == "object") {
        if (Array.isArray(value)) {
          if (typeof value[0] == "string") {
            if (!result)
              result = [];
            result.push(value);
          } else {
            for (let i2 = 0; i2 < value.length; i2++)
              scan(value[i2]);
          }
        } else {
          for (let prop in value)
            scan(value[prop]);
        }
      }
    }
    scan(attrs);
    return result;
  }
  function renderSpec(doc2, structure, xmlNS, blockArraysIn) {
    if (typeof structure == "string")
      return { dom: doc2.createTextNode(structure) };
    if (structure.nodeType != null)
      return { dom: structure };
    if (structure.dom && structure.dom.nodeType != null)
      return structure;
    let tagName = structure[0], suspicious;
    if (typeof tagName != "string")
      throw new RangeError("Invalid array passed to renderSpec");
    if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)
      throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
    let space = tagName.indexOf(" ");
    if (space > 0) {
      xmlNS = tagName.slice(0, space);
      tagName = tagName.slice(space + 1);
    }
    let contentDOM;
    let dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
    let attrs = structure[1], start = 1;
    if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
      start = 2;
      for (let name in attrs)
        if (attrs[name] != null) {
          let space2 = name.indexOf(" ");
          if (space2 > 0)
            dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);
          else if (name == "style" && dom.style)
            dom.style.cssText = attrs[name];
          else
            dom.setAttribute(name, attrs[name]);
        }
    }
    for (let i2 = start; i2 < structure.length; i2++) {
      let child = structure[i2];
      if (child === 0) {
        if (i2 < structure.length - 1 || i2 > start)
          throw new RangeError("Content hole must be the only child of its parent node");
        return { dom, contentDOM: dom };
      } else {
        let { dom: inner, contentDOM: innerContent } = renderSpec(doc2, child, xmlNS, blockArraysIn);
        dom.appendChild(inner);
        if (innerContent) {
          if (contentDOM)
            throw new RangeError("Multiple content holes");
          contentDOM = innerContent;
        }
      }
    }
    return { dom, contentDOM };
  }
  const lower16 = 65535;
  const factor16 = Math.pow(2, 16);
  function makeRecover(index, offset2) {
    return index + offset2 * factor16;
  }
  function recoverIndex(value) {
    return value & lower16;
  }
  function recoverOffset(value) {
    return (value - (value & lower16)) / factor16;
  }
  const DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;
  class MapResult {
    /**
    @internal
    */
    constructor(pos, delInfo, recover) {
      this.pos = pos;
      this.delInfo = delInfo;
      this.recover = recover;
    }
    /**
    Tells you whether the position was deleted, that is, whether the
    step removed the token on the side queried (via the `assoc`)
    argument from the document.
    */
    get deleted() {
      return (this.delInfo & DEL_SIDE) > 0;
    }
    /**
    Tells you whether the token before the mapped position was deleted.
    */
    get deletedBefore() {
      return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
    }
    /**
    True when the token after the mapped position was deleted.
    */
    get deletedAfter() {
      return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
    }
    /**
    Tells whether any of the steps mapped through deletes across the
    position (including both the token before and after the
    position).
    */
    get deletedAcross() {
      return (this.delInfo & DEL_ACROSS) > 0;
    }
  }
  class StepMap {
    /**
    Create a position map. The modifications to the document are
    represented as an array of numbers, in which each group of three
    represents a modified chunk as `[start, oldSize, newSize]`.
    */
    constructor(ranges, inverted = false) {
      this.ranges = ranges;
      this.inverted = inverted;
      if (!ranges.length && StepMap.empty)
        return StepMap.empty;
    }
    /**
    @internal
    */
    recover(value) {
      let diff = 0, index = recoverIndex(value);
      if (!this.inverted)
        for (let i2 = 0; i2 < index; i2++)
          diff += this.ranges[i2 * 3 + 2] - this.ranges[i2 * 3 + 1];
      return this.ranges[index * 3] + diff + recoverOffset(value);
    }
    mapResult(pos, assoc = 1) {
      return this._map(pos, assoc, false);
    }
    map(pos, assoc = 1) {
      return this._map(pos, assoc, true);
    }
    /**
    @internal
    */
    _map(pos, assoc, simple) {
      let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (let i2 = 0; i2 < this.ranges.length; i2 += 3) {
        let start = this.ranges[i2] - (this.inverted ? diff : 0);
        if (start > pos)
          break;
        let oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex], end = start + oldSize;
        if (pos <= end) {
          let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
          let result = start + diff + (side < 0 ? 0 : newSize);
          if (simple)
            return result;
          let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i2 / 3, pos - start);
          let del2 = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
          if (assoc < 0 ? pos != start : pos != end)
            del2 |= DEL_SIDE;
          return new MapResult(result, del2, recover);
        }
        diff += newSize - oldSize;
      }
      return simple ? pos + diff : new MapResult(pos + diff, 0, null);
    }
    /**
    @internal
    */
    touches(pos, recover) {
      let diff = 0, index = recoverIndex(recover);
      let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (let i2 = 0; i2 < this.ranges.length; i2 += 3) {
        let start = this.ranges[i2] - (this.inverted ? diff : 0);
        if (start > pos)
          break;
        let oldSize = this.ranges[i2 + oldIndex], end = start + oldSize;
        if (pos <= end && i2 == index * 3)
          return true;
        diff += this.ranges[i2 + newIndex] - oldSize;
      }
      return false;
    }
    /**
    Calls the given function on each of the changed ranges included in
    this map.
    */
    forEach(f) {
      let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (let i2 = 0, diff = 0; i2 < this.ranges.length; i2 += 3) {
        let start = this.ranges[i2], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
        let oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex];
        f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
        diff += newSize - oldSize;
      }
    }
    /**
    Create an inverted version of this map. The result can be used to
    map positions in the post-step document to the pre-step document.
    */
    invert() {
      return new StepMap(this.ranges, !this.inverted);
    }
    /**
    @internal
    */
    toString() {
      return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
    }
    /**
    Create a map that moves all positions by offset `n` (which may be
    negative). This can be useful when applying steps meant for a
    sub-document to a larger document, or vice-versa.
    */
    static offset(n) {
      return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
    }
  }
  StepMap.empty = new StepMap([]);
  class Mapping {
    /**
    Create a new mapping with the given position maps.
    */
    constructor(maps, mirror, from = 0, to = maps ? maps.length : 0) {
      this.mirror = mirror;
      this.from = from;
      this.to = to;
      this._maps = maps || [];
      this.ownData = !(maps || mirror);
    }
    /**
    The step maps in this mapping.
    */
    get maps() {
      return this._maps;
    }
    /**
    Create a mapping that maps only through a part of this one.
    */
    slice(from = 0, to = this.maps.length) {
      return new Mapping(this._maps, this.mirror, from, to);
    }
    /**
    Add a step map to the end of this mapping. If `mirrors` is
    given, it should be the index of the step map that is the mirror
    image of this one.
    */
    appendMap(map, mirrors) {
      if (!this.ownData) {
        this._maps = this._maps.slice();
        this.mirror = this.mirror && this.mirror.slice();
        this.ownData = true;
      }
      this.to = this._maps.push(map);
      if (mirrors != null)
        this.setMirror(this._maps.length - 1, mirrors);
    }
    /**
    Add all the step maps in a given mapping to this one (preserving
    mirroring information).
    */
    appendMapping(mapping) {
      for (let i2 = 0, startSize = this._maps.length; i2 < mapping._maps.length; i2++) {
        let mirr = mapping.getMirror(i2);
        this.appendMap(mapping._maps[i2], mirr != null && mirr < i2 ? startSize + mirr : void 0);
      }
    }
    /**
    Finds the offset of the step map that mirrors the map at the
    given offset, in this mapping (as per the second argument to
    `appendMap`).
    */
    getMirror(n) {
      if (this.mirror) {
        for (let i2 = 0; i2 < this.mirror.length; i2++)
          if (this.mirror[i2] == n)
            return this.mirror[i2 + (i2 % 2 ? -1 : 1)];
      }
    }
    /**
    @internal
    */
    setMirror(n, m) {
      if (!this.mirror)
        this.mirror = [];
      this.mirror.push(n, m);
    }
    /**
    Append the inverse of the given mapping to this one.
    */
    appendMappingInverted(mapping) {
      for (let i2 = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i2 >= 0; i2--) {
        let mirr = mapping.getMirror(i2);
        this.appendMap(mapping._maps[i2].invert(), mirr != null && mirr > i2 ? totalSize - mirr - 1 : void 0);
      }
    }
    /**
    Create an inverted version of this mapping.
    */
    invert() {
      let inverse = new Mapping();
      inverse.appendMappingInverted(this);
      return inverse;
    }
    /**
    Map a position through this mapping.
    */
    map(pos, assoc = 1) {
      if (this.mirror)
        return this._map(pos, assoc, true);
      for (let i2 = this.from; i2 < this.to; i2++)
        pos = this._maps[i2].map(pos, assoc);
      return pos;
    }
    /**
    Map a position through this mapping, returning a mapping
    result.
    */
    mapResult(pos, assoc = 1) {
      return this._map(pos, assoc, false);
    }
    /**
    @internal
    */
    _map(pos, assoc, simple) {
      let delInfo = 0;
      for (let i2 = this.from; i2 < this.to; i2++) {
        let map = this._maps[i2], result = map.mapResult(pos, assoc);
        if (result.recover != null) {
          let corr = this.getMirror(i2);
          if (corr != null && corr > i2 && corr < this.to) {
            i2 = corr;
            pos = this._maps[corr].recover(result.recover);
            continue;
          }
        }
        delInfo |= result.delInfo;
        pos = result.pos;
      }
      return simple ? pos : new MapResult(pos, delInfo, null);
    }
  }
  const stepsByID = /* @__PURE__ */ Object.create(null);
  class Step {
    /**
    Get the step map that represents the changes made by this step,
    and which can be used to transform between positions in the old
    and the new document.
    */
    getMap() {
      return StepMap.empty;
    }
    /**
    Try to merge this step with another one, to be applied directly
    after it. Returns the merged step when possible, null if the
    steps can't be merged.
    */
    merge(other) {
      return null;
    }
    /**
    Deserialize a step from its JSON representation. Will call
    through to the step class' own implementation of this method.
    */
    static fromJSON(schema2, json) {
      if (!json || !json.stepType)
        throw new RangeError("Invalid input for Step.fromJSON");
      let type = stepsByID[json.stepType];
      if (!type)
        throw new RangeError(`No step type ${json.stepType} defined`);
      return type.fromJSON(schema2, json);
    }
    /**
    To be able to serialize steps to JSON, each step needs a string
    ID to attach to its JSON representation. Use this method to
    register an ID for your step classes. Try to pick something
    that's unlikely to clash with steps from other modules.
    */
    static jsonID(id, stepClass) {
      if (id in stepsByID)
        throw new RangeError("Duplicate use of step JSON ID " + id);
      stepsByID[id] = stepClass;
      stepClass.prototype.jsonID = id;
      return stepClass;
    }
  }
  class StepResult {
    /**
    @internal
    */
    constructor(doc2, failed) {
      this.doc = doc2;
      this.failed = failed;
    }
    /**
    Create a successful step result.
    */
    static ok(doc2) {
      return new StepResult(doc2, null);
    }
    /**
    Create a failed step result.
    */
    static fail(message) {
      return new StepResult(null, message);
    }
    /**
    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
    arguments. Create a successful result if it succeeds, and a
    failed one if it throws a `ReplaceError`.
    */
    static fromReplace(doc2, from, to, slice) {
      try {
        return StepResult.ok(doc2.replace(from, to, slice));
      } catch (e) {
        if (e instanceof ReplaceError)
          return StepResult.fail(e.message);
        throw e;
      }
    }
  }
  function mapFragment(fragment, f, parent) {
    let mapped = [];
    for (let i2 = 0; i2 < fragment.childCount; i2++) {
      let child = fragment.child(i2);
      if (child.content.size)
        child = child.copy(mapFragment(child.content, f, child));
      if (child.isInline)
        child = f(child, parent, i2);
      mapped.push(child);
    }
    return Fragment.fromArray(mapped);
  }
  class AddMarkStep extends Step {
    /**
    Create a mark step.
    */
    constructor(from, to, mark) {
      super();
      this.from = from;
      this.to = to;
      this.mark = mark;
    }
    apply(doc2) {
      let oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
      let parent = $from.node($from.sharedDepth(this.to));
      let slice = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
        if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
          return node;
        return node.mark(this.mark.addToSet(node.marks));
      }, parent), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc2, this.from, this.to, slice);
    }
    invert() {
      return new RemoveMarkStep(this.from, this.to, this.mark);
    }
    map(mapping) {
      let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      if (from.deleted && to.deleted || from.pos >= to.pos)
        return null;
      return new AddMarkStep(from.pos, to.pos, this.mark);
    }
    merge(other) {
      if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
        return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    }
    toJSON() {
      return {
        stepType: "addMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
    /**
    @internal
    */
    static fromJSON(schema2, json) {
      if (typeof json.from != "number" || typeof json.to != "number")
        throw new RangeError("Invalid input for AddMarkStep.fromJSON");
      return new AddMarkStep(json.from, json.to, schema2.markFromJSON(json.mark));
    }
  }
  Step.jsonID("addMark", AddMarkStep);
  class RemoveMarkStep extends Step {
    /**
    Create a mark-removing step.
    */
    constructor(from, to, mark) {
      super();
      this.from = from;
      this.to = to;
      this.mark = mark;
    }
    apply(doc2) {
      let oldSlice = doc2.slice(this.from, this.to);
      let slice = new Slice(mapFragment(oldSlice.content, (node) => {
        return node.mark(this.mark.removeFromSet(node.marks));
      }, doc2), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc2, this.from, this.to, slice);
    }
    invert() {
      return new AddMarkStep(this.from, this.to, this.mark);
    }
    map(mapping) {
      let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      if (from.deleted && to.deleted || from.pos >= to.pos)
        return null;
      return new RemoveMarkStep(from.pos, to.pos, this.mark);
    }
    merge(other) {
      if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
        return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    }
    toJSON() {
      return {
        stepType: "removeMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
    /**
    @internal
    */
    static fromJSON(schema2, json) {
      if (typeof json.from != "number" || typeof json.to != "number")
        throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
      return new RemoveMarkStep(json.from, json.to, schema2.markFromJSON(json.mark));
    }
  }
  Step.jsonID("removeMark", RemoveMarkStep);
  class AddNodeMarkStep extends Step {
    /**
    Create a node mark step.
    */
    constructor(pos, mark) {
      super();
      this.pos = pos;
      this.mark = mark;
    }
    apply(doc2) {
      let node = doc2.nodeAt(this.pos);
      if (!node)
        return StepResult.fail("No node at mark step's position");
      let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
      return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
    }
    invert(doc2) {
      let node = doc2.nodeAt(this.pos);
      if (node) {
        let newSet = this.mark.addToSet(node.marks);
        if (newSet.length == node.marks.length) {
          for (let i2 = 0; i2 < node.marks.length; i2++)
            if (!node.marks[i2].isInSet(newSet))
              return new AddNodeMarkStep(this.pos, node.marks[i2]);
          return new AddNodeMarkStep(this.pos, this.mark);
        }
      }
      return new RemoveNodeMarkStep(this.pos, this.mark);
    }
    map(mapping) {
      let pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);
    }
    toJSON() {
      return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
    }
    /**
    @internal
    */
    static fromJSON(schema2, json) {
      if (typeof json.pos != "number")
        throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
      return new AddNodeMarkStep(json.pos, schema2.markFromJSON(json.mark));
    }
  }
  Step.jsonID("addNodeMark", AddNodeMarkStep);
  class RemoveNodeMarkStep extends Step {
    /**
    Create a mark-removing step.
    */
    constructor(pos, mark) {
      super();
      this.pos = pos;
      this.mark = mark;
    }
    apply(doc2) {
      let node = doc2.nodeAt(this.pos);
      if (!node)
        return StepResult.fail("No node at mark step's position");
      let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
      return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
    }
    invert(doc2) {
      let node = doc2.nodeAt(this.pos);
      if (!node || !this.mark.isInSet(node.marks))
        return this;
      return new AddNodeMarkStep(this.pos, this.mark);
    }
    map(mapping) {
      let pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);
    }
    toJSON() {
      return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
    }
    /**
    @internal
    */
    static fromJSON(schema2, json) {
      if (typeof json.pos != "number")
        throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
      return new RemoveNodeMarkStep(json.pos, schema2.markFromJSON(json.mark));
    }
  }
  Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
  class ReplaceStep extends Step {
    /**
    The given `slice` should fit the 'gap' between `from` and
    `to`the depths must line up, and the surrounding nodes must be
    able to be joined with the open sides of the slice. When
    `structure` is true, the step will fail if the content between
    from and to is not just a sequence of closing and then opening
    tokens (this is to guard against rebased replace steps
    overwriting something they weren't supposed to).
    */
    constructor(from, to, slice, structure = false) {
      super();
      this.from = from;
      this.to = to;
      this.slice = slice;
      this.structure = structure;
    }
    apply(doc2) {
      if (this.structure && contentBetween(doc2, this.from, this.to))
        return StepResult.fail("Structure replace would overwrite content");
      return StepResult.fromReplace(doc2, this.from, this.to, this.slice);
    }
    getMap() {
      return new StepMap([this.from, this.to - this.from, this.slice.size]);
    }
    invert(doc2) {
      return new ReplaceStep(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
    }
    map(mapping) {
      let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      if (from.deletedAcross && to.deletedAcross)
        return null;
      return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice, this.structure);
    }
    merge(other) {
      if (!(other instanceof ReplaceStep) || other.structure || this.structure)
        return null;
      if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
        let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
        return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);
      } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
        let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
        return new ReplaceStep(other.from, this.to, slice, this.structure);
      } else {
        return null;
      }
    }
    toJSON() {
      let json = { stepType: "replace", from: this.from, to: this.to };
      if (this.slice.size)
        json.slice = this.slice.toJSON();
      if (this.structure)
        json.structure = true;
      return json;
    }
    /**
    @internal
    */
    static fromJSON(schema2, json) {
      if (typeof json.from != "number" || typeof json.to != "number")
        throw new RangeError("Invalid input for ReplaceStep.fromJSON");
      return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema2, json.slice), !!json.structure);
    }
  }
  Step.jsonID("replace", ReplaceStep);
  class ReplaceAroundStep extends Step {
    /**
    Create a replace-around step with the given range and gap.
    `insert` should be the point in the slice into which the content
    of the gap should be moved. `structure` has the same meaning as
    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
    */
    constructor(from, to, gapFrom, gapTo, slice, insert, structure = false) {
      super();
      this.from = from;
      this.to = to;
      this.gapFrom = gapFrom;
      this.gapTo = gapTo;
      this.slice = slice;
      this.insert = insert;
      this.structure = structure;
    }
    apply(doc2) {
      if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to)))
        return StepResult.fail("Structure gap-replace would overwrite content");
      let gap = doc2.slice(this.gapFrom, this.gapTo);
      if (gap.openStart || gap.openEnd)
        return StepResult.fail("Gap is not a flat range");
      let inserted = this.slice.insertAt(this.insert, gap.content);
      if (!inserted)
        return StepResult.fail("Content does not fit in gap");
      return StepResult.fromReplace(doc2, this.from, this.to, inserted);
    }
    getMap() {
      return new StepMap([
        this.from,
        this.gapFrom - this.from,
        this.insert,
        this.gapTo,
        this.to - this.gapTo,
        this.slice.size - this.insert
      ]);
    }
    invert(doc2) {
      let gap = this.gapTo - this.gapFrom;
      return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
    }
    map(mapping) {
      let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      let gapFrom = this.from == this.gapFrom ? from.pos : mapping.map(this.gapFrom, -1);
      let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);
      if (from.deletedAcross && to.deletedAcross || gapFrom < from.pos || gapTo > to.pos)
        return null;
      return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
    }
    toJSON() {
      let json = {
        stepType: "replaceAround",
        from: this.from,
        to: this.to,
        gapFrom: this.gapFrom,
        gapTo: this.gapTo,
        insert: this.insert
      };
      if (this.slice.size)
        json.slice = this.slice.toJSON();
      if (this.structure)
        json.structure = true;
      return json;
    }
    /**
    @internal
    */
    static fromJSON(schema2, json) {
      if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
        throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
      return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema2, json.slice), json.insert, !!json.structure);
    }
  }
  Step.jsonID("replaceAround", ReplaceAroundStep);
  function contentBetween(doc2, from, to) {
    let $from = doc2.resolve(from), dist = to - from, depth = $from.depth;
    while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
      depth--;
      dist--;
    }
    if (dist > 0) {
      let next = $from.node(depth).maybeChild($from.indexAfter(depth));
      while (dist > 0) {
        if (!next || next.isLeaf)
          return true;
        next = next.firstChild;
        dist--;
      }
    }
    return false;
  }
  function addMark(tr, from, to, mark) {
    let removed = [], added = [];
    let removing, adding;
    tr.doc.nodesBetween(from, to, (node, pos, parent) => {
      if (!node.isInline)
        return;
      let marks2 = node.marks;
      if (!mark.isInSet(marks2) && parent.type.allowsMarkType(mark.type)) {
        let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);
        let newSet = mark.addToSet(marks2);
        for (let i2 = 0; i2 < marks2.length; i2++) {
          if (!marks2[i2].isInSet(newSet)) {
            if (removing && removing.to == start && removing.mark.eq(marks2[i2]))
              removing.to = end;
            else
              removed.push(removing = new RemoveMarkStep(start, end, marks2[i2]));
          }
        }
        if (adding && adding.to == start)
          adding.to = end;
        else
          added.push(adding = new AddMarkStep(start, end, mark));
      }
    });
    removed.forEach((s) => tr.step(s));
    added.forEach((s) => tr.step(s));
  }
  function removeMark(tr, from, to, mark) {
    let matched = [], step = 0;
    tr.doc.nodesBetween(from, to, (node, pos) => {
      if (!node.isInline)
        return;
      step++;
      let toRemove = null;
      if (mark instanceof MarkType) {
        let set2 = node.marks, found2;
        while (found2 = mark.isInSet(set2)) {
          (toRemove || (toRemove = [])).push(found2);
          set2 = found2.removeFromSet(set2);
        }
      } else if (mark) {
        if (mark.isInSet(node.marks))
          toRemove = [mark];
      } else {
        toRemove = node.marks;
      }
      if (toRemove && toRemove.length) {
        let end = Math.min(pos + node.nodeSize, to);
        for (let i2 = 0; i2 < toRemove.length; i2++) {
          let style = toRemove[i2], found2;
          for (let j2 = 0; j2 < matched.length; j2++) {
            let m = matched[j2];
            if (m.step == step - 1 && style.eq(matched[j2].style))
              found2 = m;
          }
          if (found2) {
            found2.to = end;
            found2.step = step;
          } else {
            matched.push({ style, from: Math.max(pos, from), to: end, step });
          }
        }
      }
    });
    matched.forEach((m) => tr.step(new RemoveMarkStep(m.from, m.to, m.style)));
  }
  function clearIncompatible(tr, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {
    let node = tr.doc.nodeAt(pos);
    let replSteps = [], cur = pos + 1;
    for (let i2 = 0; i2 < node.childCount; i2++) {
      let child = node.child(i2), end = cur + child.nodeSize;
      let allowed = match.matchType(child.type);
      if (!allowed) {
        replSteps.push(new ReplaceStep(cur, end, Slice.empty));
      } else {
        match = allowed;
        for (let j2 = 0; j2 < child.marks.length; j2++)
          if (!parentType.allowsMarkType(child.marks[j2].type))
            tr.step(new RemoveMarkStep(cur, end, child.marks[j2]));
        if (clearNewlines && child.isText && parentType.whitespace != "pre") {
          let m, newline = /\r?\n|\r/g, slice;
          while (m = newline.exec(child.text)) {
            if (!slice)
              slice = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
            replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice));
          }
        }
      }
      cur = end;
    }
    if (!match.validEnd) {
      let fill = match.fillBefore(Fragment.empty, true);
      tr.replace(cur, cur, new Slice(fill, 0, 0));
    }
    for (let i2 = replSteps.length - 1; i2 >= 0; i2--)
      tr.step(replSteps[i2]);
  }
  function canCut(node, start, end) {
    return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
  }
  function liftTarget(range) {
    let parent = range.parent;
    let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
    for (let depth = range.depth; ; --depth) {
      let node = range.$from.node(depth);
      let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
      if (depth < range.depth && node.canReplace(index, endIndex, content))
        return depth;
      if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))
        break;
    }
    return null;
  }
  function lift$1(tr, range, target) {
    let { $from, $to, depth } = range;
    let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
    let start = gapStart, end = gapEnd;
    let before = Fragment.empty, openStart = 0;
    for (let d = depth, splitting = false; d > target; d--)
      if (splitting || $from.index(d) > 0) {
        splitting = true;
        before = Fragment.from($from.node(d).copy(before));
        openStart++;
      } else {
        start--;
      }
    let after = Fragment.empty, openEnd = 0;
    for (let d = depth, splitting = false; d > target; d--)
      if (splitting || $to.after(d + 1) < $to.end(d)) {
        splitting = true;
        after = Fragment.from($to.node(d).copy(after));
        openEnd++;
      } else {
        end++;
      }
    tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
  }
  function findWrapping(range, nodeType, attrs = null, innerRange = range) {
    let around = findWrappingOutside(range, nodeType);
    let inner = around && findWrappingInside(innerRange, nodeType);
    if (!inner)
      return null;
    return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
  }
  function withAttrs(type) {
    return { type, attrs: null };
  }
  function findWrappingOutside(range, type) {
    let { parent, startIndex, endIndex } = range;
    let around = parent.contentMatchAt(startIndex).findWrapping(type);
    if (!around)
      return null;
    let outer = around.length ? around[0] : type;
    return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
  }
  function findWrappingInside(range, type) {
    let { parent, startIndex, endIndex } = range;
    let inner = parent.child(startIndex);
    let inside = type.contentMatch.findWrapping(inner.type);
    if (!inside)
      return null;
    let lastType = inside.length ? inside[inside.length - 1] : type;
    let innerMatch = lastType.contentMatch;
    for (let i2 = startIndex; innerMatch && i2 < endIndex; i2++)
      innerMatch = innerMatch.matchType(parent.child(i2).type);
    if (!innerMatch || !innerMatch.validEnd)
      return null;
    return inside;
  }
  function wrap(tr, range, wrappers) {
    let content = Fragment.empty;
    for (let i2 = wrappers.length - 1; i2 >= 0; i2--) {
      if (content.size) {
        let match = wrappers[i2].type.contentMatch.matchFragment(content);
        if (!match || !match.validEnd)
          throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
      }
      content = Fragment.from(wrappers[i2].type.create(wrappers[i2].attrs, content));
    }
    let start = range.start, end = range.end;
    tr.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));
  }
  function setBlockType$1(tr, from, to, type, attrs) {
    if (!type.isTextblock)
      throw new RangeError("Type given to setBlockType should be a textblock");
    let mapFrom = tr.steps.length;
    tr.doc.nodesBetween(from, to, (node, pos) => {
      let attrsHere = typeof attrs == "function" ? attrs(node) : attrs;
      if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {
        let convertNewlines = null;
        if (type.schema.linebreakReplacement) {
          let pre = type.whitespace == "pre", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);
          if (pre && !supportLinebreak)
            convertNewlines = false;
          else if (!pre && supportLinebreak)
            convertNewlines = true;
        }
        if (convertNewlines === false)
          replaceLinebreaks(tr, node, pos, mapFrom);
        clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type, void 0, convertNewlines === null);
        let mapping = tr.mapping.slice(mapFrom);
        let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
        tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));
        if (convertNewlines === true)
          replaceNewlines(tr, node, pos, mapFrom);
        return false;
      }
    });
  }
  function replaceNewlines(tr, node, pos, mapFrom) {
    node.forEach((child, offset2) => {
      if (child.isText) {
        let m, newline = /\r?\n|\r/g;
        while (m = newline.exec(child.text)) {
          let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset2 + m.index);
          tr.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());
        }
      }
    });
  }
  function replaceLinebreaks(tr, node, pos, mapFrom) {
    node.forEach((child, offset2) => {
      if (child.type == child.type.schema.linebreakReplacement) {
        let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset2);
        tr.replaceWith(start, start + 1, node.type.schema.text("\n"));
      }
    });
  }
  function canChangeType(doc2, pos, type) {
    let $pos = doc2.resolve(pos), index = $pos.index();
    return $pos.parent.canReplaceWith(index, index + 1, type);
  }
  function setNodeMarkup(tr, pos, type, attrs, marks2) {
    let node = tr.doc.nodeAt(pos);
    if (!node)
      throw new RangeError("No node at given position");
    if (!type)
      type = node.type;
    let newNode = type.create(attrs, null, marks2 || node.marks);
    if (node.isLeaf)
      return tr.replaceWith(pos, pos + node.nodeSize, newNode);
    if (!type.validContent(node.content))
      throw new RangeError("Invalid content for node type " + type.name);
    tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
  }
  function canSplit(doc2, pos, depth = 1, typesAfter) {
    let $pos = doc2.resolve(pos), base2 = $pos.depth - depth;
    let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
    if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
      return false;
    for (let d = $pos.depth - 1, i2 = depth - 2; d > base2; d--, i2--) {
      let node = $pos.node(d), index2 = $pos.index(d);
      if (node.type.spec.isolating)
        return false;
      let rest = node.content.cutByIndex(index2, node.childCount);
      let overrideChild = typesAfter && typesAfter[i2 + 1];
      if (overrideChild)
        rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
      let after = typesAfter && typesAfter[i2] || node;
      if (!node.canReplace(index2 + 1, node.childCount) || !after.type.validContent(rest))
        return false;
    }
    let index = $pos.indexAfter(base2);
    let baseType = typesAfter && typesAfter[0];
    return $pos.node(base2).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base2 + 1).type);
  }
  function split(tr, pos, depth = 1, typesAfter) {
    let $pos = tr.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
    for (let d = $pos.depth, e = $pos.depth - depth, i2 = depth - 1; d > e; d--, i2--) {
      before = Fragment.from($pos.node(d).copy(before));
      let typeAfter = typesAfter && typesAfter[i2];
      after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
    }
    tr.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
  }
  function canJoin(doc2, pos) {
    let $pos = doc2.resolve(pos), index = $pos.index();
    return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
  }
  function canAppendWithSubstitutedLinebreaks(a, b2) {
    if (!b2.content.size)
      a.type.compatibleContent(b2.type);
    let match = a.contentMatchAt(a.childCount);
    let { linebreakReplacement } = a.type.schema;
    for (let i2 = 0; i2 < b2.childCount; i2++) {
      let child = b2.child(i2);
      let type = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;
      match = match.matchType(type);
      if (!match)
        return false;
      if (!a.type.allowsMarks(child.marks))
        return false;
    }
    return match.validEnd;
  }
  function joinable(a, b2) {
    return !!(a && b2 && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b2));
  }
  function join(tr, pos, depth) {
    let convertNewlines = null;
    let { linebreakReplacement } = tr.doc.type.schema;
    let $before = tr.doc.resolve(pos - depth), beforeType = $before.node().type;
    if (linebreakReplacement && beforeType.inlineContent) {
      let pre = beforeType.whitespace == "pre";
      let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);
      if (pre && !supportLinebreak)
        convertNewlines = false;
      else if (!pre && supportLinebreak)
        convertNewlines = true;
    }
    let mapFrom = tr.steps.length;
    if (convertNewlines === false) {
      let $after = tr.doc.resolve(pos + depth);
      replaceLinebreaks(tr, $after.node(), $after.before(), mapFrom);
    }
    if (beforeType.inlineContent)
      clearIncompatible(tr, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);
    let mapping = tr.mapping.slice(mapFrom), start = mapping.map(pos - depth);
    tr.step(new ReplaceStep(start, mapping.map(pos + depth, -1), Slice.empty, true));
    if (convertNewlines === true) {
      let $full = tr.doc.resolve(start);
      replaceNewlines(tr, $full.node(), $full.before(), tr.steps.length);
    }
    return tr;
  }
  function insertPoint(doc2, pos, nodeType) {
    let $pos = doc2.resolve(pos);
    if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
      return pos;
    if ($pos.parentOffset == 0)
      for (let d = $pos.depth - 1; d >= 0; d--) {
        let index = $pos.index(d);
        if ($pos.node(d).canReplaceWith(index, index, nodeType))
          return $pos.before(d + 1);
        if (index > 0)
          return null;
      }
    if ($pos.parentOffset == $pos.parent.content.size)
      for (let d = $pos.depth - 1; d >= 0; d--) {
        let index = $pos.indexAfter(d);
        if ($pos.node(d).canReplaceWith(index, index, nodeType))
          return $pos.after(d + 1);
        if (index < $pos.node(d).childCount)
          return null;
      }
    return null;
  }
  function dropPoint(doc2, pos, slice) {
    let $pos = doc2.resolve(pos);
    if (!slice.content.size)
      return pos;
    let content = slice.content;
    for (let i2 = 0; i2 < slice.openStart; i2++)
      content = content.firstChild.content;
    for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {
      for (let d = $pos.depth; d >= 0; d--) {
        let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
        let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
        let parent = $pos.node(d), fits = false;
        if (pass == 1) {
          fits = parent.canReplace(insertPos, insertPos, content);
        } else {
          let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
          fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
        }
        if (fits)
          return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
      }
    }
    return null;
  }
  function replaceStep(doc2, from, to = from, slice = Slice.empty) {
    if (from == to && !slice.size)
      return null;
    let $from = doc2.resolve(from), $to = doc2.resolve(to);
    if (fitsTrivially($from, $to, slice))
      return new ReplaceStep(from, to, slice);
    return new Fitter($from, $to, slice).fit();
  }
  function fitsTrivially($from, $to, slice) {
    return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);
  }
  class Fitter {
    constructor($from, $to, unplaced) {
      this.$from = $from;
      this.$to = $to;
      this.unplaced = unplaced;
      this.frontier = [];
      this.placed = Fragment.empty;
      for (let i2 = 0; i2 <= $from.depth; i2++) {
        let node = $from.node(i2);
        this.frontier.push({
          type: node.type,
          match: node.contentMatchAt($from.indexAfter(i2))
        });
      }
      for (let i2 = $from.depth; i2 > 0; i2--)
        this.placed = Fragment.from($from.node(i2).copy(this.placed));
    }
    get depth() {
      return this.frontier.length - 1;
    }
    fit() {
      while (this.unplaced.size) {
        let fit = this.findFittable();
        if (fit)
          this.placeNodes(fit);
        else
          this.openMore() || this.dropNode();
      }
      let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
      let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
      if (!$to)
        return null;
      let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
      while (openStart && openEnd && content.childCount == 1) {
        content = content.firstChild.content;
        openStart--;
        openEnd--;
      }
      let slice = new Slice(content, openStart, openEnd);
      if (moveInline > -1)
        return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);
      if (slice.size || $from.pos != this.$to.pos)
        return new ReplaceStep($from.pos, $to.pos, slice);
      return null;
    }
    // Find a position on the start spine of `this.unplaced` that has
    // content that can be moved somewhere on the frontier. Returns two
    // depths, one for the slice and one for the frontier.
    findFittable() {
      let startDepth = this.unplaced.openStart;
      for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
        let node = cur.firstChild;
        if (cur.childCount > 1)
          openEnd = 0;
        if (node.type.spec.isolating && openEnd <= d) {
          startDepth = d;
          break;
        }
        cur = node.content;
      }
      for (let pass = 1; pass <= 2; pass++) {
        for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
          let fragment, parent = null;
          if (sliceDepth) {
            parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
            fragment = parent.content;
          } else {
            fragment = this.unplaced.content;
          }
          let first = fragment.firstChild;
          for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
            let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;
            if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false)) : parent && type.compatibleContent(parent.type)))
              return { sliceDepth, frontierDepth, parent, inject };
            else if (pass == 2 && first && (wrap2 = match.findWrapping(first.type)))
              return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
            if (parent && match.matchType(parent.type))
              break;
          }
        }
      }
    }
    openMore() {
      let { content, openStart, openEnd } = this.unplaced;
      let inner = contentAt(content, openStart);
      if (!inner.childCount || inner.firstChild.isLeaf)
        return false;
      this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
      return true;
    }
    dropNode() {
      let { content, openStart, openEnd } = this.unplaced;
      let inner = contentAt(content, openStart);
      if (inner.childCount <= 1 && openStart > 0) {
        let openAtEnd = content.size - openStart <= openStart + inner.size;
        this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
      } else {
        this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
      }
    }
    // Move content from the unplaced slice at `sliceDepth` to the
    // frontier node at `frontierDepth`. Close that frontier node when
    // applicable.
    placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
      while (this.depth > frontierDepth)
        this.closeFrontierNode();
      if (wrap2)
        for (let i2 = 0; i2 < wrap2.length; i2++)
          this.openFrontierNode(wrap2[i2]);
      let slice = this.unplaced, fragment = parent ? parent.content : slice.content;
      let openStart = slice.openStart - sliceDepth;
      let taken = 0, add2 = [];
      let { match, type } = this.frontier[frontierDepth];
      if (inject) {
        for (let i2 = 0; i2 < inject.childCount; i2++)
          add2.push(inject.child(i2));
        match = match.matchFragment(inject);
      }
      let openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);
      while (taken < fragment.childCount) {
        let next = fragment.child(taken), matches2 = match.matchType(next.type);
        if (!matches2)
          break;
        taken++;
        if (taken > 1 || openStart == 0 || next.content.size) {
          match = matches2;
          add2.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
        }
      }
      let toEnd = taken == fragment.childCount;
      if (!toEnd)
        openEndCount = -1;
      this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add2));
      this.frontier[frontierDepth].match = match;
      if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
        this.closeFrontierNode();
      for (let i2 = 0, cur = fragment; i2 < openEndCount; i2++) {
        let node = cur.lastChild;
        this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
        cur = node.content;
      }
      this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);
    }
    mustMoveInline() {
      if (!this.$to.parent.isTextblock)
        return -1;
      let top = this.frontier[this.depth], level;
      if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
        return -1;
      let { depth } = this.$to, after = this.$to.after(depth);
      while (depth > 1 && after == this.$to.end(--depth))
        ++after;
      return after;
    }
    findCloseLevel($to) {
      scan: for (let i2 = Math.min(this.depth, $to.depth); i2 >= 0; i2--) {
        let { match, type } = this.frontier[i2];
        let dropInner = i2 < $to.depth && $to.end(i2 + 1) == $to.pos + ($to.depth - (i2 + 1));
        let fit = contentAfterFits($to, i2, type, match, dropInner);
        if (!fit)
          continue;
        for (let d = i2 - 1; d >= 0; d--) {
          let { match: match2, type: type2 } = this.frontier[d];
          let matches2 = contentAfterFits($to, d, type2, match2, true);
          if (!matches2 || matches2.childCount)
            continue scan;
        }
        return { depth: i2, fit, move: dropInner ? $to.doc.resolve($to.after(i2 + 1)) : $to };
      }
    }
    close($to) {
      let close2 = this.findCloseLevel($to);
      if (!close2)
        return null;
      while (this.depth > close2.depth)
        this.closeFrontierNode();
      if (close2.fit.childCount)
        this.placed = addToFragment(this.placed, close2.depth, close2.fit);
      $to = close2.move;
      for (let d = close2.depth + 1; d <= $to.depth; d++) {
        let node = $to.node(d), add2 = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
        this.openFrontierNode(node.type, node.attrs, add2);
      }
      return $to;
    }
    openFrontierNode(type, attrs = null, content) {
      let top = this.frontier[this.depth];
      top.match = top.match.matchType(type);
      this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
      this.frontier.push({ type, match: type.contentMatch });
    }
    closeFrontierNode() {
      let open = this.frontier.pop();
      let add2 = open.match.fillBefore(Fragment.empty, true);
      if (add2.childCount)
        this.placed = addToFragment(this.placed, this.frontier.length, add2);
    }
  }
  function dropFromFragment(fragment, depth, count) {
    if (depth == 0)
      return fragment.cutByIndex(count, fragment.childCount);
    return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
  }
  function addToFragment(fragment, depth, content) {
    if (depth == 0)
      return fragment.append(content);
    return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
  }
  function contentAt(fragment, depth) {
    for (let i2 = 0; i2 < depth; i2++)
      fragment = fragment.firstChild.content;
    return fragment;
  }
  function closeNodeStart(node, openStart, openEnd) {
    if (openStart <= 0)
      return node;
    let frag = node.content;
    if (openStart > 1)
      frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
    if (openStart > 0) {
      frag = node.type.contentMatch.fillBefore(frag).append(frag);
      if (openEnd <= 0)
        frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
    }
    return node.copy(frag);
  }
  function contentAfterFits($to, depth, type, match, open) {
    let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
    if (index == node.childCount && !type.compatibleContent(node.type))
      return null;
    let fit = match.fillBefore(node.content, true, index);
    return fit && !invalidMarks(type, node.content, index) ? fit : null;
  }
  function invalidMarks(type, fragment, start) {
    for (let i2 = start; i2 < fragment.childCount; i2++)
      if (!type.allowsMarks(fragment.child(i2).marks))
        return true;
    return false;
  }
  function definesContent(type) {
    return type.spec.defining || type.spec.definingForContent;
  }
  function replaceRange(tr, from, to, slice) {
    if (!slice.size)
      return tr.deleteRange(from, to);
    let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);
    if (fitsTrivially($from, $to, slice))
      return tr.step(new ReplaceStep(from, to, slice));
    let targetDepths = coveredDepths($from, tr.doc.resolve(to));
    if (targetDepths[targetDepths.length - 1] == 0)
      targetDepths.pop();
    let preferredTarget = -($from.depth + 1);
    targetDepths.unshift(preferredTarget);
    for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
      let spec = $from.node(d).type.spec;
      if (spec.defining || spec.definingAsContext || spec.isolating)
        break;
      if (targetDepths.indexOf(d) > -1)
        preferredTarget = d;
      else if ($from.before(d) == pos)
        targetDepths.splice(1, 0, -d);
    }
    let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
    let leftNodes = [], preferredDepth = slice.openStart;
    for (let content = slice.content, i2 = 0; ; i2++) {
      let node = content.firstChild;
      leftNodes.push(node);
      if (i2 == slice.openStart)
        break;
      content = node.content;
    }
    for (let d = preferredDepth - 1; d >= 0; d--) {
      let leftNode = leftNodes[d], def = definesContent(leftNode.type);
      if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
        preferredDepth = d;
      else if (def || !leftNode.type.isTextblock)
        break;
    }
    for (let j2 = slice.openStart; j2 >= 0; j2--) {
      let openDepth = (j2 + preferredDepth + 1) % (slice.openStart + 1);
      let insert = leftNodes[openDepth];
      if (!insert)
        continue;
      for (let i2 = 0; i2 < targetDepths.length; i2++) {
        let targetDepth = targetDepths[(i2 + preferredTargetIndex) % targetDepths.length], expand = true;
        if (targetDepth < 0) {
          expand = false;
          targetDepth = -targetDepth;
        }
        let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
        if (parent.canReplaceWith(index, index, insert.type, insert.marks))
          return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));
      }
    }
    let startSteps = tr.steps.length;
    for (let i2 = targetDepths.length - 1; i2 >= 0; i2--) {
      tr.replace(from, to, slice);
      if (tr.steps.length > startSteps)
        break;
      let depth = targetDepths[i2];
      if (depth < 0)
        continue;
      from = $from.before(depth);
      to = $to.after(depth);
    }
  }
  function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
    if (depth < oldOpen) {
      let first = fragment.firstChild;
      fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
    }
    if (depth > newOpen) {
      let match = parent.contentMatchAt(0);
      let start = match.fillBefore(fragment).append(fragment);
      fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));
    }
    return fragment;
  }
  function replaceRangeWith(tr, from, to, node) {
    if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {
      let point = insertPoint(tr.doc, from, node.type);
      if (point != null)
        from = to = point;
    }
    tr.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0));
  }
  function deleteRange(tr, from, to) {
    let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);
    let covered = coveredDepths($from, $to);
    for (let i2 = 0; i2 < covered.length; i2++) {
      let depth = covered[i2], last2 = i2 == covered.length - 1;
      if (last2 && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
        return tr.delete($from.start(depth), $to.end(depth));
      if (depth > 0 && (last2 || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
        return tr.delete($from.before(depth), $to.after(depth));
    }
    for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
      if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1)))
        return tr.delete($from.before(d), to);
    }
    tr.delete(from, to);
  }
  function coveredDepths($from, $to) {
    let result = [], minDepth = Math.min($from.depth, $to.depth);
    for (let d = minDepth; d >= 0; d--) {
      let start = $from.start(d);
      if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
        break;
      if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1)
        result.push(d);
    }
    return result;
  }
  class AttrStep extends Step {
    /**
    Construct an attribute step.
    */
    constructor(pos, attr, value) {
      super();
      this.pos = pos;
      this.attr = attr;
      this.value = value;
    }
    apply(doc2) {
      let node = doc2.nodeAt(this.pos);
      if (!node)
        return StepResult.fail("No node at attribute step's position");
      let attrs = /* @__PURE__ */ Object.create(null);
      for (let name in node.attrs)
        attrs[name] = node.attrs[name];
      attrs[this.attr] = this.value;
      let updated = node.type.create(attrs, null, node.marks);
      return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
    }
    getMap() {
      return StepMap.empty;
    }
    invert(doc2) {
      return new AttrStep(this.pos, this.attr, doc2.nodeAt(this.pos).attrs[this.attr]);
    }
    map(mapping) {
      let pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);
    }
    toJSON() {
      return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
    }
    static fromJSON(schema2, json) {
      if (typeof json.pos != "number" || typeof json.attr != "string")
        throw new RangeError("Invalid input for AttrStep.fromJSON");
      return new AttrStep(json.pos, json.attr, json.value);
    }
  }
  Step.jsonID("attr", AttrStep);
  class DocAttrStep extends Step {
    /**
    Construct an attribute step.
    */
    constructor(attr, value) {
      super();
      this.attr = attr;
      this.value = value;
    }
    apply(doc2) {
      let attrs = /* @__PURE__ */ Object.create(null);
      for (let name in doc2.attrs)
        attrs[name] = doc2.attrs[name];
      attrs[this.attr] = this.value;
      let updated = doc2.type.create(attrs, doc2.content, doc2.marks);
      return StepResult.ok(updated);
    }
    getMap() {
      return StepMap.empty;
    }
    invert(doc2) {
      return new DocAttrStep(this.attr, doc2.attrs[this.attr]);
    }
    map(mapping) {
      return this;
    }
    toJSON() {
      return { stepType: "docAttr", attr: this.attr, value: this.value };
    }
    static fromJSON(schema2, json) {
      if (typeof json.attr != "string")
        throw new RangeError("Invalid input for DocAttrStep.fromJSON");
      return new DocAttrStep(json.attr, json.value);
    }
  }
  Step.jsonID("docAttr", DocAttrStep);
  let TransformError = class extends Error {
  };
  TransformError = function TransformError2(message) {
    let err2 = Error.call(this, message);
    err2.__proto__ = TransformError2.prototype;
    return err2;
  };
  TransformError.prototype = Object.create(Error.prototype);
  TransformError.prototype.constructor = TransformError;
  TransformError.prototype.name = "TransformError";
  class Transform {
    /**
    Create a transform that starts with the given document.
    */
    constructor(doc2) {
      this.doc = doc2;
      this.steps = [];
      this.docs = [];
      this.mapping = new Mapping();
    }
    /**
    The starting document.
    */
    get before() {
      return this.docs.length ? this.docs[0] : this.doc;
    }
    /**
    Apply a new step in this transform, saving the result. Throws an
    error when the step fails.
    */
    step(step) {
      let result = this.maybeStep(step);
      if (result.failed)
        throw new TransformError(result.failed);
      return this;
    }
    /**
    Try to apply a step in this transformation, ignoring it if it
    fails. Returns the step result.
    */
    maybeStep(step) {
      let result = step.apply(this.doc);
      if (!result.failed)
        this.addStep(step, result.doc);
      return result;
    }
    /**
    True when the document has been changed (when there are any
    steps).
    */
    get docChanged() {
      return this.steps.length > 0;
    }
    /**
    @internal
    */
    addStep(step, doc2) {
      this.docs.push(this.doc);
      this.steps.push(step);
      this.mapping.appendMap(step.getMap());
      this.doc = doc2;
    }
    /**
    Replace the part of the document between `from` and `to` with the
    given `slice`.
    */
    replace(from, to = from, slice = Slice.empty) {
      let step = replaceStep(this.doc, from, to, slice);
      if (step)
        this.step(step);
      return this;
    }
    /**
    Replace the given range with the given content, which may be a
    fragment, node, or array of nodes.
    */
    replaceWith(from, to, content) {
      return this.replace(from, to, new Slice(Fragment.from(content), 0, 0));
    }
    /**
    Delete the content between the given positions.
    */
    delete(from, to) {
      return this.replace(from, to, Slice.empty);
    }
    /**
    Insert the given content at the given position.
    */
    insert(pos, content) {
      return this.replaceWith(pos, pos, content);
    }
    /**
    Replace a range of the document with a given slice, using
    `from`, `to`, and the slice's
    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
    than fixed start and end points. This method may grow the
    replaced area or close open nodes in the slice in order to get a
    fit that is more in line with WYSIWYG expectations, by dropping
    fully covered parent nodes of the replaced region when they are
    marked [non-defining as
    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
    open parent node from the slice that _is_ marked as [defining
    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
    
    This is the method, for example, to handle paste. The similar
    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
    primitive tool which will _not_ move the start and end of its given
    range, and is useful in situations where you need more precise
    control over what happens.
    */
    replaceRange(from, to, slice) {
      replaceRange(this, from, to, slice);
      return this;
    }
    /**
    Replace the given range with a node, but use `from` and `to` as
    hints, rather than precise positions. When from and to are the same
    and are at the start or end of a parent node in which the given
    node doesn't fit, this method may _move_ them out towards a parent
    that does allow the given node to be placed. When the given range
    completely covers a parent node, this method may completely replace
    that parent node.
    */
    replaceRangeWith(from, to, node) {
      replaceRangeWith(this, from, to, node);
      return this;
    }
    /**
    Delete the given range, expanding it to cover fully covered
    parent nodes until a valid replace is found.
    */
    deleteRange(from, to) {
      deleteRange(this, from, to);
      return this;
    }
    /**
    Split the content in the given range off from its parent, if there
    is sibling content before or after it, and move it up the tree to
    the depth specified by `target`. You'll probably want to use
    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
    sure the lift is valid.
    */
    lift(range, target) {
      lift$1(this, range, target);
      return this;
    }
    /**
    Join the blocks around the given position. If depth is 2, their
    last and first siblings are also joined, and so on.
    */
    join(pos, depth = 1) {
      join(this, pos, depth);
      return this;
    }
    /**
    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
    The wrappers are assumed to be valid in this position, and should
    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
    */
    wrap(range, wrappers) {
      wrap(this, range, wrappers);
      return this;
    }
    /**
    Set the type of all textblocks (partly) between `from` and `to` to
    the given node type with the given attributes.
    */
    setBlockType(from, to = from, type, attrs = null) {
      setBlockType$1(this, from, to, type, attrs);
      return this;
    }
    /**
    Change the type, attributes, and/or marks of the node at `pos`.
    When `type` isn't given, the existing node type is preserved,
    */
    setNodeMarkup(pos, type, attrs = null, marks2) {
      setNodeMarkup(this, pos, type, attrs, marks2);
      return this;
    }
    /**
    Set a single attribute on a given node to a new value.
    The `pos` addresses the document content. Use `setDocAttribute`
    to set attributes on the document itself.
    */
    setNodeAttribute(pos, attr, value) {
      this.step(new AttrStep(pos, attr, value));
      return this;
    }
    /**
    Set a single attribute on the document to a new value.
    */
    setDocAttribute(attr, value) {
      this.step(new DocAttrStep(attr, value));
      return this;
    }
    /**
    Add a mark to the node at position `pos`.
    */
    addNodeMark(pos, mark) {
      this.step(new AddNodeMarkStep(pos, mark));
      return this;
    }
    /**
    Remove a mark (or all marks of the given type) from the node at
    position `pos`.
    */
    removeNodeMark(pos, mark) {
      let node = this.doc.nodeAt(pos);
      if (!node)
        throw new RangeError("No node at position " + pos);
      if (mark instanceof Mark) {
        if (mark.isInSet(node.marks))
          this.step(new RemoveNodeMarkStep(pos, mark));
      } else {
        let set2 = node.marks, found2, steps = [];
        while (found2 = mark.isInSet(set2)) {
          steps.push(new RemoveNodeMarkStep(pos, found2));
          set2 = found2.removeFromSet(set2);
        }
        for (let i2 = steps.length - 1; i2 >= 0; i2--)
          this.step(steps[i2]);
      }
      return this;
    }
    /**
    Split the node at the given position, and optionally, if `depth` is
    greater than one, any number of nodes above that. By default, the
    parts split off will inherit the node type of the original node.
    This can be changed by passing an array of types and attributes to
    use after the split (with the outermost nodes coming first).
    */
    split(pos, depth = 1, typesAfter) {
      split(this, pos, depth, typesAfter);
      return this;
    }
    /**
    Add the given mark to the inline content between `from` and `to`.
    */
    addMark(from, to, mark) {
      addMark(this, from, to, mark);
      return this;
    }
    /**
    Remove marks from inline nodes between `from` and `to`. When
    `mark` is a single mark, remove precisely that mark. When it is
    a mark type, remove all marks of that type. When it is null,
    remove all marks of any type.
    */
    removeMark(from, to, mark) {
      removeMark(this, from, to, mark);
      return this;
    }
    /**
    Removes all marks and nodes from the content of the node at
    `pos` that don't match the given new parent node type. Accepts
    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
    third argument.
    */
    clearIncompatible(pos, parentType, match) {
      clearIncompatible(this, pos, parentType, match);
      return this;
    }
  }
  const classesById = /* @__PURE__ */ Object.create(null);
  class Selection {
    /**
    Initialize a selection with the head and anchor and ranges. If no
    ranges are given, constructs a single range across `$anchor` and
    `$head`.
    */
    constructor($anchor, $head, ranges) {
      this.$anchor = $anchor;
      this.$head = $head;
      this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
    }
    /**
    The selection's anchor, as an unresolved position.
    */
    get anchor() {
      return this.$anchor.pos;
    }
    /**
    The selection's head.
    */
    get head() {
      return this.$head.pos;
    }
    /**
    The lower bound of the selection's main range.
    */
    get from() {
      return this.$from.pos;
    }
    /**
    The upper bound of the selection's main range.
    */
    get to() {
      return this.$to.pos;
    }
    /**
    The resolved lower  bound of the selection's main range.
    */
    get $from() {
      return this.ranges[0].$from;
    }
    /**
    The resolved upper bound of the selection's main range.
    */
    get $to() {
      return this.ranges[0].$to;
    }
    /**
    Indicates whether the selection contains any content.
    */
    get empty() {
      let ranges = this.ranges;
      for (let i2 = 0; i2 < ranges.length; i2++)
        if (ranges[i2].$from.pos != ranges[i2].$to.pos)
          return false;
      return true;
    }
    /**
    Get the content of this selection as a slice.
    */
    content() {
      return this.$from.doc.slice(this.from, this.to, true);
    }
    /**
    Replace the selection with a slice or, if no slice is given,
    delete the selection. Will append to the given transaction.
    */
    replace(tr, content = Slice.empty) {
      let lastNode = content.content.lastChild, lastParent = null;
      for (let i2 = 0; i2 < content.openEnd; i2++) {
        lastParent = lastNode;
        lastNode = lastNode.lastChild;
      }
      let mapFrom = tr.steps.length, ranges = this.ranges;
      for (let i2 = 0; i2 < ranges.length; i2++) {
        let { $from, $to } = ranges[i2], mapping = tr.mapping.slice(mapFrom);
        tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i2 ? Slice.empty : content);
        if (i2 == 0)
          selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
      }
    }
    /**
    Replace the selection with the given node, appending the changes
    to the given transaction.
    */
    replaceWith(tr, node) {
      let mapFrom = tr.steps.length, ranges = this.ranges;
      for (let i2 = 0; i2 < ranges.length; i2++) {
        let { $from, $to } = ranges[i2], mapping = tr.mapping.slice(mapFrom);
        let from = mapping.map($from.pos), to = mapping.map($to.pos);
        if (i2) {
          tr.deleteRange(from, to);
        } else {
          tr.replaceRangeWith(from, to, node);
          selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
        }
      }
    }
    /**
    Find a valid cursor or leaf node selection starting at the given
    position and searching back if `dir` is negative, and forward if
    positive. When `textOnly` is true, only consider cursor
    selections. Will return null when no valid selection position is
    found.
    */
    static findFrom($pos, dir, textOnly = false) {
      let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
      if (inner)
        return inner;
      for (let depth = $pos.depth - 1; depth >= 0; depth--) {
        let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
        if (found2)
          return found2;
      }
      return null;
    }
    /**
    Find a valid cursor or leaf node selection near the given
    position. Searches forward first by default, but if `bias` is
    negative, it will search backwards first.
    */
    static near($pos, bias = 1) {
      return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
    }
    /**
    Find the cursor or leaf node selection closest to the start of
    the given document. Will return an
    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
    exists.
    */
    static atStart(doc2) {
      return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
    }
    /**
    Find the cursor or leaf node selection closest to the end of the
    given document.
    */
    static atEnd(doc2) {
      return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
    }
    /**
    Deserialize the JSON representation of a selection. Must be
    implemented for custom classes (as a static class method).
    */
    static fromJSON(doc2, json) {
      if (!json || !json.type)
        throw new RangeError("Invalid input for Selection.fromJSON");
      let cls = classesById[json.type];
      if (!cls)
        throw new RangeError(`No selection type ${json.type} defined`);
      return cls.fromJSON(doc2, json);
    }
    /**
    To be able to deserialize selections from JSON, custom selection
    classes must register themselves with an ID string, so that they
    can be disambiguated. Try to pick something that's unlikely to
    clash with classes from other modules.
    */
    static jsonID(id, selectionClass) {
      if (id in classesById)
        throw new RangeError("Duplicate use of selection JSON ID " + id);
      classesById[id] = selectionClass;
      selectionClass.prototype.jsonID = id;
      return selectionClass;
    }
    /**
    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
    which is a value that can be mapped without having access to a
    current document, and later resolved to a real selection for a
    given document again. (This is used mostly by the history to
    track and restore old selections.) The default implementation of
    this method just converts the selection to a text selection and
    returns the bookmark for that.
    */
    getBookmark() {
      return TextSelection.between(this.$anchor, this.$head).getBookmark();
    }
  }
  Selection.prototype.visible = true;
  class SelectionRange {
    /**
    Create a range.
    */
    constructor($from, $to) {
      this.$from = $from;
      this.$to = $to;
    }
  }
  let warnedAboutTextSelection = false;
  function checkTextSelection($pos) {
    if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
      warnedAboutTextSelection = true;
      console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
    }
  }
  class TextSelection extends Selection {
    /**
    Construct a text selection between the given points.
    */
    constructor($anchor, $head = $anchor) {
      checkTextSelection($anchor);
      checkTextSelection($head);
      super($anchor, $head);
    }
    /**
    Returns a resolved position if this is a cursor selection (an
    empty text selection), and null otherwise.
    */
    get $cursor() {
      return this.$anchor.pos == this.$head.pos ? this.$head : null;
    }
    map(doc2, mapping) {
      let $head = doc2.resolve(mapping.map(this.head));
      if (!$head.parent.inlineContent)
        return Selection.near($head);
      let $anchor = doc2.resolve(mapping.map(this.anchor));
      return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
    }
    replace(tr, content = Slice.empty) {
      super.replace(tr, content);
      if (content == Slice.empty) {
        let marks2 = this.$from.marksAcross(this.$to);
        if (marks2)
          tr.ensureMarks(marks2);
      }
    }
    eq(other) {
      return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;
    }
    getBookmark() {
      return new TextBookmark(this.anchor, this.head);
    }
    toJSON() {
      return { type: "text", anchor: this.anchor, head: this.head };
    }
    /**
    @internal
    */
    static fromJSON(doc2, json) {
      if (typeof json.anchor != "number" || typeof json.head != "number")
        throw new RangeError("Invalid input for TextSelection.fromJSON");
      return new TextSelection(doc2.resolve(json.anchor), doc2.resolve(json.head));
    }
    /**
    Create a text selection from non-resolved positions.
    */
    static create(doc2, anchor, head = anchor) {
      let $anchor = doc2.resolve(anchor);
      return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
    }
    /**
    Return a text selection that spans the given positions or, if
    they aren't text positions, find a text selection near them.
    `bias` determines whether the method searches forward (default)
    or backwards (negative number) first. Will fall back to calling
    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
    doesn't contain a valid text position.
    */
    static between($anchor, $head, bias) {
      let dPos = $anchor.pos - $head.pos;
      if (!bias || dPos)
        bias = dPos >= 0 ? 1 : -1;
      if (!$head.parent.inlineContent) {
        let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
        if (found2)
          $head = found2.$head;
        else
          return Selection.near($head, bias);
      }
      if (!$anchor.parent.inlineContent) {
        if (dPos == 0) {
          $anchor = $head;
        } else {
          $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
          if ($anchor.pos < $head.pos != dPos < 0)
            $anchor = $head;
        }
      }
      return new TextSelection($anchor, $head);
    }
  }
  Selection.jsonID("text", TextSelection);
  class TextBookmark {
    constructor(anchor, head) {
      this.anchor = anchor;
      this.head = head;
    }
    map(mapping) {
      return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
    }
    resolve(doc2) {
      return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
    }
  }
  class NodeSelection extends Selection {
    /**
    Create a node selection. Does not verify the validity of its
    argument.
    */
    constructor($pos) {
      let node = $pos.nodeAfter;
      let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
      super($pos, $end);
      this.node = node;
    }
    map(doc2, mapping) {
      let { deleted, pos } = mapping.mapResult(this.anchor);
      let $pos = doc2.resolve(pos);
      if (deleted)
        return Selection.near($pos);
      return new NodeSelection($pos);
    }
    content() {
      return new Slice(Fragment.from(this.node), 0, 0);
    }
    eq(other) {
      return other instanceof NodeSelection && other.anchor == this.anchor;
    }
    toJSON() {
      return { type: "node", anchor: this.anchor };
    }
    getBookmark() {
      return new NodeBookmark(this.anchor);
    }
    /**
    @internal
    */
    static fromJSON(doc2, json) {
      if (typeof json.anchor != "number")
        throw new RangeError("Invalid input for NodeSelection.fromJSON");
      return new NodeSelection(doc2.resolve(json.anchor));
    }
    /**
    Create a node selection from non-resolved positions.
    */
    static create(doc2, from) {
      return new NodeSelection(doc2.resolve(from));
    }
    /**
    Determines whether the given node may be selected as a node
    selection.
    */
    static isSelectable(node) {
      return !node.isText && node.type.spec.selectable !== false;
    }
  }
  NodeSelection.prototype.visible = false;
  Selection.jsonID("node", NodeSelection);
  class NodeBookmark {
    constructor(anchor) {
      this.anchor = anchor;
    }
    map(mapping) {
      let { deleted, pos } = mapping.mapResult(this.anchor);
      return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
    }
    resolve(doc2) {
      let $pos = doc2.resolve(this.anchor), node = $pos.nodeAfter;
      if (node && NodeSelection.isSelectable(node))
        return new NodeSelection($pos);
      return Selection.near($pos);
    }
  }
  class AllSelection extends Selection {
    /**
    Create an all-selection over the given document.
    */
    constructor(doc2) {
      super(doc2.resolve(0), doc2.resolve(doc2.content.size));
    }
    replace(tr, content = Slice.empty) {
      if (content == Slice.empty) {
        tr.delete(0, tr.doc.content.size);
        let sel = Selection.atStart(tr.doc);
        if (!sel.eq(tr.selection))
          tr.setSelection(sel);
      } else {
        super.replace(tr, content);
      }
    }
    toJSON() {
      return { type: "all" };
    }
    /**
    @internal
    */
    static fromJSON(doc2) {
      return new AllSelection(doc2);
    }
    map(doc2) {
      return new AllSelection(doc2);
    }
    eq(other) {
      return other instanceof AllSelection;
    }
    getBookmark() {
      return AllBookmark;
    }
  }
  Selection.jsonID("all", AllSelection);
  const AllBookmark = {
    map() {
      return this;
    },
    resolve(doc2) {
      return new AllSelection(doc2);
    }
  };
  function findSelectionIn(doc2, node, pos, index, dir, text2 = false) {
    if (node.inlineContent)
      return TextSelection.create(doc2, pos);
    for (let i2 = index - (dir > 0 ? 0 : 1); dir > 0 ? i2 < node.childCount : i2 >= 0; i2 += dir) {
      let child = node.child(i2);
      if (!child.isAtom) {
        let inner = findSelectionIn(doc2, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text2);
        if (inner)
          return inner;
      } else if (!text2 && NodeSelection.isSelectable(child)) {
        return NodeSelection.create(doc2, pos - (dir < 0 ? child.nodeSize : 0));
      }
      pos += child.nodeSize * dir;
    }
    return null;
  }
  function selectionToInsertionEnd(tr, startLen, bias) {
    let last2 = tr.steps.length - 1;
    if (last2 < startLen)
      return;
    let step = tr.steps[last2];
    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
      return;
    let map = tr.mapping.maps[last2], end;
    map.forEach((_from, _to, _newFrom, newTo) => {
      if (end == null)
        end = newTo;
    });
    tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
  }
  const UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;
  class Transaction extends Transform {
    /**
    @internal
    */
    constructor(state) {
      super(state.doc);
      this.curSelectionFor = 0;
      this.updated = 0;
      this.meta = /* @__PURE__ */ Object.create(null);
      this.time = Date.now();
      this.curSelection = state.selection;
      this.storedMarks = state.storedMarks;
    }
    /**
    The transaction's current selection. This defaults to the editor
    selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
    transaction, but can be overwritten with
    [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
    */
    get selection() {
      if (this.curSelectionFor < this.steps.length) {
        this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
        this.curSelectionFor = this.steps.length;
      }
      return this.curSelection;
    }
    /**
    Update the transaction's current selection. Will determine the
    selection that the editor gets when the transaction is applied.
    */
    setSelection(selection) {
      if (selection.$from.doc != this.doc)
        throw new RangeError("Selection passed to setSelection must point at the current document");
      this.curSelection = selection;
      this.curSelectionFor = this.steps.length;
      this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
      this.storedMarks = null;
      return this;
    }
    /**
    Whether the selection was explicitly updated by this transaction.
    */
    get selectionSet() {
      return (this.updated & UPDATED_SEL) > 0;
    }
    /**
    Set the current stored marks.
    */
    setStoredMarks(marks2) {
      this.storedMarks = marks2;
      this.updated |= UPDATED_MARKS;
      return this;
    }
    /**
    Make sure the current stored marks or, if that is null, the marks
    at the selection, match the given set of marks. Does nothing if
    this is already the case.
    */
    ensureMarks(marks2) {
      if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks2))
        this.setStoredMarks(marks2);
      return this;
    }
    /**
    Add a mark to the set of stored marks.
    */
    addStoredMark(mark) {
      return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
    }
    /**
    Remove a mark or mark type from the set of stored marks.
    */
    removeStoredMark(mark) {
      return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
    }
    /**
    Whether the stored marks were explicitly set for this transaction.
    */
    get storedMarksSet() {
      return (this.updated & UPDATED_MARKS) > 0;
    }
    /**
    @internal
    */
    addStep(step, doc2) {
      super.addStep(step, doc2);
      this.updated = this.updated & ~UPDATED_MARKS;
      this.storedMarks = null;
    }
    /**
    Update the timestamp for the transaction.
    */
    setTime(time) {
      this.time = time;
      return this;
    }
    /**
    Replace the current selection with the given slice.
    */
    replaceSelection(slice) {
      this.selection.replace(this, slice);
      return this;
    }
    /**
    Replace the selection with the given node. When `inheritMarks` is
    true and the content is inline, it inherits the marks from the
    place where it is inserted.
    */
    replaceSelectionWith(node, inheritMarks = true) {
      let selection = this.selection;
      if (inheritMarks)
        node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
      selection.replaceWith(this, node);
      return this;
    }
    /**
    Delete the selection.
    */
    deleteSelection() {
      this.selection.replace(this);
      return this;
    }
    /**
    Replace the given range, or the selection if no range is given,
    with a text node containing the given string.
    */
    insertText(text2, from, to) {
      let schema2 = this.doc.type.schema;
      if (from == null) {
        if (!text2)
          return this.deleteSelection();
        return this.replaceSelectionWith(schema2.text(text2), true);
      } else {
        if (to == null)
          to = from;
        to = to == null ? from : to;
        if (!text2)
          return this.deleteRange(from, to);
        let marks2 = this.storedMarks;
        if (!marks2) {
          let $from = this.doc.resolve(from);
          marks2 = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
        }
        this.replaceRangeWith(from, to, schema2.text(text2, marks2));
        if (!this.selection.empty)
          this.setSelection(Selection.near(this.selection.$to));
        return this;
      }
    }
    /**
    Store a metadata property in this transaction, keyed either by
    name or by plugin.
    */
    setMeta(key2, value) {
      this.meta[typeof key2 == "string" ? key2 : key2.key] = value;
      return this;
    }
    /**
    Retrieve a metadata property for a given name or plugin.
    */
    getMeta(key2) {
      return this.meta[typeof key2 == "string" ? key2 : key2.key];
    }
    /**
    Returns true if this transaction doesn't contain any metadata,
    and can thus safely be extended.
    */
    get isGeneric() {
      for (let _2 in this.meta)
        return false;
      return true;
    }
    /**
    Indicate that the editor should scroll the selection into view
    when updated to the state produced by this transaction.
    */
    scrollIntoView() {
      this.updated |= UPDATED_SCROLL;
      return this;
    }
    /**
    True when this transaction has had `scrollIntoView` called on it.
    */
    get scrolledIntoView() {
      return (this.updated & UPDATED_SCROLL) > 0;
    }
  }
  function bind(f, self2) {
    return !self2 || !f ? f : f.bind(self2);
  }
  class FieldDesc {
    constructor(name, desc, self2) {
      this.name = name;
      this.init = bind(desc.init, self2);
      this.apply = bind(desc.apply, self2);
    }
  }
  const baseFields = [
    new FieldDesc("doc", {
      init(config) {
        return config.doc || config.schema.topNodeType.createAndFill();
      },
      apply(tr) {
        return tr.doc;
      }
    }),
    new FieldDesc("selection", {
      init(config, instance) {
        return config.selection || Selection.atStart(instance.doc);
      },
      apply(tr) {
        return tr.selection;
      }
    }),
    new FieldDesc("storedMarks", {
      init(config) {
        return config.storedMarks || null;
      },
      apply(tr, _marks, _old, state) {
        return state.selection.$cursor ? tr.storedMarks : null;
      }
    }),
    new FieldDesc("scrollToSelection", {
      init() {
        return 0;
      },
      apply(tr, prev) {
        return tr.scrolledIntoView ? prev + 1 : prev;
      }
    })
  ];
  class Configuration {
    constructor(schema2, plugins) {
      this.schema = schema2;
      this.plugins = [];
      this.pluginsByKey = /* @__PURE__ */ Object.create(null);
      this.fields = baseFields.slice();
      if (plugins)
        plugins.forEach((plugin) => {
          if (this.pluginsByKey[plugin.key])
            throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
          this.plugins.push(plugin);
          this.pluginsByKey[plugin.key] = plugin;
          if (plugin.spec.state)
            this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
        });
    }
  }
  class EditorState {
    /**
    @internal
    */
    constructor(config) {
      this.config = config;
    }
    /**
    The schema of the state's document.
    */
    get schema() {
      return this.config.schema;
    }
    /**
    The plugins that are active in this state.
    */
    get plugins() {
      return this.config.plugins;
    }
    /**
    Apply the given transaction to produce a new state.
    */
    apply(tr) {
      return this.applyTransaction(tr).state;
    }
    /**
    @internal
    */
    filterTransaction(tr, ignore = -1) {
      for (let i2 = 0; i2 < this.config.plugins.length; i2++)
        if (i2 != ignore) {
          let plugin = this.config.plugins[i2];
          if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))
            return false;
        }
      return true;
    }
    /**
    Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
    returns the precise transactions that were applied (which might
    be influenced by the [transaction
    hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
    plugins) along with the new state.
    */
    applyTransaction(rootTr) {
      if (!this.filterTransaction(rootTr))
        return { state: this, transactions: [] };
      let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
      for (; ; ) {
        let haveNew = false;
        for (let i2 = 0; i2 < this.config.plugins.length; i2++) {
          let plugin = this.config.plugins[i2];
          if (plugin.spec.appendTransaction) {
            let n = seen ? seen[i2].n : 0, oldState = seen ? seen[i2].state : this;
            let tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
            if (tr && newState.filterTransaction(tr, i2)) {
              tr.setMeta("appendedTransaction", rootTr);
              if (!seen) {
                seen = [];
                for (let j2 = 0; j2 < this.config.plugins.length; j2++)
                  seen.push(j2 < i2 ? { state: newState, n: trs.length } : { state: this, n: 0 });
              }
              trs.push(tr);
              newState = newState.applyInner(tr);
              haveNew = true;
            }
            if (seen)
              seen[i2] = { state: newState, n: trs.length };
          }
        }
        if (!haveNew)
          return { state: newState, transactions: trs };
      }
    }
    /**
    @internal
    */
    applyInner(tr) {
      if (!tr.before.eq(this.doc))
        throw new RangeError("Applying a mismatched transaction");
      let newInstance = new EditorState(this.config), fields = this.config.fields;
      for (let i2 = 0; i2 < fields.length; i2++) {
        let field = fields[i2];
        newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
      }
      return newInstance;
    }
    /**
    Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
    */
    get tr() {
      return new Transaction(this);
    }
    /**
    Create a new state.
    */
    static create(config) {
      let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
      let instance = new EditorState($config);
      for (let i2 = 0; i2 < $config.fields.length; i2++)
        instance[$config.fields[i2].name] = $config.fields[i2].init(config, instance);
      return instance;
    }
    /**
    Create a new state based on this one, but with an adjusted set
    of active plugins. State fields that exist in both sets of
    plugins are kept unchanged. Those that no longer exist are
    dropped, and those that are new are initialized using their
    [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
    configuration object..
    */
    reconfigure(config) {
      let $config = new Configuration(this.schema, config.plugins);
      let fields = $config.fields, instance = new EditorState($config);
      for (let i2 = 0; i2 < fields.length; i2++) {
        let name = fields[i2].name;
        instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i2].init(config, instance);
      }
      return instance;
    }
    /**
    Serialize this state to JSON. If you want to serialize the state
    of plugins, pass an object mapping property names to use in the
    resulting JSON object to plugin objects. The argument may also be
    a string or number, in which case it is ignored, to support the
    way `JSON.stringify` calls `toString` methods.
    */
    toJSON(pluginFields) {
      let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
      if (this.storedMarks)
        result.storedMarks = this.storedMarks.map((m) => m.toJSON());
      if (pluginFields && typeof pluginFields == "object")
        for (let prop in pluginFields) {
          if (prop == "doc" || prop == "selection")
            throw new RangeError("The JSON fields `doc` and `selection` are reserved");
          let plugin = pluginFields[prop], state = plugin.spec.state;
          if (state && state.toJSON)
            result[prop] = state.toJSON.call(plugin, this[plugin.key]);
        }
      return result;
    }
    /**
    Deserialize a JSON representation of a state. `config` should
    have at least a `schema` field, and should contain array of
    plugins to initialize the state with. `pluginFields` can be used
    to deserialize the state of plugins, by associating plugin
    instances with the property names they use in the JSON object.
    */
    static fromJSON(config, json, pluginFields) {
      if (!json)
        throw new RangeError("Invalid input for EditorState.fromJSON");
      if (!config.schema)
        throw new RangeError("Required config field 'schema' missing");
      let $config = new Configuration(config.schema, config.plugins);
      let instance = new EditorState($config);
      $config.fields.forEach((field) => {
        if (field.name == "doc") {
          instance.doc = Node$1.fromJSON(config.schema, json.doc);
        } else if (field.name == "selection") {
          instance.selection = Selection.fromJSON(instance.doc, json.selection);
        } else if (field.name == "storedMarks") {
          if (json.storedMarks)
            instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
        } else {
          if (pluginFields)
            for (let prop in pluginFields) {
              let plugin = pluginFields[prop], state = plugin.spec.state;
              if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
                instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
                return;
              }
            }
          instance[field.name] = field.init(config, instance);
        }
      });
      return instance;
    }
  }
  function bindProps(obj, self2, target) {
    for (let prop in obj) {
      let val = obj[prop];
      if (val instanceof Function)
        val = val.bind(self2);
      else if (prop == "handleDOMEvents")
        val = bindProps(val, self2, {});
      target[prop] = val;
    }
    return target;
  }
  class Plugin {
    /**
    Create a plugin.
    */
    constructor(spec) {
      this.spec = spec;
      this.props = {};
      if (spec.props)
        bindProps(spec.props, this, this.props);
      this.key = spec.key ? spec.key.key : createKey("plugin");
    }
    /**
    Extract the plugin's state field from an editor state.
    */
    getState(state) {
      return state[this.key];
    }
  }
  const keys = /* @__PURE__ */ Object.create(null);
  function createKey(name) {
    if (name in keys)
      return name + "$" + ++keys[name];
    keys[name] = 0;
    return name + "$";
  }
  class PluginKey {
    /**
    Create a plugin key.
    */
    constructor(name = "key") {
      this.key = createKey(name);
    }
    /**
    Get the active plugin with this key, if any, from an editor
    state.
    */
    get(state) {
      return state.config.pluginsByKey[this.key];
    }
    /**
    Get the plugin's state from an editor state.
    */
    getState(state) {
      return state[this.key];
    }
  }
  const domIndex = function(node) {
    for (var index = 0; ; index++) {
      node = node.previousSibling;
      if (!node)
        return index;
    }
  };
  const parentNode = function(node) {
    let parent = node.assignedSlot || node.parentNode;
    return parent && parent.nodeType == 11 ? parent.host : parent;
  };
  let reusedRange = null;
  const textRange = function(node, from, to) {
    let range = reusedRange || (reusedRange = document.createRange());
    range.setEnd(node, to == null ? node.nodeValue.length : to);
    range.setStart(node, from || 0);
    return range;
  };
  const clearReusedRange = function() {
    reusedRange = null;
  };
  const isEquivalentPosition = function(node, off, targetNode, targetOff) {
    return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
  };
  const atomElements = /^(img|br|input|textarea|hr)$/i;
  function scanFor(node, off, targetNode, targetOff, dir) {
    var _a2;
    for (; ; ) {
      if (node == targetNode && off == targetOff)
        return true;
      if (off == (dir < 0 ? 0 : nodeSize(node))) {
        let parent = node.parentNode;
        if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
          return false;
        off = domIndex(node) + (dir < 0 ? 0 : 1);
        node = parent;
      } else if (node.nodeType == 1) {
        let child = node.childNodes[off + (dir < 0 ? -1 : 0)];
        if (child.nodeType == 1 && child.contentEditable == "false") {
          if ((_a2 = child.pmViewDesc) === null || _a2 === void 0 ? void 0 : _a2.ignoreForSelection)
            off += dir;
          else
            return false;
        } else {
          node = child;
          off = dir < 0 ? nodeSize(node) : 0;
        }
      } else {
        return false;
      }
    }
  }
  function nodeSize(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  function textNodeBefore$1(node, offset2) {
    for (; ; ) {
      if (node.nodeType == 3 && offset2)
        return node;
      if (node.nodeType == 1 && offset2 > 0) {
        if (node.contentEditable == "false")
          return null;
        node = node.childNodes[offset2 - 1];
        offset2 = nodeSize(node);
      } else if (node.parentNode && !hasBlockDesc(node)) {
        offset2 = domIndex(node);
        node = node.parentNode;
      } else {
        return null;
      }
    }
  }
  function textNodeAfter$1(node, offset2) {
    for (; ; ) {
      if (node.nodeType == 3 && offset2 < node.nodeValue.length)
        return node;
      if (node.nodeType == 1 && offset2 < node.childNodes.length) {
        if (node.contentEditable == "false")
          return null;
        node = node.childNodes[offset2];
        offset2 = 0;
      } else if (node.parentNode && !hasBlockDesc(node)) {
        offset2 = domIndex(node) + 1;
        node = node.parentNode;
      } else {
        return null;
      }
    }
  }
  function isOnEdge(node, offset2, parent) {
    for (let atStart = offset2 == 0, atEnd = offset2 == nodeSize(node); atStart || atEnd; ) {
      if (node == parent)
        return true;
      let index = domIndex(node);
      node = node.parentNode;
      if (!node)
        return false;
      atStart = atStart && index == 0;
      atEnd = atEnd && index == nodeSize(node);
    }
  }
  function hasBlockDesc(dom) {
    let desc;
    for (let cur = dom; cur; cur = cur.parentNode)
      if (desc = cur.pmViewDesc)
        break;
    return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
  }
  const selectionCollapsed = function(domSel) {
    return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
  };
  function keyEvent(keyCode, key2) {
    let event = document.createEvent("Event");
    event.initEvent("keydown", true, true);
    event.keyCode = keyCode;
    event.key = event.code = key2;
    return event;
  }
  function deepActiveElement(doc2) {
    let elt = doc2.activeElement;
    while (elt && elt.shadowRoot)
      elt = elt.shadowRoot.activeElement;
    return elt;
  }
  function caretFromPoint(doc2, x2, y) {
    if (doc2.caretPositionFromPoint) {
      try {
        let pos = doc2.caretPositionFromPoint(x2, y);
        if (pos)
          return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };
      } catch (_2) {
      }
    }
    if (doc2.caretRangeFromPoint) {
      let range = doc2.caretRangeFromPoint(x2, y);
      if (range)
        return { node: range.startContainer, offset: Math.min(nodeSize(range.startContainer), range.startOffset) };
    }
  }
  const nav = typeof navigator != "undefined" ? navigator : null;
  const doc = typeof document != "undefined" ? document : null;
  const agent = nav && nav.userAgent || "";
  const ie_edge = /Edge\/(\d+)/.exec(agent);
  const ie_upto10 = /MSIE \d/.exec(agent);
  const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
  const ie$1 = !!(ie_upto10 || ie_11up || ie_edge);
  const ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
  const gecko = !ie$1 && /gecko\/(\d+)/i.test(agent);
  gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
  const _chrome = !ie$1 && /Chrome\/(\d+)/.exec(agent);
  const chrome = !!_chrome;
  const chrome_version = _chrome ? +_chrome[1] : 0;
  const safari = !ie$1 && !!nav && /Apple Computer/.test(nav.vendor);
  const ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
  const mac$3 = ios || (nav ? /Mac/.test(nav.platform) : false);
  const windows$1 = nav ? /Win/.test(nav.platform) : false;
  const android = /Android \d/.test(agent);
  const webkit = !!doc && "webkitFontSmoothing" in doc.documentElement.style;
  const webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
  function windowRect(doc2) {
    let vp = doc2.defaultView && doc2.defaultView.visualViewport;
    if (vp)
      return {
        left: 0,
        right: vp.width,
        top: 0,
        bottom: vp.height
      };
    return {
      left: 0,
      right: doc2.documentElement.clientWidth,
      top: 0,
      bottom: doc2.documentElement.clientHeight
    };
  }
  function getSide(value, side) {
    return typeof value == "number" ? value : value[side];
  }
  function clientRect(node) {
    let rect = node.getBoundingClientRect();
    let scaleX = rect.width / node.offsetWidth || 1;
    let scaleY = rect.height / node.offsetHeight || 1;
    return {
      left: rect.left,
      right: rect.left + node.clientWidth * scaleX,
      top: rect.top,
      bottom: rect.top + node.clientHeight * scaleY
    };
  }
  function scrollRectIntoView(view, rect, startDOM) {
    let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
    let doc2 = view.dom.ownerDocument;
    for (let parent = startDOM || view.dom; ; ) {
      if (!parent)
        break;
      if (parent.nodeType != 1) {
        parent = parentNode(parent);
        continue;
      }
      let elt = parent;
      let atTop = elt == doc2.body;
      let bounding = atTop ? windowRect(doc2) : clientRect(elt);
      let moveX = 0, moveY = 0;
      if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
        moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
      else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
        moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
      if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
        moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
      else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
        moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
      if (moveX || moveY) {
        if (atTop) {
          doc2.defaultView.scrollBy(moveX, moveY);
        } else {
          let startX = elt.scrollLeft, startY = elt.scrollTop;
          if (moveY)
            elt.scrollTop += moveY;
          if (moveX)
            elt.scrollLeft += moveX;
          let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
          rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
        }
      }
      let pos = atTop ? "fixed" : getComputedStyle(parent).position;
      if (/^(fixed|sticky)$/.test(pos))
        break;
      parent = pos == "absolute" ? parent.offsetParent : parentNode(parent);
    }
  }
  function storeScrollPos(view) {
    let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
    let refDOM, refTop;
    for (let x2 = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
      let dom = view.root.elementFromPoint(x2, y);
      if (!dom || dom == view.dom || !view.dom.contains(dom))
        continue;
      let localRect = dom.getBoundingClientRect();
      if (localRect.top >= startY - 20) {
        refDOM = dom;
        refTop = localRect.top;
        break;
      }
    }
    return { refDOM, refTop, stack: scrollStack(view.dom) };
  }
  function scrollStack(dom) {
    let stack = [], doc2 = dom.ownerDocument;
    for (let cur = dom; cur; cur = parentNode(cur)) {
      stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
      if (dom == doc2)
        break;
    }
    return stack;
  }
  function resetScrollPos({ refDOM, refTop, stack }) {
    let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
    restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
  }
  function restoreScrollStack(stack, dTop) {
    for (let i2 = 0; i2 < stack.length; i2++) {
      let { dom, top, left } = stack[i2];
      if (dom.scrollTop != top + dTop)
        dom.scrollTop = top + dTop;
      if (dom.scrollLeft != left)
        dom.scrollLeft = left;
    }
  }
  let preventScrollSupported = null;
  function focusPreventScroll(dom) {
    if (dom.setActive)
      return dom.setActive();
    if (preventScrollSupported)
      return dom.focus(preventScrollSupported);
    let stored = scrollStack(dom);
    dom.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = { preventScroll: true };
        return true;
      }
    } : void 0);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      restoreScrollStack(stored, 0);
    }
  }
  function findOffsetInNode(node, coords) {
    let closest, dxClosest = 2e8, coordsClosest, offset2 = 0;
    let rowBot = coords.top, rowTop = coords.top;
    let firstBelow, coordsBelow;
    for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
      let rects;
      if (child.nodeType == 1)
        rects = child.getClientRects();
      else if (child.nodeType == 3)
        rects = textRange(child).getClientRects();
      else
        continue;
      for (let i2 = 0; i2 < rects.length; i2++) {
        let rect = rects[i2];
        if (rect.top <= rowBot && rect.bottom >= rowTop) {
          rowBot = Math.max(rect.bottom, rowBot);
          rowTop = Math.min(rect.top, rowTop);
          let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
          if (dx < dxClosest) {
            closest = child;
            dxClosest = dx;
            coordsClosest = dx && closest.nodeType == 3 ? {
              left: rect.right < coords.left ? rect.right : rect.left,
              top: coords.top
            } : coords;
            if (child.nodeType == 1 && dx)
              offset2 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
            continue;
          }
        } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
          firstBelow = child;
          coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
        }
        if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
          offset2 = childIndex + 1;
      }
    }
    if (!closest && firstBelow) {
      closest = firstBelow;
      coordsClosest = coordsBelow;
      dxClosest = 0;
    }
    if (closest && closest.nodeType == 3)
      return findOffsetInText(closest, coordsClosest);
    if (!closest || dxClosest && closest.nodeType == 1)
      return { node, offset: offset2 };
    return findOffsetInNode(closest, coordsClosest);
  }
  function findOffsetInText(node, coords) {
    let len = node.nodeValue.length;
    let range = document.createRange();
    for (let i2 = 0; i2 < len; i2++) {
      range.setEnd(node, i2 + 1);
      range.setStart(node, i2);
      let rect = singleRect(range, 1);
      if (rect.top == rect.bottom)
        continue;
      if (inRect(coords, rect))
        return { node, offset: i2 + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
    }
    return { node, offset: 0 };
  }
  function inRect(coords, rect) {
    return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
  }
  function targetKludge(dom, coords) {
    let parent = dom.parentNode;
    if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
      return parent;
    return dom;
  }
  function posFromElement(view, elt, coords) {
    let { node, offset: offset2 } = findOffsetInNode(elt, coords), bias = -1;
    if (node.nodeType == 1 && !node.firstChild) {
      let rect = node.getBoundingClientRect();
      bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
    }
    return view.docView.posFromDOM(node, offset2, bias);
  }
  function posFromCaret(view, node, offset2, coords) {
    let outsideBlock = -1;
    for (let cur = node, sawBlock = false; ; ) {
      if (cur == view.dom)
        break;
      let desc = view.docView.nearestDesc(cur, true), rect;
      if (!desc)
        return null;
      if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles
      ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {
        if (desc.node.isBlock && desc.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(desc.dom.nodeName)) {
          if (!sawBlock && rect.left > coords.left || rect.top > coords.top)
            outsideBlock = desc.posBefore;
          else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)
            outsideBlock = desc.posAfter;
          sawBlock = true;
        }
        if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
          let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
          return before ? desc.posBefore : desc.posAfter;
        }
      }
      cur = desc.dom.parentNode;
    }
    return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset2, -1);
  }
  function elementFromPoint(element, coords, box) {
    let len = element.childNodes.length;
    if (len && box.top < box.bottom) {
      for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i2 = startI; ; ) {
        let child = element.childNodes[i2];
        if (child.nodeType == 1) {
          let rects = child.getClientRects();
          for (let j2 = 0; j2 < rects.length; j2++) {
            let rect = rects[j2];
            if (inRect(coords, rect))
              return elementFromPoint(child, coords, rect);
          }
        }
        if ((i2 = (i2 + 1) % len) == startI)
          break;
      }
    }
    return element;
  }
  function posAtCoords(view, coords) {
    let doc2 = view.dom.ownerDocument, node, offset2 = 0;
    let caret = caretFromPoint(doc2, coords.left, coords.top);
    if (caret)
      ({ node, offset: offset2 } = caret);
    let elt = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(coords.left, coords.top);
    let pos;
    if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
      let box = view.dom.getBoundingClientRect();
      if (!inRect(coords, box))
        return null;
      elt = elementFromPoint(view.dom, coords, box);
      if (!elt)
        return null;
    }
    if (safari) {
      for (let p = elt; node && p; p = parentNode(p))
        if (p.draggable)
          node = void 0;
    }
    elt = targetKludge(elt, coords);
    if (node) {
      if (gecko && node.nodeType == 1) {
        offset2 = Math.min(offset2, node.childNodes.length);
        if (offset2 < node.childNodes.length) {
          let next = node.childNodes[offset2], box;
          if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
            offset2++;
        }
      }
      let prev;
      if (webkit && offset2 && node.nodeType == 1 && (prev = node.childNodes[offset2 - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
        offset2--;
      if (node == view.dom && offset2 == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
        pos = view.state.doc.content.size;
      else if (offset2 == 0 || node.nodeType != 1 || node.childNodes[offset2 - 1].nodeName != "BR")
        pos = posFromCaret(view, node, offset2, coords);
    }
    if (pos == null)
      pos = posFromElement(view, elt, coords);
    let desc = view.docView.nearestDesc(elt, true);
    return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
  }
  function nonZero(rect) {
    return rect.top < rect.bottom || rect.left < rect.right;
  }
  function singleRect(target, bias) {
    let rects = target.getClientRects();
    if (rects.length) {
      let first = rects[bias < 0 ? 0 : rects.length - 1];
      if (nonZero(first))
        return first;
    }
    return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
  }
  const BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
  function coordsAtPos(view, pos, side) {
    let { node, offset: offset2, atom: atom2 } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
    let supportEmptyRange = webkit || gecko;
    if (node.nodeType == 3) {
      if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset2 : offset2 == node.nodeValue.length))) {
        let rect = singleRect(textRange(node, offset2, offset2), side);
        if (gecko && offset2 && /\s/.test(node.nodeValue[offset2 - 1]) && offset2 < node.nodeValue.length) {
          let rectBefore = singleRect(textRange(node, offset2 - 1, offset2 - 1), -1);
          if (rectBefore.top == rect.top) {
            let rectAfter = singleRect(textRange(node, offset2, offset2 + 1), -1);
            if (rectAfter.top != rect.top)
              return flattenV(rectAfter, rectAfter.left < rectBefore.left);
          }
        }
        return rect;
      } else {
        let from = offset2, to = offset2, takeSide = side < 0 ? 1 : -1;
        if (side < 0 && !offset2) {
          to++;
          takeSide = -1;
        } else if (side >= 0 && offset2 == node.nodeValue.length) {
          from--;
          takeSide = 1;
        } else if (side < 0) {
          from--;
        } else {
          to++;
        }
        return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0);
      }
    }
    let $dom = view.state.doc.resolve(pos - (atom2 || 0));
    if (!$dom.parent.inlineContent) {
      if (atom2 == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
        let before = node.childNodes[offset2 - 1];
        if (before.nodeType == 1)
          return flattenH(before.getBoundingClientRect(), false);
      }
      if (atom2 == null && offset2 < nodeSize(node)) {
        let after = node.childNodes[offset2];
        if (after.nodeType == 1)
          return flattenH(after.getBoundingClientRect(), true);
      }
      return flattenH(node.getBoundingClientRect(), side >= 0);
    }
    if (atom2 == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
      let before = node.childNodes[offset2 - 1];
      let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
      if (target)
        return flattenV(singleRect(target, 1), false);
    }
    if (atom2 == null && offset2 < nodeSize(node)) {
      let after = node.childNodes[offset2];
      while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
        after = after.nextSibling;
      let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
      if (target)
        return flattenV(singleRect(target, -1), true);
    }
    return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
  }
  function flattenV(rect, left) {
    if (rect.width == 0)
      return rect;
    let x2 = left ? rect.left : rect.right;
    return { top: rect.top, bottom: rect.bottom, left: x2, right: x2 };
  }
  function flattenH(rect, top) {
    if (rect.height == 0)
      return rect;
    let y = top ? rect.top : rect.bottom;
    return { top: y, bottom: y, left: rect.left, right: rect.right };
  }
  function withFlushedState(view, state, f) {
    let viewState = view.state, active = view.root.activeElement;
    if (viewState != state)
      view.updateState(state);
    if (active != view.dom)
      view.focus();
    try {
      return f();
    } finally {
      if (viewState != state)
        view.updateState(viewState);
      if (active != view.dom && active)
        active.focus();
    }
  }
  function endOfTextblockVertical(view, state, dir) {
    let sel = state.selection;
    let $pos = dir == "up" ? sel.$from : sel.$to;
    return withFlushedState(view, state, () => {
      let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
      for (; ; ) {
        let nearest = view.docView.nearestDesc(dom, true);
        if (!nearest)
          break;
        if (nearest.node.isBlock) {
          dom = nearest.contentDOM || nearest.dom;
          break;
        }
        dom = nearest.dom.parentNode;
      }
      let coords = coordsAtPos(view, $pos.pos, 1);
      for (let child = dom.firstChild; child; child = child.nextSibling) {
        let boxes;
        if (child.nodeType == 1)
          boxes = child.getClientRects();
        else if (child.nodeType == 3)
          boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
        else
          continue;
        for (let i2 = 0; i2 < boxes.length; i2++) {
          let box = boxes[i2];
          if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
            return false;
        }
      }
      return true;
    });
  }
  const maybeRTL = /[\u0590-\u08ac]/;
  function endOfTextblockHorizontal(view, state, dir) {
    let { $head } = state.selection;
    if (!$head.parent.isTextblock)
      return false;
    let offset2 = $head.parentOffset, atStart = !offset2, atEnd = offset2 == $head.parent.content.size;
    let sel = view.domSelection();
    if (!sel)
      return $head.pos == $head.start() || $head.pos == $head.end();
    if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
      return dir == "left" || dir == "backward" ? atStart : atEnd;
    return withFlushedState(view, state, () => {
      let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
      let oldBidiLevel = sel.caretBidiLevel;
      sel.modify("move", dir, "character");
      let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
      let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
      let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
      try {
        sel.collapse(anchorNode, anchorOffset);
        if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
          sel.extend(oldNode, oldOff);
      } catch (_2) {
      }
      if (oldBidiLevel != null)
        sel.caretBidiLevel = oldBidiLevel;
      return result;
    });
  }
  let cachedState = null;
  let cachedDir = null;
  let cachedResult = false;
  function endOfTextblock(view, state, dir) {
    if (cachedState == state && cachedDir == dir)
      return cachedResult;
    cachedState = state;
    cachedDir = dir;
    return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
  }
  const NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;
  class ViewDesc {
    constructor(parent, children, dom, contentDOM) {
      this.parent = parent;
      this.children = children;
      this.dom = dom;
      this.contentDOM = contentDOM;
      this.dirty = NOT_DIRTY;
      dom.pmViewDesc = this;
    }
    // Used to check whether a given description corresponds to a
    // widget/mark/node.
    matchesWidget(widget) {
      return false;
    }
    matchesMark(mark) {
      return false;
    }
    matchesNode(node, outerDeco, innerDeco) {
      return false;
    }
    matchesHack(nodeName) {
      return false;
    }
    // When parsing in-editor content (in domchange.js), we allow
    // descriptions to determine the parse rules that should be used to
    // parse them.
    parseRule() {
      return null;
    }
    // Used by the editor's event handler to ignore events that come
    // from certain descs.
    stopEvent(event) {
      return false;
    }
    // The size of the content represented by this desc.
    get size() {
      let size = 0;
      for (let i2 = 0; i2 < this.children.length; i2++)
        size += this.children[i2].size;
      return size;
    }
    // For block nodes, this represents the space taken up by their
    // start/end tokens.
    get border() {
      return 0;
    }
    destroy() {
      this.parent = void 0;
      if (this.dom.pmViewDesc == this)
        this.dom.pmViewDesc = void 0;
      for (let i2 = 0; i2 < this.children.length; i2++)
        this.children[i2].destroy();
    }
    posBeforeChild(child) {
      for (let i2 = 0, pos = this.posAtStart; ; i2++) {
        let cur = this.children[i2];
        if (cur == child)
          return pos;
        pos += cur.size;
      }
    }
    get posBefore() {
      return this.parent.posBeforeChild(this);
    }
    get posAtStart() {
      return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
    }
    get posAfter() {
      return this.posBefore + this.size;
    }
    get posAtEnd() {
      return this.posAtStart + this.size - 2 * this.border;
    }
    localPosFromDOM(dom, offset2, bias) {
      if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
        if (bias < 0) {
          let domBefore, desc;
          if (dom == this.contentDOM) {
            domBefore = dom.childNodes[offset2 - 1];
          } else {
            while (dom.parentNode != this.contentDOM)
              dom = dom.parentNode;
            domBefore = dom.previousSibling;
          }
          while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
            domBefore = domBefore.previousSibling;
          return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
        } else {
          let domAfter, desc;
          if (dom == this.contentDOM) {
            domAfter = dom.childNodes[offset2];
          } else {
            while (dom.parentNode != this.contentDOM)
              dom = dom.parentNode;
            domAfter = dom.nextSibling;
          }
          while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
            domAfter = domAfter.nextSibling;
          return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
        }
      }
      let atEnd;
      if (dom == this.dom && this.contentDOM) {
        atEnd = offset2 > domIndex(this.contentDOM);
      } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
        atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
      } else if (this.dom.firstChild) {
        if (offset2 == 0)
          for (let search = dom; ; search = search.parentNode) {
            if (search == this.dom) {
              atEnd = false;
              break;
            }
            if (search.previousSibling)
              break;
          }
        if (atEnd == null && offset2 == dom.childNodes.length)
          for (let search = dom; ; search = search.parentNode) {
            if (search == this.dom) {
              atEnd = true;
              break;
            }
            if (search.nextSibling)
              break;
          }
      }
      return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
    }
    nearestDesc(dom, onlyNodes = false) {
      for (let first = true, cur = dom; cur; cur = cur.parentNode) {
        let desc = this.getDesc(cur), nodeDOM;
        if (desc && (!onlyNodes || desc.node)) {
          if (first && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
            first = false;
          else
            return desc;
        }
      }
    }
    getDesc(dom) {
      let desc = dom.pmViewDesc;
      for (let cur = desc; cur; cur = cur.parent)
        if (cur == this)
          return desc;
    }
    posFromDOM(dom, offset2, bias) {
      for (let scan = dom; scan; scan = scan.parentNode) {
        let desc = this.getDesc(scan);
        if (desc)
          return desc.localPosFromDOM(dom, offset2, bias);
      }
      return -1;
    }
    // Find the desc for the node after the given pos, if any. (When a
    // parent node overrode rendering, there might not be one.)
    descAt(pos) {
      for (let i2 = 0, offset2 = 0; i2 < this.children.length; i2++) {
        let child = this.children[i2], end = offset2 + child.size;
        if (offset2 == pos && end != offset2) {
          while (!child.border && child.children.length) {
            for (let i3 = 0; i3 < child.children.length; i3++) {
              let inner = child.children[i3];
              if (inner.size) {
                child = inner;
                break;
              }
            }
          }
          return child;
        }
        if (pos < end)
          return child.descAt(pos - offset2 - child.border);
        offset2 = end;
      }
    }
    domFromPos(pos, side) {
      if (!this.contentDOM)
        return { node: this.dom, offset: 0, atom: pos + 1 };
      let i2 = 0, offset2 = 0;
      for (let curPos = 0; i2 < this.children.length; i2++) {
        let child = this.children[i2], end = curPos + child.size;
        if (end > pos || child instanceof TrailingHackViewDesc) {
          offset2 = pos - curPos;
          break;
        }
        curPos = end;
      }
      if (offset2)
        return this.children[i2].domFromPos(offset2 - this.children[i2].border, side);
      for (let prev; i2 && !(prev = this.children[i2 - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i2--) {
      }
      if (side <= 0) {
        let prev, enter = true;
        for (; ; i2--, enter = false) {
          prev = i2 ? this.children[i2 - 1] : null;
          if (!prev || prev.dom.parentNode == this.contentDOM)
            break;
        }
        if (prev && side && enter && !prev.border && !prev.domAtom)
          return prev.domFromPos(prev.size, side);
        return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
      } else {
        let next, enter = true;
        for (; ; i2++, enter = false) {
          next = i2 < this.children.length ? this.children[i2] : null;
          if (!next || next.dom.parentNode == this.contentDOM)
            break;
        }
        if (next && enter && !next.border && !next.domAtom)
          return next.domFromPos(0, side);
        return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
      }
    }
    // Used to find a DOM range in a single parent for a given changed
    // range.
    parseRange(from, to, base2 = 0) {
      if (this.children.length == 0)
        return { node: this.contentDOM, from, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
      let fromOffset = -1, toOffset = -1;
      for (let offset2 = base2, i2 = 0; ; i2++) {
        let child = this.children[i2], end = offset2 + child.size;
        if (fromOffset == -1 && from <= end) {
          let childBase = offset2 + child.border;
          if (from >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
            return child.parseRange(from, to, childBase);
          from = offset2;
          for (let j2 = i2; j2 > 0; j2--) {
            let prev = this.children[j2 - 1];
            if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
              fromOffset = domIndex(prev.dom) + 1;
              break;
            }
            from -= prev.size;
          }
          if (fromOffset == -1)
            fromOffset = 0;
        }
        if (fromOffset > -1 && (end > to || i2 == this.children.length - 1)) {
          to = end;
          for (let j2 = i2 + 1; j2 < this.children.length; j2++) {
            let next = this.children[j2];
            if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
              toOffset = domIndex(next.dom);
              break;
            }
            to += next.size;
          }
          if (toOffset == -1)
            toOffset = this.contentDOM.childNodes.length;
          break;
        }
        offset2 = end;
      }
      return { node: this.contentDOM, from, to, fromOffset, toOffset };
    }
    emptyChildAt(side) {
      if (this.border || !this.contentDOM || !this.children.length)
        return false;
      let child = this.children[side < 0 ? 0 : this.children.length - 1];
      return child.size == 0 || child.emptyChildAt(side);
    }
    domAfterPos(pos) {
      let { node, offset: offset2 } = this.domFromPos(pos, 0);
      if (node.nodeType != 1 || offset2 == node.childNodes.length)
        throw new RangeError("No node after pos " + pos);
      return node.childNodes[offset2];
    }
    // View descs are responsible for setting any selection that falls
    // entirely inside of them, so that custom implementations can do
    // custom things with the selection. Note that this falls apart when
    // a selection starts in such a node and ends in another, in which
    // case we just use whatever domFromPos produces as a best effort.
    setSelection(anchor, head, view, force = false) {
      let from = Math.min(anchor, head), to = Math.max(anchor, head);
      for (let i2 = 0, offset2 = 0; i2 < this.children.length; i2++) {
        let child = this.children[i2], end = offset2 + child.size;
        if (from > offset2 && to < end)
          return child.setSelection(anchor - offset2 - child.border, head - offset2 - child.border, view, force);
        offset2 = end;
      }
      let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
      let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
      let domSel = view.root.getSelection();
      let selRange = view.domSelectionRange();
      let brKludge = false;
      if ((gecko || safari) && anchor == head) {
        let { node, offset: offset2 } = anchorDOM;
        if (node.nodeType == 3) {
          brKludge = !!(offset2 && node.nodeValue[offset2 - 1] == "\n");
          if (brKludge && offset2 == node.nodeValue.length) {
            for (let scan = node, after; scan; scan = scan.parentNode) {
              if (after = scan.nextSibling) {
                if (after.nodeName == "BR")
                  anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
                break;
              }
              let desc = scan.pmViewDesc;
              if (desc && desc.node && desc.node.isBlock)
                break;
            }
          }
        } else {
          let prev = node.childNodes[offset2 - 1];
          brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
        }
      }
      if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {
        let after = selRange.focusNode.childNodes[selRange.focusOffset];
        if (after && after.contentEditable == "false")
          force = true;
      }
      if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))
        return;
      let domSelExtended = false;
      if ((domSel.extend || anchor == head) && !brKludge) {
        domSel.collapse(anchorDOM.node, anchorDOM.offset);
        try {
          if (anchor != head)
            domSel.extend(headDOM.node, headDOM.offset);
          domSelExtended = true;
        } catch (_2) {
        }
      }
      if (!domSelExtended) {
        if (anchor > head) {
          let tmp = anchorDOM;
          anchorDOM = headDOM;
          headDOM = tmp;
        }
        let range = document.createRange();
        range.setEnd(headDOM.node, headDOM.offset);
        range.setStart(anchorDOM.node, anchorDOM.offset);
        domSel.removeAllRanges();
        domSel.addRange(range);
      }
    }
    ignoreMutation(mutation) {
      return !this.contentDOM && mutation.type != "selection";
    }
    get contentLost() {
      return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
    }
    // Remove a subtree of the element tree that has been touched
    // by a DOM change, so that the next update will redraw it.
    markDirty(from, to) {
      for (let offset2 = 0, i2 = 0; i2 < this.children.length; i2++) {
        let child = this.children[i2], end = offset2 + child.size;
        if (offset2 == end ? from <= end && to >= offset2 : from < end && to > offset2) {
          let startInside = offset2 + child.border, endInside = end - child.border;
          if (from >= startInside && to <= endInside) {
            this.dirty = from == offset2 || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
            if (from == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
              child.dirty = NODE_DIRTY;
            else
              child.markDirty(from - startInside, to - startInside);
            return;
          } else {
            child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
          }
        }
        offset2 = end;
      }
      this.dirty = CONTENT_DIRTY;
    }
    markParentsDirty() {
      let level = 1;
      for (let node = this.parent; node; node = node.parent, level++) {
        let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
        if (node.dirty < dirty)
          node.dirty = dirty;
      }
    }
    get domAtom() {
      return false;
    }
    get ignoreForCoords() {
      return false;
    }
    get ignoreForSelection() {
      return false;
    }
    isText(text2) {
      return false;
    }
  }
  class WidgetViewDesc extends ViewDesc {
    constructor(parent, widget, view, pos) {
      let self2, dom = widget.type.toDOM;
      if (typeof dom == "function")
        dom = dom(view, () => {
          if (!self2)
            return pos;
          if (self2.parent)
            return self2.parent.posBeforeChild(self2);
        });
      if (!widget.type.spec.raw) {
        if (dom.nodeType != 1) {
          let wrap2 = document.createElement("span");
          wrap2.appendChild(dom);
          dom = wrap2;
        }
        dom.contentEditable = "false";
        dom.classList.add("ProseMirror-widget");
      }
      super(parent, [], dom, null);
      this.widget = widget;
      this.widget = widget;
      self2 = this;
    }
    matchesWidget(widget) {
      return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
    }
    parseRule() {
      return { ignore: true };
    }
    stopEvent(event) {
      let stop = this.widget.spec.stopEvent;
      return stop ? stop(event) : false;
    }
    ignoreMutation(mutation) {
      return mutation.type != "selection" || this.widget.spec.ignoreSelection;
    }
    destroy() {
      this.widget.type.destroy(this.dom);
      super.destroy();
    }
    get domAtom() {
      return true;
    }
    get ignoreForSelection() {
      return !!this.widget.type.spec.relaxedSide;
    }
    get side() {
      return this.widget.type.side;
    }
  }
  class CompositionViewDesc extends ViewDesc {
    constructor(parent, dom, textDOM, text2) {
      super(parent, [], dom, null);
      this.textDOM = textDOM;
      this.text = text2;
    }
    get size() {
      return this.text.length;
    }
    localPosFromDOM(dom, offset2) {
      if (dom != this.textDOM)
        return this.posAtStart + (offset2 ? this.size : 0);
      return this.posAtStart + offset2;
    }
    domFromPos(pos) {
      return { node: this.textDOM, offset: pos };
    }
    ignoreMutation(mut) {
      return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
    }
  }
  class MarkViewDesc extends ViewDesc {
    constructor(parent, mark, dom, contentDOM, spec) {
      super(parent, [], dom, contentDOM);
      this.mark = mark;
      this.spec = spec;
    }
    static create(parent, mark, inline, view) {
      let custom2 = view.nodeViews[mark.type.name];
      let spec = custom2 && custom2(mark, view, inline);
      if (!spec || !spec.dom)
        spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);
      return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);
    }
    parseRule() {
      if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
        return null;
      return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
    }
    matchesMark(mark) {
      return this.dirty != NODE_DIRTY && this.mark.eq(mark);
    }
    markDirty(from, to) {
      super.markDirty(from, to);
      if (this.dirty != NOT_DIRTY) {
        let parent = this.parent;
        while (!parent.node)
          parent = parent.parent;
        if (parent.dirty < this.dirty)
          parent.dirty = this.dirty;
        this.dirty = NOT_DIRTY;
      }
    }
    slice(from, to, view) {
      let copy2 = MarkViewDesc.create(this.parent, this.mark, true, view);
      let nodes2 = this.children, size = this.size;
      if (to < size)
        nodes2 = replaceNodes(nodes2, to, size, view);
      if (from > 0)
        nodes2 = replaceNodes(nodes2, 0, from, view);
      for (let i2 = 0; i2 < nodes2.length; i2++)
        nodes2[i2].parent = copy2;
      copy2.children = nodes2;
      return copy2;
    }
    ignoreMutation(mutation) {
      return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
    }
    destroy() {
      if (this.spec.destroy)
        this.spec.destroy();
      super.destroy();
    }
  }
  class NodeViewDesc extends ViewDesc {
    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
      super(parent, [], dom, contentDOM);
      this.node = node;
      this.outerDeco = outerDeco;
      this.innerDeco = innerDeco;
      this.nodeDOM = nodeDOM;
    }
    // By default, a node is rendered using the `toDOM` method from the
    // node type spec. But client code can use the `nodeViews` spec to
    // supply a custom node view, which can influence various aspects of
    // the way the node works.
    //
    // (Using subclassing for this was intentionally decided against,
    // since it'd require exposing a whole slew of finicky
    // implementation details to the user code that they probably will
    // never need.)
    static create(parent, node, outerDeco, innerDeco, view, pos) {
      let custom2 = view.nodeViews[node.type.name], descObj;
      let spec = custom2 && custom2(node, view, () => {
        if (!descObj)
          return pos;
        if (descObj.parent)
          return descObj.parent.posBeforeChild(descObj);
      }, outerDeco, innerDeco);
      let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
      if (node.isText) {
        if (!dom)
          dom = document.createTextNode(node.text);
        else if (dom.nodeType != 3)
          throw new RangeError("Text must be rendered as a DOM text node");
      } else if (!dom) {
        let spec2 = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);
        ({ dom, contentDOM } = spec2);
      }
      if (!contentDOM && !node.isText && dom.nodeName != "BR") {
        if (!dom.hasAttribute("contenteditable"))
          dom.contentEditable = "false";
        if (node.type.spec.draggable)
          dom.draggable = true;
      }
      let nodeDOM = dom;
      dom = applyOuterDeco(dom, outerDeco, node);
      if (spec)
        return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
      else if (node.isText)
        return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
      else
        return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
    }
    parseRule() {
      if (this.node.type.spec.reparseInView)
        return null;
      let rule = { node: this.node.type.name, attrs: this.node.attrs };
      if (this.node.type.whitespace == "pre")
        rule.preserveWhitespace = "full";
      if (!this.contentDOM) {
        rule.getContent = () => this.node.content;
      } else if (!this.contentLost) {
        rule.contentElement = this.contentDOM;
      } else {
        for (let i2 = this.children.length - 1; i2 >= 0; i2--) {
          let child = this.children[i2];
          if (this.dom.contains(child.dom.parentNode)) {
            rule.contentElement = child.dom.parentNode;
            break;
          }
        }
        if (!rule.contentElement)
          rule.getContent = () => Fragment.empty;
      }
      return rule;
    }
    matchesNode(node, outerDeco, innerDeco) {
      return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
    }
    get size() {
      return this.node.nodeSize;
    }
    get border() {
      return this.node.isLeaf ? 0 : 1;
    }
    // Syncs `this.children` to match `this.node.content` and the local
    // decorations, possibly introducing nesting for marks. Then, in a
    // separate step, syncs the DOM inside `this.contentDOM` to
    // `this.children`.
    updateChildren(view, pos) {
      let inline = this.node.inlineContent, off = pos;
      let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
      let localComposition = composition && composition.pos > -1 ? composition : null;
      let compositionInChild = composition && composition.pos < 0;
      let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
      iterDeco(this.node, this.innerDeco, (widget, i2, insideNode) => {
        if (widget.spec.marks)
          updater.syncToMarks(widget.spec.marks, inline, view);
        else if (widget.type.side >= 0 && !insideNode)
          updater.syncToMarks(i2 == this.node.childCount ? Mark.none : this.node.child(i2).marks, inline, view);
        updater.placeWidget(widget, view, off);
      }, (child, outerDeco, innerDeco, i2) => {
        updater.syncToMarks(child.marks, inline, view);
        let compIndex;
        if (updater.findNodeMatch(child, outerDeco, innerDeco, i2)) ;
        else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;
        else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i2, off)) ;
        else {
          updater.addNode(child, outerDeco, innerDeco, view, off);
        }
        off += child.nodeSize;
      });
      updater.syncToMarks([], inline, view);
      if (this.node.isTextblock)
        updater.addTextblockHacks();
      updater.destroyRest();
      if (updater.changed || this.dirty == CONTENT_DIRTY) {
        if (localComposition)
          this.protectLocalComposition(view, localComposition);
        renderDescs(this.contentDOM, this.children, view);
        if (ios)
          iosHacks(this.dom);
      }
    }
    localCompositionInfo(view, pos) {
      let { from, to } = view.state.selection;
      if (!(view.state.selection instanceof TextSelection) || from < pos || to > pos + this.node.content.size)
        return null;
      let textNode = view.input.compositionNode;
      if (!textNode || !this.dom.contains(textNode.parentNode))
        return null;
      if (this.node.inlineContent) {
        let text2 = textNode.nodeValue;
        let textPos = findTextInFragment(this.node.content, text2, from - pos, to - pos);
        return textPos < 0 ? null : { node: textNode, pos: textPos, text: text2 };
      } else {
        return { node: textNode, pos: -1, text: "" };
      }
    }
    protectLocalComposition(view, { node, pos, text: text2 }) {
      if (this.getDesc(node))
        return;
      let topNode = node;
      for (; ; topNode = topNode.parentNode) {
        if (topNode.parentNode == this.contentDOM)
          break;
        while (topNode.previousSibling)
          topNode.parentNode.removeChild(topNode.previousSibling);
        while (topNode.nextSibling)
          topNode.parentNode.removeChild(topNode.nextSibling);
        if (topNode.pmViewDesc)
          topNode.pmViewDesc = void 0;
      }
      let desc = new CompositionViewDesc(this, topNode, node, text2);
      view.input.compositionNodes.push(desc);
      this.children = replaceNodes(this.children, pos, pos + text2.length, view, desc);
    }
    // If this desc must be updated to match the given node decoration,
    // do so and return true.
    update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
        return false;
      this.updateInner(node, outerDeco, innerDeco, view);
      return true;
    }
    updateInner(node, outerDeco, innerDeco, view) {
      this.updateOuterDeco(outerDeco);
      this.node = node;
      this.innerDeco = innerDeco;
      if (this.contentDOM)
        this.updateChildren(view, this.posAtStart);
      this.dirty = NOT_DIRTY;
    }
    updateOuterDeco(outerDeco) {
      if (sameOuterDeco(outerDeco, this.outerDeco))
        return;
      let needsWrap = this.nodeDOM.nodeType != 1;
      let oldDOM = this.dom;
      this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
      if (this.dom != oldDOM) {
        oldDOM.pmViewDesc = void 0;
        this.dom.pmViewDesc = this;
      }
      this.outerDeco = outerDeco;
    }
    // Mark this node as being the selected node.
    selectNode() {
      if (this.nodeDOM.nodeType == 1)
        this.nodeDOM.classList.add("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.dom.draggable = true;
    }
    // Remove selected node marking from this node.
    deselectNode() {
      if (this.nodeDOM.nodeType == 1) {
        this.nodeDOM.classList.remove("ProseMirror-selectednode");
        if (this.contentDOM || !this.node.type.spec.draggable)
          this.dom.removeAttribute("draggable");
      }
    }
    get domAtom() {
      return this.node.isAtom;
    }
  }
  function docViewDesc(doc2, outerDeco, innerDeco, dom, view) {
    applyOuterDeco(dom, outerDeco, doc2);
    let docView = new NodeViewDesc(void 0, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);
    if (docView.contentDOM)
      docView.updateChildren(view, 0);
    return docView;
  }
  class TextViewDesc extends NodeViewDesc {
    constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
      super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
    }
    parseRule() {
      let skip = this.nodeDOM.parentNode;
      while (skip && skip != this.dom && !skip.pmIsDeco)
        skip = skip.parentNode;
      return { skip: skip || true };
    }
    update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
        return false;
      this.updateOuterDeco(outerDeco);
      if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
        this.nodeDOM.nodeValue = node.text;
        if (view.trackWrites == this.nodeDOM)
          view.trackWrites = null;
      }
      this.node = node;
      this.dirty = NOT_DIRTY;
      return true;
    }
    inParent() {
      let parentDOM = this.parent.contentDOM;
      for (let n = this.nodeDOM; n; n = n.parentNode)
        if (n == parentDOM)
          return true;
      return false;
    }
    domFromPos(pos) {
      return { node: this.nodeDOM, offset: pos };
    }
    localPosFromDOM(dom, offset2, bias) {
      if (dom == this.nodeDOM)
        return this.posAtStart + Math.min(offset2, this.node.text.length);
      return super.localPosFromDOM(dom, offset2, bias);
    }
    ignoreMutation(mutation) {
      return mutation.type != "characterData" && mutation.type != "selection";
    }
    slice(from, to, view) {
      let node = this.node.cut(from, to), dom = document.createTextNode(node.text);
      return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
    }
    markDirty(from, to) {
      super.markDirty(from, to);
      if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length))
        this.dirty = NODE_DIRTY;
    }
    get domAtom() {
      return false;
    }
    isText(text2) {
      return this.node.text == text2;
    }
  }
  class TrailingHackViewDesc extends ViewDesc {
    parseRule() {
      return { ignore: true };
    }
    matchesHack(nodeName) {
      return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
    }
    get domAtom() {
      return true;
    }
    get ignoreForCoords() {
      return this.dom.nodeName == "IMG";
    }
  }
  class CustomNodeViewDesc extends NodeViewDesc {
    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
      super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
      this.spec = spec;
    }
    // A custom `update` method gets to decide whether the update goes
    // through. If it does, and there's a `contentDOM` node, our logic
    // updates the children.
    update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY)
        return false;
      if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {
        let result = this.spec.update(node, outerDeco, innerDeco);
        if (result)
          this.updateInner(node, outerDeco, innerDeco, view);
        return result;
      } else if (!this.contentDOM && !node.isLeaf) {
        return false;
      } else {
        return super.update(node, outerDeco, innerDeco, view);
      }
    }
    selectNode() {
      this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
    }
    deselectNode() {
      this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
    }
    setSelection(anchor, head, view, force) {
      this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);
    }
    destroy() {
      if (this.spec.destroy)
        this.spec.destroy();
      super.destroy();
    }
    stopEvent(event) {
      return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
    }
    ignoreMutation(mutation) {
      return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
    }
  }
  function renderDescs(parentDOM, descs, view) {
    let dom = parentDOM.firstChild, written = false;
    for (let i2 = 0; i2 < descs.length; i2++) {
      let desc = descs[i2], childDOM = desc.dom;
      if (childDOM.parentNode == parentDOM) {
        while (childDOM != dom) {
          dom = rm(dom);
          written = true;
        }
        dom = dom.nextSibling;
      } else {
        written = true;
        parentDOM.insertBefore(childDOM, dom);
      }
      if (desc instanceof MarkViewDesc) {
        let pos = dom ? dom.previousSibling : parentDOM.lastChild;
        renderDescs(desc.contentDOM, desc.children, view);
        dom = pos ? pos.nextSibling : parentDOM.firstChild;
      }
    }
    while (dom) {
      dom = rm(dom);
      written = true;
    }
    if (written && view.trackWrites == parentDOM)
      view.trackWrites = null;
  }
  const OuterDecoLevel = function(nodeName) {
    if (nodeName)
      this.nodeName = nodeName;
  };
  OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
  const noDeco = [new OuterDecoLevel()];
  function computeOuterDeco(outerDeco, node, needsWrap) {
    if (outerDeco.length == 0)
      return noDeco;
    let top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top];
    for (let i2 = 0; i2 < outerDeco.length; i2++) {
      let attrs = outerDeco[i2].type.attrs;
      if (!attrs)
        continue;
      if (attrs.nodeName)
        result.push(top = new OuterDecoLevel(attrs.nodeName));
      for (let name in attrs) {
        let val = attrs[name];
        if (val == null)
          continue;
        if (needsWrap && result.length == 1)
          result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));
        if (name == "class")
          top.class = (top.class ? top.class + " " : "") + val;
        else if (name == "style")
          top.style = (top.style ? top.style + ";" : "") + val;
        else if (name != "nodeName")
          top[name] = val;
      }
    }
    return result;
  }
  function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
    if (prevComputed == noDeco && curComputed == noDeco)
      return nodeDOM;
    let curDOM = nodeDOM;
    for (let i2 = 0; i2 < curComputed.length; i2++) {
      let deco = curComputed[i2], prev = prevComputed[i2];
      if (i2) {
        let parent;
        if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
          curDOM = parent;
        } else {
          parent = document.createElement(deco.nodeName);
          parent.pmIsDeco = true;
          parent.appendChild(curDOM);
          prev = noDeco[0];
          curDOM = parent;
        }
      }
      patchAttributes(curDOM, prev || noDeco[0], deco);
    }
    return curDOM;
  }
  function patchAttributes(dom, prev, cur) {
    for (let name in prev)
      if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
        dom.removeAttribute(name);
    for (let name in cur)
      if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
        dom.setAttribute(name, cur[name]);
    if (prev.class != cur.class) {
      let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
      let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
      for (let i2 = 0; i2 < prevList.length; i2++)
        if (curList.indexOf(prevList[i2]) == -1)
          dom.classList.remove(prevList[i2]);
      for (let i2 = 0; i2 < curList.length; i2++)
        if (prevList.indexOf(curList[i2]) == -1)
          dom.classList.add(curList[i2]);
      if (dom.classList.length == 0)
        dom.removeAttribute("class");
    }
    if (prev.style != cur.style) {
      if (prev.style) {
        let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
        while (m = prop.exec(prev.style))
          dom.style.removeProperty(m[1]);
      }
      if (cur.style)
        dom.style.cssText += cur.style;
    }
  }
  function applyOuterDeco(dom, deco, node) {
    return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
  }
  function sameOuterDeco(a, b2) {
    if (a.length != b2.length)
      return false;
    for (let i2 = 0; i2 < a.length; i2++)
      if (!a[i2].type.eq(b2[i2].type))
        return false;
    return true;
  }
  function rm(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
  }
  class ViewTreeUpdater {
    constructor(top, lock, view) {
      this.lock = lock;
      this.view = view;
      this.index = 0;
      this.stack = [];
      this.changed = false;
      this.top = top;
      this.preMatch = preMatch(top.node.content, top);
    }
    // Destroy and remove the children between the given indices in
    // `this.top`.
    destroyBetween(start, end) {
      if (start == end)
        return;
      for (let i2 = start; i2 < end; i2++)
        this.top.children[i2].destroy();
      this.top.children.splice(start, end - start);
      this.changed = true;
    }
    // Destroy all remaining children in `this.top`.
    destroyRest() {
      this.destroyBetween(this.index, this.top.children.length);
    }
    // Sync the current stack of mark descs with the given array of
    // marks, reusing existing mark descs when possible.
    syncToMarks(marks2, inline, view) {
      let keep = 0, depth = this.stack.length >> 1;
      let maxKeep = Math.min(depth, marks2.length);
      while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks2[keep]) && marks2[keep].type.spec.spanning !== false)
        keep++;
      while (keep < depth) {
        this.destroyRest();
        this.top.dirty = NOT_DIRTY;
        this.index = this.stack.pop();
        this.top = this.stack.pop();
        depth--;
      }
      while (depth < marks2.length) {
        this.stack.push(this.top, this.index + 1);
        let found2 = -1;
        for (let i2 = this.index; i2 < Math.min(this.index + 3, this.top.children.length); i2++) {
          let next = this.top.children[i2];
          if (next.matchesMark(marks2[depth]) && !this.isLocked(next.dom)) {
            found2 = i2;
            break;
          }
        }
        if (found2 > -1) {
          if (found2 > this.index) {
            this.changed = true;
            this.destroyBetween(this.index, found2);
          }
          this.top = this.top.children[this.index];
        } else {
          let markDesc = MarkViewDesc.create(this.top, marks2[depth], inline, view);
          this.top.children.splice(this.index, 0, markDesc);
          this.top = markDesc;
          this.changed = true;
        }
        this.index = 0;
        depth++;
      }
    }
    // Try to find a node desc matching the given data. Skip over it and
    // return true when successful.
    findNodeMatch(node, outerDeco, innerDeco, index) {
      let found2 = -1, targetDesc;
      if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
        found2 = this.top.children.indexOf(targetDesc, this.index);
      } else {
        for (let i2 = this.index, e = Math.min(this.top.children.length, i2 + 5); i2 < e; i2++) {
          let child = this.top.children[i2];
          if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
            found2 = i2;
            break;
          }
        }
      }
      if (found2 < 0)
        return false;
      this.destroyBetween(this.index, found2);
      this.index++;
      return true;
    }
    updateNodeAt(node, outerDeco, innerDeco, index, view) {
      let child = this.top.children[index];
      if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
        child.dirty = CONTENT_DIRTY;
      if (!child.update(node, outerDeco, innerDeco, view))
        return false;
      this.destroyBetween(this.index, index);
      this.index++;
      return true;
    }
    findIndexWithChild(domNode) {
      for (; ; ) {
        let parent = domNode.parentNode;
        if (!parent)
          return -1;
        if (parent == this.top.contentDOM) {
          let desc = domNode.pmViewDesc;
          if (desc)
            for (let i2 = this.index; i2 < this.top.children.length; i2++) {
              if (this.top.children[i2] == desc)
                return i2;
            }
          return -1;
        }
        domNode = parent;
      }
    }
    // Try to update the next node, if any, to the given data. Checks
    // pre-matches to avoid overwriting nodes that could still be used.
    updateNextNode(node, outerDeco, innerDeco, view, index, pos) {
      for (let i2 = this.index; i2 < this.top.children.length; i2++) {
        let next = this.top.children[i2];
        if (next instanceof NodeViewDesc) {
          let preMatch2 = this.preMatch.matched.get(next);
          if (preMatch2 != null && preMatch2 != index)
            return false;
          let nextDOM = next.dom, updated;
          let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
          if (!locked && next.update(node, outerDeco, innerDeco, view)) {
            this.destroyBetween(this.index, i2);
            if (next.dom != nextDOM)
              this.changed = true;
            this.index++;
            return true;
          } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
            this.destroyBetween(this.index, i2);
            this.top.children[this.index] = updated;
            if (updated.contentDOM) {
              updated.dirty = CONTENT_DIRTY;
              updated.updateChildren(view, pos + 1);
              updated.dirty = NOT_DIRTY;
            }
            this.changed = true;
            this.index++;
            return true;
          }
          break;
        }
      }
      return false;
    }
    // When a node with content is replaced by a different node with
    // identical content, move over its children.
    recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
      if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))
        return null;
      let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
      if (wrapper.contentDOM) {
        wrapper.children = next.children;
        next.children = [];
        for (let ch of wrapper.children)
          ch.parent = wrapper;
      }
      next.destroy();
      return wrapper;
    }
    // Insert the node as a newly created node desc.
    addNode(node, outerDeco, innerDeco, view, pos) {
      let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
      if (desc.contentDOM)
        desc.updateChildren(view, pos + 1);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
    placeWidget(widget, view, pos) {
      let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
      if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
        this.index++;
      } else {
        let desc = new WidgetViewDesc(this.top, widget, view, pos);
        this.top.children.splice(this.index++, 0, desc);
        this.changed = true;
      }
    }
    // Make sure a textblock looks and behaves correctly in
    // contentEditable.
    addTextblockHacks() {
      let lastChild = this.top.children[this.index - 1], parent = this.top;
      while (lastChild instanceof MarkViewDesc) {
        parent = lastChild;
        lastChild = parent.children[parent.children.length - 1];
      }
      if (!lastChild || // Empty textblock
      !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
        if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
          this.addHackNode("IMG", parent);
        this.addHackNode("BR", this.top);
      }
    }
    addHackNode(nodeName, parent) {
      if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
        this.index++;
      } else {
        let dom = document.createElement(nodeName);
        if (nodeName == "IMG") {
          dom.className = "ProseMirror-separator";
          dom.alt = "";
        }
        if (nodeName == "BR")
          dom.className = "ProseMirror-trailingBreak";
        let hack = new TrailingHackViewDesc(this.top, [], dom, null);
        if (parent != this.top)
          parent.children.push(hack);
        else
          parent.children.splice(this.index++, 0, hack);
        this.changed = true;
      }
    }
    isLocked(node) {
      return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
    }
  }
  function preMatch(frag, parentDesc) {
    let curDesc = parentDesc, descI = curDesc.children.length;
    let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
    outer: while (fI > 0) {
      let desc;
      for (; ; ) {
        if (descI) {
          let next = curDesc.children[descI - 1];
          if (next instanceof MarkViewDesc) {
            curDesc = next;
            descI = next.children.length;
          } else {
            desc = next;
            descI--;
            break;
          }
        } else if (curDesc == parentDesc) {
          break outer;
        } else {
          descI = curDesc.parent.children.indexOf(curDesc);
          curDesc = curDesc.parent;
        }
      }
      let node = desc.node;
      if (!node)
        continue;
      if (node != frag.child(fI - 1))
        break;
      --fI;
      matched.set(desc, fI);
      matches2.push(desc);
    }
    return { index: fI, matched, matches: matches2.reverse() };
  }
  function compareSide(a, b2) {
    return a.type.side - b2.type.side;
  }
  function iterDeco(parent, deco, onWidget, onNode) {
    let locals = deco.locals(parent), offset2 = 0;
    if (locals.length == 0) {
      for (let i2 = 0; i2 < parent.childCount; i2++) {
        let child = parent.child(i2);
        onNode(child, locals, deco.forChild(offset2, child), i2);
        offset2 += child.nodeSize;
      }
      return;
    }
    let decoIndex = 0, active = [], restNode = null;
    for (let parentIndex = 0; ; ) {
      let widget, widgets;
      while (decoIndex < locals.length && locals[decoIndex].to == offset2) {
        let next = locals[decoIndex++];
        if (next.widget) {
          if (!widget)
            widget = next;
          else
            (widgets || (widgets = [widget])).push(next);
        }
      }
      if (widget) {
        if (widgets) {
          widgets.sort(compareSide);
          for (let i2 = 0; i2 < widgets.length; i2++)
            onWidget(widgets[i2], parentIndex, !!restNode);
        } else {
          onWidget(widget, parentIndex, !!restNode);
        }
      }
      let child, index;
      if (restNode) {
        index = -1;
        child = restNode;
        restNode = null;
      } else if (parentIndex < parent.childCount) {
        index = parentIndex;
        child = parent.child(parentIndex++);
      } else {
        break;
      }
      for (let i2 = 0; i2 < active.length; i2++)
        if (active[i2].to <= offset2)
          active.splice(i2--, 1);
      while (decoIndex < locals.length && locals[decoIndex].from <= offset2 && locals[decoIndex].to > offset2)
        active.push(locals[decoIndex++]);
      let end = offset2 + child.nodeSize;
      if (child.isText) {
        let cutAt = end;
        if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
          cutAt = locals[decoIndex].from;
        for (let i2 = 0; i2 < active.length; i2++)
          if (active[i2].to < cutAt)
            cutAt = active[i2].to;
        if (cutAt < end) {
          restNode = child.cut(cutAt - offset2);
          child = child.cut(0, cutAt - offset2);
          end = cutAt;
          index = -1;
        }
      } else {
        while (decoIndex < locals.length && locals[decoIndex].to < end)
          decoIndex++;
      }
      let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
      onNode(child, outerDeco, deco.forChild(offset2, child), index);
      offset2 = end;
    }
  }
  function iosHacks(dom) {
    if (dom.nodeName == "UL" || dom.nodeName == "OL") {
      let oldCSS = dom.style.cssText;
      dom.style.cssText = oldCSS + "; list-style: square !important";
      window.getComputedStyle(dom).listStyle;
      dom.style.cssText = oldCSS;
    }
  }
  function findTextInFragment(frag, text2, from, to) {
    for (let i2 = 0, pos = 0; i2 < frag.childCount && pos <= to; ) {
      let child = frag.child(i2++), childStart = pos;
      pos += child.nodeSize;
      if (!child.isText)
        continue;
      let str = child.text;
      while (i2 < frag.childCount) {
        let next = frag.child(i2++);
        pos += next.nodeSize;
        if (!next.isText)
          break;
        str += next.text;
      }
      if (pos >= from) {
        if (pos >= to && str.slice(to - text2.length - childStart, to - childStart) == text2)
          return to - text2.length;
        let found2 = childStart < to ? str.lastIndexOf(text2, to - childStart - 1) : -1;
        if (found2 >= 0 && found2 + text2.length + childStart >= from)
          return childStart + found2;
        if (from == to && str.length >= to + text2.length - childStart && str.slice(to - childStart, to - childStart + text2.length) == text2)
          return to;
      }
    }
    return -1;
  }
  function replaceNodes(nodes2, from, to, view, replacement) {
    let result = [];
    for (let i2 = 0, off = 0; i2 < nodes2.length; i2++) {
      let child = nodes2[i2], start = off, end = off += child.size;
      if (start >= to || end <= from) {
        result.push(child);
      } else {
        if (start < from)
          result.push(child.slice(0, from - start, view));
        if (replacement) {
          result.push(replacement);
          replacement = void 0;
        }
        if (end > to)
          result.push(child.slice(to - start, child.size, view));
      }
    }
    return result;
  }
  function selectionFromDOM(view, origin2 = null) {
    let domSel = view.domSelectionRange(), doc2 = view.state.doc;
    if (!domSel.focusNode)
      return null;
    let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
    let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
    if (head < 0)
      return null;
    let $head = doc2.resolve(head), anchor, selection;
    if (selectionCollapsed(domSel)) {
      anchor = head;
      while (nearestDesc && !nearestDesc.node)
        nearestDesc = nearestDesc.parent;
      let nearestDescNode = nearestDesc.node;
      if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
        let pos = nearestDesc.posBefore;
        selection = new NodeSelection(head == pos ? $head : doc2.resolve(pos));
      }
    } else {
      if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {
        let min2 = head, max2 = head;
        for (let i2 = 0; i2 < domSel.rangeCount; i2++) {
          let range = domSel.getRangeAt(i2);
          min2 = Math.min(min2, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));
          max2 = Math.max(max2, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));
        }
        if (min2 < 0)
          return null;
        [anchor, head] = max2 == view.state.selection.anchor ? [max2, min2] : [min2, max2];
        $head = doc2.resolve(head);
      } else {
        anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
      }
      if (anchor < 0)
        return null;
    }
    let $anchor = doc2.resolve(anchor);
    if (!selection) {
      let bias = origin2 == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
      selection = selectionBetween(view, $anchor, $head, bias);
    }
    return selection;
  }
  function editorOwnsSelection(view) {
    return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
  }
  function selectionToDOM(view, force = false) {
    let sel = view.state.selection;
    syncNodeSelection(view, sel);
    if (!editorOwnsSelection(view))
      return;
    if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
      let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
      if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
        view.input.mouseDown.delayedSelectionSync = true;
        view.domObserver.setCurSelection();
        return;
      }
    }
    view.domObserver.disconnectSelection();
    if (view.cursorWrapper) {
      selectCursorWrapper(view);
    } else {
      let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
      if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
        if (!sel.$from.parent.inlineContent)
          resetEditableFrom = temporarilyEditableNear(view, sel.from);
        if (!sel.empty && !sel.$from.parent.inlineContent)
          resetEditableTo = temporarilyEditableNear(view, sel.to);
      }
      view.docView.setSelection(anchor, head, view, force);
      if (brokenSelectBetweenUneditable) {
        if (resetEditableFrom)
          resetEditable(resetEditableFrom);
        if (resetEditableTo)
          resetEditable(resetEditableTo);
      }
      if (sel.visible) {
        view.dom.classList.remove("ProseMirror-hideselection");
      } else {
        view.dom.classList.add("ProseMirror-hideselection");
        if ("onselectionchange" in document)
          removeClassOnSelectionChange(view);
      }
    }
    view.domObserver.setCurSelection();
    view.domObserver.connectSelection();
  }
  const brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
  function temporarilyEditableNear(view, pos) {
    let { node, offset: offset2 } = view.docView.domFromPos(pos, 0);
    let after = offset2 < node.childNodes.length ? node.childNodes[offset2] : null;
    let before = offset2 ? node.childNodes[offset2 - 1] : null;
    if (safari && after && after.contentEditable == "false")
      return setEditable(after);
    if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
      if (after)
        return setEditable(after);
      else if (before)
        return setEditable(before);
    }
  }
  function setEditable(element) {
    element.contentEditable = "true";
    if (safari && element.draggable) {
      element.draggable = false;
      element.wasDraggable = true;
    }
    return element;
  }
  function resetEditable(element) {
    element.contentEditable = "false";
    if (element.wasDraggable) {
      element.draggable = true;
      element.wasDraggable = null;
    }
  }
  function removeClassOnSelectionChange(view) {
    let doc2 = view.dom.ownerDocument;
    doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
    let domSel = view.domSelectionRange();
    let node = domSel.anchorNode, offset2 = domSel.anchorOffset;
    doc2.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
      if (domSel.anchorNode != node || domSel.anchorOffset != offset2) {
        doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
        setTimeout(() => {
          if (!editorOwnsSelection(view) || view.state.selection.visible)
            view.dom.classList.remove("ProseMirror-hideselection");
        }, 20);
      }
    });
  }
  function selectCursorWrapper(view) {
    let domSel = view.domSelection(), range = document.createRange();
    if (!domSel)
      return;
    let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
    if (img)
      range.setStart(node.parentNode, domIndex(node) + 1);
    else
      range.setStart(node, 0);
    range.collapse(true);
    domSel.removeAllRanges();
    domSel.addRange(range);
    if (!img && !view.state.selection.visible && ie$1 && ie_version <= 11) {
      node.disabled = true;
      node.disabled = false;
    }
  }
  function syncNodeSelection(view, sel) {
    if (sel instanceof NodeSelection) {
      let desc = view.docView.descAt(sel.from);
      if (desc != view.lastSelectedViewDesc) {
        clearNodeSelection(view);
        if (desc)
          desc.selectNode();
        view.lastSelectedViewDesc = desc;
      }
    } else {
      clearNodeSelection(view);
    }
  }
  function clearNodeSelection(view) {
    if (view.lastSelectedViewDesc) {
      if (view.lastSelectedViewDesc.parent)
        view.lastSelectedViewDesc.deselectNode();
      view.lastSelectedViewDesc = void 0;
    }
  }
  function selectionBetween(view, $anchor, $head, bias) {
    return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
  }
  function hasFocusAndSelection(view) {
    if (view.editable && !view.hasFocus())
      return false;
    return hasSelection(view);
  }
  function hasSelection(view) {
    let sel = view.domSelectionRange();
    if (!sel.anchorNode)
      return false;
    try {
      return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
    } catch (_2) {
      return false;
    }
  }
  function anchorInRightPlace(view) {
    let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
    let domSel = view.domSelectionRange();
    return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
  }
  function moveSelectionBlock(state, dir) {
    let { $anchor, $head } = state.selection;
    let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
    let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
    return $start && Selection.findFrom($start, dir);
  }
  function apply(view, sel) {
    view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
    return true;
  }
  function selectHorizontally(view, dir, mods) {
    let sel = view.state.selection;
    if (sel instanceof TextSelection) {
      if (mods.indexOf("s") > -1) {
        let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
        if (!node || node.isText || !node.isLeaf)
          return false;
        let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
        return apply(view, new TextSelection(sel.$anchor, $newHead));
      } else if (!sel.empty) {
        return false;
      } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
        let next = moveSelectionBlock(view.state, dir);
        if (next && next instanceof NodeSelection)
          return apply(view, next);
        return false;
      } else if (!(mac$3 && mods.indexOf("m") > -1)) {
        let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
        if (!node || node.isText)
          return false;
        let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
        if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
          return false;
        if (NodeSelection.isSelectable(node)) {
          return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
        } else if (webkit) {
          return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
        } else {
          return false;
        }
      }
    } else if (sel instanceof NodeSelection && sel.node.isInline) {
      return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
    } else {
      let next = moveSelectionBlock(view.state, dir);
      if (next)
        return apply(view, next);
      return false;
    }
  }
  function nodeLen(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  function isIgnorable(dom, dir) {
    let desc = dom.pmViewDesc;
    return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
  }
  function skipIgnoredNodes(view, dir) {
    return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
  }
  function skipIgnoredNodesBefore(view) {
    let sel = view.domSelectionRange();
    let node = sel.focusNode, offset2 = sel.focusOffset;
    if (!node)
      return;
    let moveNode, moveOffset, force = false;
    if (gecko && node.nodeType == 1 && offset2 < nodeLen(node) && isIgnorable(node.childNodes[offset2], -1))
      force = true;
    for (; ; ) {
      if (offset2 > 0) {
        if (node.nodeType != 1) {
          break;
        } else {
          let before = node.childNodes[offset2 - 1];
          if (isIgnorable(before, -1)) {
            moveNode = node;
            moveOffset = --offset2;
          } else if (before.nodeType == 3) {
            node = before;
            offset2 = node.nodeValue.length;
          } else
            break;
        }
      } else if (isBlockNode(node)) {
        break;
      } else {
        let prev = node.previousSibling;
        while (prev && isIgnorable(prev, -1)) {
          moveNode = node.parentNode;
          moveOffset = domIndex(prev);
          prev = prev.previousSibling;
        }
        if (!prev) {
          node = node.parentNode;
          if (node == view.dom)
            break;
          offset2 = 0;
        } else {
          node = prev;
          offset2 = nodeLen(node);
        }
      }
    }
    if (force)
      setSelFocus(view, node, offset2);
    else if (moveNode)
      setSelFocus(view, moveNode, moveOffset);
  }
  function skipIgnoredNodesAfter(view) {
    let sel = view.domSelectionRange();
    let node = sel.focusNode, offset2 = sel.focusOffset;
    if (!node)
      return;
    let len = nodeLen(node);
    let moveNode, moveOffset;
    for (; ; ) {
      if (offset2 < len) {
        if (node.nodeType != 1)
          break;
        let after = node.childNodes[offset2];
        if (isIgnorable(after, 1)) {
          moveNode = node;
          moveOffset = ++offset2;
        } else
          break;
      } else if (isBlockNode(node)) {
        break;
      } else {
        let next = node.nextSibling;
        while (next && isIgnorable(next, 1)) {
          moveNode = next.parentNode;
          moveOffset = domIndex(next) + 1;
          next = next.nextSibling;
        }
        if (!next) {
          node = node.parentNode;
          if (node == view.dom)
            break;
          offset2 = len = 0;
        } else {
          node = next;
          offset2 = 0;
          len = nodeLen(node);
        }
      }
    }
    if (moveNode)
      setSelFocus(view, moveNode, moveOffset);
  }
  function isBlockNode(dom) {
    let desc = dom.pmViewDesc;
    return desc && desc.node && desc.node.isBlock;
  }
  function textNodeAfter(node, offset2) {
    while (node && offset2 == node.childNodes.length && !hasBlockDesc(node)) {
      offset2 = domIndex(node) + 1;
      node = node.parentNode;
    }
    while (node && offset2 < node.childNodes.length) {
      let next = node.childNodes[offset2];
      if (next.nodeType == 3)
        return next;
      if (next.nodeType == 1 && next.contentEditable == "false")
        break;
      node = next;
      offset2 = 0;
    }
  }
  function textNodeBefore(node, offset2) {
    while (node && !offset2 && !hasBlockDesc(node)) {
      offset2 = domIndex(node);
      node = node.parentNode;
    }
    while (node && offset2) {
      let next = node.childNodes[offset2 - 1];
      if (next.nodeType == 3)
        return next;
      if (next.nodeType == 1 && next.contentEditable == "false")
        break;
      node = next;
      offset2 = node.childNodes.length;
    }
  }
  function setSelFocus(view, node, offset2) {
    if (node.nodeType != 3) {
      let before, after;
      if (after = textNodeAfter(node, offset2)) {
        node = after;
        offset2 = 0;
      } else if (before = textNodeBefore(node, offset2)) {
        node = before;
        offset2 = before.nodeValue.length;
      }
    }
    let sel = view.domSelection();
    if (!sel)
      return;
    if (selectionCollapsed(sel)) {
      let range = document.createRange();
      range.setEnd(node, offset2);
      range.setStart(node, offset2);
      sel.removeAllRanges();
      sel.addRange(range);
    } else if (sel.extend) {
      sel.extend(node, offset2);
    }
    view.domObserver.setCurSelection();
    let { state } = view;
    setTimeout(() => {
      if (view.state == state)
        selectionToDOM(view);
    }, 50);
  }
  function findDirection(view, pos) {
    let $pos = view.state.doc.resolve(pos);
    if (!(chrome || windows$1) && $pos.parent.inlineContent) {
      let coords = view.coordsAtPos(pos);
      if (pos > $pos.start()) {
        let before = view.coordsAtPos(pos - 1);
        let mid = (before.top + before.bottom) / 2;
        if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
          return before.left < coords.left ? "ltr" : "rtl";
      }
      if (pos < $pos.end()) {
        let after = view.coordsAtPos(pos + 1);
        let mid = (after.top + after.bottom) / 2;
        if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
          return after.left > coords.left ? "ltr" : "rtl";
      }
    }
    let computed = getComputedStyle(view.dom).direction;
    return computed == "rtl" ? "rtl" : "ltr";
  }
  function selectVertically(view, dir, mods) {
    let sel = view.state.selection;
    if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
      return false;
    if (mac$3 && mods.indexOf("m") > -1)
      return false;
    let { $from, $to } = sel;
    if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
    }
    if (!$from.parent.inlineContent) {
      let side = dir < 0 ? $from : $to;
      let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
      return beyond ? apply(view, beyond) : false;
    }
    return false;
  }
  function stopNativeHorizontalDelete(view, dir) {
    if (!(view.state.selection instanceof TextSelection))
      return true;
    let { $head, $anchor, empty: empty2 } = view.state.selection;
    if (!$head.sameParent($anchor))
      return true;
    if (!empty2)
      return false;
    if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
      return true;
    let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
    if (nextNode && !nextNode.isText) {
      let tr = view.state.tr;
      if (dir < 0)
        tr.delete($head.pos - nextNode.nodeSize, $head.pos);
      else
        tr.delete($head.pos, $head.pos + nextNode.nodeSize);
      view.dispatch(tr);
      return true;
    }
    return false;
  }
  function switchEditable(view, node, state) {
    view.domObserver.stop();
    node.contentEditable = state;
    view.domObserver.start();
  }
  function safariDownArrowBug(view) {
    if (!safari || view.state.selection.$head.parentOffset > 0)
      return false;
    let { focusNode, focusOffset } = view.domSelectionRange();
    if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
      let child = focusNode.firstChild;
      switchEditable(view, child, "true");
      setTimeout(() => switchEditable(view, child, "false"), 20);
    }
    return false;
  }
  function getMods(event) {
    let result = "";
    if (event.ctrlKey)
      result += "c";
    if (event.metaKey)
      result += "m";
    if (event.altKey)
      result += "a";
    if (event.shiftKey)
      result += "s";
    return result;
  }
  function captureKeyDown(view, event) {
    let code2 = event.keyCode, mods = getMods(event);
    if (code2 == 8 || mac$3 && code2 == 72 && mods == "c") {
      return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
    } else if (code2 == 46 && !event.shiftKey || mac$3 && code2 == 68 && mods == "c") {
      return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
    } else if (code2 == 13 || code2 == 27) {
      return true;
    } else if (code2 == 37 || mac$3 && code2 == 66 && mods == "c") {
      let dir = code2 == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
      return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
    } else if (code2 == 39 || mac$3 && code2 == 70 && mods == "c") {
      let dir = code2 == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
      return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
    } else if (code2 == 38 || mac$3 && code2 == 80 && mods == "c") {
      return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
    } else if (code2 == 40 || mac$3 && code2 == 78 && mods == "c") {
      return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
    } else if (mods == (mac$3 ? "m" : "c") && (code2 == 66 || code2 == 73 || code2 == 89 || code2 == 90)) {
      return true;
    }
    return false;
  }
  function serializeForClipboard(view, slice) {
    view.someProp("transformCopied", (f) => {
      slice = f(slice, view);
    });
    let context = [], { content, openStart, openEnd } = slice;
    while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
      openStart--;
      openEnd--;
      let node = content.firstChild;
      context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
      content = node.content;
    }
    let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
    let doc2 = detachedDoc(), wrap2 = doc2.createElement("div");
    wrap2.appendChild(serializer.serializeFragment(content, { document: doc2 }));
    let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
    while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
      for (let i2 = needsWrap.length - 1; i2 >= 0; i2--) {
        let wrapper = doc2.createElement(needsWrap[i2]);
        while (wrap2.firstChild)
          wrapper.appendChild(wrap2.firstChild);
        wrap2.appendChild(wrapper);
        wrappers++;
      }
      firstChild = wrap2.firstChild;
    }
    if (firstChild && firstChild.nodeType == 1)
      firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
    let text2 = view.someProp("clipboardTextSerializer", (f) => f(slice, view)) || slice.content.textBetween(0, slice.content.size, "\n\n");
    return { dom: wrap2, text: text2, slice };
  }
  function parseFromClipboard(view, text2, html2, plainText, $context) {
    let inCode = $context.parent.type.spec.code;
    let dom, slice;
    if (!html2 && !text2)
      return null;
    let asText = text2 && (plainText || inCode || !html2);
    if (asText) {
      view.someProp("transformPastedText", (f) => {
        text2 = f(text2, inCode || plainText, view);
      });
      if (inCode)
        return text2 ? new Slice(Fragment.from(view.state.schema.text(text2.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
      let parsed = view.someProp("clipboardTextParser", (f) => f(text2, $context, plainText, view));
      if (parsed) {
        slice = parsed;
      } else {
        let marks2 = $context.marks();
        let { schema: schema2 } = view.state, serializer = DOMSerializer.fromSchema(schema2);
        dom = document.createElement("div");
        text2.split(/(?:\r\n?|\n)+/).forEach((block) => {
          let p = dom.appendChild(document.createElement("p"));
          if (block)
            p.appendChild(serializer.serializeNode(schema2.text(block, marks2)));
        });
      }
    } else {
      view.someProp("transformPastedHTML", (f) => {
        html2 = f(html2, view);
      });
      dom = readHTML(html2);
      if (webkit)
        restoreReplacedSpaces(dom);
    }
    let contextNode = dom && dom.querySelector("[data-pm-slice]");
    let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
    if (sliceData && sliceData[3])
      for (let i2 = +sliceData[3]; i2 > 0; i2--) {
        let child = dom.firstChild;
        while (child && child.nodeType != 1)
          child = child.nextSibling;
        if (!child)
          break;
        dom = child;
      }
    if (!slice) {
      let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser$1.fromSchema(view.state.schema);
      slice = parser.parseSlice(dom, {
        preserveWhitespace: !!(asText || sliceData),
        context: $context,
        ruleFromNode(dom2) {
          if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
            return { ignore: true };
          return null;
        }
      });
    }
    if (sliceData) {
      slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);
    } else {
      slice = Slice.maxOpen(normalizeSiblings(slice.content, $context), true);
      if (slice.openStart || slice.openEnd) {
        let openStart = 0, openEnd = 0;
        for (let node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
        }
        for (let node = slice.content.lastChild; openEnd < slice.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
        }
        slice = closeSlice(slice, openStart, openEnd);
      }
    }
    view.someProp("transformPasted", (f) => {
      slice = f(slice, view);
    });
    return slice;
  }
  const inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
  function normalizeSiblings(fragment, $context) {
    if (fragment.childCount < 2)
      return fragment;
    for (let d = $context.depth; d >= 0; d--) {
      let parent = $context.node(d);
      let match = parent.contentMatchAt($context.index(d));
      let lastWrap, result = [];
      fragment.forEach((node) => {
        if (!result)
          return;
        let wrap2 = match.findWrapping(node.type), inLast;
        if (!wrap2)
          return result = null;
        if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {
          result[result.length - 1] = inLast;
        } else {
          if (result.length)
            result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
          let wrapped = withWrappers(node, wrap2);
          result.push(wrapped);
          match = match.matchType(wrapped.type);
          lastWrap = wrap2;
        }
      });
      if (result)
        return Fragment.from(result);
    }
    return fragment;
  }
  function withWrappers(node, wrap2, from = 0) {
    for (let i2 = wrap2.length - 1; i2 >= from; i2--)
      node = wrap2[i2].create(null, Fragment.from(node));
    return node;
  }
  function addToSibling(wrap2, lastWrap, node, sibling, depth) {
    if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
      let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
      if (inner)
        return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
      let match = sibling.contentMatchAt(sibling.childCount);
      if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))
        return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));
    }
  }
  function closeRight(node, depth) {
    if (depth == 0)
      return node;
    let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
    let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
    return node.copy(fragment.append(fill));
  }
  function closeRange(fragment, side, from, to, depth, openEnd) {
    let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
    if (fragment.childCount > 1)
      openEnd = 0;
    if (depth < to - 1)
      inner = closeRange(inner, side, from, to, depth + 1, openEnd);
    if (depth >= from)
      inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
    return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
  }
  function closeSlice(slice, openStart, openEnd) {
    if (openStart < slice.openStart)
      slice = new Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);
    if (openEnd < slice.openEnd)
      slice = new Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);
    return slice;
  }
  const wrapMap = {
    thead: ["table"],
    tbody: ["table"],
    tfoot: ["table"],
    caption: ["table"],
    colgroup: ["table"],
    col: ["table", "colgroup"],
    tr: ["table", "tbody"],
    td: ["table", "tbody", "tr"],
    th: ["table", "tbody", "tr"]
  };
  let _detachedDoc = null;
  function detachedDoc() {
    return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
  }
  let _policy = null;
  function maybeWrapTrusted(html2) {
    let trustedTypes = window.trustedTypes;
    if (!trustedTypes)
      return html2;
    if (!_policy)
      _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy("ProseMirrorClipboard", { createHTML: (s) => s });
    return _policy.createHTML(html2);
  }
  function readHTML(html2) {
    let metas = /^(\s*<meta [^>]*>)*/.exec(html2);
    if (metas)
      html2 = html2.slice(metas[0].length);
    let elt = detachedDoc().createElement("div");
    let firstTag = /<([a-z][^>\s]+)/i.exec(html2), wrap2;
    if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
      html2 = wrap2.map((n) => "<" + n + ">").join("") + html2 + wrap2.map((n) => "</" + n + ">").reverse().join("");
    elt.innerHTML = maybeWrapTrusted(html2);
    if (wrap2)
      for (let i2 = 0; i2 < wrap2.length; i2++)
        elt = elt.querySelector(wrap2[i2]) || elt;
    return elt;
  }
  function restoreReplacedSpaces(dom) {
    let nodes2 = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
    for (let i2 = 0; i2 < nodes2.length; i2++) {
      let node = nodes2[i2];
      if (node.childNodes.length == 1 && node.textContent == "" && node.parentNode)
        node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
    }
  }
  function addContext(slice, context) {
    if (!slice.size)
      return slice;
    let schema2 = slice.content.firstChild.type.schema, array;
    try {
      array = JSON.parse(context);
    } catch (e) {
      return slice;
    }
    let { content, openStart, openEnd } = slice;
    for (let i2 = array.length - 2; i2 >= 0; i2 -= 2) {
      let type = schema2.nodes[array[i2]];
      if (!type || type.hasRequiredAttrs())
        break;
      content = Fragment.from(type.create(array[i2 + 1], content));
      openStart++;
      openEnd++;
    }
    return new Slice(content, openStart, openEnd);
  }
  const handlers = {};
  const editHandlers = {};
  const passiveHandlers = { touchstart: true, touchmove: true };
  class InputState {
    constructor() {
      this.shiftKey = false;
      this.mouseDown = null;
      this.lastKeyCode = null;
      this.lastKeyCodeTime = 0;
      this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 };
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastIOSEnter = 0;
      this.lastIOSEnterFallbackTimeout = -1;
      this.lastFocus = 0;
      this.lastTouch = 0;
      this.lastChromeDelete = 0;
      this.composing = false;
      this.compositionNode = null;
      this.composingTimeout = -1;
      this.compositionNodes = [];
      this.compositionEndedAt = -2e8;
      this.compositionID = 1;
      this.compositionPendingChanges = 0;
      this.domChangeCount = 0;
      this.eventHandlers = /* @__PURE__ */ Object.create(null);
      this.hideSelectionGuard = null;
    }
  }
  function initInput(view) {
    for (let event in handlers) {
      let handler = handlers[event];
      view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
        if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
          handler(view, event2);
      }, passiveHandlers[event] ? { passive: true } : void 0);
    }
    if (safari)
      view.dom.addEventListener("input", () => null);
    ensureListeners(view);
  }
  function setSelectionOrigin(view, origin2) {
    view.input.lastSelectionOrigin = origin2;
    view.input.lastSelectionTime = Date.now();
  }
  function destroyInput(view) {
    view.domObserver.stop();
    for (let type in view.input.eventHandlers)
      view.dom.removeEventListener(type, view.input.eventHandlers[type]);
    clearTimeout(view.input.composingTimeout);
    clearTimeout(view.input.lastIOSEnterFallbackTimeout);
  }
  function ensureListeners(view) {
    view.someProp("handleDOMEvents", (currentHandlers) => {
      for (let type in currentHandlers)
        if (!view.input.eventHandlers[type])
          view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
    });
  }
  function runCustomHandler(view, event) {
    return view.someProp("handleDOMEvents", (handlers2) => {
      let handler = handlers2[event.type];
      return handler ? handler(view, event) || event.defaultPrevented : false;
    });
  }
  function eventBelongsToView(view, event) {
    if (!event.bubbles)
      return true;
    if (event.defaultPrevented)
      return false;
    for (let node = event.target; node != view.dom; node = node.parentNode)
      if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
        return false;
    return true;
  }
  function dispatchEvent(view, event) {
    if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
      handlers[event.type](view, event);
  }
  editHandlers.keydown = (view, _event) => {
    let event = _event;
    view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
    if (inOrNearComposition(view, event))
      return;
    view.input.lastKeyCode = event.keyCode;
    view.input.lastKeyCodeTime = Date.now();
    if (android && chrome && event.keyCode == 13)
      return;
    if (event.keyCode != 229)
      view.domObserver.forceFlush();
    if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
      let now = Date.now();
      view.input.lastIOSEnter = now;
      view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        if (view.input.lastIOSEnter == now) {
          view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
          view.input.lastIOSEnter = 0;
        }
      }, 200);
    } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
      event.preventDefault();
    } else {
      setSelectionOrigin(view, "key");
    }
  };
  editHandlers.keyup = (view, event) => {
    if (event.keyCode == 16)
      view.input.shiftKey = false;
  };
  editHandlers.keypress = (view, _event) => {
    let event = _event;
    if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac$3 && event.metaKey)
      return;
    if (view.someProp("handleKeyPress", (f) => f(view, event))) {
      event.preventDefault();
      return;
    }
    let sel = view.state.selection;
    if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
      let text2 = String.fromCharCode(event.charCode);
      let deflt = () => view.state.tr.insertText(text2).scrollIntoView();
      if (!/[\r\n]/.test(text2) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text2, deflt)))
        view.dispatch(deflt());
      event.preventDefault();
    }
  };
  function eventCoords(event) {
    return { left: event.clientX, top: event.clientY };
  }
  function isNear(event, click) {
    let dx = click.x - event.clientX, dy = click.y - event.clientY;
    return dx * dx + dy * dy < 100;
  }
  function runHandlerOnContext(view, propName, pos, inside, event) {
    if (inside == -1)
      return false;
    let $pos = view.state.doc.resolve(inside);
    for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
      if (view.someProp(propName, (f) => i2 > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i2), event, true) : f(view, pos, $pos.node(i2), $pos.before(i2), event, false)))
        return true;
    }
    return false;
  }
  function updateSelection(view, selection, origin2) {
    if (!view.focused)
      view.focus();
    if (view.state.selection.eq(selection))
      return;
    let tr = view.state.tr.setSelection(selection);
    tr.setMeta("pointer", true);
    view.dispatch(tr);
  }
  function selectClickedLeaf(view, inside) {
    if (inside == -1)
      return false;
    let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
    if (node && node.isAtom && NodeSelection.isSelectable(node)) {
      updateSelection(view, new NodeSelection($pos));
      return true;
    }
    return false;
  }
  function selectClickedNode(view, inside) {
    if (inside == -1)
      return false;
    let sel = view.state.selection, selectedNode, selectAt;
    if (sel instanceof NodeSelection)
      selectedNode = sel.node;
    let $pos = view.state.doc.resolve(inside);
    for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
      let node = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
      if (NodeSelection.isSelectable(node)) {
        if (selectedNode && sel.$from.depth > 0 && i2 >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
          selectAt = $pos.before(sel.$from.depth);
        else
          selectAt = $pos.before(i2);
        break;
      }
    }
    if (selectAt != null) {
      updateSelection(view, NodeSelection.create(view.state.doc, selectAt));
      return true;
    } else {
      return false;
    }
  }
  function handleSingleClick(view, pos, inside, event, selectNode) {
    return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
  }
  function handleDoubleClick(view, pos, inside, event) {
    return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
  }
  function handleTripleClick(view, pos, inside, event) {
    return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
  }
  function defaultTripleClick(view, inside, event) {
    if (event.button != 0)
      return false;
    let doc2 = view.state.doc;
    if (inside == -1) {
      if (doc2.inlineContent) {
        updateSelection(view, TextSelection.create(doc2, 0, doc2.content.size));
        return true;
      }
      return false;
    }
    let $pos = doc2.resolve(inside);
    for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
      let node = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
      let nodePos = $pos.before(i2);
      if (node.inlineContent)
        updateSelection(view, TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node.content.size));
      else if (NodeSelection.isSelectable(node))
        updateSelection(view, NodeSelection.create(doc2, nodePos));
      else
        continue;
      return true;
    }
  }
  function forceDOMFlush(view) {
    return endComposition(view);
  }
  const selectNodeModifier = mac$3 ? "metaKey" : "ctrlKey";
  handlers.mousedown = (view, _event) => {
    let event = _event;
    view.input.shiftKey = event.shiftKey;
    let flushed = forceDOMFlush(view);
    let now = Date.now(), type = "singleClick";
    if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier] && view.input.lastClick.button == event.button) {
      if (view.input.lastClick.type == "singleClick")
        type = "doubleClick";
      else if (view.input.lastClick.type == "doubleClick")
        type = "tripleClick";
    }
    view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type, button: event.button };
    let pos = view.posAtCoords(eventCoords(event));
    if (!pos)
      return;
    if (type == "singleClick") {
      if (view.input.mouseDown)
        view.input.mouseDown.done();
      view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
    } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
      event.preventDefault();
    } else {
      setSelectionOrigin(view, "pointer");
    }
  };
  class MouseDown {
    constructor(view, pos, event, flushed) {
      this.view = view;
      this.pos = pos;
      this.event = event;
      this.flushed = flushed;
      this.delayedSelectionSync = false;
      this.mightDrag = null;
      this.startDoc = view.state.doc;
      this.selectNode = !!event[selectNodeModifier];
      this.allowDefault = event.shiftKey;
      let targetNode, targetPos;
      if (pos.inside > -1) {
        targetNode = view.state.doc.nodeAt(pos.inside);
        targetPos = pos.inside;
      } else {
        let $pos = view.state.doc.resolve(pos.pos);
        targetNode = $pos.parent;
        targetPos = $pos.depth ? $pos.before() : 0;
      }
      const target = flushed ? null : event.target;
      const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
      this.target = targetDesc && targetDesc.dom.nodeType == 1 ? targetDesc.dom : null;
      let { selection } = view.state;
      if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
        this.mightDrag = {
          node: targetNode,
          pos: targetPos,
          addAttr: !!(this.target && !this.target.draggable),
          setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
        };
      if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr)
          this.target.draggable = true;
        if (this.mightDrag.setUneditable)
          setTimeout(() => {
            if (this.view.input.mouseDown == this)
              this.target.setAttribute("contentEditable", "false");
          }, 20);
        this.view.domObserver.start();
      }
      view.root.addEventListener("mouseup", this.up = this.up.bind(this));
      view.root.addEventListener("mousemove", this.move = this.move.bind(this));
      setSelectionOrigin(view, "pointer");
    }
    done() {
      this.view.root.removeEventListener("mouseup", this.up);
      this.view.root.removeEventListener("mousemove", this.move);
      if (this.mightDrag && this.target) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr)
          this.target.removeAttribute("draggable");
        if (this.mightDrag.setUneditable)
          this.target.removeAttribute("contentEditable");
        this.view.domObserver.start();
      }
      if (this.delayedSelectionSync)
        setTimeout(() => selectionToDOM(this.view));
      this.view.input.mouseDown = null;
    }
    up(event) {
      this.done();
      if (!this.view.dom.contains(event.target))
        return;
      let pos = this.pos;
      if (this.view.state.doc != this.startDoc)
        pos = this.view.posAtCoords(eventCoords(event));
      this.updateAllowDefault(event);
      if (this.allowDefault || !pos) {
        setSelectionOrigin(this.view, "pointer");
      } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
        event.preventDefault();
      } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
      safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
      // cursor, but still report that the node is selected
      // when asked through getSelection. You'll then get a
      // situation where clicking at the point where that
      // (hidden) cursor is doesn't change the selection, and
      // thus doesn't get a reaction from ProseMirror. This
      // works around that.
      chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
        updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)));
        event.preventDefault();
      } else {
        setSelectionOrigin(this.view, "pointer");
      }
    }
    move(event) {
      this.updateAllowDefault(event);
      setSelectionOrigin(this.view, "pointer");
      if (event.buttons == 0)
        this.done();
    }
    updateAllowDefault(event) {
      if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
        this.allowDefault = true;
    }
  }
  handlers.touchstart = (view) => {
    view.input.lastTouch = Date.now();
    forceDOMFlush(view);
    setSelectionOrigin(view, "pointer");
  };
  handlers.touchmove = (view) => {
    view.input.lastTouch = Date.now();
    setSelectionOrigin(view, "pointer");
  };
  handlers.contextmenu = (view) => forceDOMFlush(view);
  function inOrNearComposition(view, event) {
    if (view.composing)
      return true;
    if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
      view.input.compositionEndedAt = -2e8;
      return true;
    }
    return false;
  }
  const timeoutComposition = android ? 5e3 : -1;
  editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
    if (!view.composing) {
      view.domObserver.flush();
      let { state } = view, $pos = state.selection.$to;
      if (state.selection instanceof TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
        view.markCursor = view.state.storedMarks || $pos.marks();
        endComposition(view, true);
        view.markCursor = null;
      } else {
        endComposition(view, !state.selection.empty);
        if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
          let sel = view.domSelectionRange();
          for (let node = sel.focusNode, offset2 = sel.focusOffset; node && node.nodeType == 1 && offset2 != 0; ) {
            let before = offset2 < 0 ? node.lastChild : node.childNodes[offset2 - 1];
            if (!before)
              break;
            if (before.nodeType == 3) {
              let sel2 = view.domSelection();
              if (sel2)
                sel2.collapse(before, before.nodeValue.length);
              break;
            } else {
              node = before;
              offset2 = -1;
            }
          }
        }
      }
      view.input.composing = true;
    }
    scheduleComposeEnd(view, timeoutComposition);
  };
  editHandlers.compositionend = (view, event) => {
    if (view.composing) {
      view.input.composing = false;
      view.input.compositionEndedAt = event.timeStamp;
      view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
      view.input.compositionNode = null;
      if (view.input.compositionPendingChanges)
        Promise.resolve().then(() => view.domObserver.flush());
      view.input.compositionID++;
      scheduleComposeEnd(view, 20);
    }
  };
  function scheduleComposeEnd(view, delay) {
    clearTimeout(view.input.composingTimeout);
    if (delay > -1)
      view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
  }
  function clearComposition(view) {
    if (view.composing) {
      view.input.composing = false;
      view.input.compositionEndedAt = timestampFromCustomEvent();
    }
    while (view.input.compositionNodes.length > 0)
      view.input.compositionNodes.pop().markParentsDirty();
  }
  function findCompositionNode(view) {
    let sel = view.domSelectionRange();
    if (!sel.focusNode)
      return null;
    let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
    let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
    if (textBefore && textAfter && textBefore != textAfter) {
      let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;
      if (textBefore == lastChanged || textAfter == lastChanged)
        return lastChanged;
      if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
        return textAfter;
      } else if (view.input.compositionNode == textAfter) {
        let descBefore = textBefore.pmViewDesc;
        if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
          return textAfter;
      }
    }
    return textBefore || textAfter;
  }
  function timestampFromCustomEvent() {
    let event = document.createEvent("Event");
    event.initEvent("event", true, true);
    return event.timeStamp;
  }
  function endComposition(view, restarting = false) {
    if (android && view.domObserver.flushingSoon >= 0)
      return;
    view.domObserver.forceFlush();
    clearComposition(view);
    if (restarting || view.docView && view.docView.dirty) {
      let sel = selectionFromDOM(view), cur = view.state.selection;
      if (sel && !sel.eq(cur))
        view.dispatch(view.state.tr.setSelection(sel));
      else if ((view.markCursor || restarting) && !cur.$from.node(cur.$from.sharedDepth(cur.to)).inlineContent)
        view.dispatch(view.state.tr.deleteSelection());
      else
        view.updateState(view.state);
      return true;
    }
    return false;
  }
  function captureCopy(view, dom) {
    if (!view.dom.parentNode)
      return;
    let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
    wrap2.appendChild(dom);
    wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
    let sel = getSelection(), range = document.createRange();
    range.selectNodeContents(dom);
    view.dom.blur();
    sel.removeAllRanges();
    sel.addRange(range);
    setTimeout(() => {
      if (wrap2.parentNode)
        wrap2.parentNode.removeChild(wrap2);
      view.focus();
    }, 50);
  }
  const brokenClipboardAPI = ie$1 && ie_version < 15 || ios && webkit_version < 604;
  handlers.copy = editHandlers.cut = (view, _event) => {
    let event = _event;
    let sel = view.state.selection, cut = event.type == "cut";
    if (sel.empty)
      return;
    let data = brokenClipboardAPI ? null : event.clipboardData;
    let slice = sel.content(), { dom, text: text2 } = serializeForClipboard(view, slice);
    if (data) {
      event.preventDefault();
      data.clearData();
      data.setData("text/html", dom.innerHTML);
      data.setData("text/plain", text2);
    } else {
      captureCopy(view, dom);
    }
    if (cut)
      view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
  };
  function sliceSingleNode(slice) {
    return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;
  }
  function capturePaste(view, event) {
    if (!view.dom.parentNode)
      return;
    let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
    let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
    if (!plainText)
      target.contentEditable = "true";
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
    setTimeout(() => {
      view.focus();
      if (target.parentNode)
        target.parentNode.removeChild(target);
      if (plainText)
        doPaste(view, target.value, null, plain, event);
      else
        doPaste(view, target.textContent, target.innerHTML, plain, event);
    }, 50);
  }
  function doPaste(view, text2, html2, preferPlain, event) {
    let slice = parseFromClipboard(view, text2, html2, preferPlain, view.state.selection.$from);
    if (view.someProp("handlePaste", (f) => f(view, event, slice || Slice.empty)))
      return true;
    if (!slice)
      return false;
    let singleNode = sliceSingleNode(slice);
    let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice);
    view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
    return true;
  }
  function getText(clipboardData) {
    let text2 = clipboardData.getData("text/plain") || clipboardData.getData("Text");
    if (text2)
      return text2;
    let uris = clipboardData.getData("text/uri-list");
    return uris ? uris.replace(/\r?\n/g, " ") : "";
  }
  editHandlers.paste = (view, _event) => {
    let event = _event;
    if (view.composing && !android)
      return;
    let data = brokenClipboardAPI ? null : event.clipboardData;
    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
    if (data && doPaste(view, getText(data), data.getData("text/html"), plain, event))
      event.preventDefault();
    else
      capturePaste(view, event);
  };
  class Dragging {
    constructor(slice, move, node) {
      this.slice = slice;
      this.move = move;
      this.node = node;
    }
  }
  const dragCopyModifier = mac$3 ? "altKey" : "ctrlKey";
  function dragMoves(view, event) {
    let moves = view.someProp("dragCopies", (test2) => !test2(event));
    return moves != null ? moves : !event[dragCopyModifier];
  }
  handlers.dragstart = (view, _event) => {
    let event = _event;
    let mouseDown = view.input.mouseDown;
    if (mouseDown)
      mouseDown.done();
    if (!event.dataTransfer)
      return;
    let sel = view.state.selection;
    let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
    let node;
    if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to)) ;
    else if (mouseDown && mouseDown.mightDrag) {
      node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
    } else if (event.target && event.target.nodeType == 1) {
      let desc = view.docView.nearestDesc(event.target, true);
      if (desc && desc.node.type.spec.draggable && desc != view.docView)
        node = NodeSelection.create(view.state.doc, desc.posBefore);
    }
    let draggedSlice = (node || view.state.selection).content();
    let { dom, text: text2, slice } = serializeForClipboard(view, draggedSlice);
    if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)
      event.dataTransfer.clearData();
    event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
    event.dataTransfer.effectAllowed = "copyMove";
    if (!brokenClipboardAPI)
      event.dataTransfer.setData("text/plain", text2);
    view.dragging = new Dragging(slice, dragMoves(view, event), node);
  };
  handlers.dragend = (view) => {
    let dragging = view.dragging;
    window.setTimeout(() => {
      if (view.dragging == dragging)
        view.dragging = null;
    }, 50);
  };
  editHandlers.dragover = editHandlers.dragenter = (_2, e) => e.preventDefault();
  editHandlers.drop = (view, _event) => {
    let event = _event;
    let dragging = view.dragging;
    view.dragging = null;
    if (!event.dataTransfer)
      return;
    let eventPos = view.posAtCoords(eventCoords(event));
    if (!eventPos)
      return;
    let $mouse = view.state.doc.resolve(eventPos.pos);
    let slice = dragging && dragging.slice;
    if (slice) {
      view.someProp("transformPasted", (f) => {
        slice = f(slice, view);
      });
    } else {
      slice = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
    }
    let move = !!(dragging && dragMoves(view, event));
    if (view.someProp("handleDrop", (f) => f(view, event, slice || Slice.empty, move))) {
      event.preventDefault();
      return;
    }
    if (!slice)
      return;
    event.preventDefault();
    let insertPos = slice ? dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos;
    if (insertPos == null)
      insertPos = $mouse.pos;
    let tr = view.state.tr;
    if (move) {
      let { node } = dragging;
      if (node)
        node.replace(tr);
      else
        tr.deleteSelection();
    }
    let pos = tr.mapping.map(insertPos);
    let isNode2 = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;
    let beforeInsert = tr.doc;
    if (isNode2)
      tr.replaceRangeWith(pos, pos, slice.content.firstChild);
    else
      tr.replaceRange(pos, pos, slice);
    if (tr.doc.eq(beforeInsert))
      return;
    let $pos = tr.doc.resolve(pos);
    if (isNode2 && NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {
      tr.setSelection(new NodeSelection($pos));
    } else {
      let end = tr.mapping.map(insertPos);
      tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);
      tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));
    }
    view.focus();
    view.dispatch(tr.setMeta("uiEvent", "drop"));
  };
  handlers.focus = (view) => {
    view.input.lastFocus = Date.now();
    if (!view.focused) {
      view.domObserver.stop();
      view.dom.classList.add("ProseMirror-focused");
      view.domObserver.start();
      view.focused = true;
      setTimeout(() => {
        if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
          selectionToDOM(view);
      }, 20);
    }
  };
  handlers.blur = (view, _event) => {
    let event = _event;
    if (view.focused) {
      view.domObserver.stop();
      view.dom.classList.remove("ProseMirror-focused");
      view.domObserver.start();
      if (event.relatedTarget && view.dom.contains(event.relatedTarget))
        view.domObserver.currentSelection.clear();
      view.focused = false;
    }
  };
  handlers.beforeinput = (view, _event) => {
    let event = _event;
    if (chrome && android && event.inputType == "deleteContentBackward") {
      view.domObserver.flushSoon();
      let { domChangeCount } = view.input;
      setTimeout(() => {
        if (view.input.domChangeCount != domChangeCount)
          return;
        view.dom.blur();
        view.focus();
        if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
          return;
        let { $cursor } = view.state.selection;
        if ($cursor && $cursor.pos > 0)
          view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
      }, 50);
    }
  };
  for (let prop in editHandlers)
    handlers[prop] = editHandlers[prop];
  function compareObjs(a, b2) {
    if (a == b2)
      return true;
    for (let p in a)
      if (a[p] !== b2[p])
        return false;
    for (let p in b2)
      if (!(p in a))
        return false;
    return true;
  }
  class WidgetType {
    constructor(toDOM, spec) {
      this.toDOM = toDOM;
      this.spec = spec || noSpec;
      this.side = this.spec.side || 0;
    }
    map(mapping, span, offset2, oldOffset) {
      let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
      return deleted ? null : new Decoration(pos - offset2, pos - offset2, this);
    }
    valid() {
      return true;
    }
    eq(other) {
      return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
    }
    destroy(node) {
      if (this.spec.destroy)
        this.spec.destroy(node);
    }
  }
  class InlineType {
    constructor(attrs, spec) {
      this.attrs = attrs;
      this.spec = spec || noSpec;
    }
    map(mapping, span, offset2, oldOffset) {
      let from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
      let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
      return from >= to ? null : new Decoration(from, to, this);
    }
    valid(_2, span) {
      return span.from < span.to;
    }
    eq(other) {
      return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    }
    static is(span) {
      return span.type instanceof InlineType;
    }
    destroy() {
    }
  }
  class NodeType {
    constructor(attrs, spec) {
      this.attrs = attrs;
      this.spec = spec || noSpec;
    }
    map(mapping, span, offset2, oldOffset) {
      let from = mapping.mapResult(span.from + oldOffset, 1);
      if (from.deleted)
        return null;
      let to = mapping.mapResult(span.to + oldOffset, -1);
      if (to.deleted || to.pos <= from.pos)
        return null;
      return new Decoration(from.pos - offset2, to.pos - offset2, this);
    }
    valid(node, span) {
      let { index, offset: offset2 } = node.content.findIndex(span.from), child;
      return offset2 == span.from && !(child = node.child(index)).isText && offset2 + child.nodeSize == span.to;
    }
    eq(other) {
      return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    }
    destroy() {
    }
  }
  class Decoration {
    /**
    @internal
    */
    constructor(from, to, type) {
      this.from = from;
      this.to = to;
      this.type = type;
    }
    /**
    @internal
    */
    copy(from, to) {
      return new Decoration(from, to, this.type);
    }
    /**
    @internal
    */
    eq(other, offset2 = 0) {
      return this.type.eq(other.type) && this.from + offset2 == other.from && this.to + offset2 == other.to;
    }
    /**
    @internal
    */
    map(mapping, offset2, oldOffset) {
      return this.type.map(mapping, this, offset2, oldOffset);
    }
    /**
    Creates a widget decoration, which is a DOM node that's shown in
    the document at the given position. It is recommended that you
    delay rendering the widget by passing a function that will be
    called when the widget is actually drawn in a view, but you can
    also directly pass a DOM node. `getPos` can be used to find the
    widget's current document position.
    */
    static widget(pos, toDOM, spec) {
      return new Decoration(pos, pos, new WidgetType(toDOM, spec));
    }
    /**
    Creates an inline decoration, which adds the given attributes to
    each inline node between `from` and `to`.
    */
    static inline(from, to, attrs, spec) {
      return new Decoration(from, to, new InlineType(attrs, spec));
    }
    /**
    Creates a node decoration. `from` and `to` should point precisely
    before and after a node in the document. That node, and only that
    node, will receive the given attributes.
    */
    static node(from, to, attrs, spec) {
      return new Decoration(from, to, new NodeType(attrs, spec));
    }
    /**
    The spec provided when creating this decoration. Can be useful
    if you've stored extra information in that object.
    */
    get spec() {
      return this.type.spec;
    }
    /**
    @internal
    */
    get inline() {
      return this.type instanceof InlineType;
    }
    /**
    @internal
    */
    get widget() {
      return this.type instanceof WidgetType;
    }
  }
  const none = [], noSpec = {};
  class DecorationSet {
    /**
    @internal
    */
    constructor(local, children) {
      this.local = local.length ? local : none;
      this.children = children.length ? children : none;
    }
    /**
    Create a set of decorations, using the structure of the given
    document. This will consume (modify) the `decorations` array, so
    you must make a copy if you want need to preserve that.
    */
    static create(doc2, decorations) {
      return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
    }
    /**
    Find all decorations in this set which touch the given range
    (including decorations that start or end directly at the
    boundaries) and match the given predicate on their spec. When
    `start` and `end` are omitted, all decorations in the set are
    considered. When `predicate` isn't given, all decorations are
    assumed to match.
    */
    find(start, end, predicate) {
      let result = [];
      this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
      return result;
    }
    findInner(start, end, result, offset2, predicate) {
      for (let i2 = 0; i2 < this.local.length; i2++) {
        let span = this.local[i2];
        if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
          result.push(span.copy(span.from + offset2, span.to + offset2));
      }
      for (let i2 = 0; i2 < this.children.length; i2 += 3) {
        if (this.children[i2] < end && this.children[i2 + 1] > start) {
          let childOff = this.children[i2] + 1;
          this.children[i2 + 2].findInner(start - childOff, end - childOff, result, offset2 + childOff, predicate);
        }
      }
    }
    /**
    Map the set of decorations in response to a change in the
    document.
    */
    map(mapping, doc2, options) {
      if (this == empty || mapping.maps.length == 0)
        return this;
      return this.mapInner(mapping, doc2, 0, 0, options || noSpec);
    }
    /**
    @internal
    */
    mapInner(mapping, node, offset2, oldOffset, options) {
      let newLocal;
      for (let i2 = 0; i2 < this.local.length; i2++) {
        let mapped = this.local[i2].map(mapping, offset2, oldOffset);
        if (mapped && mapped.type.valid(node, mapped))
          (newLocal || (newLocal = [])).push(mapped);
        else if (options.onRemove)
          options.onRemove(this.local[i2].spec);
      }
      if (this.children.length)
        return mapChildren(this.children, newLocal || [], mapping, node, offset2, oldOffset, options);
      else
        return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;
    }
    /**
    Add the given array of decorations to the ones in the set,
    producing a new set. Consumes the `decorations` array. Needs
    access to the current document to create the appropriate tree
    structure.
    */
    add(doc2, decorations) {
      if (!decorations.length)
        return this;
      if (this == empty)
        return DecorationSet.create(doc2, decorations);
      return this.addInner(doc2, decorations, 0);
    }
    addInner(doc2, decorations, offset2) {
      let children, childIndex = 0;
      doc2.forEach((childNode, childOffset) => {
        let baseOffset = childOffset + offset2, found2;
        if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
          return;
        if (!children)
          children = this.children.slice();
        while (childIndex < children.length && children[childIndex] < childOffset)
          childIndex += 3;
        if (children[childIndex] == childOffset)
          children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
        else
          children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
        childIndex += 3;
      });
      let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset2);
      for (let i2 = 0; i2 < local.length; i2++)
        if (!local[i2].type.valid(doc2, local[i2]))
          local.splice(i2--, 1);
      return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
    }
    /**
    Create a new set that contains the decorations in this set, minus
    the ones in the given array.
    */
    remove(decorations) {
      if (decorations.length == 0 || this == empty)
        return this;
      return this.removeInner(decorations, 0);
    }
    removeInner(decorations, offset2) {
      let children = this.children, local = this.local;
      for (let i2 = 0; i2 < children.length; i2 += 3) {
        let found2;
        let from = children[i2] + offset2, to = children[i2 + 1] + offset2;
        for (let j2 = 0, span; j2 < decorations.length; j2++)
          if (span = decorations[j2]) {
            if (span.from > from && span.to < to) {
              decorations[j2] = null;
              (found2 || (found2 = [])).push(span);
            }
          }
        if (!found2)
          continue;
        if (children == this.children)
          children = this.children.slice();
        let removed = children[i2 + 2].removeInner(found2, from + 1);
        if (removed != empty) {
          children[i2 + 2] = removed;
        } else {
          children.splice(i2, 3);
          i2 -= 3;
        }
      }
      if (local.length) {
        for (let i2 = 0, span; i2 < decorations.length; i2++)
          if (span = decorations[i2]) {
            for (let j2 = 0; j2 < local.length; j2++)
              if (local[j2].eq(span, offset2)) {
                if (local == this.local)
                  local = this.local.slice();
                local.splice(j2--, 1);
              }
          }
      }
      if (children == this.children && local == this.local)
        return this;
      return local.length || children.length ? new DecorationSet(local, children) : empty;
    }
    forChild(offset2, node) {
      if (this == empty)
        return this;
      if (node.isLeaf)
        return DecorationSet.empty;
      let child, local;
      for (let i2 = 0; i2 < this.children.length; i2 += 3)
        if (this.children[i2] >= offset2) {
          if (this.children[i2] == offset2)
            child = this.children[i2 + 2];
          break;
        }
      let start = offset2 + 1, end = start + node.content.size;
      for (let i2 = 0; i2 < this.local.length; i2++) {
        let dec = this.local[i2];
        if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
          let from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;
          if (from < to)
            (local || (local = [])).push(dec.copy(from, to));
        }
      }
      if (local) {
        let localSet = new DecorationSet(local.sort(byPos), none);
        return child ? new DecorationGroup([localSet, child]) : localSet;
      }
      return child || empty;
    }
    /**
    @internal
    */
    eq(other) {
      if (this == other)
        return true;
      if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
        return false;
      for (let i2 = 0; i2 < this.local.length; i2++)
        if (!this.local[i2].eq(other.local[i2]))
          return false;
      for (let i2 = 0; i2 < this.children.length; i2 += 3)
        if (this.children[i2] != other.children[i2] || this.children[i2 + 1] != other.children[i2 + 1] || !this.children[i2 + 2].eq(other.children[i2 + 2]))
          return false;
      return true;
    }
    /**
    @internal
    */
    locals(node) {
      return removeOverlap(this.localsInner(node));
    }
    /**
    @internal
    */
    localsInner(node) {
      if (this == empty)
        return none;
      if (node.inlineContent || !this.local.some(InlineType.is))
        return this.local;
      let result = [];
      for (let i2 = 0; i2 < this.local.length; i2++) {
        if (!(this.local[i2].type instanceof InlineType))
          result.push(this.local[i2]);
      }
      return result;
    }
    forEachSet(f) {
      f(this);
    }
  }
  DecorationSet.empty = new DecorationSet([], []);
  DecorationSet.removeOverlap = removeOverlap;
  const empty = DecorationSet.empty;
  class DecorationGroup {
    constructor(members) {
      this.members = members;
    }
    map(mapping, doc2) {
      const mappedDecos = this.members.map((member) => member.map(mapping, doc2, noSpec));
      return DecorationGroup.from(mappedDecos);
    }
    forChild(offset2, child) {
      if (child.isLeaf)
        return DecorationSet.empty;
      let found2 = [];
      for (let i2 = 0; i2 < this.members.length; i2++) {
        let result = this.members[i2].forChild(offset2, child);
        if (result == empty)
          continue;
        if (result instanceof DecorationGroup)
          found2 = found2.concat(result.members);
        else
          found2.push(result);
      }
      return DecorationGroup.from(found2);
    }
    eq(other) {
      if (!(other instanceof DecorationGroup) || other.members.length != this.members.length)
        return false;
      for (let i2 = 0; i2 < this.members.length; i2++)
        if (!this.members[i2].eq(other.members[i2]))
          return false;
      return true;
    }
    locals(node) {
      let result, sorted = true;
      for (let i2 = 0; i2 < this.members.length; i2++) {
        let locals = this.members[i2].localsInner(node);
        if (!locals.length)
          continue;
        if (!result) {
          result = locals;
        } else {
          if (sorted) {
            result = result.slice();
            sorted = false;
          }
          for (let j2 = 0; j2 < locals.length; j2++)
            result.push(locals[j2]);
        }
      }
      return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
    }
    // Create a group for the given array of decoration sets, or return
    // a single set when possible.
    static from(members) {
      switch (members.length) {
        case 0:
          return empty;
        case 1:
          return members[0];
        default:
          return new DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));
      }
    }
    forEachSet(f) {
      for (let i2 = 0; i2 < this.members.length; i2++)
        this.members[i2].forEachSet(f);
    }
  }
  function mapChildren(oldChildren, newLocal, mapping, node, offset2, oldOffset, options) {
    let children = oldChildren.slice();
    for (let i2 = 0, baseOffset = oldOffset; i2 < mapping.maps.length; i2++) {
      let moved = 0;
      mapping.maps[i2].forEach((oldStart, oldEnd, newStart, newEnd) => {
        let dSize = newEnd - newStart - (oldEnd - oldStart);
        for (let i3 = 0; i3 < children.length; i3 += 3) {
          let end = children[i3 + 1];
          if (end < 0 || oldStart > end + baseOffset - moved)
            continue;
          let start = children[i3] + baseOffset - moved;
          if (oldEnd >= start) {
            children[i3 + 1] = oldStart <= start ? -2 : -1;
          } else if (oldStart >= baseOffset && dSize) {
            children[i3] += dSize;
            children[i3 + 1] += dSize;
          }
        }
        moved += dSize;
      });
      baseOffset = mapping.maps[i2].map(baseOffset, -1);
    }
    let mustRebuild = false;
    for (let i2 = 0; i2 < children.length; i2 += 3)
      if (children[i2 + 1] < 0) {
        if (children[i2 + 1] == -2) {
          mustRebuild = true;
          children[i2 + 1] = -1;
          continue;
        }
        let from = mapping.map(oldChildren[i2] + oldOffset), fromLocal = from - offset2;
        if (fromLocal < 0 || fromLocal >= node.content.size) {
          mustRebuild = true;
          continue;
        }
        let to = mapping.map(oldChildren[i2 + 1] + oldOffset, -1), toLocal = to - offset2;
        let { index, offset: childOffset } = node.content.findIndex(fromLocal);
        let childNode = node.maybeChild(index);
        if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
          let mapped = children[i2 + 2].mapInner(mapping, childNode, from + 1, oldChildren[i2] + oldOffset + 1, options);
          if (mapped != empty) {
            children[i2] = fromLocal;
            children[i2 + 1] = toLocal;
            children[i2 + 2] = mapped;
          } else {
            children[i2 + 1] = -2;
            mustRebuild = true;
          }
        } else {
          mustRebuild = true;
        }
      }
    if (mustRebuild) {
      let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset2, oldOffset, options);
      let built = buildTree(decorations, node, 0, options);
      newLocal = built.local;
      for (let i2 = 0; i2 < children.length; i2 += 3)
        if (children[i2 + 1] < 0) {
          children.splice(i2, 3);
          i2 -= 3;
        }
      for (let i2 = 0, j2 = 0; i2 < built.children.length; i2 += 3) {
        let from = built.children[i2];
        while (j2 < children.length && children[j2] < from)
          j2 += 3;
        children.splice(j2, 0, built.children[i2], built.children[i2 + 1], built.children[i2 + 2]);
      }
    }
    return new DecorationSet(newLocal.sort(byPos), children);
  }
  function moveSpans(spans, offset2) {
    if (!offset2 || !spans.length)
      return spans;
    let result = [];
    for (let i2 = 0; i2 < spans.length; i2++) {
      let span = spans[i2];
      result.push(new Decoration(span.from + offset2, span.to + offset2, span.type));
    }
    return result;
  }
  function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset2, oldOffset, options) {
    function gather(set2, oldOffset2) {
      for (let i2 = 0; i2 < set2.local.length; i2++) {
        let mapped = set2.local[i2].map(mapping, offset2, oldOffset2);
        if (mapped)
          decorations.push(mapped);
        else if (options.onRemove)
          options.onRemove(set2.local[i2].spec);
      }
      for (let i2 = 0; i2 < set2.children.length; i2 += 3)
        gather(set2.children[i2 + 2], set2.children[i2] + oldOffset2 + 1);
    }
    for (let i2 = 0; i2 < children.length; i2 += 3)
      if (children[i2 + 1] == -1)
        gather(children[i2 + 2], oldChildren[i2] + oldOffset + 1);
    return decorations;
  }
  function takeSpansForNode(spans, node, offset2) {
    if (node.isLeaf)
      return null;
    let end = offset2 + node.nodeSize, found2 = null;
    for (let i2 = 0, span; i2 < spans.length; i2++) {
      if ((span = spans[i2]) && span.from > offset2 && span.to < end) {
        (found2 || (found2 = [])).push(span);
        spans[i2] = null;
      }
    }
    return found2;
  }
  function withoutNulls(array) {
    let result = [];
    for (let i2 = 0; i2 < array.length; i2++)
      if (array[i2] != null)
        result.push(array[i2]);
    return result;
  }
  function buildTree(spans, node, offset2, options) {
    let children = [], hasNulls = false;
    node.forEach((childNode, localStart) => {
      let found2 = takeSpansForNode(spans, childNode, localStart + offset2);
      if (found2) {
        hasNulls = true;
        let subtree = buildTree(found2, childNode, offset2 + localStart + 1, options);
        if (subtree != empty)
          children.push(localStart, localStart + childNode.nodeSize, subtree);
      }
    });
    let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset2).sort(byPos);
    for (let i2 = 0; i2 < locals.length; i2++)
      if (!locals[i2].type.valid(node, locals[i2])) {
        if (options.onRemove)
          options.onRemove(locals[i2].spec);
        locals.splice(i2--, 1);
      }
    return locals.length || children.length ? new DecorationSet(locals, children) : empty;
  }
  function byPos(a, b2) {
    return a.from - b2.from || a.to - b2.to;
  }
  function removeOverlap(spans) {
    let working = spans;
    for (let i2 = 0; i2 < working.length - 1; i2++) {
      let span = working[i2];
      if (span.from != span.to)
        for (let j2 = i2 + 1; j2 < working.length; j2++) {
          let next = working[j2];
          if (next.from == span.from) {
            if (next.to != span.to) {
              if (working == spans)
                working = spans.slice();
              working[j2] = next.copy(next.from, span.to);
              insertAhead(working, j2 + 1, next.copy(span.to, next.to));
            }
            continue;
          } else {
            if (next.from < span.to) {
              if (working == spans)
                working = spans.slice();
              working[i2] = span.copy(span.from, next.from);
              insertAhead(working, j2, span.copy(next.from, span.to));
            }
            break;
          }
        }
    }
    return working;
  }
  function insertAhead(array, i2, deco) {
    while (i2 < array.length && byPos(deco, array[i2]) > 0)
      i2++;
    array.splice(i2, 0, deco);
  }
  function viewDecorations(view) {
    let found2 = [];
    view.someProp("decorations", (f) => {
      let result = f(view.state);
      if (result && result != empty)
        found2.push(result);
    });
    if (view.cursorWrapper)
      found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
    return DecorationGroup.from(found2);
  }
  const observeOptions = {
    childList: true,
    characterData: true,
    characterDataOldValue: true,
    attributes: true,
    attributeOldValue: true,
    subtree: true
  };
  const useCharData = ie$1 && ie_version <= 11;
  class SelectionState {
    constructor() {
      this.anchorNode = null;
      this.anchorOffset = 0;
      this.focusNode = null;
      this.focusOffset = 0;
    }
    set(sel) {
      this.anchorNode = sel.anchorNode;
      this.anchorOffset = sel.anchorOffset;
      this.focusNode = sel.focusNode;
      this.focusOffset = sel.focusOffset;
    }
    clear() {
      this.anchorNode = this.focusNode = null;
    }
    eq(sel) {
      return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
    }
  }
  class DOMObserver {
    constructor(view, handleDOMChange) {
      this.view = view;
      this.handleDOMChange = handleDOMChange;
      this.queue = [];
      this.flushingSoon = -1;
      this.observer = null;
      this.currentSelection = new SelectionState();
      this.onCharData = null;
      this.suppressingSelectionUpdates = false;
      this.lastChangedTextNode = null;
      this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
        for (let i2 = 0; i2 < mutations.length; i2++)
          this.queue.push(mutations[i2]);
        if (ie$1 && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
          this.flushSoon();
        else
          this.flush();
      });
      if (useCharData) {
        this.onCharData = (e) => {
          this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
          this.flushSoon();
        };
      }
      this.onSelectionChange = this.onSelectionChange.bind(this);
    }
    flushSoon() {
      if (this.flushingSoon < 0)
        this.flushingSoon = window.setTimeout(() => {
          this.flushingSoon = -1;
          this.flush();
        }, 20);
    }
    forceFlush() {
      if (this.flushingSoon > -1) {
        window.clearTimeout(this.flushingSoon);
        this.flushingSoon = -1;
        this.flush();
      }
    }
    start() {
      if (this.observer) {
        this.observer.takeRecords();
        this.observer.observe(this.view.dom, observeOptions);
      }
      if (this.onCharData)
        this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.connectSelection();
    }
    stop() {
      if (this.observer) {
        let take = this.observer.takeRecords();
        if (take.length) {
          for (let i2 = 0; i2 < take.length; i2++)
            this.queue.push(take[i2]);
          window.setTimeout(() => this.flush(), 20);
        }
        this.observer.disconnect();
      }
      if (this.onCharData)
        this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
      this.disconnectSelection();
    }
    connectSelection() {
      this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    }
    disconnectSelection() {
      this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
    }
    suppressSelectionUpdates() {
      this.suppressingSelectionUpdates = true;
      setTimeout(() => this.suppressingSelectionUpdates = false, 50);
    }
    onSelectionChange() {
      if (!hasFocusAndSelection(this.view))
        return;
      if (this.suppressingSelectionUpdates)
        return selectionToDOM(this.view);
      if (ie$1 && ie_version <= 11 && !this.view.state.selection.empty) {
        let sel = this.view.domSelectionRange();
        if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
    setCurSelection() {
      this.currentSelection.set(this.view.domSelectionRange());
    }
    ignoreSelectionChange(sel) {
      if (!sel.focusNode)
        return true;
      let ancestors = /* @__PURE__ */ new Set(), container;
      for (let scan = sel.focusNode; scan; scan = parentNode(scan))
        ancestors.add(scan);
      for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
        if (ancestors.has(scan)) {
          container = scan;
          break;
        }
      let desc = container && this.view.docView.nearestDesc(container);
      if (desc && desc.ignoreMutation({
        type: "selection",
        target: container.nodeType == 3 ? container.parentNode : container
      })) {
        this.setCurSelection();
        return true;
      }
    }
    pendingRecords() {
      if (this.observer)
        for (let mut of this.observer.takeRecords())
          this.queue.push(mut);
      return this.queue;
    }
    flush() {
      let { view } = this;
      if (!view.docView || this.flushingSoon > -1)
        return;
      let mutations = this.pendingRecords();
      if (mutations.length)
        this.queue = [];
      let sel = view.domSelectionRange();
      let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
      let from = -1, to = -1, typeOver = false, added = [];
      if (view.editable) {
        for (let i2 = 0; i2 < mutations.length; i2++) {
          let result = this.registerMutation(mutations[i2], added);
          if (result) {
            from = from < 0 ? result.from : Math.min(result.from, from);
            to = to < 0 ? result.to : Math.max(result.to, to);
            if (result.typeOver)
              typeOver = true;
          }
        }
      }
      if (gecko && added.length) {
        let brs = added.filter((n) => n.nodeName == "BR");
        if (brs.length == 2) {
          let [a, b2] = brs;
          if (a.parentNode && a.parentNode.parentNode == b2.parentNode)
            b2.remove();
          else
            a.remove();
        } else {
          let { focusNode } = this.currentSelection;
          for (let br of brs) {
            let parent = br.parentNode;
            if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent))
              br.remove();
          }
        }
      }
      let readSel = null;
      if (from < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
        view.input.lastFocus = 0;
        selectionToDOM(view);
        this.currentSelection.set(sel);
        view.scrollToSelection();
      } else if (from > -1 || newSel) {
        if (from > -1) {
          view.docView.markDirty(from, to);
          checkCSS(view);
        }
        this.handleDOMChange(from, to, typeOver, added);
        if (view.docView && view.docView.dirty)
          view.updateState(view.state);
        else if (!this.currentSelection.eq(sel))
          selectionToDOM(view);
        this.currentSelection.set(sel);
      }
    }
    registerMutation(mut, added) {
      if (added.indexOf(mut.target) > -1)
        return null;
      let desc = this.view.docView.nearestDesc(mut.target);
      if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
      mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
        return null;
      if (!desc || desc.ignoreMutation(mut))
        return null;
      if (mut.type == "childList") {
        for (let i2 = 0; i2 < mut.addedNodes.length; i2++) {
          let node = mut.addedNodes[i2];
          added.push(node);
          if (node.nodeType == 3)
            this.lastChangedTextNode = node;
        }
        if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
          return { from: desc.posBefore, to: desc.posAfter };
        let prev = mut.previousSibling, next = mut.nextSibling;
        if (ie$1 && ie_version <= 11 && mut.addedNodes.length) {
          for (let i2 = 0; i2 < mut.addedNodes.length; i2++) {
            let { previousSibling, nextSibling } = mut.addedNodes[i2];
            if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
              prev = previousSibling;
            if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
              next = nextSibling;
          }
        }
        let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
        let from = desc.localPosFromDOM(mut.target, fromOffset, -1);
        let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
        let to = desc.localPosFromDOM(mut.target, toOffset, 1);
        return { from, to };
      } else if (mut.type == "attributes") {
        return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
      } else {
        this.lastChangedTextNode = mut.target;
        return {
          from: desc.posAtStart,
          to: desc.posAtEnd,
          // An event was generated for a text change that didn't change
          // any text. Mark the dom change to fall back to assuming the
          // selection was typed over with an identical value if it can't
          // find another change.
          typeOver: mut.target.nodeValue == mut.oldValue
        };
      }
    }
  }
  let cssChecked = /* @__PURE__ */ new WeakMap();
  let cssCheckWarned = false;
  function checkCSS(view) {
    if (cssChecked.has(view))
      return;
    cssChecked.set(view, null);
    if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
      view.requiresGeckoHackNode = gecko;
      if (cssCheckWarned)
        return;
      console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
      cssCheckWarned = true;
    }
  }
  function rangeToSelectionRange(view, range) {
    let anchorNode = range.startContainer, anchorOffset = range.startOffset;
    let focusNode = range.endContainer, focusOffset = range.endOffset;
    let currentAnchor = view.domAtPos(view.state.selection.anchor);
    if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
      [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
  }
  function safariShadowSelectionRange(view, selection) {
    if (selection.getComposedRanges) {
      let range = selection.getComposedRanges(view.root)[0];
      if (range)
        return rangeToSelectionRange(view, range);
    }
    let found2;
    function read(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      found2 = event.getTargetRanges()[0];
    }
    view.dom.addEventListener("beforeinput", read, true);
    document.execCommand("indent");
    view.dom.removeEventListener("beforeinput", read, true);
    return found2 ? rangeToSelectionRange(view, found2) : null;
  }
  function blockParent(view, node) {
    for (let p = node.parentNode; p && p != view.dom; p = p.parentNode) {
      let desc = view.docView.nearestDesc(p, true);
      if (desc && desc.node.isBlock)
        return p;
    }
    return null;
  }
  function parseBetween(view, from_, to_) {
    let { node: parent, fromOffset, toOffset, from, to } = view.docView.parseRange(from_, to_);
    let domSel = view.domSelectionRange();
    let find;
    let anchor = domSel.anchorNode;
    if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
      find = [{ node: anchor, offset: domSel.anchorOffset }];
      if (!selectionCollapsed(domSel))
        find.push({ node: domSel.focusNode, offset: domSel.focusOffset });
    }
    if (chrome && view.input.lastKeyCode === 8) {
      for (let off = toOffset; off > fromOffset; off--) {
        let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
        if (node.nodeName == "BR" && !desc) {
          toOffset = off;
          break;
        }
        if (!desc || desc.size)
          break;
      }
    }
    let startDoc = view.state.doc;
    let parser = view.someProp("domParser") || DOMParser$1.fromSchema(view.state.schema);
    let $from = startDoc.resolve(from);
    let sel = null, doc2 = parser.parse(parent, {
      topNode: $from.parent,
      topMatch: $from.parent.contentMatchAt($from.index()),
      topOpen: true,
      from: fromOffset,
      to: toOffset,
      preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
      findPositions: find,
      ruleFromNode,
      context: $from
    });
    if (find && find[0].pos != null) {
      let anchor2 = find[0].pos, head = find[1] && find[1].pos;
      if (head == null)
        head = anchor2;
      sel = { anchor: anchor2 + from, head: head + from };
    }
    return { doc: doc2, sel, from, to };
  }
  function ruleFromNode(dom) {
    let desc = dom.pmViewDesc;
    if (desc) {
      return desc.parseRule();
    } else if (dom.nodeName == "BR" && dom.parentNode) {
      if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
        let skip = document.createElement("div");
        skip.appendChild(document.createElement("li"));
        return { skip };
      } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
        return { ignore: true };
      }
    } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
      return { ignore: true };
    }
    return null;
  }
  const isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
  function readDOMChange(view, from, to, typeOver, addedNodes) {
    let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
    view.input.compositionPendingChanges = 0;
    if (from < 0) {
      let origin2 = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
      let newSel = selectionFromDOM(view, origin2);
      if (newSel && !view.state.selection.eq(newSel)) {
        if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
          return;
        let tr = view.state.tr.setSelection(newSel);
        if (origin2 == "pointer")
          tr.setMeta("pointer", true);
        else if (origin2 == "key")
          tr.scrollIntoView();
        if (compositionID)
          tr.setMeta("composition", compositionID);
        view.dispatch(tr);
      }
      return;
    }
    let $before = view.state.doc.resolve(from);
    let shared = $before.sharedDepth(to);
    from = $before.before(shared + 1);
    to = view.state.doc.resolve(to).after(shared + 1);
    let sel = view.state.selection;
    let parse = parseBetween(view, from, to);
    let doc2 = view.state.doc, compare = doc2.slice(parse.from, parse.to);
    let preferredPos, preferredSide;
    if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
      preferredPos = view.state.selection.to;
      preferredSide = "end";
    } else {
      preferredPos = view.state.selection.from;
      preferredSide = "start";
    }
    view.input.lastKeyCode = null;
    let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
    if (change)
      view.input.domChangeCount++;
    if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
      view.input.lastIOSEnter = 0;
      return;
    }
    if (!change) {
      if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
        change = { start: sel.from, endA: sel.to, endB: sel.to };
      } else {
        if (parse.sel) {
          let sel2 = resolveSelection(view, view.state.doc, parse.sel);
          if (sel2 && !sel2.eq(view.state.selection)) {
            let tr = view.state.tr.setSelection(sel2);
            if (compositionID)
              tr.setMeta("composition", compositionID);
            view.dispatch(tr);
          }
        }
        return;
      }
    }
    if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
      if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
        change.start = view.state.selection.from;
      } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
        change.endB += view.state.selection.to - change.endA;
        change.endA = view.state.selection.to;
      }
    }
    if (ie$1 && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " ") {
      change.start--;
      change.endA--;
      change.endB--;
    }
    let $from = parse.doc.resolveNoCache(change.start - parse.from);
    let $to = parse.doc.resolveNoCache(change.endB - parse.from);
    let $fromA = doc2.resolve(change.start);
    let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
    let nextSel;
    if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse.doc.content.size && (!$from.sameParent($to) || !$from.parent.inlineContent) && !/\S/.test(parse.doc.textBetween($from.pos, $to.pos, "", "")) && (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head > $from.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
      view.input.lastIOSEnter = 0;
      return;
    }
    if (view.state.selection.anchor > change.start && looksLikeBackspace(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
      if (android && chrome)
        view.domObserver.suppressSelectionUpdates();
      return;
    }
    if (chrome && change.endB == change.start)
      view.input.lastChromeDelete = Date.now();
    if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
      change.endB -= 2;
      $to = parse.doc.resolveNoCache(change.endB - parse.from);
      setTimeout(() => {
        view.someProp("handleKeyDown", function(f) {
          return f(view, keyEvent(13, "Enter"));
        });
      }, 20);
    }
    let chFrom = change.start, chTo = change.endA;
    let mkTr = (base2) => {
      let tr = base2 || view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
      if (parse.sel) {
        let sel2 = resolveSelection(view, tr.doc, parse.sel);
        if (sel2 && !(chrome && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr.mapping.map(chTo) - 1) || ie$1 && sel2.empty && sel2.head == chFrom))
          tr.setSelection(sel2);
      }
      if (compositionID)
        tr.setMeta("composition", compositionID);
      return tr.scrollIntoView();
    };
    let markChange;
    if (inlineChange) {
      if ($from.pos == $to.pos) {
        if (ie$1 && ie_version <= 11 && $from.parentOffset == 0) {
          view.domObserver.suppressSelectionUpdates();
          setTimeout(() => selectionToDOM(view), 20);
        }
        let tr = mkTr(view.state.tr.delete(chFrom, chTo));
        let marks2 = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
        if (marks2)
          tr.ensureMarks(marks2);
        view.dispatch(tr);
      } else if (
        // Adding or removing a mark
        change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
      ) {
        let tr = mkTr(view.state.tr);
        if (markChange.type == "add")
          tr.addMark(chFrom, chTo, markChange.mark);
        else
          tr.removeMark(chFrom, chTo, markChange.mark);
        view.dispatch(tr);
      } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
        let text2 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
        let deflt = () => mkTr(view.state.tr.insertText(text2, chFrom, chTo));
        if (!view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text2, deflt)))
          view.dispatch(deflt());
      }
    } else {
      view.dispatch(mkTr());
    }
  }
  function resolveSelection(view, doc2, parsedSel) {
    if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size)
      return null;
    return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
  }
  function isMarkChange(cur, prev) {
    let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
    let added = curMarks, removed = prevMarks, type, mark, update;
    for (let i2 = 0; i2 < prevMarks.length; i2++)
      added = prevMarks[i2].removeFromSet(added);
    for (let i2 = 0; i2 < curMarks.length; i2++)
      removed = curMarks[i2].removeFromSet(removed);
    if (added.length == 1 && removed.length == 0) {
      mark = added[0];
      type = "add";
      update = (node) => node.mark(mark.addToSet(node.marks));
    } else if (added.length == 0 && removed.length == 1) {
      mark = removed[0];
      type = "remove";
      update = (node) => node.mark(mark.removeFromSet(node.marks));
    } else {
      return null;
    }
    let updated = [];
    for (let i2 = 0; i2 < prev.childCount; i2++)
      updated.push(update(prev.child(i2)));
    if (Fragment.from(updated).eq(cur))
      return { mark, type };
  }
  function looksLikeBackspace(old, start, end, $newStart, $newEnd) {
    if (
      // The content must have shrunk
      end - start <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
      skipClosingAndOpening($newStart, true, false) < $newEnd.pos
    )
      return false;
    let $start = old.resolve(start);
    if (!$newStart.parent.isTextblock) {
      let after = $start.nodeAfter;
      return after != null && end == start + after.nodeSize;
    }
    if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
      return false;
    let $next = old.resolve(skipClosingAndOpening($start, true, true));
    if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end)
      return false;
    return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
  }
  function skipClosingAndOpening($pos, fromEnd, mayOpen) {
    let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
    while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
      depth--;
      end++;
      fromEnd = false;
    }
    if (mayOpen) {
      let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
      while (next && !next.isLeaf) {
        next = next.firstChild;
        end++;
      }
    }
    return end;
  }
  function findDiff(a, b2, pos, preferredPos, preferredSide) {
    let start = a.findDiffStart(b2, pos);
    if (start == null)
      return null;
    let { a: endA, b: endB } = a.findDiffEnd(b2, pos + a.size, pos + b2.size);
    if (preferredSide == "end") {
      let adjust = Math.max(0, start - Math.min(endA, endB));
      preferredPos -= endA + adjust - start;
    }
    if (endA < start && a.size < b2.size) {
      let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
      start -= move;
      if (start && start < b2.size && isSurrogatePair(b2.textBetween(start - 1, start + 1)))
        start += move ? 1 : -1;
      endB = start + (endB - endA);
      endA = start;
    } else if (endB < start) {
      let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
      start -= move;
      if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1)))
        start += move ? 1 : -1;
      endA = start + (endA - endB);
      endB = start;
    }
    return { start, endA, endB };
  }
  function isSurrogatePair(str) {
    if (str.length != 2)
      return false;
    let a = str.charCodeAt(0), b2 = str.charCodeAt(1);
    return a >= 56320 && a <= 57343 && b2 >= 55296 && b2 <= 56319;
  }
  class EditorView {
    /**
    Create a view. `place` may be a DOM node that the editor should
    be appended to, a function that will place it into the document,
    or an object whose `mount` property holds the node to use as the
    document container. If it is `null`, the editor will not be
    added to the document.
    */
    constructor(place, props) {
      this._root = null;
      this.focused = false;
      this.trackWrites = null;
      this.mounted = false;
      this.markCursor = null;
      this.cursorWrapper = null;
      this.lastSelectedViewDesc = void 0;
      this.input = new InputState();
      this.prevDirectPlugins = [];
      this.pluginViews = [];
      this.requiresGeckoHackNode = false;
      this.dragging = null;
      this._props = props;
      this.state = props.state;
      this.directPlugins = props.plugins || [];
      this.directPlugins.forEach(checkStateComponent);
      this.dispatch = this.dispatch.bind(this);
      this.dom = place && place.mount || document.createElement("div");
      if (place) {
        if (place.appendChild)
          place.appendChild(this.dom);
        else if (typeof place == "function")
          place(this.dom);
        else if (place.mount)
          this.mounted = true;
      }
      this.editable = getEditable(this);
      updateCursorWrapper(this);
      this.nodeViews = buildNodeViews(this);
      this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
      this.domObserver = new DOMObserver(this, (from, to, typeOver, added) => readDOMChange(this, from, to, typeOver, added));
      this.domObserver.start();
      initInput(this);
      this.updatePluginViews();
    }
    /**
    Holds `true` when a
    [composition](https://w3c.github.io/uievents/#events-compositionevents)
    is active.
    */
    get composing() {
      return this.input.composing;
    }
    /**
    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
    */
    get props() {
      if (this._props.state != this.state) {
        let prev = this._props;
        this._props = {};
        for (let name in prev)
          this._props[name] = prev[name];
        this._props.state = this.state;
      }
      return this._props;
    }
    /**
    Update the view's props. Will immediately cause an update to
    the DOM.
    */
    update(props) {
      if (props.handleDOMEvents != this._props.handleDOMEvents)
        ensureListeners(this);
      let prevProps = this._props;
      this._props = props;
      if (props.plugins) {
        props.plugins.forEach(checkStateComponent);
        this.directPlugins = props.plugins;
      }
      this.updateStateInner(props.state, prevProps);
    }
    /**
    Update the view by updating existing props object with the object
    given as argument. Equivalent to `view.update(Object.assign({},
    view.props, props))`.
    */
    setProps(props) {
      let updated = {};
      for (let name in this._props)
        updated[name] = this._props[name];
      updated.state = this.state;
      for (let name in props)
        updated[name] = props[name];
      this.update(updated);
    }
    /**
    Update the editor's `state` prop, without touching any of the
    other props.
    */
    updateState(state) {
      this.updateStateInner(state, this._props);
    }
    updateStateInner(state, prevProps) {
      var _a2;
      let prev = this.state, redraw = false, updateSel = false;
      if (state.storedMarks && this.composing) {
        clearComposition(this);
        updateSel = true;
      }
      this.state = state;
      let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
      if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
        let nodeViews = buildNodeViews(this);
        if (changedNodeViews(nodeViews, this.nodeViews)) {
          this.nodeViews = nodeViews;
          redraw = true;
        }
      }
      if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
        ensureListeners(this);
      }
      this.editable = getEditable(this);
      updateCursorWrapper(this);
      let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
      let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
      let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
      if (updateDoc || !state.selection.eq(prev.selection))
        updateSel = true;
      let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
      if (updateSel) {
        this.domObserver.stop();
        let forceSelUpdate = updateDoc && (ie$1 || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
        if (updateDoc) {
          let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
          if (this.composing)
            this.input.compositionNode = findCompositionNode(this);
          if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
            this.docView.updateOuterDeco(outerDeco);
            this.docView.destroy();
            this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
          }
          if (chromeKludge && !this.trackWrites)
            forceSelUpdate = true;
        }
        if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
          selectionToDOM(this, forceSelUpdate);
        } else {
          syncNodeSelection(this, state.selection);
          this.domObserver.setCurSelection();
        }
        this.domObserver.start();
      }
      this.updatePluginViews(prev);
      if (((_a2 = this.dragging) === null || _a2 === void 0 ? void 0 : _a2.node) && !prev.doc.eq(state.doc))
        this.updateDraggedNode(this.dragging, prev);
      if (scroll == "reset") {
        this.dom.scrollTop = 0;
      } else if (scroll == "to selection") {
        this.scrollToSelection();
      } else if (oldScrollPos) {
        resetScrollPos(oldScrollPos);
      }
    }
    /**
    @internal
    */
    scrollToSelection() {
      let startDOM = this.domSelectionRange().focusNode;
      if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;
      else if (this.someProp("handleScrollToSelection", (f) => f(this))) ;
      else if (this.state.selection instanceof NodeSelection) {
        let target = this.docView.domAfterPos(this.state.selection.from);
        if (target.nodeType == 1)
          scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
      } else {
        scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
      }
    }
    destroyPluginViews() {
      let view;
      while (view = this.pluginViews.pop())
        if (view.destroy)
          view.destroy();
    }
    updatePluginViews(prevState) {
      if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
        this.prevDirectPlugins = this.directPlugins;
        this.destroyPluginViews();
        for (let i2 = 0; i2 < this.directPlugins.length; i2++) {
          let plugin = this.directPlugins[i2];
          if (plugin.spec.view)
            this.pluginViews.push(plugin.spec.view(this));
        }
        for (let i2 = 0; i2 < this.state.plugins.length; i2++) {
          let plugin = this.state.plugins[i2];
          if (plugin.spec.view)
            this.pluginViews.push(plugin.spec.view(this));
        }
      } else {
        for (let i2 = 0; i2 < this.pluginViews.length; i2++) {
          let pluginView = this.pluginViews[i2];
          if (pluginView.update)
            pluginView.update(this, prevState);
        }
      }
    }
    updateDraggedNode(dragging, prev) {
      let sel = dragging.node, found2 = -1;
      if (this.state.doc.nodeAt(sel.from) == sel.node) {
        found2 = sel.from;
      } else {
        let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
        let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
        if (moved == sel.node)
          found2 = movedPos;
      }
      this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
    }
    someProp(propName, f) {
      let prop = this._props && this._props[propName], value;
      if (prop != null && (value = f ? f(prop) : prop))
        return value;
      for (let i2 = 0; i2 < this.directPlugins.length; i2++) {
        let prop2 = this.directPlugins[i2].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
      let plugins = this.state.plugins;
      if (plugins)
        for (let i2 = 0; i2 < plugins.length; i2++) {
          let prop2 = plugins[i2].props[propName];
          if (prop2 != null && (value = f ? f(prop2) : prop2))
            return value;
        }
    }
    /**
    Query whether the view has focus.
    */
    hasFocus() {
      if (ie$1) {
        let node = this.root.activeElement;
        if (node == this.dom)
          return true;
        if (!node || !this.dom.contains(node))
          return false;
        while (node && this.dom != node && this.dom.contains(node)) {
          if (node.contentEditable == "false")
            return false;
          node = node.parentElement;
        }
        return true;
      }
      return this.root.activeElement == this.dom;
    }
    /**
    Focus the editor.
    */
    focus() {
      this.domObserver.stop();
      if (this.editable)
        focusPreventScroll(this.dom);
      selectionToDOM(this);
      this.domObserver.start();
    }
    /**
    Get the document root in which the editor exists. This will
    usually be the top-level `document`, but might be a [shadow
    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
    root if the editor is inside one.
    */
    get root() {
      let cached = this._root;
      if (cached == null)
        for (let search = this.dom.parentNode; search; search = search.parentNode) {
          if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
            if (!search.getSelection)
              Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
            return this._root = search;
          }
        }
      return cached || document;
    }
    /**
    When an existing editor view is moved to a new document or
    shadow tree, call this to make it recompute its root.
    */
    updateRoot() {
      this._root = null;
    }
    /**
    Given a pair of viewport coordinates, return the document
    position that corresponds to them. May return null if the given
    coordinates aren't inside of the editor. When an object is
    returned, its `pos` property is the position nearest to the
    coordinates, and its `inside` property holds the position of the
    inner node that the position falls inside of, or -1 if it is at
    the top level, not in any node.
    */
    posAtCoords(coords) {
      return posAtCoords(this, coords);
    }
    /**
    Returns the viewport rectangle at a given document position.
    `left` and `right` will be the same number, as this returns a
    flat cursor-ish rectangle. If the position is between two things
    that aren't directly adjacent, `side` determines which element
    is used. When < 0, the element before the position is used,
    otherwise the element after.
    */
    coordsAtPos(pos, side = 1) {
      return coordsAtPos(this, pos, side);
    }
    /**
    Find the DOM position that corresponds to the given document
    position. When `side` is negative, find the position as close as
    possible to the content before the position. When positive,
    prefer positions close to the content after the position. When
    zero, prefer as shallow a position as possible.
    
    Note that you should **not** mutate the editor's internal DOM,
    only inspect it (and even that is usually not necessary).
    */
    domAtPos(pos, side = 0) {
      return this.docView.domFromPos(pos, side);
    }
    /**
    Find the DOM node that represents the document node after the
    given position. May return `null` when the position doesn't point
    in front of a node or if the node is inside an opaque node view.
    
    This is intended to be able to call things like
    `getBoundingClientRect` on that DOM node. Do **not** mutate the
    editor DOM directly, or add styling this way, since that will be
    immediately overriden by the editor as it redraws the node.
    */
    nodeDOM(pos) {
      let desc = this.docView.descAt(pos);
      return desc ? desc.nodeDOM : null;
    }
    /**
    Find the document position that corresponds to a given DOM
    position. (Whenever possible, it is preferable to inspect the
    document structure directly, rather than poking around in the
    DOM, but sometimesfor example when interpreting an event
    targetyou don't have a choice.)
    
    The `bias` parameter can be used to influence which side of a DOM
    node to use when the position is inside a leaf node.
    */
    posAtDOM(node, offset2, bias = -1) {
      let pos = this.docView.posFromDOM(node, offset2, bias);
      if (pos == null)
        throw new RangeError("DOM position not inside the editor");
      return pos;
    }
    /**
    Find out whether the selection is at the end of a textblock when
    moving in a given direction. When, for example, given `"left"`,
    it will return true if moving left from the current cursor
    position would leave that position's parent textblock. Will apply
    to the view's current state by default, but it is possible to
    pass a different state.
    */
    endOfTextblock(dir, state) {
      return endOfTextblock(this, state || this.state, dir);
    }
    /**
    Run the editor's paste logic with the given HTML string. The
    `event`, if given, will be passed to the
    [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
    */
    pasteHTML(html2, event) {
      return doPaste(this, "", html2, false, event || new ClipboardEvent("paste"));
    }
    /**
    Run the editor's paste logic with the given plain-text input.
    */
    pasteText(text2, event) {
      return doPaste(this, text2, null, true, event || new ClipboardEvent("paste"));
    }
    /**
    Serialize the given slice as it would be if it was copied from
    this editor. Returns a DOM element that contains a
    representation of the slice as its children, a textual
    representation, and the transformed slice (which can be
    different from the given input due to hooks like
    [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
    */
    serializeForClipboard(slice) {
      return serializeForClipboard(this, slice);
    }
    /**
    Removes the editor from the DOM and destroys all [node
    views](https://prosemirror.net/docs/ref/#view.NodeView).
    */
    destroy() {
      if (!this.docView)
        return;
      destroyInput(this);
      this.destroyPluginViews();
      if (this.mounted) {
        this.docView.update(this.state.doc, [], viewDecorations(this), this);
        this.dom.textContent = "";
      } else if (this.dom.parentNode) {
        this.dom.parentNode.removeChild(this.dom);
      }
      this.docView.destroy();
      this.docView = null;
      clearReusedRange();
    }
    /**
    This is true when the view has been
    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
    used anymore).
    */
    get isDestroyed() {
      return this.docView == null;
    }
    /**
    Used for testing.
    */
    dispatchEvent(event) {
      return dispatchEvent(this, event);
    }
    /**
    @internal
    */
    domSelectionRange() {
      let sel = this.domSelection();
      if (!sel)
        return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
      return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
    }
    /**
    @internal
    */
    domSelection() {
      return this.root.getSelection();
    }
  }
  EditorView.prototype.dispatch = function(tr) {
    let dispatchTransaction = this._props.dispatchTransaction;
    if (dispatchTransaction)
      dispatchTransaction.call(this, tr);
    else
      this.updateState(this.state.apply(tr));
  };
  function computeDocDeco(view) {
    let attrs = /* @__PURE__ */ Object.create(null);
    attrs.class = "ProseMirror";
    attrs.contenteditable = String(view.editable);
    view.someProp("attributes", (value) => {
      if (typeof value == "function")
        value = value(view.state);
      if (value)
        for (let attr in value) {
          if (attr == "class")
            attrs.class += " " + value[attr];
          else if (attr == "style")
            attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
          else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
            attrs[attr] = String(value[attr]);
        }
    });
    if (!attrs.translate)
      attrs.translate = "no";
    return [Decoration.node(0, view.state.doc.content.size, attrs)];
  }
  function updateCursorWrapper(view) {
    if (view.markCursor) {
      let dom = document.createElement("img");
      dom.className = "ProseMirror-separator";
      dom.setAttribute("mark-placeholder", "true");
      dom.setAttribute("alt", "");
      view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };
    } else {
      view.cursorWrapper = null;
    }
  }
  function getEditable(view) {
    return !view.someProp("editable", (value) => value(view.state) === false);
  }
  function selectionContextChanged(sel1, sel2) {
    let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
    return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
  }
  function buildNodeViews(view) {
    let result = /* @__PURE__ */ Object.create(null);
    function add2(obj) {
      for (let prop in obj)
        if (!Object.prototype.hasOwnProperty.call(result, prop))
          result[prop] = obj[prop];
    }
    view.someProp("nodeViews", add2);
    view.someProp("markViews", add2);
    return result;
  }
  function changedNodeViews(a, b2) {
    let nA = 0, nB = 0;
    for (let prop in a) {
      if (a[prop] != b2[prop])
        return true;
      nA++;
    }
    for (let _2 in b2)
      nB++;
    return nA != nB;
  }
  function checkStateComponent(plugin) {
    if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
      throw new RangeError("Plugins passed directly to the view must not have a state component");
  }
  var base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  };
  var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  };
  var mac$2 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
  for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;
  for (var i = 65; i <= 90; i++) {
    base[i] = String.fromCharCode(i + 32);
    shift[i] = String.fromCharCode(i);
  }
  for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
  function keyName(event) {
    var ignoreKey = mac$2 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
    var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
    if (name == "Esc") name = "Escape";
    if (name == "Del") name = "Delete";
    if (name == "Left") name = "ArrowLeft";
    if (name == "Up") name = "ArrowUp";
    if (name == "Right") name = "ArrowRight";
    if (name == "Down") name = "ArrowDown";
    return name;
  }
  const mac$1 = typeof navigator != "undefined" && /Mac|iP(hone|[oa]d)/.test(navigator.platform);
  const windows = typeof navigator != "undefined" && /Win/.test(navigator.platform);
  function normalizeKeyName(name) {
    let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
    if (result == "Space")
      result = " ";
    let alt, ctrl, shift2, meta;
    for (let i2 = 0; i2 < parts.length - 1; i2++) {
      let mod = parts[i2];
      if (/^(cmd|meta|m)$/i.test(mod))
        meta = true;
      else if (/^a(lt)?$/i.test(mod))
        alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod))
        ctrl = true;
      else if (/^s(hift)?$/i.test(mod))
        shift2 = true;
      else if (/^mod$/i.test(mod)) {
        if (mac$1)
          meta = true;
        else
          ctrl = true;
      } else
        throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
      result = "Alt-" + result;
    if (ctrl)
      result = "Ctrl-" + result;
    if (meta)
      result = "Meta-" + result;
    if (shift2)
      result = "Shift-" + result;
    return result;
  }
  function normalize(map) {
    let copy2 = /* @__PURE__ */ Object.create(null);
    for (let prop in map)
      copy2[normalizeKeyName(prop)] = map[prop];
    return copy2;
  }
  function modifiers(name, event, shift2 = true) {
    if (event.altKey)
      name = "Alt-" + name;
    if (event.ctrlKey)
      name = "Ctrl-" + name;
    if (event.metaKey)
      name = "Meta-" + name;
    if (shift2 && event.shiftKey)
      name = "Shift-" + name;
    return name;
  }
  function keymap(bindings) {
    return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
  }
  function keydownHandler(bindings) {
    let map = normalize(bindings);
    return function(view, event) {
      let name = keyName(event), baseName, direct = map[modifiers(name, event)];
      if (direct && direct(view.state, view.dispatch, view))
        return true;
      if (name.length == 1 && name != " ") {
        if (event.shiftKey) {
          let noShift = map[modifiers(name, event, false)];
          if (noShift && noShift(view.state, view.dispatch, view))
            return true;
        }
        if ((event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
        !(windows && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name) {
          let fromCode = map[modifiers(baseName, event)];
          if (fromCode && fromCode(view.state, view.dispatch, view))
            return true;
        }
      }
      return false;
    };
  }
  var GOOD_LEAF_SIZE = 200;
  var RopeSequence = function RopeSequence2() {
  };
  RopeSequence.prototype.append = function append(other) {
    if (!other.length) {
      return this;
    }
    other = RopeSequence.from(other);
    return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
  };
  RopeSequence.prototype.prepend = function prepend(other) {
    if (!other.length) {
      return this;
    }
    return RopeSequence.from(other).append(this);
  };
  RopeSequence.prototype.appendInner = function appendInner(other) {
    return new Append(this, other);
  };
  RopeSequence.prototype.slice = function slice(from, to) {
    if (from === void 0) from = 0;
    if (to === void 0) to = this.length;
    if (from >= to) {
      return RopeSequence.empty;
    }
    return this.sliceInner(Math.max(0, from), Math.min(this.length, to));
  };
  RopeSequence.prototype.get = function get2(i2) {
    if (i2 < 0 || i2 >= this.length) {
      return void 0;
    }
    return this.getInner(i2);
  };
  RopeSequence.prototype.forEach = function forEach2(f, from, to) {
    if (from === void 0) from = 0;
    if (to === void 0) to = this.length;
    if (from <= to) {
      this.forEachInner(f, from, to, 0);
    } else {
      this.forEachInvertedInner(f, from, to, 0);
    }
  };
  RopeSequence.prototype.map = function map(f, from, to) {
    if (from === void 0) from = 0;
    if (to === void 0) to = this.length;
    var result = [];
    this.forEach(function(elt, i2) {
      return result.push(f(elt, i2));
    }, from, to);
    return result;
  };
  RopeSequence.from = function from(values) {
    if (values instanceof RopeSequence) {
      return values;
    }
    return values && values.length ? new Leaf(values) : RopeSequence.empty;
  };
  var Leaf = /* @__PURE__ */ function(RopeSequence2) {
    function Leaf2(values) {
      RopeSequence2.call(this);
      this.values = values;
    }
    if (RopeSequence2) Leaf2.__proto__ = RopeSequence2;
    Leaf2.prototype = Object.create(RopeSequence2 && RopeSequence2.prototype);
    Leaf2.prototype.constructor = Leaf2;
    var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
    Leaf2.prototype.flatten = function flatten() {
      return this.values;
    };
    Leaf2.prototype.sliceInner = function sliceInner(from, to) {
      if (from == 0 && to == this.length) {
        return this;
      }
      return new Leaf2(this.values.slice(from, to));
    };
    Leaf2.prototype.getInner = function getInner(i2) {
      return this.values[i2];
    };
    Leaf2.prototype.forEachInner = function forEachInner(f, from, to, start) {
      for (var i2 = from; i2 < to; i2++) {
        if (f(this.values[i2], start + i2) === false) {
          return false;
        }
      }
    };
    Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from, to, start) {
      for (var i2 = from - 1; i2 >= to; i2--) {
        if (f(this.values[i2], start + i2) === false) {
          return false;
        }
      }
    };
    Leaf2.prototype.leafAppend = function leafAppend(other) {
      if (this.length + other.length <= GOOD_LEAF_SIZE) {
        return new Leaf2(this.values.concat(other.flatten()));
      }
    };
    Leaf2.prototype.leafPrepend = function leafPrepend(other) {
      if (this.length + other.length <= GOOD_LEAF_SIZE) {
        return new Leaf2(other.flatten().concat(this.values));
      }
    };
    prototypeAccessors.length.get = function() {
      return this.values.length;
    };
    prototypeAccessors.depth.get = function() {
      return 0;
    };
    Object.defineProperties(Leaf2.prototype, prototypeAccessors);
    return Leaf2;
  }(RopeSequence);
  RopeSequence.empty = new Leaf([]);
  var Append = /* @__PURE__ */ function(RopeSequence2) {
    function Append2(left, right) {
      RopeSequence2.call(this);
      this.left = left;
      this.right = right;
      this.length = left.length + right.length;
      this.depth = Math.max(left.depth, right.depth) + 1;
    }
    if (RopeSequence2) Append2.__proto__ = RopeSequence2;
    Append2.prototype = Object.create(RopeSequence2 && RopeSequence2.prototype);
    Append2.prototype.constructor = Append2;
    Append2.prototype.flatten = function flatten() {
      return this.left.flatten().concat(this.right.flatten());
    };
    Append2.prototype.getInner = function getInner(i2) {
      return i2 < this.left.length ? this.left.get(i2) : this.right.get(i2 - this.left.length);
    };
    Append2.prototype.forEachInner = function forEachInner(f, from, to, start) {
      var leftLen = this.left.length;
      if (from < leftLen && this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false) {
        return false;
      }
      if (to > leftLen && this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {
        return false;
      }
    };
    Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from, to, start) {
      var leftLen = this.left.length;
      if (from > leftLen && this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {
        return false;
      }
      if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false) {
        return false;
      }
    };
    Append2.prototype.sliceInner = function sliceInner(from, to) {
      if (from == 0 && to == this.length) {
        return this;
      }
      var leftLen = this.left.length;
      if (to <= leftLen) {
        return this.left.slice(from, to);
      }
      if (from >= leftLen) {
        return this.right.slice(from - leftLen, to - leftLen);
      }
      return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen));
    };
    Append2.prototype.leafAppend = function leafAppend(other) {
      var inner = this.right.leafAppend(other);
      if (inner) {
        return new Append2(this.left, inner);
      }
    };
    Append2.prototype.leafPrepend = function leafPrepend(other) {
      var inner = this.left.leafPrepend(other);
      if (inner) {
        return new Append2(inner, this.right);
      }
    };
    Append2.prototype.appendInner = function appendInner(other) {
      if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
        return new Append2(this.left, new Append2(this.right, other));
      }
      return new Append2(this, other);
    };
    return Append2;
  }(RopeSequence);
  const max_empty_items = 500;
  class Branch {
    constructor(items, eventCount) {
      this.items = items;
      this.eventCount = eventCount;
    }
    // Pop the latest event off the branch's history and apply it
    // to a document transform.
    popEvent(state, preserveItems) {
      if (this.eventCount == 0)
        return null;
      let end = this.items.length;
      for (; ; end--) {
        let next = this.items.get(end - 1);
        if (next.selection) {
          --end;
          break;
        }
      }
      let remap, mapFrom;
      if (preserveItems) {
        remap = this.remapping(end, this.items.length);
        mapFrom = remap.maps.length;
      }
      let transform = state.tr;
      let selection, remaining;
      let addAfter = [], addBefore = [];
      this.items.forEach((item, i2) => {
        if (!item.step) {
          if (!remap) {
            remap = this.remapping(end, i2 + 1);
            mapFrom = remap.maps.length;
          }
          mapFrom--;
          addBefore.push(item);
          return;
        }
        if (remap) {
          addBefore.push(new Item(item.map));
          let step = item.step.map(remap.slice(mapFrom)), map;
          if (step && transform.maybeStep(step).doc) {
            map = transform.mapping.maps[transform.mapping.maps.length - 1];
            addAfter.push(new Item(map, void 0, void 0, addAfter.length + addBefore.length));
          }
          mapFrom--;
          if (map)
            remap.appendMap(map, mapFrom);
        } else {
          transform.maybeStep(item.step);
        }
        if (item.selection) {
          selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
          remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
          return false;
        }
      }, this.items.length, 0);
      return { remaining, transform, selection };
    }
    // Create a new branch with the given transform added.
    addTransform(transform, selection, histOptions, preserveItems) {
      let newItems = [], eventCount = this.eventCount;
      let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
      for (let i2 = 0; i2 < transform.steps.length; i2++) {
        let step = transform.steps[i2].invert(transform.docs[i2]);
        let item = new Item(transform.mapping.maps[i2], step, selection), merged;
        if (merged = lastItem && lastItem.merge(item)) {
          item = merged;
          if (i2)
            newItems.pop();
          else
            oldItems = oldItems.slice(0, oldItems.length - 1);
        }
        newItems.push(item);
        if (selection) {
          eventCount++;
          selection = void 0;
        }
        if (!preserveItems)
          lastItem = item;
      }
      let overflow = eventCount - histOptions.depth;
      if (overflow > DEPTH_OVERFLOW) {
        oldItems = cutOffEvents(oldItems, overflow);
        eventCount -= overflow;
      }
      return new Branch(oldItems.append(newItems), eventCount);
    }
    remapping(from, to) {
      let maps = new Mapping();
      this.items.forEach((item, i2) => {
        let mirrorPos = item.mirrorOffset != null && i2 - item.mirrorOffset >= from ? maps.maps.length - item.mirrorOffset : void 0;
        maps.appendMap(item.map, mirrorPos);
      }, from, to);
      return maps;
    }
    addMaps(array) {
      if (this.eventCount == 0)
        return this;
      return new Branch(this.items.append(array.map((map) => new Item(map))), this.eventCount);
    }
    // When the collab module receives remote changes, the history has
    // to know about those, so that it can adjust the steps that were
    // rebased on top of the remote changes, and include the position
    // maps for the remote changes in its array of items.
    rebased(rebasedTransform, rebasedCount) {
      if (!this.eventCount)
        return this;
      let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);
      let mapping = rebasedTransform.mapping;
      let newUntil = rebasedTransform.steps.length;
      let eventCount = this.eventCount;
      this.items.forEach((item) => {
        if (item.selection)
          eventCount--;
      }, start);
      let iRebased = rebasedCount;
      this.items.forEach((item) => {
        let pos = mapping.getMirror(--iRebased);
        if (pos == null)
          return;
        newUntil = Math.min(newUntil, pos);
        let map = mapping.maps[pos];
        if (item.step) {
          let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
          let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
          if (selection)
            eventCount++;
          rebasedItems.push(new Item(map, step, selection));
        } else {
          rebasedItems.push(new Item(map));
        }
      }, start);
      let newMaps = [];
      for (let i2 = rebasedCount; i2 < newUntil; i2++)
        newMaps.push(new Item(mapping.maps[i2]));
      let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
      let branch = new Branch(items, eventCount);
      if (branch.emptyItemCount() > max_empty_items)
        branch = branch.compress(this.items.length - rebasedItems.length);
      return branch;
    }
    emptyItemCount() {
      let count = 0;
      this.items.forEach((item) => {
        if (!item.step)
          count++;
      });
      return count;
    }
    // Compressing a branch means rewriting it to push the air (map-only
    // items) out. During collaboration, these naturally accumulate
    // because each remote change adds one. The `upto` argument is used
    // to ensure that only the items below a given level are compressed,
    // because `rebased` relies on a clean, untouched set of items in
    // order to associate old items with rebased steps.
    compress(upto = this.items.length) {
      let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
      let items = [], events = 0;
      this.items.forEach((item, i2) => {
        if (i2 >= upto) {
          items.push(item);
          if (item.selection)
            events++;
        } else if (item.step) {
          let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();
          mapFrom--;
          if (map)
            remap.appendMap(map, mapFrom);
          if (step) {
            let selection = item.selection && item.selection.map(remap.slice(mapFrom));
            if (selection)
              events++;
            let newItem = new Item(map.invert(), step, selection), merged, last2 = items.length - 1;
            if (merged = items.length && items[last2].merge(newItem))
              items[last2] = merged;
            else
              items.push(newItem);
          }
        } else if (item.map) {
          mapFrom--;
        }
      }, this.items.length, 0);
      return new Branch(RopeSequence.from(items.reverse()), events);
    }
  }
  Branch.empty = new Branch(RopeSequence.empty, 0);
  function cutOffEvents(items, n) {
    let cutPoint;
    items.forEach((item, i2) => {
      if (item.selection && n-- == 0) {
        cutPoint = i2;
        return false;
      }
    });
    return items.slice(cutPoint);
  }
  class Item {
    constructor(map, step, selection, mirrorOffset) {
      this.map = map;
      this.step = step;
      this.selection = selection;
      this.mirrorOffset = mirrorOffset;
    }
    merge(other) {
      if (this.step && other.step && !other.selection) {
        let step = other.step.merge(this.step);
        if (step)
          return new Item(step.getMap().invert(), step, this.selection);
      }
    }
  }
  class HistoryState {
    constructor(done, undone, prevRanges, prevTime, prevComposition) {
      this.done = done;
      this.undone = undone;
      this.prevRanges = prevRanges;
      this.prevTime = prevTime;
      this.prevComposition = prevComposition;
    }
  }
  const DEPTH_OVERFLOW = 20;
  function applyTransaction(history2, state, tr, options) {
    let historyTr = tr.getMeta(historyKey), rebased;
    if (historyTr)
      return historyTr.historyState;
    if (tr.getMeta(closeHistoryKey))
      history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
    let appended = tr.getMeta("appendedTransaction");
    if (tr.steps.length == 0) {
      return history2;
    } else if (appended && appended.getMeta(historyKey)) {
      if (appended.getMeta(historyKey).redo)
        return new HistoryState(history2.done.addTransform(tr, void 0, options, mustPreserveItems(state)), history2.undone, rangesFor(tr.mapping.maps), history2.prevTime, history2.prevComposition);
      else
        return new HistoryState(history2.done, history2.undone.addTransform(tr, void 0, options, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
    } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
      let composition = tr.getMeta("composition");
      let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history2.prevRanges));
      let prevRanges = appended ? mapRanges(history2.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);
      return new HistoryState(history2.done.addTransform(tr, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history2.prevComposition : composition);
    } else if (rebased = tr.getMeta("rebased")) {
      return new HistoryState(history2.done.rebased(tr, rebased), history2.undone.rebased(tr, rebased), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);
    } else {
      return new HistoryState(history2.done.addMaps(tr.mapping.maps), history2.undone.addMaps(tr.mapping.maps), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);
    }
  }
  function isAdjacentTo(transform, prevRanges) {
    if (!prevRanges)
      return false;
    if (!transform.docChanged)
      return true;
    let adjacent = false;
    transform.mapping.maps[0].forEach((start, end) => {
      for (let i2 = 0; i2 < prevRanges.length; i2 += 2)
        if (start <= prevRanges[i2 + 1] && end >= prevRanges[i2])
          adjacent = true;
    });
    return adjacent;
  }
  function rangesFor(maps) {
    let result = [];
    for (let i2 = maps.length - 1; i2 >= 0 && result.length == 0; i2--)
      maps[i2].forEach((_from, _to, from, to) => result.push(from, to));
    return result;
  }
  function mapRanges(ranges, mapping) {
    if (!ranges)
      return null;
    let result = [];
    for (let i2 = 0; i2 < ranges.length; i2 += 2) {
      let from = mapping.map(ranges[i2], 1), to = mapping.map(ranges[i2 + 1], -1);
      if (from <= to)
        result.push(from, to);
    }
    return result;
  }
  function histTransaction(history2, state, redo2) {
    let preserveItems = mustPreserveItems(state);
    let histOptions = historyKey.get(state).spec.config;
    let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
    if (!pop)
      return null;
    let selection = pop.selection.resolve(pop.transform.doc);
    let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
    let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
    return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist });
  }
  let cachedPreserveItems = false, cachedPreserveItemsPlugins = null;
  function mustPreserveItems(state) {
    let plugins = state.plugins;
    if (cachedPreserveItemsPlugins != plugins) {
      cachedPreserveItems = false;
      cachedPreserveItemsPlugins = plugins;
      for (let i2 = 0; i2 < plugins.length; i2++)
        if (plugins[i2].spec.historyPreserveItems) {
          cachedPreserveItems = true;
          break;
        }
    }
    return cachedPreserveItems;
  }
  const historyKey = new PluginKey("history");
  const closeHistoryKey = new PluginKey("closeHistory");
  function history(config = {}) {
    config = {
      depth: config.depth || 100,
      newGroupDelay: config.newGroupDelay || 500
    };
    return new Plugin({
      key: historyKey,
      state: {
        init() {
          return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
        },
        apply(tr, hist, state) {
          return applyTransaction(hist, state, tr, config);
        }
      },
      config,
      props: {
        handleDOMEvents: {
          beforeinput(view, e) {
            let inputType = e.inputType;
            let command = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
            if (!command)
              return false;
            e.preventDefault();
            return command(view.state, view.dispatch);
          }
        }
      }
    });
  }
  function buildCommand(redo2, scroll) {
    return (state, dispatch) => {
      let hist = historyKey.getState(state);
      if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0)
        return false;
      if (dispatch) {
        let tr = histTransaction(hist, state, redo2);
        if (tr)
          dispatch(scroll ? tr.scrollIntoView() : tr);
      }
      return true;
    };
  }
  const undo = buildCommand(false, true);
  const redo = buildCommand(true, true);
  function crelt() {
    var elt = arguments[0];
    if (typeof elt == "string") elt = document.createElement(elt);
    var i2 = 1, next = arguments[1];
    if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
      for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {
        var value = next[name];
        if (typeof value == "string") elt.setAttribute(name, value);
        else if (value != null) elt[name] = value;
      }
      i2++;
    }
    for (; i2 < arguments.length; i2++) add$1(elt, arguments[i2]);
    return elt;
  }
  function add$1(elt, child) {
    if (typeof child == "string") {
      elt.appendChild(document.createTextNode(child));
    } else if (child == null) ;
    else if (child.nodeType != null) {
      elt.appendChild(child);
    } else if (Array.isArray(child)) {
      for (var i2 = 0; i2 < child.length; i2++) add$1(elt, child[i2]);
    } else {
      throw new RangeError("Unsupported child node: " + child);
    }
  }
  const deleteSelection = (state, dispatch) => {
    if (state.selection.empty)
      return false;
    if (dispatch)
      dispatch(state.tr.deleteSelection().scrollIntoView());
    return true;
  };
  function atBlockStart(state, view) {
    let { $cursor } = state.selection;
    if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
      return null;
    return $cursor;
  }
  const joinBackward = (state, dispatch, view) => {
    let $cursor = atBlockStart(state, view);
    if (!$cursor)
      return false;
    let $cut = findCutBefore($cursor);
    if (!$cut) {
      let range = $cursor.blockRange(), target = range && liftTarget(range);
      if (target == null)
        return false;
      if (dispatch)
        dispatch(state.tr.lift(range, target).scrollIntoView());
      return true;
    }
    let before = $cut.nodeBefore;
    if (deleteBarrier(state, $cut, dispatch, -1))
      return true;
    if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
      for (let depth = $cursor.depth; ; depth--) {
        let delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);
        if (delStep && delStep.slice.size < delStep.to - delStep.from) {
          if (dispatch) {
            let tr = state.tr.step(delStep);
            tr.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
            dispatch(tr.scrollIntoView());
          }
          return true;
        }
        if (depth == 1 || $cursor.node(depth - 1).childCount > 1)
          break;
      }
    }
    if (before.isAtom && $cut.depth == $cursor.depth - 1) {
      if (dispatch)
        dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
      return true;
    }
    return false;
  };
  function textblockAt(node, side, only = false) {
    for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
      if (scan.isTextblock)
        return true;
      if (only && scan.childCount != 1)
        return false;
    }
    return false;
  }
  const selectNodeBackward = (state, dispatch, view) => {
    let { $head, empty: empty2 } = state.selection, $cut = $head;
    if (!empty2)
      return false;
    if ($head.parent.isTextblock) {
      if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
        return false;
      $cut = findCutBefore($head);
    }
    let node = $cut && $cut.nodeBefore;
    if (!node || !NodeSelection.isSelectable(node))
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
    return true;
  };
  function findCutBefore($pos) {
    if (!$pos.parent.type.spec.isolating)
      for (let i2 = $pos.depth - 1; i2 >= 0; i2--) {
        if ($pos.index(i2) > 0)
          return $pos.doc.resolve($pos.before(i2 + 1));
        if ($pos.node(i2).type.spec.isolating)
          break;
      }
    return null;
  }
  function atBlockEnd(state, view) {
    let { $cursor } = state.selection;
    if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
      return null;
    return $cursor;
  }
  const joinForward = (state, dispatch, view) => {
    let $cursor = atBlockEnd(state, view);
    if (!$cursor)
      return false;
    let $cut = findCutAfter($cursor);
    if (!$cut)
      return false;
    let after = $cut.nodeAfter;
    if (deleteBarrier(state, $cut, dispatch, 1))
      return true;
    if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
      let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch) {
          let tr = state.tr.step(delStep);
          tr.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
    }
    if (after.isAtom && $cut.depth == $cursor.depth - 1) {
      if (dispatch)
        dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
      return true;
    }
    return false;
  };
  const selectNodeForward = (state, dispatch, view) => {
    let { $head, empty: empty2 } = state.selection, $cut = $head;
    if (!empty2)
      return false;
    if ($head.parent.isTextblock) {
      if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
        return false;
      $cut = findCutAfter($head);
    }
    let node = $cut && $cut.nodeAfter;
    if (!node || !NodeSelection.isSelectable(node))
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
    return true;
  };
  function findCutAfter($pos) {
    if (!$pos.parent.type.spec.isolating)
      for (let i2 = $pos.depth - 1; i2 >= 0; i2--) {
        let parent = $pos.node(i2);
        if ($pos.index(i2) + 1 < parent.childCount)
          return $pos.doc.resolve($pos.after(i2 + 1));
        if (parent.type.spec.isolating)
          break;
      }
    return null;
  }
  const lift = (state, dispatch) => {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  };
  const newlineInCode = (state, dispatch) => {
    let { $head, $anchor } = state.selection;
    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
      return false;
    if (dispatch)
      dispatch(state.tr.insertText("\n").scrollIntoView());
    return true;
  };
  function defaultBlockAt(match) {
    for (let i2 = 0; i2 < match.edgeCount; i2++) {
      let { type } = match.edge(i2);
      if (type.isTextblock && !type.hasRequiredAttrs())
        return type;
    }
    return null;
  }
  const exitCode = (state, dispatch) => {
    let { $head, $anchor } = state.selection;
    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
      return false;
    let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
    if (!type || !above.canReplaceWith(after, after, type))
      return false;
    if (dispatch) {
      let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
      tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
  const createParagraphNear = (state, dispatch) => {
    let sel = state.selection, { $from, $to } = sel;
    if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
      return false;
    let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
    if (!type || !type.isTextblock)
      return false;
    if (dispatch) {
      let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
      let tr = state.tr.insert(side, type.createAndFill());
      tr.setSelection(TextSelection.create(tr.doc, side + 1));
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
  const liftEmptyBlock = (state, dispatch) => {
    let { $cursor } = state.selection;
    if (!$cursor || $cursor.parent.content.size)
      return false;
    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
      let before = $cursor.before();
      if (canSplit(state.doc, before)) {
        if (dispatch)
          dispatch(state.tr.split(before).scrollIntoView());
        return true;
      }
    }
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  };
  function splitBlockAs(splitNode) {
    return (state, dispatch) => {
      let { $from, $to } = state.selection;
      if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
        if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
          return false;
        if (dispatch)
          dispatch(state.tr.split($from.pos).scrollIntoView());
        return true;
      }
      if (!$from.depth)
        return false;
      let types = [];
      let splitDepth, deflt, atEnd = false, atStart = false;
      for (let d = $from.depth; ; d--) {
        let node = $from.node(d);
        if (node.isBlock) {
          atEnd = $from.end(d) == $from.pos + ($from.depth - d);
          atStart = $from.start(d) == $from.pos - ($from.depth - d);
          deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));
          types.unshift(atEnd && deflt ? { type: deflt } : null);
          splitDepth = d;
          break;
        } else {
          if (d == 1)
            return false;
          types.unshift(null);
        }
      }
      let tr = state.tr;
      if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
        tr.deleteSelection();
      let splitPos = tr.mapping.map($from.pos);
      let can = canSplit(tr.doc, splitPos, types.length, types);
      if (!can) {
        types[0] = deflt ? { type: deflt } : null;
        can = canSplit(tr.doc, splitPos, types.length, types);
      }
      if (!can)
        return false;
      tr.split(splitPos, types.length, types);
      if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {
        let first = tr.mapping.map($from.before(splitDepth)), $first = tr.doc.resolve(first);
        if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))
          tr.setNodeMarkup(tr.mapping.map($from.before(splitDepth)), deflt);
      }
      if (dispatch)
        dispatch(tr.scrollIntoView());
      return true;
    };
  }
  const splitBlock = splitBlockAs();
  const selectAll = (state, dispatch) => {
    if (dispatch)
      dispatch(state.tr.setSelection(new AllSelection(state.doc)));
    return true;
  };
  function joinMaybeClear(state, $pos, dispatch) {
    let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();
    if (!before || !after || !before.type.compatibleContent(after.type))
      return false;
    if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
      if (dispatch)
        dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
      return true;
    }
    if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
      return false;
    if (dispatch)
      dispatch(state.tr.join($pos.pos).scrollIntoView());
    return true;
  }
  function deleteBarrier(state, $cut, dispatch, dir) {
    let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
    let isolated = before.type.spec.isolating || after.type.spec.isolating;
    if (!isolated && joinMaybeClear(state, $cut, dispatch))
      return true;
    let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);
    if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
      if (dispatch) {
        let end = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;
        for (let i2 = conn.length - 1; i2 >= 0; i2--)
          wrap2 = Fragment.from(conn[i2].create(null, wrap2));
        wrap2 = Fragment.from(before.copy(wrap2));
        let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap2, 1, 0), conn.length, true));
        let $joinAt = tr.doc.resolve(end + 2 * conn.length);
        if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && canJoin(tr.doc, $joinAt.pos))
          tr.join($joinAt.pos);
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
    let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);
    let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
    if (target != null && target >= $cut.depth) {
      if (dispatch)
        dispatch(state.tr.lift(range, target).scrollIntoView());
      return true;
    }
    if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
      let at = before, wrap2 = [];
      for (; ; ) {
        wrap2.push(at);
        if (at.isTextblock)
          break;
        at = at.lastChild;
      }
      let afterText = after, afterDepth = 1;
      for (; !afterText.isTextblock; afterText = afterText.firstChild)
        afterDepth++;
      if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
        if (dispatch) {
          let end = Fragment.empty;
          for (let i2 = wrap2.length - 1; i2 >= 0; i2--)
            end = Fragment.from(wrap2[i2].copy(end));
          let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap2.length, 0), 0, true));
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
    }
    return false;
  }
  function selectTextblockSide(side) {
    return function(state, dispatch) {
      let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
      let depth = $pos.depth;
      while ($pos.node(depth).isInline) {
        if (!depth)
          return false;
        depth--;
      }
      if (!$pos.node(depth).isTextblock)
        return false;
      if (dispatch)
        dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
      return true;
    };
  }
  const selectTextblockStart = selectTextblockSide(-1);
  const selectTextblockEnd = selectTextblockSide(1);
  function wrapIn(nodeType, attrs = null) {
    return function(state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
      if (!wrapping)
        return false;
      if (dispatch)
        dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
      return true;
    };
  }
  function setBlockType(nodeType, attrs = null) {
    return function(state, dispatch) {
      let applicable = false;
      for (let i2 = 0; i2 < state.selection.ranges.length && !applicable; i2++) {
        let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i2];
        state.doc.nodesBetween(from, to, (node, pos) => {
          if (applicable)
            return false;
          if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
            return;
          if (node.type == nodeType) {
            applicable = true;
          } else {
            let $pos = state.doc.resolve(pos), index = $pos.index();
            applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
          }
        });
      }
      if (!applicable)
        return false;
      if (dispatch) {
        let tr = state.tr;
        for (let i2 = 0; i2 < state.selection.ranges.length; i2++) {
          let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i2];
          tr.setBlockType(from, to, nodeType, attrs);
        }
        dispatch(tr.scrollIntoView());
      }
      return true;
    };
  }
  function markApplies(doc2, ranges, type, enterAtoms) {
    for (let i2 = 0; i2 < ranges.length; i2++) {
      let { $from, $to } = ranges[i2];
      let can = $from.depth == 0 ? doc2.inlineContent && doc2.type.allowsMarkType(type) : false;
      doc2.nodesBetween($from.pos, $to.pos, (node, pos) => {
        if (can || false)
          return false;
        can = node.inlineContent && node.type.allowsMarkType(type);
      });
      if (can)
        return true;
    }
    return false;
  }
  function toggleMark(markType, attrs = null, options) {
    return function(state, dispatch) {
      let { empty: empty2, $cursor, ranges } = state.selection;
      if (empty2 && !$cursor || !markApplies(state.doc, ranges, markType))
        return false;
      if (dispatch) {
        if ($cursor) {
          if (markType.isInSet(state.storedMarks || $cursor.marks()))
            dispatch(state.tr.removeStoredMark(markType));
          else
            dispatch(state.tr.addStoredMark(markType.create(attrs)));
        } else {
          let add2, tr = state.tr;
          {
            add2 = !ranges.some((r) => state.doc.rangeHasMark(r.$from.pos, r.$to.pos, markType));
          }
          for (let i2 = 0; i2 < ranges.length; i2++) {
            let { $from, $to } = ranges[i2];
            if (!add2) {
              tr.removeMark($from.pos, $to.pos, markType);
            } else {
              let from = $from.pos, to = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore;
              let spaceStart = start && start.isText ? /^\s*/.exec(start.text)[0].length : 0;
              let spaceEnd = end && end.isText ? /\s*$/.exec(end.text)[0].length : 0;
              if (from + spaceStart < to) {
                from += spaceStart;
                to -= spaceEnd;
              }
              tr.addMark(from, to, markType.create(attrs));
            }
          }
          dispatch(tr.scrollIntoView());
        }
      }
      return true;
    };
  }
  function chainCommands(...commands) {
    return function(state, dispatch, view) {
      for (let i2 = 0; i2 < commands.length; i2++)
        if (commands[i2](state, dispatch, view))
          return true;
      return false;
    };
  }
  let backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
  let del = chainCommands(deleteSelection, joinForward, selectNodeForward);
  const pcBaseKeymap = {
    "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
    "Mod-Enter": exitCode,
    "Backspace": backspace,
    "Mod-Backspace": backspace,
    "Shift-Backspace": backspace,
    "Delete": del,
    "Mod-Delete": del,
    "Mod-a": selectAll
  };
  const macBaseKeymap = {
    "Ctrl-h": pcBaseKeymap["Backspace"],
    "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
    "Ctrl-d": pcBaseKeymap["Delete"],
    "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
    "Alt-Delete": pcBaseKeymap["Mod-Delete"],
    "Alt-d": pcBaseKeymap["Mod-Delete"],
    "Ctrl-a": selectTextblockStart,
    "Ctrl-e": selectTextblockEnd
  };
  for (let key2 in pcBaseKeymap)
    macBaseKeymap[key2] = pcBaseKeymap[key2];
  const mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
  const baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;
  const SVG = "http://www.w3.org/2000/svg";
  const XLINK = "http://www.w3.org/1999/xlink";
  const prefix$2 = "ProseMirror-icon";
  function hashPath(path) {
    let hash = 0;
    for (let i2 = 0; i2 < path.length; i2++)
      hash = (hash << 5) - hash + path.charCodeAt(i2) | 0;
    return hash;
  }
  function getIcon(root, icon) {
    let doc2 = (root.nodeType == 9 ? root : root.ownerDocument) || document;
    let node = doc2.createElement("div");
    node.className = prefix$2;
    if (icon.path) {
      let { path, width, height } = icon;
      let name = "pm-icon-" + hashPath(path).toString(16);
      if (!doc2.getElementById(name))
        buildSVG(root, name, icon);
      let svg2 = node.appendChild(doc2.createElementNS(SVG, "svg"));
      svg2.style.width = width / height + "em";
      let use2 = svg2.appendChild(doc2.createElementNS(SVG, "use"));
      use2.setAttributeNS(XLINK, "href", /([^#]*)/.exec(doc2.location.toString())[1] + "#" + name);
    } else if (icon.dom) {
      node.appendChild(icon.dom.cloneNode(true));
    } else {
      let { text: text2, css } = icon;
      node.appendChild(doc2.createElement("span")).textContent = text2 || "";
      if (css)
        node.firstChild.style.cssText = css;
    }
    return node;
  }
  function buildSVG(root, name, data) {
    let [doc2, top] = root.nodeType == 9 ? [root, root.body] : [root.ownerDocument || document, root];
    let collection = doc2.getElementById(prefix$2 + "-collection");
    if (!collection) {
      collection = doc2.createElementNS(SVG, "svg");
      collection.id = prefix$2 + "-collection";
      collection.style.display = "none";
      top.insertBefore(collection, top.firstChild);
    }
    let sym = doc2.createElementNS(SVG, "symbol");
    sym.id = name;
    sym.setAttribute("viewBox", "0 0 " + data.width + " " + data.height);
    let path = sym.appendChild(doc2.createElementNS(SVG, "path"));
    path.setAttribute("d", data.path);
    collection.appendChild(sym);
  }
  const prefix$1 = "ProseMirror-menu";
  class MenuItem {
    /**
    Create a menu item.
    */
    constructor(spec) {
      this.spec = spec;
    }
    /**
    Renders the icon according to its [display
    spec](https://prosemirror.net/docs/ref/#menu.MenuItemSpec.display), and adds an event handler which
    executes the command when the representation is clicked.
    */
    render(view) {
      let spec = this.spec;
      let dom = spec.render ? spec.render(view) : spec.icon ? getIcon(view.root, spec.icon) : spec.label ? crelt("div", null, translate(view, spec.label)) : null;
      if (!dom)
        throw new RangeError("MenuItem without icon or label property");
      if (spec.title) {
        const title = typeof spec.title === "function" ? spec.title(view.state) : spec.title;
        dom.setAttribute("title", translate(view, title));
      }
      if (spec.class)
        dom.classList.add(spec.class);
      if (spec.css)
        dom.style.cssText += spec.css;
      dom.addEventListener("mousedown", (e) => {
        e.preventDefault();
        if (!dom.classList.contains(prefix$1 + "-disabled"))
          spec.run(view.state, view.dispatch, view, e);
      });
      function update(state) {
        if (spec.select) {
          let selected = spec.select(state);
          dom.style.display = selected ? "" : "none";
          if (!selected)
            return false;
        }
        let enabled = true;
        if (spec.enable) {
          enabled = spec.enable(state) || false;
          setClass(dom, prefix$1 + "-disabled", !enabled);
        }
        if (spec.active) {
          let active = enabled && spec.active(state) || false;
          setClass(dom, prefix$1 + "-active", active);
        }
        return true;
      }
      return { dom, update };
    }
  }
  function translate(view, text2) {
    return view._props.translate ? view._props.translate(text2) : text2;
  }
  function combineUpdates(updates, nodes2) {
    return (state) => {
      let something = false;
      for (let i2 = 0; i2 < updates.length; i2++) {
        let up = updates[i2](state);
        nodes2[i2].style.display = up ? "" : "none";
        if (up)
          something = true;
      }
      return something;
    };
  }
  function renderGrouped(view, content) {
    let result = document.createDocumentFragment();
    let updates = [], separators = [];
    for (let i2 = 0; i2 < content.length; i2++) {
      let items = content[i2], localUpdates = [], localNodes = [];
      for (let j2 = 0; j2 < items.length; j2++) {
        let { dom, update: update2 } = items[j2].render(view);
        let span = crelt("span", { class: prefix$1 + "item" }, dom);
        result.appendChild(span);
        localNodes.push(span);
        localUpdates.push(update2);
      }
      if (localUpdates.length) {
        updates.push(combineUpdates(localUpdates, localNodes));
        if (i2 < content.length - 1)
          separators.push(result.appendChild(separator()));
      }
    }
    function update(state) {
      let something = false, needSep = false;
      for (let i2 = 0; i2 < updates.length; i2++) {
        let hasContent = updates[i2](state);
        if (i2)
          separators[i2 - 1].style.display = needSep && hasContent ? "" : "none";
        needSep = hasContent;
        if (hasContent)
          something = true;
      }
      return something;
    }
    return { dom: result, update };
  }
  function separator() {
    return crelt("span", { class: prefix$1 + "separator" });
  }
  function setClass(dom, cls, on) {
    if (on)
      dom.classList.add(cls);
    else
      dom.classList.remove(cls);
  }
  const prefix = "ProseMirror-menubar";
  function isIOS() {
    if (typeof navigator == "undefined")
      return false;
    let agent2 = navigator.userAgent;
    return !/Edge\/\d/.test(agent2) && /AppleWebKit/.test(agent2) && /Mobile\/\w+/.test(agent2);
  }
  function menuBar(options) {
    return new Plugin({
      view(editorView) {
        return new MenuBarView(editorView, options);
      }
    });
  }
  class MenuBarView {
    constructor(editorView, options) {
      this.editorView = editorView;
      this.options = options;
      this.spacer = null;
      this.maxHeight = 0;
      this.widthForMaxHeight = 0;
      this.floating = false;
      this.scrollHandler = null;
      this.root = editorView.root;
      this.wrapper = crelt("div", { class: prefix + "-wrapper" });
      this.menu = this.wrapper.appendChild(crelt("div", { class: prefix }));
      this.menu.className = prefix;
      if (editorView.dom.parentNode)
        editorView.dom.parentNode.replaceChild(this.wrapper, editorView.dom);
      this.wrapper.appendChild(editorView.dom);
      let { dom, update } = renderGrouped(this.editorView, this.options.content);
      this.contentUpdate = update;
      this.menu.appendChild(dom);
      this.update();
      if (options.floating && !isIOS()) {
        this.updateFloat();
        let potentialScrollers = getAllWrapping(this.wrapper);
        this.scrollHandler = (e) => {
          let root = this.editorView.root;
          if (!(root.body || root).contains(this.wrapper))
            potentialScrollers.forEach((el) => el.removeEventListener("scroll", this.scrollHandler));
          else
            this.updateFloat(e.target.getBoundingClientRect ? e.target : void 0);
        };
        potentialScrollers.forEach((el) => el.addEventListener("scroll", this.scrollHandler));
      }
    }
    update() {
      if (this.editorView.root != this.root) {
        let { dom, update } = renderGrouped(this.editorView, this.options.content);
        this.contentUpdate = update;
        this.menu.replaceChild(dom, this.menu.firstChild);
        this.root = this.editorView.root;
      }
      this.contentUpdate(this.editorView.state);
      if (this.floating) {
        this.updateScrollCursor();
      } else {
        if (this.menu.offsetWidth != this.widthForMaxHeight) {
          this.widthForMaxHeight = this.menu.offsetWidth;
          this.maxHeight = 0;
        }
        if (this.menu.offsetHeight > this.maxHeight) {
          this.maxHeight = this.menu.offsetHeight;
          this.menu.style.minHeight = this.maxHeight + "px";
        }
      }
    }
    updateScrollCursor() {
      let selection = this.editorView.root.getSelection();
      if (!selection.focusNode)
        return;
      let rects = selection.getRangeAt(0).getClientRects();
      let selRect = rects[selectionIsInverted(selection) ? 0 : rects.length - 1];
      if (!selRect)
        return;
      let menuRect = this.menu.getBoundingClientRect();
      if (selRect.top < menuRect.bottom && selRect.bottom > menuRect.top) {
        let scrollable = findWrappingScrollable(this.wrapper);
        if (scrollable)
          scrollable.scrollTop -= menuRect.bottom - selRect.top;
      }
    }
    updateFloat(scrollAncestor) {
      let parent = this.wrapper, editorRect = parent.getBoundingClientRect(), top = scrollAncestor ? Math.max(0, scrollAncestor.getBoundingClientRect().top) : 0;
      if (this.floating) {
        if (editorRect.top >= top || editorRect.bottom < this.menu.offsetHeight + 10) {
          this.floating = false;
          this.menu.style.position = this.menu.style.left = this.menu.style.top = this.menu.style.width = "";
          this.menu.style.display = "";
          this.spacer.parentNode.removeChild(this.spacer);
          this.spacer = null;
        } else {
          let border = (parent.offsetWidth - parent.clientWidth) / 2;
          this.menu.style.left = editorRect.left + border + "px";
          this.menu.style.display = editorRect.top > (this.editorView.dom.ownerDocument.defaultView || window).innerHeight ? "none" : "";
          if (scrollAncestor)
            this.menu.style.top = top + "px";
        }
      } else {
        if (editorRect.top < top && editorRect.bottom >= this.menu.offsetHeight + 10) {
          this.floating = true;
          let menuRect = this.menu.getBoundingClientRect();
          this.menu.style.left = menuRect.left + "px";
          this.menu.style.width = menuRect.width + "px";
          if (scrollAncestor)
            this.menu.style.top = top + "px";
          this.menu.style.position = "fixed";
          this.spacer = crelt("div", { class: prefix + "-spacer", style: `height: ${menuRect.height}px` });
          parent.insertBefore(this.spacer, this.menu);
        }
      }
    }
    destroy() {
      if (this.wrapper.parentNode)
        this.wrapper.parentNode.replaceChild(this.editorView.dom, this.wrapper);
    }
  }
  function selectionIsInverted(selection) {
    if (selection.anchorNode == selection.focusNode)
      return selection.anchorOffset > selection.focusOffset;
    return selection.anchorNode.compareDocumentPosition(selection.focusNode) == Node.DOCUMENT_POSITION_FOLLOWING;
  }
  function findWrappingScrollable(node) {
    for (let cur = node.parentNode; cur; cur = cur.parentNode)
      if (cur.scrollHeight > cur.clientHeight)
        return cur;
  }
  function getAllWrapping(node) {
    let res = [node.ownerDocument.defaultView || window];
    for (let cur = node.parentNode; cur; cur = cur.parentNode)
      res.push(cur);
    return res;
  }
  const olDOM = ["ol", 0], ulDOM = ["ul", 0], liDOM = ["li", 0];
  const orderedList = {
    attrs: { order: { default: 1, validate: "number" } },
    parseDOM: [{ tag: "ol", getAttrs(dom) {
      return { order: dom.hasAttribute("start") ? +dom.getAttribute("start") : 1 };
    } }],
    toDOM(node) {
      return node.attrs.order == 1 ? olDOM : ["ol", { start: node.attrs.order }, 0];
    }
  };
  const bulletList = {
    parseDOM: [{ tag: "ul" }],
    toDOM() {
      return ulDOM;
    }
  };
  const listItem = {
    parseDOM: [{ tag: "li" }],
    toDOM() {
      return liDOM;
    },
    defining: true
  };
  function add(obj, props) {
    let copy2 = {};
    for (let prop in obj)
      copy2[prop] = obj[prop];
    for (let prop in props)
      copy2[prop] = props[prop];
    return copy2;
  }
  function addListNodes(nodes2, itemContent, listGroup) {
    return nodes2.append({
      ordered_list: add(orderedList, { content: "list_item+", group: listGroup }),
      bullet_list: add(bulletList, { content: "list_item+", group: listGroup }),
      list_item: add(listItem, { content: itemContent })
    });
  }
  function wrapInList(listType, attrs = null) {
    return function(state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to);
      if (!range)
        return false;
      let tr = dispatch ? state.tr : null;
      if (!wrapRangeInList(tr, range, listType, attrs))
        return false;
      if (dispatch)
        dispatch(tr.scrollIntoView());
      return true;
    };
  }
  function wrapRangeInList(tr, range, listType, attrs = null) {
    let doJoin = false, outerRange = range, doc2 = range.$from.doc;
    if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
      if (range.$from.index(range.depth - 1) == 0)
        return false;
      let $insert = doc2.resolve(range.start - 2);
      outerRange = new NodeRange($insert, $insert, range.depth);
      if (range.endIndex < range.parent.childCount)
        range = new NodeRange(range.$from, doc2.resolve(range.$to.end(range.depth)), range.depth);
      doJoin = true;
    }
    let wrap2 = findWrapping(outerRange, listType, attrs, range);
    if (!wrap2)
      return false;
    if (tr)
      doWrapInList(tr, range, wrap2, doJoin, listType);
    return true;
  }
  function doWrapInList(tr, range, wrappers, joinBefore, listType) {
    let content = Fragment.empty;
    for (let i2 = wrappers.length - 1; i2 >= 0; i2--)
      content = Fragment.from(wrappers[i2].type.create(wrappers[i2].attrs, content));
    tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
    let found2 = 0;
    for (let i2 = 0; i2 < wrappers.length; i2++)
      if (wrappers[i2].type == listType)
        found2 = i2 + 1;
    let splitDepth = wrappers.length - found2;
    let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
    for (let i2 = range.startIndex, e = range.endIndex, first = true; i2 < e; i2++, first = false) {
      if (!first && canSplit(tr.doc, splitPos, splitDepth)) {
        tr.split(splitPos, splitDepth);
        splitPos += 2 * splitDepth;
      }
      splitPos += parent.child(i2).nodeSize;
    }
    return tr;
  }
  function liftListItem(itemType) {
    return function(state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
      if (!range)
        return false;
      if (!dispatch)
        return true;
      if ($from.node(range.depth - 1).type == itemType)
        return liftToOuterList(state, dispatch, itemType, range);
      else
        return liftOutOfList(state, dispatch, range);
    };
  }
  function liftToOuterList(state, dispatch, itemType, range) {
    let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);
    if (end < endOfList) {
      tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
      range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
    }
    const target = liftTarget(range);
    if (target == null)
      return false;
    tr.lift(range, target);
    let $after = tr.doc.resolve(tr.mapping.map(end, -1) - 1);
    if (canJoin(tr.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)
      tr.join($after.pos);
    dispatch(tr.scrollIntoView());
    return true;
  }
  function liftOutOfList(state, dispatch, range) {
    let tr = state.tr, list = range.parent;
    for (let pos = range.end, i2 = range.endIndex - 1, e = range.startIndex; i2 > e; i2--) {
      pos -= list.child(i2).nodeSize;
      tr.delete(pos - 1, pos + 1);
    }
    let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;
    if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
      return false;
    let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
    let parent = $start.node(-1), indexBefore = $start.index(-1);
    if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
      return false;
    let start = $start.pos, end = start + item.nodeSize;
    tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
    dispatch(tr.scrollIntoView());
    return true;
  }
  function sinkListItem(itemType) {
    return function(state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
      if (!range)
        return false;
      let startIndex = range.startIndex;
      if (startIndex == 0)
        return false;
      let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
      if (nodeBefore.type != itemType)
        return false;
      if (dispatch) {
        let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
        let inner = Fragment.from(nestedBefore ? itemType.create() : null);
        let slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
        let before = range.start, after = range.end;
        dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());
      }
      return true;
    };
  }
  const pDOM = ["p", 0], blockquoteDOM = ["blockquote", 0], hrDOM = ["hr"], preDOM = ["pre", ["code", 0]], brDOM = ["br"];
  const nodes$1 = {
    /**
    NodeSpec The top level document node.
    */
    doc: {
      content: "block+"
    },
    /**
    A plain paragraph textblock. Represented in the DOM
    as a `<p>` element.
    */
    paragraph: {
      content: "inline*",
      group: "block",
      parseDOM: [{ tag: "p" }],
      toDOM() {
        return pDOM;
      }
    },
    /**
    A blockquote (`<blockquote>`) wrapping one or more blocks.
    */
    blockquote: {
      content: "block+",
      group: "block",
      defining: true,
      parseDOM: [{ tag: "blockquote" }],
      toDOM() {
        return blockquoteDOM;
      }
    },
    /**
    A horizontal rule (`<hr>`).
    */
    horizontal_rule: {
      group: "block",
      parseDOM: [{ tag: "hr" }],
      toDOM() {
        return hrDOM;
      }
    },
    /**
    A heading textblock, with a `level` attribute that
    should hold the number 1 to 6. Parsed and serialized as `<h1>` to
    `<h6>` elements.
    */
    heading: {
      attrs: { level: { default: 1, validate: "number" } },
      content: "inline*",
      group: "block",
      defining: true,
      parseDOM: [
        { tag: "h1", attrs: { level: 1 } },
        { tag: "h2", attrs: { level: 2 } },
        { tag: "h3", attrs: { level: 3 } },
        { tag: "h4", attrs: { level: 4 } },
        { tag: "h5", attrs: { level: 5 } },
        { tag: "h6", attrs: { level: 6 } }
      ],
      toDOM(node) {
        return ["h" + node.attrs.level, 0];
      }
    },
    /**
    A code listing. Disallows marks or non-text inline
    nodes by default. Represented as a `<pre>` element with a
    `<code>` element inside of it.
    */
    code_block: {
      content: "text*",
      marks: "",
      group: "block",
      code: true,
      defining: true,
      parseDOM: [{ tag: "pre", preserveWhitespace: "full" }],
      toDOM() {
        return preDOM;
      }
    },
    /**
    The text node.
    */
    text: {
      group: "inline"
    },
    /**
    An inline image (`<img>`) node. Supports `src`,
    `alt`, and `href` attributes. The latter two default to the empty
    string.
    */
    image: {
      inline: true,
      attrs: {
        src: { validate: "string" },
        alt: { default: null, validate: "string|null" },
        title: { default: null, validate: "string|null" }
      },
      group: "inline",
      draggable: true,
      parseDOM: [{ tag: "img[src]", getAttrs(dom) {
        return {
          src: dom.getAttribute("src"),
          title: dom.getAttribute("title"),
          alt: dom.getAttribute("alt")
        };
      } }],
      toDOM(node) {
        let { src, alt, title } = node.attrs;
        return ["img", { src, alt, title }];
      }
    },
    /**
    A hard line break, represented in the DOM as `<br>`.
    */
    hard_break: {
      inline: true,
      group: "inline",
      selectable: false,
      parseDOM: [{ tag: "br" }],
      toDOM() {
        return brDOM;
      }
    }
  };
  const emDOM = ["em", 0], strongDOM = ["strong", 0], codeDOM = ["code", 0];
  const marks = {
    /**
    A link. Has `href` and `title` attributes. `title`
    defaults to the empty string. Rendered and parsed as an `<a>`
    element.
    */
    link: {
      attrs: {
        href: { validate: "string" },
        title: { default: null, validate: "string|null" }
      },
      inclusive: false,
      parseDOM: [{ tag: "a[href]", getAttrs(dom) {
        return { href: dom.getAttribute("href"), title: dom.getAttribute("title") };
      } }],
      toDOM(node) {
        let { href, title } = node.attrs;
        return ["a", { href, title }, 0];
      }
    },
    /**
    An emphasis mark. Rendered as an `<em>` element. Has parse rules
    that also match `<i>` and `font-style: italic`.
    */
    em: {
      parseDOM: [
        { tag: "i" },
        { tag: "em" },
        { style: "font-style=italic" },
        { style: "font-style=normal", clearMark: (m) => m.type.name == "em" }
      ],
      toDOM() {
        return emDOM;
      }
    },
    /**
    A strong mark. Rendered as `<strong>`, parse rules also match
    `<b>` and `font-weight: bold`.
    */
    strong: {
      parseDOM: [
        { tag: "strong" },
        // This works around a Google Docs misbehavior where
        // pasted content will be inexplicably wrapped in `<b>`
        // tags with a font-weight normal.
        { tag: "b", getAttrs: (node) => node.style.fontWeight != "normal" && null },
        { style: "font-weight=400", clearMark: (m) => m.type.name == "strong" },
        { style: "font-weight", getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null }
      ],
      toDOM() {
        return strongDOM;
      }
    },
    /**
    Code font mark. Represented as a `<code>` element.
    */
    code: {
      code: true,
      parseDOM: [{ tag: "code" }],
      toDOM() {
        return codeDOM;
      }
    }
  };
  const schema = new Schema({ nodes: nodes$1, marks });
  const Attachments = ({
    setUploadedAttachments,
    attachments = [],
    objectId,
    id,
    isLoadingUploading,
    uploadProgress,
    remove = true,
    preview = true
  }) => {
    var _a2;
    const [selectedFileId, setSelectedFileId] = reactExports.useState(null);
    const portalId = (_a2 = getPortal()) == null ? void 0 : _a2.portalId;
    const {
      data: fileDetails,
      isLoading,
      isError: isError2
    } = useQuery(
      ["fileDetails", selectedFileId],
      () => Client.files.getDetails({
        objectId,
        id,
        portalId,
        rowId: selectedFileId
      }),
      {
        enabled: !!selectedFileId,
        onSuccess: (data) => {
        },
        onError: (error) => {
          console.error("Error fetching file details:", error);
        }
      }
    );
    const closeModal = () => {
      setSelectedFileId(null);
    };
    const FileIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        height: "24px",
        viewBox: "0 -960 960 960",
        width: "24px",
        fill: "currentColor",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M320-240h320v-80H320v80Zm0-160h320v-80H320v80ZM240-80q-33 0-56.5-23.5T160-160v-640q0-33 23.5-56.5T240-880h320l240 240v480q0 33-23.5 56.5T720-80H240Zm280-520v-200H240v640h480v-440H520ZM240-800v200-200 640-640Z" })
      }
    );
    const getFileName = (filePath) => {
      const fileName = filePath.split("/").pop();
      return fileName;
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `transition-all w-[100%] duration-300 ${isLoadingUploading ? "opacity-100" : "opacity-0"} overflow-hidden`,
          children: [
            isLoadingUploading && uploadProgress < 90 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full bg-gray-200 rounded-sm overflow-hidden h-3 mt-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: `h-3 bg-secondary transition-all duration-300 w-[${uploadProgress + 10}%]`
              }
            ) }) : null,
            isLoadingUploading && uploadProgress > 90 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "meter", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {}) }) : null
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: `list-none ${attachments.length > 0 ? "p-1" : ""} flex flex-wrap gap-2 max-w-full`, children: attachments.map((attachment) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "w-full p-2 bg-[#f5f8fa] dark:bg-dark-300 dark:text-white border dark:border-gray-600 rounded-sm text-sm", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[20px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FileIcon, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "[calc(90%_-_100px)]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              onClick: () => setSelectedFileId(attachment.id),
              className: "cursor-pointer font-semibold text-xs text-lightblue text-[#5f6368] dark:text-white hover:underline",
              target: "_blank",
              children: getFileName(attachment.name)
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[80px]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs font-normal", children: [
            "(",
            attachment.size,
            ")"
          ] }) })
        ] }) })) }),
        preview && selectedFileId && /* @__PURE__ */ jsxRuntimeExports.jsx(
          FileDetailsModal,
          {
            file: fileDetails,
            onClose: closeModal,
            loading: isLoading,
            error: isError2
          }
        )
      ] })
    ] });
  };
  const Checkbox = ({
    label,
    checked,
    onChange,
    number = null,
    labelClassName = "font-medium text-sm",
    checkboxClassName = "font-medium text-sm",
    containerClassName = "font-medium text-sm"
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex justify-between items-center cursor-pointer ${containerClassName}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "checkbox",
            checked,
            onChange,
            className: `form-checkbox h-4 w-4 cursor-pointer ${checkboxClassName}`
          }
        ),
        label && /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: `ml-2  ${labelClassName}`, children: label })
      ] }),
      label && number && /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: `ml-2 `, children: number })
    ] });
  };
  const findTextRange = (editor, searchText) => {
    const { doc: doc2 } = editor.state;
    let startPos = -1;
    let endPos = -1;
    doc2.descendants((node, pos) => {
      if (node.isText) {
        const text2 = node.text;
        const index = text2.indexOf(searchText);
        if (index !== -1) {
          startPos = pos + index;
          endPos = startPos + searchText.length;
          return false;
        }
      }
    });
    return { from: startPos, to: endPos };
  };
  const normalizeUrl$1 = (text2) => {
    if (!/^https?:\/\//i.test(text2)) {
      return `http://${text2}`;
    }
    return text2;
  };
  const insertEditLink = (editorView, state, dispatch, title, linkText, url, blank) => {
    const { schema: schema2, selection, tr } = state;
    const linkType = schema2.marks.link;
    const { from, to } = findTextRange(editorView, title);
    let href = normalizeUrl$1(url);
    let attrs = {
      href,
      title: linkText,
      ...{ target: blank ? "_blank" : "_self" }
    };
    if (dispatch) {
      tr.delete(from, to);
      tr.insertText(linkText, from);
      tr.addMark(from, from + linkText.length, linkType.create(attrs));
      dispatch(tr);
    }
    return true;
  };
  const ProseMirrorMenuInsertLinkPopUp = ({
    randomId,
    editorView,
    href,
    title,
    target,
    closeLinkPopup
  }) => {
    const [isSetLinkText, setIsSetLinkText] = reactExports.useState(title ? true : false);
    const [linkText, setLinkText] = reactExports.useState(title);
    const [url, setUrl] = reactExports.useState(href);
    const [blank, setBlank] = reactExports.useState(target === "_self" ? false : true);
    reactExports.useRef(null);
    const dropdownMenuRef = reactExports.useRef(null);
    const inputRef = reactExports.useRef(null);
    const inputRef2 = reactExports.useRef(null);
    reactExports.useEffect(() => {
      if (inputRef.current) {
        inputRef.current.focus();
      }
    }, []);
    const resetMenu = () => {
      setLinkText("");
      setIsSetLinkText(false);
      setUrl("");
      setBlank(true);
    };
    const onChangeCheckbox = () => {
      setBlank((prev) => !prev);
    };
    const onSubmit = () => {
      insertEditLink(
        editorView,
        editorView.state,
        editorView.dispatch,
        title,
        linkText,
        url,
        blank
      );
      resetMenu();
      closeLinkPopup();
    };
    const removeEditLink = () => {
      const { state, dispatch } = editorView;
      const { schema: schema2, tr } = state;
      const linkType = schema2.marks.link;
      const { from, to } = findTextRange(editorView, title);
      if (dispatch) {
        tr.removeMark(from, to, linkType);
        dispatch(tr);
      }
      resetMenu();
      closeLinkPopup();
      return true;
    };
    const [popupPosition, setPopupPosition] = React.useState({ top: 0, left: 0 });
    const updatePopupPosition = () => {
      const mainButton = document.getElementById(`main-${randomId}`);
      if (mainButton) {
        const rect = mainButton.getBoundingClientRect();
        setPopupPosition({
          top: rect.bottom + window.scrollY,
          left: rect.left + window.scrollX
        });
      }
    };
    reactExports.useEffect(() => {
      updatePopupPosition();
    }, []);
    reactExports.useEffect(() => {
      const handleScroll = () => {
        updatePopupPosition();
      };
      const scrollableDiv = document.getElementById(
        "details-scrollable-container"
      );
      if (scrollableDiv) {
        scrollableDiv.addEventListener("scroll", handleScroll);
      }
      return () => {
        if (scrollableDiv) {
          scrollableDiv.removeEventListener("scroll", handleScroll);
        }
      };
    }, [popupPosition]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        id: `child-${randomId}`,
        ref: dropdownMenuRef,
        className: `absolute bg-white shadow-lg rounded-sm border z-[103]
      `,
        style: popupPosition,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2 px-2 note-dd-Select-menu list-none list-inside dark:text-gray-400", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-sm", children: "Edit Link" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "text-sm", children: "Link text" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                ref: inputRef,
                onClick: () => inputRef.current.focus(),
                height: "medium",
                placeholder: "",
                defaultValue: linkText,
                onChange: (e) => {
                  setLinkText(e.target.value);
                  if (e.target.value) {
                    setIsSetLinkText(true);
                  } else {
                    setIsSetLinkText(false);
                  }
                },
                className: "!bg-white !text-black !border-gray-200"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "text-sm", children: "Url" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                ref: inputRef2,
                onClick: () => inputRef2.current.focus(),
                height: "medium",
                placeholder: "",
                defaultValue: url,
                onChange: (e) => {
                  setUrl(e.target.value);
                  if (!isSetLinkText) setLinkText(e.target.value);
                },
                className: "!bg-white !text-black !border-gray-200"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              label: "Open in new tab",
              checked: blank,
              onChange: onChangeCheckbox
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                size: "sm",
                className: "w-full",
                onClick: onSubmit,
                disabled: !linkText || !url,
                children: "Apply"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                size: "sm",
                variant: "outline",
                className: "w-full",
                onClick: () => closeLinkPopup(),
                children: "Cancel"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                size: "sm",
                variant: "link",
                className: "w-full !text-secondary",
                onClick: () => removeEditLink(),
                children: "Remove link"
              }
            )
          ] })
        ] })
      }
    );
  };
  const ProseMirrorLinkView = (attrs, type) => {
    const mark = attrs;
    const view = type;
    const dom = document.createElement("a");
    dom.setAttribute("href", mark.attrs.href);
    dom.setAttribute("title", mark.attrs.title || mark.attrs.href);
    dom.setAttribute("target", mark.attrs.target || "_blank");
    dom.setAttribute("rel", "noopener noreferrer");
    dom.textContent = mark.attrs.title;
    let isOpenLinkPopup = false;
    let linkPopupContainer = null;
    const closeLinkPopup = () => {
      if (linkPopupContainer) {
        document.body.removeChild(linkPopupContainer);
        linkPopupContainer = null;
      }
      isOpenLinkPopup = false;
    };
    const handleClickOutside = (event) => {
      if (linkPopupContainer && linkPopupContainer.contains(event.target) || dom && dom.contains(event.target)) {
        return;
      }
      closeLinkPopup();
    };
    dom.addEventListener("click", (event) => {
      let target = event.target.closest("a");
      if (target) {
        event.preventDefault();
        if (isOpenLinkPopup && linkPopupContainer) {
          document.body.removeChild(linkPopupContainer);
          linkPopupContainer = null;
        }
        isOpenLinkPopup = !isOpenLinkPopup;
        setTimeout(() => {
          document.addEventListener("mousedown", handleClickOutside);
        }, 0);
        if (isOpenLinkPopup) {
          const randomId = Math.floor(Math.random() * 1e7) + 1;
          target.id = `main-${randomId}`;
          target.classList.add("relative", "inline-block");
          const href = target.getAttribute("href");
          const title = target.getAttribute("title") || target.textContent;
          const target_b = target.getAttribute("target");
          linkPopupContainer = document.createElement("div");
          document.body.appendChild(linkPopupContainer);
          const root = clientExports.createRoot(linkPopupContainer);
          root.render(
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ProseMirrorMenuInsertLinkPopUp,
              {
                randomId,
                editorView: view,
                href,
                title,
                target: target_b,
                closeLinkPopup
              }
            )
          );
        }
      }
    });
    return { dom };
  };
  const ProseMirrorImage = ({ node, view, getPos }) => {
    const imgResizeRef = reactExports.useRef(null);
    const [imageResize, setImageResize] = reactExports.useState(false);
    const width = Number(node.attrs.width);
    const height = Number(node.attrs.height);
    const [size, setSize] = reactExports.useState({ width, height });
    size.width / size.height;
    const handleClickOutside = (event) => {
      if (imgResizeRef.current && !imgResizeRef.current.contains(event.target)) {
        setImageResize(false);
      }
    };
    reactExports.useEffect(() => {
      if (imageResize) {
        document.addEventListener("mousedown", handleClickOutside);
      } else {
        document.removeEventListener("mousedown", handleClickOutside);
      }
      return () => {
        document.removeEventListener("mousedown", handleClickOutside);
      };
    }, [imageResize]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: `relative inline-block border-2 cursor-pointer w-[${size == null ? void 0 : size.width}] h-[${size == null ? void 0 : size.height}] ${imageResize ? "border-[#00d0e4]" : "border-transparent"}`,
        ref: imgResizeRef,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: node.attrs.src,
            width: size == null ? void 0 : size.width,
            height: size == null ? void 0 : size.height,
            alt: `img-${1}`
          }
        )
      }
    );
  };
  const ProseMirrorImageResizeView = () => {
    return (node, view, getPos) => {
      const dom = document.createElement("div");
      dom.className = "prosemirror-react-image";
      const applyAlignmentStyle = (node2) => {
        var _a2;
        const figureStyle = ((_a2 = node2.attrs) == null ? void 0 : _a2.style) || "";
        if (figureStyle.includes("text-align: left;")) {
          dom.style.textAlign = "left";
        } else if (figureStyle.includes("text-align: center;")) {
          dom.style.textAlign = "center";
        } else if (figureStyle.includes("text-align: right;")) {
          dom.style.textAlign = "right";
        } else {
          dom.style.textAlign = "initial";
        }
      };
      applyAlignmentStyle(node);
      const root = clientExports.createRoot(dom);
      root.render(
        /* @__PURE__ */ jsxRuntimeExports.jsx(ProseMirrorImage, { node, view, getPos })
      );
      return {
        dom,
        update(updatedNode) {
          if (updatedNode.type !== node.type) return false;
          applyAlignmentStyle(updatedNode);
          root.render(
            /* @__PURE__ */ jsxRuntimeExports.jsx(ProseMirrorImage, { node: updatedNode, view, getPos })
          );
          return true;
        },
        destroy() {
          root.unmount();
        }
      };
    };
  };
  const ProseMirrorMenuPopup = ({ children, open, setOpen }) => {
    const containerRef = reactExports.useRef(null);
    const dropdownMenuRef = reactExports.useRef(null);
    const toggleDropdown = (event) => {
      event.stopPropagation();
      setOpen(!open);
    };
    const handleClickOutside = (event) => {
      if (containerRef.current && containerRef.current.contains(event.target)) {
        return;
      }
      if (dropdownMenuRef.current && !dropdownMenuRef.current.contains(event.target)) {
        setOpen(false);
      }
    };
    reactExports.useEffect(() => {
      if (open) {
        document.addEventListener("mousedown", handleClickOutside);
      } else {
        document.removeEventListener("mousedown", handleClickOutside);
      }
      return () => {
        document.removeEventListener("mousedown", handleClickOutside);
      };
    }, [open]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative inline-block", ref: containerRef, children: React.Children.map(children, (child) => {
      if (!React.isValidElement(child)) return child;
      if (child.type === ProseMirrorMenuButton) {
        return React.cloneElement(child, { toggleDropdown });
      }
      if (child.type === ProseMirrorMenuOption) {
        return React.cloneElement(child, { open, dropdownMenuRef });
      }
      return child;
    }) });
  };
  const ProseMirrorMenuButton = ({
    id,
    title,
    isActive,
    variant,
    children,
    toggleDropdown
  }) => {
    const classes2 = {
      root: "ProseMirror-icon"
    };
    const variantClasses2 = {
      default: "",
      outline: "border"
    };
    const classesName = classNames(
      classes2.root,
      // Base classes
      variantClasses2[variant]
      // Dynamic variant classes
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        onClick: toggleDropdown,
        title,
        className: classNames(classesName),
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id, className: `note-menuitem ${isActive ? "" : ""}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: `${id}-icon`, children }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              height: "15px",
              viewBox: "0 -960 960 960",
              width: "15px",
              fill: "#e8eaed",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M480-360 280-560h400L480-360Z" })
            }
          )
        ] })
      }
    );
  };
  const ProseMirrorMenuOption = ({ children, open, dropdownMenuRef }) => {
    const [position, setPosition] = reactExports.useState({ top: "100%", left: 0 });
    const menuRef = reactExports.useRef(null);
    reactExports.useEffect(() => {
      if (!open) {
        setPosition({
          top: "100%",
          left: 0,
          right: "auto"
        });
      }
    }, [open]);
    reactExports.useEffect(() => {
      if (open && menuRef.current && dropdownMenuRef.current) {
        const menuElement = menuRef.current;
        const dropdownElement = dropdownMenuRef.current;
        const modalContainer = menuElement.closest(".popup-modal") || document.body;
        const containerRect = modalContainer.getBoundingClientRect();
        const buttonRect = dropdownElement.getBoundingClientRect();
        const relativeLeft = buttonRect.left - containerRect.left;
        const menuWidth = menuElement.offsetWidth;
        const availableSpaceRight = containerRect.width - (relativeLeft + menuWidth);
        let newPosition = {
          top: "100%",
          left: 0,
          right: "auto"
        };
        if (availableSpaceRight < 0) {
          newPosition = {
            top: "100%",
            left: "auto",
            right: 0
          };
          const availableSpaceLeft = relativeLeft;
          if (availableSpaceLeft < menuWidth) {
            newPosition = {
              top: "100%",
              left: -20,
              right: "auto"
            };
          }
        }
        setPosition(newPosition);
      }
    }, [open]);
    return open && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "ul",
      {
        ref: (node) => {
          menuRef.current = node;
          dropdownMenuRef.current = node;
        },
        className: `absolute mt-1 border bg-white shadow-lg rounded-rounded overflow-hidden z-50 w-max transition-all duration-200 ease-in-out transform 
          ${open ? "opacity-100 translate-y-0 scale-100" : "opacity-0 -translate-y-2 scale-95 pointer-events-none"}
        `,
        style: position,
        children
      }
    );
  };
  const alignments = [
    {
      label: "Left",
      value: "left",
      icon: `<svg xmlns="http://www.w3.org/2000/svg" height="15px" viewBox="0 -960 960 960" width="15px" fill="#5f6368"><path d="M120-120v-80h720v80H120Zm0-160v-80h480v80H120Zm0-160v-80h720v80H120Zm0-160v-80h480v80H120Zm0-160v-80h720v80H120Z"/></svg>`
    },
    {
      label: "Center",
      value: "center",
      icon: `<svg xmlns="http://www.w3.org/2000/svg" height="15px" viewBox="0 -960 960 960" width="15px" fill="#5f6368"><path d="M120-120v-80h720v80H120Zm160-160v-80h400v80H280ZM120-440v-80h720v80H120Zm160-160v-80h400v80H280ZM120-760v-80h720v80H120Z"/></svg>`
    },
    {
      label: "Right",
      value: "right",
      icon: `<svg xmlns="http://www.w3.org/2000/svg" height="15px" viewBox="0 -960 960 960" width="15px" fill="#5f6368"><path d="M120-760v-80h720v80H120Zm240 160v-80h480v80H360ZM120-440v-80h720v80H120Zm240 160v-80h480v80H360ZM120-120v-80h720v80H120Z"/></svg>`
    }
  ];
  let defaultEditorAlignment = null;
  const updateImageAlignment = (node, view, getPos, alignment) => {
    requestAnimationFrame(() => {
      const { state, dispatch } = view;
      const pos = getPos();
      if (pos === null || pos < 0 || pos >= state.doc.content.size) {
        console.error("Invalid position for node update");
        return;
      }
      let tr = state == null ? void 0 : state.tr;
      if (node.attrs.wrap) {
        const newAttrs = {
          ...node.attrs,
          wrap: true,
          // Maintain wrap attribute
          style: `text-align: ${alignment};`
        };
        tr = tr == null ? void 0 : tr.setNodeMarkup(pos, null, newAttrs);
      } else {
        const wrapperAttrs = {
          ...node.attrs,
          wrap: true,
          // Add wrap attribute to indicate it's wrapped
          style: `text-align: ${alignment};`
        };
        tr = tr == null ? void 0 : tr.replaceWith(
          pos,
          pos + node.nodeSize,
          state.schema.nodes.image.create(wrapperAttrs)
        );
      }
      tr = tr == null ? void 0 : tr.setSelection(NodeSelection.create(tr.doc, pos));
      if (tr.docChanged) {
        dispatch(tr);
      }
    });
  };
  const DropdownAlightMenu = ({ editorView }) => {
    const [open, setOpen] = React.useState(false);
    const [textAlign, setTextAlign] = reactExports.useState(alignments[0]);
    const applyAlignment = (state, dispatch, align) => {
      const { schema: schema2, selection } = state;
      const nodeType = schema2.nodes.paragraph;
      const { from, to } = selection;
      state.doc.nodesBetween(from, to, (node, pos) => {
        if (node.type.name === "image") {
          updateImageAlignment(node, editorView, () => pos, align);
          return true;
        }
      });
      let selectedPaddingLeft = null;
      state.doc.nodesBetween(from, to, (node) => {
        if (node.type === nodeType) {
          selectedPaddingLeft = node.attrs.paddingLeft;
        }
      });
      let attrs = {
        align
      };
      if (selectedPaddingLeft) attrs.paddingLeft = selectedPaddingLeft;
      if (dispatch) {
        dispatch(state.tr.setBlockType(from, to, nodeType, attrs));
      }
      setOpen(false);
      return true;
    };
    const changeAlignment = (alignment) => {
      applyAlignment(editorView.state, editorView.dispatch, alignment.value);
    };
    reactExports.useEffect(() => {
      if (defaultEditorAlignment) setTextAlign(defaultEditorAlignment);
    }, [defaultEditorAlignment]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative inline-block", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ProseMirrorMenuPopup, { open, setOpen, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ProseMirrorMenuButton,
        {
          id: "defaultEditorAlignment",
          title: "Text Alignment",
          isActive: defaultEditorAlignment,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgRenderer, { svgContent: textAlign == null ? void 0 : textAlign.icon })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ProseMirrorMenuOption, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "space-y-2 note-dd-Select-menu list-none list-inside dark:text-gray-400", children: alignments.map((alignment) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "li",
        {
          className: `cursor-pointer note-dd-Select-menu-options hover:bg-[#e5f5f8]  py-1 ${(defaultEditorAlignment == null ? void 0 : defaultEditorAlignment.value) === alignment.value ? "bg-gray-100" : "bg-none"}`,
          onClick: () => {
            changeAlignment(alignment);
            defaultEditorAlignment = alignment;
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgRenderer, { svgContent: alignment.icon })
        },
        alignment.value
      )) }) })
    ] }) });
  };
  const renderReactAlignComponent = (editorView) => {
    const container = document.createElement("div");
    const root = clientExports.createRoot(container);
    root.render(/* @__PURE__ */ jsxRuntimeExports.jsx(DropdownAlightMenu, { editorView }));
    return container;
  };
  function isAlignmentActive(state, alignValue) {
    const { selection } = state;
    const { $from } = selection;
    for (let depth = $from.depth; depth > 0; depth--) {
      const node = $from.node(depth);
      if (node.attrs.align === alignValue) {
        return true;
      }
    }
    return false;
  }
  function isImageSelected(state) {
    const { from } = state.selection;
    const node = state.doc.nodeAt(from);
    return node && node.type.name === "image" ? node : false;
  }
  const alignmentDropdown = new MenuItem({
    title: `Select Alignment`,
    run: () => {
    },
    select: (state) => {
      var _a2, _b2, _c2, _d2, _e2;
      let isAlignmentLeft = isAlignmentActive(state, "left");
      let isAlignmentCenter = isAlignmentActive(state, "center");
      let isAlignmentRight = isAlignmentActive(state, "right");
      let editorListButton = document.querySelector(
        "#defaultEditorAlignment-icon"
      );
      const imageNode = isImageSelected(state);
      if (imageNode) {
        const figureStyle = ((_a2 = imageNode == null ? void 0 : imageNode.attrs) == null ? void 0 : _a2.style) || "";
        isAlignmentLeft = figureStyle.includes("text-align: left;");
        isAlignmentCenter = figureStyle.includes("text-align: center;");
        isAlignmentRight = figureStyle.includes("text-align: right;");
      }
      if (isAlignmentLeft && editorListButton) {
        editorListButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="15px" viewBox="0 -960 960 960" width="15px" fill="#5f6368"><path d="M120-120v-80h720v80H120Zm0-160v-80h480v80H120Zm0-160v-80h720v80H120Zm0-160v-80h480v80H120Zm0-160v-80h720v80H120Z"/></svg>`;
        (_b2 = document.getElementById("defaultEditorAlignment")) == null ? void 0 : _b2.classList.add("note-active-state");
        defaultEditorAlignment = alignments[0];
      }
      if (isAlignmentCenter && editorListButton) {
        editorListButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="15px" viewBox="0 -960 960 960" width="15px" fill="#5f6368"><path d="M120-120v-80h720v80H120Zm160-160v-80h400v80H280ZM120-440v-80h720v80H120Zm160-160v-80h400v80H280ZM120-760v-80h720v80H120Z"/></svg>`;
        (_c2 = document.getElementById("defaultEditorAlignment")) == null ? void 0 : _c2.classList.add("note-active-state");
        defaultEditorAlignment = alignments[1];
      }
      if (isAlignmentRight && editorListButton) {
        editorListButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="15px" viewBox="0 -960 960 960" width="15px" fill="#5f6368"><path d="M120-760v-80h720v80H120Zm240 160v-80h480v80H360ZM120-440v-80h720v80H120Zm240 160v-80h480v80H360ZM120-120v-80h720v80H120Z"/></svg>`;
        (_d2 = document.getElementById("defaultEditorAlignment")) == null ? void 0 : _d2.classList.add("note-active-state");
        defaultEditorAlignment = alignments[2];
      }
      if (!isAlignmentLeft && !isAlignmentCenter && !isAlignmentRight && editorListButton) {
        editorListButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="15px" viewBox="0 -960 960 960" width="15px" fill="#5f6368"><path d="M120-120v-80h720v80H120Zm0-160v-80h480v80H120Zm0-160v-80h720v80H120Zm0-160v-80h480v80H120Zm0-160v-80h720v80H120Z"/></svg>`;
        (_e2 = document.getElementById("defaultEditorAlignment")) == null ? void 0 : _e2.classList.remove("note-active-state");
        defaultEditorAlignment = "";
      }
      return true;
    },
    render: (editorView) => renderReactAlignComponent(editorView)
  });
  const AttachmentIcon = ({
    width = "15px",
    height = "15px",
    color = "#e8eaed",
    ...props
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width,
        height,
        fill: color,
        ...props,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M720-330q0 104-73 177T470-80q-104 0-177-73t-73-177v-370q0-75 52.5-127.5T400-880q75 0 127.5 52.5T580-700v350q0 46-32 78t-78 32q-46 0-78-32t-32-78v-370h80v370q0 13 8.5 21.5T470-320q13 0 21.5-8.5T500-350v-350q-1-42-29.5-71T400-800q-42 0-71 29t-29 71v370q-1 71 49 120.5T470-160q70 0 119-49.5T640-330v-390h80v390Z" })
      }
    );
  };
  const EditorAttachmentUploadMenu = ({
    editorView,
    attachmentUploadUrl,
    attachmentUploadMethod,
    setUploadedAttachments,
    setisLoadingUoloading,
    setUploadProgress,
    setAttachmentId
  }) => {
    const token = getAuthToken();
    const boldButtonRef = reactExports.useRef(null);
    const fileInputRef = reactExports.useRef(null);
    const uploadImage = () => {
      var _a2;
      (_a2 = fileInputRef.current) == null ? void 0 : _a2.click();
    };
    const handleFileChange = async (event) => {
      const file = event.target.files[0];
      if (!file) return;
      const formData = new FormData();
      formData.append("file", file);
      await uploadImageToAPI(editorView, formData);
    };
    const uploadImageToAPI = async (pmView, formData) => {
      setisLoadingUoloading(true);
      try {
        const response = await axios({
          method: attachmentUploadMethod,
          url: attachmentUploadUrl,
          data: formData,
          headers: {
            "Content-Type": "multipart/form-data",
            Authorization: `Bearer ${token}`
          },
          onUploadProgress: (progressEvent) => {
            const percentCompleted = Math.round(
              progressEvent.loaded * 100 / progressEvent.total
            );
            setUploadProgress(percentCompleted);
          }
        });
        setUploadedAttachments((prevAttachments) => [
          ...prevAttachments,
          response.data.data
        ]);
        setAttachmentId(
          (prevAttachments) => {
            var _a2, _b2, _c2, _d2;
            return prevAttachments ? `${prevAttachments};${(_b2 = (_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.data) == null ? void 0 : _b2.id}` : (_d2 = (_c2 = response == null ? void 0 : response.data) == null ? void 0 : _c2.data) == null ? void 0 : _d2.id;
          }
        );
        setUploadProgress(0);
        setisLoadingUoloading(false);
      } catch (error) {
        setisLoadingUoloading(false);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "ProseMirror-icon note-menuitem",
          title: "Insert Attatchment",
          ref: boldButtonRef,
          onClick: uploadImage,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(AttachmentIcon, {})
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "file",
          ref: fileInputRef,
          accept: "image/*",
          className: "hidden",
          onChange: handleFileChange
        }
      )
    ] });
  };
  const renderReactAttachmentUploadComponent = (editorView, attachmentUploadUrl, attachmentUploadMethod, setUploadedAttachments, setisLoadingUoloading, setUploadProgress, setAttachmentId) => {
    const container = document.createElement("div");
    const root = clientExports.createRoot(container);
    root.render(
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        EditorAttachmentUploadMenu,
        {
          editorView,
          attachmentUploadUrl,
          attachmentUploadMethod,
          setUploadedAttachments,
          setisLoadingUoloading,
          setUploadProgress,
          setAttachmentId
        }
      )
    );
    return container;
  };
  const customMenuItemAttachment = (attachmentUploadUrl, attachmentUploadMethod, setUploadedAttachments, setisLoadingUoloading, setUploadProgress, setAttachmentId) => new MenuItem({
    title: `Insert Attatchment`,
    run: () => {
    },
    select: (state) => {
      return true;
    },
    render: (editorView) => renderReactAttachmentUploadComponent(
      editorView,
      attachmentUploadUrl,
      attachmentUploadMethod,
      setUploadedAttachments,
      setisLoadingUoloading,
      setUploadProgress,
      setAttachmentId
    )
  });
  const blockquoteItem = new MenuItem({
    title: "Blockquote",
    icon: {
      dom: (() => {
        const span = document.createElement("span");
        span.innerHTML = `
        <svg version="1.0" xmlns="http://www.w3.org/2000/svg"
        width="15px" height="15px" viewBox="0 0 24.000000 23.000000"
        preserveAspectRatio="xMidYMid meet">
        <g transform="translate(0.000000,23.000000) scale(0.100000,-0.100000)"
        fill="#666666" stroke="none">
        <path d="M44 166 c-3 -7 -4 -35 -2 -62 3 -45 5 -49 31 -52 25 -3 27 -1 27 33
        0 28 -5 38 -20 42 -24 6 -26 21 -5 29 22 9 18 24 -5 24 -11 0 -23 -6 -26 -14z"/>
        <path d="M124 166 c-3 -7 -4 -35 -2 -62 3 -45 5 -49 31 -52 18 -2 29 2 33 12
        9 24 -4 66 -21 66 -8 0 -15 7 -15 15 0 8 7 15 15 15 8 0 15 5 15 10 0 15 -50
        12 -56 -4z"/>
        </g>
        </svg>
      `;
        span.className = "note-menuitem";
        return span;
      })()
    },
    enable: (state) => wrapIn(state.schema.nodes.blockquote)(state) || lift(state),
    // Enable if can wrap or lift
    run: (state, dispatch) => {
      const { blockquote } = state.schema.nodes;
      const { $from, $to } = state.selection;
      let inBlockquote = false;
      state.doc.nodesBetween($from.pos, $to.pos, (node) => {
        if (node.type === blockquote) {
          inBlockquote = true;
        }
      });
      if (inBlockquote) {
        lift(state, dispatch);
      } else {
        wrapIn(blockquote)(state, dispatch);
      }
    }
  });
  const BoldIcon = ({
    width = "15px",
    height = "15px",
    color = "#e8eaed",
    ...props
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width,
        height,
        fill: color,
        ...props,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M272-200v-560h221q65 0 120 40t55 111q0 51-23 78.5T602-491q25 11 55.5 41t30.5 90q0 89-65 124.5T501-200H272Zm121-112h104q48 0 58.5-24.5T566-372q0-11-10.5-35.5T494-432H393v120Zm0-228h93q33 0 48-17t15-38q0-24-17-39t-44-15h-95v109Z" })
      }
    );
  };
  const isBoldMarkActive = (state, markType) => {
    const { from, to, empty: empty2 } = state.selection;
    if (empty2) {
      return !!markType.isInSet(
        state.storedMarks || state.selection.$from.marks()
      );
    } else {
      let hasMark = false;
      state.doc.nodesBetween(from, to, (node) => {
        if (node.marks.some((mark) => mark.type === markType)) {
          hasMark = true;
        }
      });
      return hasMark;
    }
  };
  const EditorBoldMenu = ({ editorView }) => {
    const boldButtonRef = reactExports.useRef(null);
    const [selectedEditorBold, setSelectedEditorBold] = reactExports.useState(false);
    const toggleMenu = () => {
      const { state, dispatch } = editorView;
      setSelectedEditorBold(!selectedEditorBold);
      toggleMark(state.schema.marks.strong)(state, dispatch);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative inline-block", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "ProseMirror-icon",
        title: "Bold",
        ref: boldButtonRef,
        onClick: toggleMenu,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            id: "selectedEditorBold",
            className: `note-menuitem  ${selectedEditorBold ? "note-active-state" : ""}`,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(BoldIcon, {})
          }
        )
      }
    ) });
  };
  const renderReactBoldComponent = (editorView) => {
    const container = document.createElement("div");
    const root = clientExports.createRoot(container);
    root.render(/* @__PURE__ */ jsxRuntimeExports.jsx(EditorBoldMenu, { editorView }));
    return container;
  };
  const boldItem = new MenuItem({
    title: `Bold`,
    run: () => {
    },
    select: (state) => {
      const editorListButton = document.querySelector("#selectedEditorBold");
      if (editorListButton && isBoldMarkActive(state, state.schema.marks.strong)) {
        editorListButton.classList.add("note-active-state");
      }
      if (editorListButton && !isBoldMarkActive(state, state.schema.marks.strong)) {
        editorListButton.classList.remove("note-active-state");
      }
      return true;
    },
    render: (editorView) => renderReactBoldComponent(editorView)
  });
  const AlfabateIcon = ({
    width = "15px",
    height = "15px",
    color = "#e8eaed",
    ...props
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width,
        height,
        fill: color,
        ...props,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M80 0v-160h800V0H80Z",
              fill: color,
              id: "text-color-svg"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M220-280 430-840h100l210 560h-96l-50-144H368l-52 144h-96Zm176-224h168l-82-232h-4l-82 232Z",
              fill: color
            }
          )
        ]
      }
    );
  };
  var pickr_min = { exports: {} };
  /*! Pickr 1.9.1 MIT | https://github.com/Simonwep/pickr */
  var hasRequiredPickr_min;
  function requirePickr_min() {
    if (hasRequiredPickr_min) return pickr_min.exports;
    hasRequiredPickr_min = 1;
    (function(module, exports) {
      !function(t, e) {
        module.exports = e();
      }(self, () => (() => {
        var t = { d: (e2, o2) => {
          for (var n2 in o2) t.o(o2, n2) && !t.o(e2, n2) && Object.defineProperty(e2, n2, { enumerable: true, get: o2[n2] });
        }, o: (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r: (t2) => {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
        } }, e = {};
        t.d(e, { default: () => E2 });
        var o = {};
        function n(t2, e2, o2, n2, i3 = {}) {
          e2 instanceof HTMLCollection || e2 instanceof NodeList ? e2 = Array.from(e2) : Array.isArray(e2) || (e2 = [e2]), Array.isArray(o2) || (o2 = [o2]);
          for (const s2 of e2) for (const e3 of o2) s2[t2](e3, n2, { capture: false, ...i3 });
          return Array.prototype.slice.call(arguments, 1);
        }
        t.r(o), t.d(o, { adjustableInputNumbers: () => p, createElementFromString: () => r, createFromTemplate: () => a, eventPath: () => l, off: () => s, on: () => i2, resolveElement: () => c });
        const i2 = n.bind(null, "addEventListener"), s = n.bind(null, "removeEventListener");
        function r(t2) {
          const e2 = document.createElement("div");
          return e2.innerHTML = t2.trim(), e2.firstElementChild;
        }
        function a(t2) {
          const e2 = (t3, e3) => {
            const o3 = t3.getAttribute(e3);
            return t3.removeAttribute(e3), o3;
          }, o2 = (t3, n2 = {}) => {
            const i3 = e2(t3, ":obj"), s2 = e2(t3, ":ref"), r2 = i3 ? n2[i3] = {} : n2;
            s2 && (n2[s2] = t3);
            for (const n3 of Array.from(t3.children)) {
              const t4 = e2(n3, ":arr"), i4 = o2(n3, t4 ? {} : r2);
              t4 && (r2[t4] || (r2[t4] = [])).push(Object.keys(i4).length ? i4 : n3);
            }
            return n2;
          };
          return o2(r(t2));
        }
        function l(t2) {
          let e2 = t2.path || t2.composedPath && t2.composedPath();
          if (e2) return e2;
          let o2 = t2.target.parentElement;
          for (e2 = [t2.target, o2]; o2 = o2.parentElement; ) e2.push(o2);
          return e2.push(document, window), e2;
        }
        function c(t2) {
          return t2 instanceof Element ? t2 : "string" == typeof t2 ? t2.split(/>>/g).reduce((t3, e2, o2, n2) => (t3 = t3.querySelector(e2), o2 < n2.length - 1 ? t3.shadowRoot : t3), document) : null;
        }
        function p(t2, e2 = (t3) => t3) {
          function o2(o3) {
            const n2 = [1e-3, 0.01, 0.1][Number(o3.shiftKey || 2 * o3.ctrlKey)] * (o3.deltaY < 0 ? 1 : -1);
            let i3 = 0, s2 = t2.selectionStart;
            t2.value = t2.value.replace(/[\d.]+/g, (t3, o4) => o4 <= s2 && o4 + t3.length >= s2 ? (s2 = o4, e2(Number(t3), n2, i3)) : (i3++, t3)), t2.focus(), t2.setSelectionRange(s2, s2), o3.preventDefault(), t2.dispatchEvent(new Event("input"));
          }
          i2(t2, "focus", () => i2(window, "wheel", o2, { passive: false })), i2(t2, "blur", () => s(window, "wheel", o2));
        }
        const { min: u, max: h2, floor: d, round: m } = Math;
        function f(t2, e2, o2) {
          e2 /= 100, o2 /= 100;
          const n2 = d(t2 = t2 / 360 * 6), i3 = t2 - n2, s2 = o2 * (1 - e2), r2 = o2 * (1 - i3 * e2), a2 = o2 * (1 - (1 - i3) * e2), l2 = n2 % 6;
          return [255 * [o2, r2, s2, s2, a2, o2][l2], 255 * [a2, o2, o2, r2, s2, s2][l2], 255 * [s2, s2, a2, o2, o2, r2][l2]];
        }
        function v(t2, e2, o2) {
          const n2 = (2 - (e2 /= 100)) * (o2 /= 100) / 2;
          return 0 !== n2 && (e2 = 1 === n2 ? 0 : n2 < 0.5 ? e2 * o2 / (2 * n2) : e2 * o2 / (2 - 2 * n2)), [t2, 100 * e2, 100 * n2];
        }
        function b2(t2, e2, o2) {
          const n2 = u(t2 /= 255, e2 /= 255, o2 /= 255), i3 = h2(t2, e2, o2), s2 = i3 - n2;
          let r2, a2;
          if (0 === s2) r2 = a2 = 0;
          else {
            a2 = s2 / i3;
            const n3 = ((i3 - t2) / 6 + s2 / 2) / s2, l2 = ((i3 - e2) / 6 + s2 / 2) / s2, c2 = ((i3 - o2) / 6 + s2 / 2) / s2;
            t2 === i3 ? r2 = c2 - l2 : e2 === i3 ? r2 = 1 / 3 + n3 - c2 : o2 === i3 && (r2 = 2 / 3 + l2 - n3), r2 < 0 ? r2 += 1 : r2 > 1 && (r2 -= 1);
          }
          return [360 * r2, 100 * a2, 100 * i3];
        }
        function y(t2, e2, o2, n2) {
          e2 /= 100, o2 /= 100;
          return [...b2(255 * (1 - u(1, (t2 /= 100) * (1 - (n2 /= 100)) + n2)), 255 * (1 - u(1, e2 * (1 - n2) + n2)), 255 * (1 - u(1, o2 * (1 - n2) + n2)))];
        }
        function g(t2, e2, o2) {
          e2 /= 100;
          const n2 = 2 * (e2 *= (o2 /= 100) < 0.5 ? o2 : 1 - o2) / (o2 + e2) * 100, i3 = 100 * (o2 + e2);
          return [t2, isNaN(n2) ? 0 : n2, i3];
        }
        function _2(t2) {
          return b2(...t2.match(/.{2}/g).map((t3) => parseInt(t3, 16)));
        }
        function w2(t2) {
          t2 = t2.match(/^[a-zA-Z]+$/) ? function(t3) {
            if ("black" === t3.toLowerCase()) return "#000";
            const e3 = document.createElement("canvas").getContext("2d");
            return e3.fillStyle = t3, "#000" === e3.fillStyle ? null : e3.fillStyle;
          }(t2) : t2;
          const e2 = { cmyk: /^cmyk\D+([\d.]+)\D+([\d.]+)\D+([\d.]+)\D+([\d.]+)/i, rgba: /^rgba?\D+([\d.]+)(%?)\D+([\d.]+)(%?)\D+([\d.]+)(%?)\D*?(([\d.]+)(%?)|$)/i, hsla: /^hsla?\D+([\d.]+)\D+([\d.]+)\D+([\d.]+)\D*?(([\d.]+)(%?)|$)/i, hsva: /^hsva?\D+([\d.]+)\D+([\d.]+)\D+([\d.]+)\D*?(([\d.]+)(%?)|$)/i, hexa: /^#?(([\dA-Fa-f]{3,4})|([\dA-Fa-f]{6})|([\dA-Fa-f]{8}))$/i }, o2 = (t3) => t3.map((t4) => /^(|\d+)\.\d+|\d+$/.test(t4) ? Number(t4) : void 0);
          let n2;
          t: for (const i3 in e2) if (n2 = e2[i3].exec(t2)) switch (i3) {
            case "cmyk": {
              const [, t3, e3, s2, r2] = o2(n2);
              if (t3 > 100 || e3 > 100 || s2 > 100 || r2 > 100) break t;
              return { values: y(t3, e3, s2, r2), type: i3 };
            }
            case "rgba": {
              let [, t3, , e3, , s2, , , r2] = o2(n2);
              if (t3 = "%" === n2[2] ? t3 / 100 * 255 : t3, e3 = "%" === n2[4] ? e3 / 100 * 255 : e3, s2 = "%" === n2[6] ? s2 / 100 * 255 : s2, r2 = "%" === n2[9] ? r2 / 100 : r2, t3 > 255 || e3 > 255 || s2 > 255 || r2 < 0 || r2 > 1) break t;
              return { values: [...b2(t3, e3, s2), r2], a: r2, type: i3 };
            }
            case "hexa": {
              let [, t3] = n2;
              4 !== t3.length && 3 !== t3.length || (t3 = t3.split("").map((t4) => t4 + t4).join(""));
              const e3 = t3.substring(0, 6);
              let o3 = t3.substring(6);
              return o3 = o3 ? parseInt(o3, 16) / 255 : void 0, { values: [..._2(e3), o3], a: o3, type: i3 };
            }
            case "hsla": {
              let [, t3, e3, s2, , r2] = o2(n2);
              if (r2 = "%" === n2[6] ? r2 / 100 : r2, t3 > 360 || e3 > 100 || s2 > 100 || r2 < 0 || r2 > 1) break t;
              return { values: [...g(t3, e3, s2), r2], a: r2, type: i3 };
            }
            case "hsva": {
              let [, t3, e3, s2, , r2] = o2(n2);
              if (r2 = "%" === n2[6] ? r2 / 100 : r2, t3 > 360 || e3 > 100 || s2 > 100 || r2 < 0 || r2 > 1) break t;
              return { values: [t3, e3, s2, r2], a: r2, type: i3 };
            }
          }
          return { values: null, type: null };
        }
        function A2(t2 = 0, e2 = 0, o2 = 0, n2 = 1) {
          const i3 = (t3, e3) => (o3 = -1) => e3(~o3 ? t3.map((t4) => Number(t4.toFixed(o3))) : t3), s2 = { h: t2, s: e2, v: o2, a: n2, toHSVA() {
            const t3 = [s2.h, s2.s, s2.v, s2.a];
            return t3.toString = i3(t3, (t4) => `hsva(${t4[0]}, ${t4[1]}%, ${t4[2]}%, ${s2.a})`), t3;
          }, toHSLA() {
            const t3 = [...v(s2.h, s2.s, s2.v), s2.a];
            return t3.toString = i3(t3, (t4) => `hsla(${t4[0]}, ${t4[1]}%, ${t4[2]}%, ${s2.a})`), t3;
          }, toRGBA() {
            const t3 = [...f(s2.h, s2.s, s2.v), s2.a];
            return t3.toString = i3(t3, (t4) => `rgba(${t4[0]}, ${t4[1]}, ${t4[2]}, ${s2.a})`), t3;
          }, toCMYK() {
            const t3 = function(t4, e3, o3) {
              const n3 = f(t4, e3, o3), i4 = n3[0] / 255, s3 = n3[1] / 255, r2 = n3[2] / 255, a2 = u(1 - i4, 1 - s3, 1 - r2);
              return [100 * (1 === a2 ? 0 : (1 - i4 - a2) / (1 - a2)), 100 * (1 === a2 ? 0 : (1 - s3 - a2) / (1 - a2)), 100 * (1 === a2 ? 0 : (1 - r2 - a2) / (1 - a2)), 100 * a2];
            }(s2.h, s2.s, s2.v);
            return t3.toString = i3(t3, (t4) => `cmyk(${t4[0]}%, ${t4[1]}%, ${t4[2]}%, ${t4[3]}%)`), t3;
          }, toHEXA() {
            const t3 = function(t4, e4, o3) {
              return f(t4, e4, o3).map((t5) => m(t5).toString(16).padStart(2, "0"));
            }(s2.h, s2.s, s2.v), e3 = s2.a >= 1 ? "" : Number((255 * s2.a).toFixed(0)).toString(16).toUpperCase().padStart(2, "0");
            return e3 && t3.push(e3), t3.toString = () => `#${t3.join("").toUpperCase()}`, t3;
          }, clone: () => A2(s2.h, s2.s, s2.v, s2.a) };
          return s2;
        }
        const $2 = (t2) => Math.max(Math.min(t2, 1), 0);
        function C2(t2) {
          const e2 = { options: Object.assign({ lock: null, onchange: () => 0, onstop: () => 0 }, t2), _keyboard(t3) {
            const { options: o3 } = e2, { type: n3, key: i3 } = t3;
            if (document.activeElement === o3.wrapper) {
              const { lock: o4 } = e2.options, s2 = "ArrowUp" === i3, r3 = "ArrowRight" === i3, a2 = "ArrowDown" === i3, l2 = "ArrowLeft" === i3;
              if ("keydown" === n3 && (s2 || r3 || a2 || l2)) {
                let n4 = 0, i4 = 0;
                "v" === o4 ? n4 = s2 || r3 ? 1 : -1 : "h" === o4 ? n4 = s2 || r3 ? -1 : 1 : (i4 = s2 ? -1 : a2 ? 1 : 0, n4 = l2 ? -1 : r3 ? 1 : 0), e2.update($2(e2.cache.x + 0.01 * n4), $2(e2.cache.y + 0.01 * i4)), t3.preventDefault();
              } else i3.startsWith("Arrow") && (e2.options.onstop(), t3.preventDefault());
            }
          }, _tapstart(t3) {
            i2(document, ["mouseup", "touchend", "touchcancel"], e2._tapstop), i2(document, ["mousemove", "touchmove"], e2._tapmove), t3.cancelable && t3.preventDefault(), e2._tapmove(t3);
          }, _tapmove(t3) {
            const { options: o3, cache: n3 } = e2, { lock: i3, element: s2, wrapper: r3 } = o3, a2 = r3.getBoundingClientRect();
            let l2 = 0, c2 = 0;
            if (t3) {
              const e3 = t3 && t3.touches && t3.touches[0];
              l2 = t3 ? (e3 || t3).clientX : 0, c2 = t3 ? (e3 || t3).clientY : 0, l2 < a2.left ? l2 = a2.left : l2 > a2.left + a2.width && (l2 = a2.left + a2.width), c2 < a2.top ? c2 = a2.top : c2 > a2.top + a2.height && (c2 = a2.top + a2.height), l2 -= a2.left, c2 -= a2.top;
            } else n3 && (l2 = n3.x * a2.width, c2 = n3.y * a2.height);
            "h" !== i3 && (s2.style.left = `calc(${l2 / a2.width * 100}% - ${s2.offsetWidth / 2}px)`), "v" !== i3 && (s2.style.top = `calc(${c2 / a2.height * 100}% - ${s2.offsetHeight / 2}px)`), e2.cache = { x: l2 / a2.width, y: c2 / a2.height };
            const p2 = $2(l2 / a2.width), u2 = $2(c2 / a2.height);
            switch (i3) {
              case "v":
                return o3.onchange(p2);
              case "h":
                return o3.onchange(u2);
              default:
                return o3.onchange(p2, u2);
            }
          }, _tapstop() {
            e2.options.onstop(), s(document, ["mouseup", "touchend", "touchcancel"], e2._tapstop), s(document, ["mousemove", "touchmove"], e2._tapmove);
          }, trigger() {
            e2._tapmove();
          }, update(t3 = 0, o3 = 0) {
            const { left: n3, top: i3, width: s2, height: r3 } = e2.options.wrapper.getBoundingClientRect();
            "h" === e2.options.lock && (o3 = t3), e2._tapmove({ clientX: n3 + s2 * t3, clientY: i3 + r3 * o3 });
          }, destroy() {
            const { options: t3, _tapstart: o3, _keyboard: n3 } = e2;
            s(document, ["keydown", "keyup"], n3), s([t3.wrapper, t3.element], "mousedown", o3), s([t3.wrapper, t3.element], "touchstart", o3, { passive: false });
          } }, { options: o2, _tapstart: n2, _keyboard: r2 } = e2;
          return i2([o2.wrapper, o2.element], "mousedown", n2), i2([o2.wrapper, o2.element], "touchstart", n2, { passive: false }), i2(document, ["keydown", "keyup"], r2), e2;
        }
        function k2(t2 = {}) {
          t2 = Object.assign({ onchange: () => 0, className: "", elements: [] }, t2);
          const e2 = i2(t2.elements, "click", (e3) => {
            t2.elements.forEach((o2) => o2.classList[e3.target === o2 ? "add" : "remove"](t2.className)), t2.onchange(e3), e3.stopPropagation();
          });
          return { destroy: () => s(...e2) };
        }
        const S2 = { variantFlipOrder: { start: "sme", middle: "mse", end: "ems" }, positionFlipOrder: { top: "tbrl", right: "rltb", bottom: "btrl", left: "lrbt" }, position: "bottom", margin: 8, padding: 0 }, O2 = (t2, e2, o2) => {
          const n2 = "object" != typeof t2 || t2 instanceof HTMLElement ? { reference: t2, popper: e2, ...o2 } : t2;
          return { update(t3 = n2) {
            const { reference: e3, popper: o3 } = Object.assign(n2, t3);
            if (!o3 || !e3) throw new Error("Popper- or reference-element missing.");
            return ((t4, e4, o4) => {
              const { container: n3, arrow: i3, margin: s2, padding: r2, position: a2, variantFlipOrder: l2, positionFlipOrder: c2 } = { container: document.documentElement.getBoundingClientRect(), ...S2, ...o4 }, { left: p2, top: u2 } = e4.style;
              e4.style.left = "0", e4.style.top = "0";
              const h3 = t4.getBoundingClientRect(), d2 = e4.getBoundingClientRect(), m2 = { t: h3.top - d2.height - s2, b: h3.bottom + s2, r: h3.right + s2, l: h3.left - d2.width - s2 }, f2 = { vs: h3.left, vm: h3.left + h3.width / 2 - d2.width / 2, ve: h3.left + h3.width - d2.width, hs: h3.top, hm: h3.bottom - h3.height / 2 - d2.height / 2, he: h3.bottom - d2.height }, [v2, b3 = "middle"] = a2.split("-"), y2 = c2[v2], g2 = l2[b3], { top: _3, left: w3, bottom: A3, right: $3 } = n3;
              for (const t5 of y2) {
                const o5 = "t" === t5 || "b" === t5;
                let n4 = m2[t5];
                const [s3, a3] = o5 ? ["top", "left"] : ["left", "top"], [l3, c3] = o5 ? [d2.height, d2.width] : [d2.width, d2.height], [p3, u3] = o5 ? [A3, $3] : [$3, A3], [v3, b4] = o5 ? [_3, w3] : [w3, _3];
                if (!(n4 < v3 || n4 + l3 + r2 > p3)) for (const p4 of g2) {
                  let m3 = f2[(o5 ? "v" : "h") + p4];
                  if (!(m3 < b4 || m3 + c3 + r2 > u3)) {
                    if (m3 -= d2[a3], n4 -= d2[s3], e4.style[a3] = `${m3}px`, e4.style[s3] = `${n4}px`, i3) {
                      const e5 = o5 ? h3.width / 2 : h3.height / 2, r3 = c3 / 2, u4 = e5 > r3, d3 = m3 + { s: u4 ? r3 : e5, m: r3, e: u4 ? r3 : c3 - e5 }[p4], f3 = n4 + { t: l3, b: 0, r: 0, l: l3 }[t5];
                      i3.style[a3] = `${d3}px`, i3.style[s3] = `${f3}px`;
                    }
                    return t5 + p4;
                  }
                }
              }
              return e4.style.left = p2, e4.style.top = u2, null;
            })(e3, o3, n2);
          } };
        };
        const _E = class _E {
          constructor(t2) {
            __publicField(this, "_initializingActive", true);
            __publicField(this, "_recalc", true);
            __publicField(this, "_nanopop", null);
            __publicField(this, "_root", null);
            __publicField(this, "_color", A2());
            __publicField(this, "_lastColor", A2());
            __publicField(this, "_swatchColors", []);
            __publicField(this, "_setupAnimationFrame", null);
            __publicField(this, "_eventListener", { init: [], save: [], hide: [], show: [], clear: [], change: [], changestop: [], cancel: [], swatchselect: [] });
            this.options = t2 = Object.assign({ ..._E.DEFAULT_OPTIONS }, t2);
            const { swatches: e2, components: o2, theme: n2, sliders: i3, lockOpacity: s2, padding: r2 } = t2;
            ["nano", "monolith"].includes(n2) && !i3 && (t2.sliders = "h"), o2.interaction || (o2.interaction = {});
            const { preview: a2, opacity: l2, hue: c2, palette: p2 } = o2;
            o2.opacity = !s2 && l2, o2.palette = p2 || a2 || l2 || c2, this._preBuild(), this._buildComponents(), this._bindEvents(), this._finalBuild(), e2 && e2.length && e2.forEach((t3) => this.addSwatch(t3));
            const { button: u2, app: h3 } = this._root;
            this._nanopop = O2(u2, h3, { margin: r2 }), u2.setAttribute("role", "button"), u2.setAttribute("aria-label", this._t("btn:toggle"));
            const d2 = this;
            this._setupAnimationFrame = requestAnimationFrame(function e3() {
              if (!h3.offsetWidth) return requestAnimationFrame(e3);
              d2.setColor(t2.default), d2._rePositioningPicker(), t2.defaultRepresentation && (d2._representation = t2.defaultRepresentation, d2.setColorRepresentation(d2._representation)), t2.showAlways && d2.show(), d2._initializingActive = false, d2._emit("init");
            });
          }
          _preBuild() {
            const { options: t2 } = this;
            for (const e2 of ["el", "container"]) t2[e2] = c(t2[e2]);
            this._root = ((t3) => {
              const { components: e2, useAsButton: o2, inline: n2, appClass: i3, theme: s2, lockOpacity: r2 } = t3.options, l2 = (t4) => t4 ? "" : 'style="display:none" hidden', c2 = (e3) => t3._t(e3), p2 = a(`
      <div :ref="root" class="pickr">

        ${o2 ? "" : '<button type="button" :ref="button" class="pcr-button"></button>'}

        <div :ref="app" class="pcr-app ${i3 || ""}" data-theme="${s2}" ${n2 ? 'style="position: unset"' : ""} aria-label="${c2("ui:dialog")}" role="window">
          <div class="pcr-selection" ${l2(e2.palette)}>
            <div :obj="preview" class="pcr-color-preview" ${l2(e2.preview)}>
              <button type="button" :ref="lastColor" class="pcr-last-color" aria-label="${c2("btn:last-color")}"></button>
              <div :ref="currentColor" class="pcr-current-color"></div>
            </div>

            <div :obj="palette" class="pcr-color-palette">
              <div :ref="picker" class="pcr-picker"></div>
              <div :ref="palette" class="pcr-palette" tabindex="0" aria-label="${c2("aria:palette")}" role="listbox"></div>
            </div>

            <div :obj="hue" class="pcr-color-chooser" ${l2(e2.hue)}>
              <div :ref="picker" class="pcr-picker"></div>
              <div :ref="slider" class="pcr-hue pcr-slider" tabindex="0" aria-label="${c2("aria:hue")}" role="slider"></div>
            </div>

            <div :obj="opacity" class="pcr-color-opacity" ${l2(e2.opacity)}>
              <div :ref="picker" class="pcr-picker"></div>
              <div :ref="slider" class="pcr-opacity pcr-slider" tabindex="0" aria-label="${c2("aria:opacity")}" role="slider"></div>
            </div>
          </div>

          <div class="pcr-swatches ${e2.palette ? "" : "pcr-last"}" :ref="swatches"></div>

          <div :obj="interaction" class="pcr-interaction" ${l2(Object.keys(e2.interaction).length)}>
            <input :ref="result" class="pcr-result" type="text" spellcheck="false" ${l2(e2.interaction.input)} aria-label="${c2("aria:input")}">

            <input :arr="options" class="pcr-type" data-type="HEXA" value="${r2 ? "HEX" : "HEXA"}" type="button" ${l2(e2.interaction.hex)}>
            <input :arr="options" class="pcr-type" data-type="RGBA" value="${r2 ? "RGB" : "RGBA"}" type="button" ${l2(e2.interaction.rgba)}>
            <input :arr="options" class="pcr-type" data-type="HSLA" value="${r2 ? "HSL" : "HSLA"}" type="button" ${l2(e2.interaction.hsla)}>
            <input :arr="options" class="pcr-type" data-type="HSVA" value="${r2 ? "HSV" : "HSVA"}" type="button" ${l2(e2.interaction.hsva)}>
            <input :arr="options" class="pcr-type" data-type="CMYK" value="CMYK" type="button" ${l2(e2.interaction.cmyk)}>

            <input :ref="save" class="pcr-save" value="${c2("btn:save")}" type="button" ${l2(e2.interaction.save)} aria-label="${c2("aria:btn:save")}">
            <input :ref="cancel" class="pcr-cancel" value="${c2("btn:cancel")}" type="button" ${l2(e2.interaction.cancel)} aria-label="${c2("aria:btn:cancel")}">
            <input :ref="clear" class="pcr-clear" value="${c2("btn:clear")}" type="button" ${l2(e2.interaction.clear)} aria-label="${c2("aria:btn:clear")}">
          </div>
        </div>
      </div>
    `), u2 = p2.interaction;
              return u2.options.find((t4) => !t4.hidden && !t4.classList.add("active")), u2.type = () => u2.options.find((t4) => t4.classList.contains("active")), p2;
            })(this), t2.useAsButton && (this._root.button = t2.el), t2.container.appendChild(this._root.root);
          }
          _finalBuild() {
            const t2 = this.options, e2 = this._root;
            if (t2.container.removeChild(e2.root), t2.inline) {
              const o2 = t2.el.parentElement;
              t2.el.nextSibling ? o2.insertBefore(e2.app, t2.el.nextSibling) : o2.appendChild(e2.app);
            } else t2.container.appendChild(e2.app);
            t2.useAsButton ? t2.inline && t2.el.remove() : t2.el.parentNode.replaceChild(e2.root, t2.el), t2.disabled && this.disable(), t2.comparison || (e2.button.style.transition = "none", t2.useAsButton || (e2.preview.lastColor.style.transition = "none")), this.hide();
          }
          _buildComponents() {
            const t2 = this, e2 = this.options.components, o2 = (t2.options.sliders || "v").repeat(2), [n2, i3] = o2.match(/^[vh]+$/g) ? o2 : [], s2 = () => this._color || (this._color = this._lastColor.clone()), r2 = { palette: C2({ element: t2._root.palette.picker, wrapper: t2._root.palette.palette, onstop: () => t2._emit("changestop", "slider", t2), onchange(o3, n3) {
              if (!e2.palette) return;
              const i4 = s2(), { _root: r3, options: a2 } = t2, { lastColor: l2, currentColor: c2 } = r3.preview;
              t2._recalc && (i4.s = 100 * o3, i4.v = 100 - 100 * n3, i4.v < 0 && (i4.v = 0), t2._updateOutput("slider"));
              const p2 = i4.toRGBA().toString(0);
              this.element.style.background = p2, this.wrapper.style.background = `
                        linear-gradient(to top, rgba(0, 0, 0, ${i4.a}), transparent),
                        linear-gradient(to left, hsla(${i4.h}, 100%, 50%, ${i4.a}), rgba(255, 255, 255, ${i4.a}))
                    `, a2.comparison ? a2.useAsButton || t2._lastColor || l2.style.setProperty("--pcr-color", p2) : (r3.button.style.setProperty("--pcr-color", p2), r3.button.classList.remove("clear"));
              const u2 = i4.toHEXA().toString();
              for (const { el: e3, color: o4 } of t2._swatchColors) e3.classList[u2 === o4.toHEXA().toString() ? "add" : "remove"]("pcr-active");
              c2.style.setProperty("--pcr-color", p2);
            } }), hue: C2({ lock: "v" === i3 ? "h" : "v", element: t2._root.hue.picker, wrapper: t2._root.hue.slider, onstop: () => t2._emit("changestop", "slider", t2), onchange(o3) {
              if (!e2.hue || !e2.palette) return;
              const n3 = s2();
              t2._recalc && (n3.h = 360 * o3), this.element.style.backgroundColor = `hsl(${n3.h}, 100%, 50%)`, r2.palette.trigger();
            } }), opacity: C2({ lock: "v" === n2 ? "h" : "v", element: t2._root.opacity.picker, wrapper: t2._root.opacity.slider, onstop: () => t2._emit("changestop", "slider", t2), onchange(o3) {
              if (!e2.opacity || !e2.palette) return;
              const n3 = s2();
              t2._recalc && (n3.a = Math.round(100 * o3) / 100), this.element.style.background = `rgba(0, 0, 0, ${n3.a})`, r2.palette.trigger();
            } }), selectable: k2({ elements: t2._root.interaction.options, className: "active", onchange(e3) {
              t2._representation = e3.target.getAttribute("data-type").toUpperCase(), t2._recalc && t2._updateOutput("swatch");
            } }) };
            this._components = r2;
          }
          _bindEvents() {
            const { _root: t2, options: e2 } = this, o2 = [i2(t2.interaction.clear, "click", () => this._clearColor()), i2([t2.interaction.cancel, t2.preview.lastColor], "click", () => {
              this.setHSVA(...(this._lastColor || this._color).toHSVA(), true), this._emit("cancel");
            }), i2(t2.interaction.save, "click", () => {
              !this.applyColor() && !e2.showAlways && this.hide();
            }), i2(t2.interaction.result, ["keyup", "input"], (t3) => {
              this.setColor(t3.target.value, true) && !this._initializingActive && (this._emit("change", this._color, "input", this), this._emit("changestop", "input", this)), t3.stopImmediatePropagation();
            }), i2(t2.interaction.result, ["focus", "blur"], (t3) => {
              this._recalc = "blur" === t3.type, this._recalc && this._updateOutput(null);
            }), i2([t2.palette.palette, t2.palette.picker, t2.hue.slider, t2.hue.picker, t2.opacity.slider, t2.opacity.picker], ["mousedown", "touchstart"], () => this._recalc = true, { passive: true })];
            if (!e2.showAlways) {
              const n2 = e2.closeWithKey;
              o2.push(i2(t2.button, "click", () => this.isOpen() ? this.hide() : this.show()), i2(document, "keyup", (t3) => this.isOpen() && (t3.key === n2 || t3.code === n2) && this.hide()), i2(document, ["touchstart", "mousedown"], (e3) => {
                this.isOpen() && !l(e3).some((e4) => e4 === t2.app || e4 === t2.button) && this.hide();
              }, { capture: true }));
            }
            if (e2.adjustableNumbers) {
              const e3 = { rgba: [255, 255, 255, 1], hsva: [360, 100, 100, 1], hsla: [360, 100, 100, 1], cmyk: [100, 100, 100, 100] };
              p(t2.interaction.result, (t3, o3, n2) => {
                const i3 = e3[this.getColorRepresentation().toLowerCase()];
                if (i3) {
                  const e4 = i3[n2], s2 = t3 + (e4 >= 100 ? 1e3 * o3 : o3);
                  return s2 <= 0 ? 0 : Number((s2 < e4 ? s2 : e4).toPrecision(3));
                }
                return t3;
              });
            }
            if (e2.autoReposition && !e2.inline) {
              let t3 = null;
              const n2 = this;
              o2.push(i2(window, ["scroll", "resize"], () => {
                n2.isOpen() && (e2.closeOnScroll && n2.hide(), null === t3 ? (t3 = setTimeout(() => t3 = null, 100), requestAnimationFrame(function e3() {
                  n2._rePositioningPicker(), null !== t3 && requestAnimationFrame(e3);
                })) : (clearTimeout(t3), t3 = setTimeout(() => t3 = null, 100)));
              }, { capture: true }));
            }
            this._eventBindings = o2;
          }
          _rePositioningPicker() {
            const { options: t2 } = this;
            if (!t2.inline) {
              if (!this._nanopop.update({ container: document.body.getBoundingClientRect(), position: t2.position })) {
                const t3 = this._root.app, e2 = t3.getBoundingClientRect();
                t3.style.top = (window.innerHeight - e2.height) / 2 + "px", t3.style.left = (window.innerWidth - e2.width) / 2 + "px";
              }
            }
          }
          _updateOutput(t2) {
            const { _root: e2, _color: o2, options: n2 } = this;
            if (e2.interaction.type()) {
              const t3 = `to${e2.interaction.type().getAttribute("data-type")}`;
              e2.interaction.result.value = "function" == typeof o2[t3] ? o2[t3]().toString(n2.outputPrecision) : "";
            }
            !this._initializingActive && this._recalc && this._emit("change", o2, t2, this);
          }
          _clearColor(t2 = false) {
            const { _root: e2, options: o2 } = this;
            o2.useAsButton || e2.button.style.setProperty("--pcr-color", "rgba(0, 0, 0, 0.15)"), e2.button.classList.add("clear"), o2.showAlways || this.hide(), this._lastColor = null, this._initializingActive || t2 || (this._emit("save", null), this._emit("clear"));
          }
          _parseLocalColor(t2) {
            const { values: e2, type: o2, a: n2 } = w2(t2), { lockOpacity: i3 } = this.options, s2 = void 0 !== n2 && 1 !== n2;
            return e2 && 3 === e2.length && (e2[3] = void 0), { values: !e2 || i3 && s2 ? null : e2, type: o2 };
          }
          _t(t2) {
            return this.options.i18n[t2] || _E.I18N_DEFAULTS[t2];
          }
          _emit(t2, ...e2) {
            this._eventListener[t2].forEach((t3) => t3(...e2, this));
          }
          on(t2, e2) {
            return this._eventListener[t2].push(e2), this;
          }
          off(t2, e2) {
            const o2 = this._eventListener[t2] || [], n2 = o2.indexOf(e2);
            return ~n2 && o2.splice(n2, 1), this;
          }
          addSwatch(t2) {
            const { values: e2 } = this._parseLocalColor(t2);
            if (e2) {
              const { _swatchColors: t3, _root: o2 } = this, n2 = A2(...e2), s2 = r(`<button type="button" style="--pcr-color: ${n2.toRGBA().toString(0)}" aria-label="${this._t("btn:swatch")}"/>`);
              return o2.swatches.appendChild(s2), t3.push({ el: s2, color: n2 }), this._eventBindings.push(i2(s2, "click", () => {
                this.setHSVA(...n2.toHSVA(), true), this._emit("swatchselect", n2), this._emit("change", n2, "swatch", this);
              })), true;
            }
            return false;
          }
          removeSwatch(t2) {
            const e2 = this._swatchColors[t2];
            if (e2) {
              const { el: o2 } = e2;
              return this._root.swatches.removeChild(o2), this._swatchColors.splice(t2, 1), true;
            }
            return false;
          }
          applyColor(t2 = false) {
            const { preview: e2, button: o2 } = this._root, n2 = this._color.toRGBA().toString(0);
            return e2.lastColor.style.setProperty("--pcr-color", n2), this.options.useAsButton || o2.style.setProperty("--pcr-color", n2), o2.classList.remove("clear"), this._lastColor = this._color.clone(), this._initializingActive || t2 || this._emit("save", this._color), this;
          }
          destroy() {
            cancelAnimationFrame(this._setupAnimationFrame), this._eventBindings.forEach((t2) => s(...t2)), Object.keys(this._components).forEach((t2) => this._components[t2].destroy());
          }
          destroyAndRemove() {
            this.destroy();
            const { root: t2, app: e2 } = this._root;
            t2.parentElement && t2.parentElement.removeChild(t2), e2.parentElement.removeChild(e2), Object.keys(this).forEach((t3) => this[t3] = null);
          }
          hide() {
            return !!this.isOpen() && (this._root.app.classList.remove("visible"), this._emit("hide"), true);
          }
          show() {
            return !this.options.disabled && !this.isOpen() && (this._root.app.classList.add("visible"), this._rePositioningPicker(), this._emit("show", this._color), this);
          }
          isOpen() {
            return this._root.app.classList.contains("visible");
          }
          setHSVA(t2 = 360, e2 = 0, o2 = 0, n2 = 1, i3 = false) {
            const s2 = this._recalc;
            if (this._recalc = false, t2 < 0 || t2 > 360 || e2 < 0 || e2 > 100 || o2 < 0 || o2 > 100 || n2 < 0 || n2 > 1) return false;
            this._color = A2(t2, e2, o2, n2);
            const { hue: r2, opacity: a2, palette: l2 } = this._components;
            return r2.update(t2 / 360), a2.update(n2), l2.update(e2 / 100, 1 - o2 / 100), i3 || this.applyColor(), s2 && this._updateOutput(), this._recalc = s2, true;
          }
          setColor(t2, e2 = false) {
            if (null === t2) return this._clearColor(e2), true;
            const { values: o2, type: n2 } = this._parseLocalColor(t2);
            if (o2) {
              const t3 = n2.toUpperCase(), { options: i3 } = this._root.interaction, s2 = i3.find((e3) => e3.getAttribute("data-type") === t3);
              if (s2 && !s2.hidden) for (const t4 of i3) t4.classList[t4 === s2 ? "add" : "remove"]("active");
              return !!this.setHSVA(...o2, e2) && this.setColorRepresentation(t3);
            }
            return false;
          }
          setColorRepresentation(t2) {
            return t2 = t2.toUpperCase(), !!this._root.interaction.options.find((e2) => e2.getAttribute("data-type").startsWith(t2) && !e2.click());
          }
          getColorRepresentation() {
            return this._representation;
          }
          getColor() {
            return this._color;
          }
          getSelectedColor() {
            return this._lastColor;
          }
          getRoot() {
            return this._root;
          }
          disable() {
            return this.hide(), this.options.disabled = true, this._root.button.classList.add("disabled"), this;
          }
          enable() {
            return this.options.disabled = false, this._root.button.classList.remove("disabled"), this;
          }
        };
        __publicField(_E, "utils", o);
        __publicField(_E, "version", "1.9.1");
        __publicField(_E, "I18N_DEFAULTS", { "ui:dialog": "color picker dialog", "btn:toggle": "toggle color picker dialog", "btn:swatch": "color swatch", "btn:last-color": "use previous color", "btn:save": "Save", "btn:cancel": "Cancel", "btn:clear": "Clear", "aria:btn:save": "save and close", "aria:btn:cancel": "cancel and close", "aria:btn:clear": "clear and close", "aria:input": "color input field", "aria:palette": "color selection area", "aria:hue": "hue selection slider", "aria:opacity": "selection slider" });
        __publicField(_E, "DEFAULT_OPTIONS", { appClass: null, theme: "classic", useAsButton: false, padding: 8, disabled: false, comparison: true, closeOnScroll: false, outputPrecision: 0, lockOpacity: false, autoReposition: true, container: "body", components: { interaction: {} }, i18n: {}, swatches: null, inline: false, sliders: null, default: "#42445a", defaultRepresentation: null, position: "bottom-middle", adjustableNumbers: true, showAlways: false, closeWithKey: "Escape" });
        __publicField(_E, "create", (t2) => new _E(t2));
        let E2 = _E;
        return e = e.default;
      })());
    })(pickr_min);
    return pickr_min.exports;
  }
  var pickr_minExports = requirePickr_min();
  const Pickr = /* @__PURE__ */ getDefaultExportFromCjs(pickr_minExports);
  const ColorPicker = ({ color, setColor, setIsOpen, defaultTextColor: defaultTextColor2 }) => {
    const [tab, setTab] = reactExports.useState("tab1");
    const defaultColor = defaultTextColor2;
    const onColorChange = (color2, open) => {
      setColor(color2);
      if (!open) setIsOpen(false);
    };
    const resetColor = () => {
      setColor(defaultColor);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `${tab == "tab1" ? "bg-gray-100" : ""} inline-flex items-center justify-center whitespace-nowrap rounded-tl-sm text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 border border-input dark:text-dark-300 bg-background shadow-sm hover:bg-accent hover:text-accent-foreground h-10 w-full py-3`,
            onClick: () => setTab("tab1"),
            children: "Simple"
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: `${tab == "tab2" ? "bg-gray-100" : ""} inline-flex items-center justify-center whitespace-nowrap rounded-tl-sm text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 border border-input dark:text-dark-300 bg-background shadow-sm hover:bg-accent hover:text-accent-foreground h-10 w-full py-3`,
            onClick: () => setTab("tab2"),
            children: "Advance"
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${tab === "tab1" ? "block bg-gray-100" : "hidden"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridColorPicker, { onColorChange }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${tab === "tab2" ? "block bg-gray-100" : "hidden"} advance-color-picker`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SimonColorPicker, { onColorChange, defaultColor }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center bg-gray-100 py-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          className: "!w-full",
          size: "sm",
          onClick: resetColor,
          children: "Reset to Default"
        }
      ) })
    ] });
  };
  const GridColorPicker = ({ onColorChange }) => {
    const colors = [
      "#000000",
      "#FF0201",
      "#FF9902",
      "#FFFF04",
      "#00FF03",
      "#00FFFF",
      "#0600FF",
      "#9A00FF",
      "#FF00FF",
      "#FFFFFF",
      "#F4CCCC",
      "#FCE5CD",
      "#FFF2CC",
      "#D9EAD3",
      "#D0E0E3",
      "#CFE2F3",
      "#D9D2E9",
      "#EAD1DC",
      "#FAFAFA",
      "#EA9999",
      "#F9CB9C",
      "#FFE599",
      "#B6D7A8",
      "#A2C4C9",
      "#9FC5E8",
      "#B4A7D6",
      "#D5A6BD",
      "#EEEEEE",
      "#E06666",
      "#F6B26B",
      "#FFD966",
      "#93C47D",
      "#76A5AF",
      "#6FA8DC",
      "#8E7CC3",
      "#C27BA0",
      "#CCCCCC",
      "#CC0201",
      "#E69138",
      "#F1C233",
      "#69A84F",
      "#45818E",
      "#3D85C6",
      "#674EA7",
      "#A64D79",
      "#999999",
      "#990100",
      "#B45F06",
      "#BF9002",
      "#37761D",
      "#134F5C",
      "#0C5394",
      "#351C75",
      "#741B47",
      "#666666",
      "#660000",
      "#783F04",
      "#7F6001",
      "#274E13",
      "#0C343D",
      "#073763",
      "#20124D",
      "#4C1130"
    ];
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-9 gap-2 p-4 ", children: colors.map((color, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: { "backgroundColor": color },
        className: `w-5 h-5 rounded shadow-md cursor-pointer border border-gray-300`,
        title: color,
        onClick: () => onColorChange(color, false)
      },
      index
    )) }) });
  };
  const SimonColorPicker = ({ onColorChange, defaultColor }) => {
    const [color, setColor] = reactExports.useState(defaultColor);
    const pickerRef = React.useRef(null);
    reactExports.useEffect(() => {
      const pickr = Pickr.create({
        el: pickerRef.current,
        theme: "nano",
        useAsButton: true,
        inline: true,
        width: 100,
        default: color,
        components: {
          // Main components
          preview: true,
          opacity: true,
          hue: true,
          // Input / output Options
          interaction: {
            hex: true,
            rgba: true,
            hsla: true,
            hsva: true,
            cmyk: true,
            input: true
          }
        },
        defaultRepresentation: "HEX",
        showAlways: true
      });
      pickr.on("change", (color2) => {
        const selectedColor = color2.toHEXA().toString();
        setColor(selectedColor);
        onColorChange(selectedColor, true);
      });
      return () => pickr.destroy();
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: pickerRef });
  };
  const getTextColorFromSelection = (state) => {
    var _a2;
    const { from, to, empty: empty2 } = state.selection;
    const markType = state.schema.marks.textColor;
    let textColor2 = null;
    if (!markType) return null;
    if (empty2) {
      const storedMark = (_a2 = state.storedMarks) == null ? void 0 : _a2.find((m) => m.type === markType);
      if (storedMark) {
        return storedMark.attrs.color;
      }
      const marksAtCursor = state.selection.$from.marks();
      const mark = marksAtCursor.find((m) => m.type === markType);
      if (mark) {
        return mark.attrs.color;
      }
    }
    state.doc.nodesBetween(from, to, (node) => {
      if (node.marks && node.marks.length) {
        const mark = node.marks.find((m) => m.type === markType);
        if (mark) {
          textColor2 = mark.attrs.color;
          return false;
        }
      }
    });
    return textColor2;
  };
  const textColorPluginKey = new PluginKey("textColor");
  const textColorPlugin = new Plugin({
    key: textColorPluginKey,
    state: {
      init(_config, state) {
        return getTextColorFromSelection(state) || null;
      },
      apply(tr, value, oldState, newState) {
        if (tr.docChanged || tr.selectionSet) {
          return getTextColorFromSelection(newState) || null;
        }
        return value;
      }
    }
  });
  let defaultTextColor = "#000";
  let selectedTextColor = "";
  const DropdownColorMenu = ({ editorView, icon }) => {
    const [open, setOpen] = reactExports.useState(false);
    const [color, setColor] = reactExports.useState("");
    const applyTextColor = (color2) => {
      return (state, dispatch) => {
        const { schema: schema2, selection } = state;
        const { from, to } = selection;
        const markType = schema2.marks.textColor;
        if (!markType) return false;
        const attrs = { color: color2 };
        const tr = state.tr;
        if (selection.empty) {
          tr.addStoredMark(markType.create(attrs));
        } else {
          tr.addMark(from, to, markType.create(attrs));
        }
        if (dispatch) dispatch(tr);
        return true;
      };
    };
    reactExports.useEffect(() => {
      if (color) {
        applyTextColor(color)(editorView.state, editorView.dispatch);
        const div = document.getElementById("text-color-svg");
        if (div) {
          div.setAttribute("fill", color);
        }
      }
    }, [color]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ProseMirrorMenuPopup, { open, setOpen, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ProseMirrorMenuButton,
        {
          id: "defaultEditorColor",
          title: "Text Color",
          isActive: defaultTextColor,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlfabateIcon, { color: defaultTextColor })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ProseMirrorMenuOption, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        ColorPicker,
        {
          color,
          setColor,
          setIsOpen: setOpen,
          defaultTextColor
        }
      ) })
    ] });
  };
  const renderReactComponent = (editorView) => {
    const container = document.createElement("div");
    const root = clientExports.createRoot(container);
    root.render(/* @__PURE__ */ jsxRuntimeExports.jsx(DropdownColorMenu, { editorView }));
    return container;
  };
  const textColor = new MenuItem({
    title: `Text color`,
    run: () => {
    },
    select: (state) => {
      const activeFont = textColorPluginKey.getState(state) || true;
      selectedTextColor = getTextColorFromSelection(state);
      const div = document.getElementById("text-color-svg");
      if (div && selectedTextColor) {
        div.setAttribute("fill", selectedTextColor);
      }
      if (div && !selectedTextColor) {
        div.setAttribute("fill", defaultTextColor);
      }
      return activeFont !== null;
    },
    render: (editorView) => renderReactComponent(editorView)
  });
  const HighlightIcon = ({
    width = "15px",
    height = "15px",
    color = "#e8eaed",
    id = "text-bg-color-svg",
    ...props
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        width,
        height,
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M80 0v-160h800V0H80Z",
              fill: color,
              id
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M160-320h56l312-311-29-29-28-28-311 312v56Z",
              fill: "#666666"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M80-240v-170l448-447q11-11 25.5-17t30.5-6q16 0 31 6t27 18l55 56q12 11 17.5 26t5.5 31q0 15-5.5 29.5T777-687L330-240H160Z",
              fill: "#666666"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M720-744l-56-56 56 56Z", fill: "#666666" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M608-631l-29-29-28-28 57 57Z", fill: "#666666" })
        ]
      }
    );
  };
  const getTextBGColorFromSelection = (state) => {
    var _a2;
    const { from, to, empty: empty2 } = state.selection;
    const markType = state.schema.marks.textBackgroundColor;
    let textBackgroundColor = null;
    if (!markType) return null;
    if (empty2) {
      const storedMark = (_a2 = state.storedMarks) == null ? void 0 : _a2.find((m) => m.type === markType);
      if (storedMark) {
        return storedMark.attrs.color;
      }
      const marksAtCursor = state.selection.$from.marks();
      const mark = marksAtCursor.find((m) => m.type === markType);
      if (mark) {
        return mark.attrs.color;
      }
    }
    state.doc.nodesBetween(from, to, (node) => {
      if (node.marks && node.marks.length) {
        const mark = node.marks.find((m) => m.type === markType);
        if (mark) {
          textBackgroundColor = mark.attrs.color;
          return false;
        }
      }
    });
    return textBackgroundColor;
  };
  const textBGColorPluginKey = new PluginKey("textColor");
  const textBGColorPlugin = new Plugin({
    key: textBGColorPluginKey,
    state: {
      init(_config, state) {
        return getTextBGColorFromSelection(state) || null;
      },
      apply(tr, value, oldState, newState) {
        if (tr.docChanged || tr.selectionSet) {
          return getTextBGColorFromSelection(newState) || null;
        }
        return value;
      }
    }
  });
  let defaultTextBGColor = " ";
  let selectedTextBGColor = "";
  const DropdownColorMenu2 = ({ editorView, icon }) => {
    const [open, setOpen] = reactExports.useState(false);
    const [color, setColor] = reactExports.useState("");
    const applyTextBackgroundColor = (color2) => {
      return (state, dispatch) => {
        const { schema: schema2, selection } = state;
        const { from, to } = selection;
        const markType = schema2.marks.textBackgroundColor;
        if (!markType) return false;
        const attrs = { color: color2 };
        const tr = state.tr;
        if (selection.empty) {
          tr.addStoredMark(markType.create(attrs));
        } else {
          tr.addMark(from, to, markType.create(attrs));
        }
        if (dispatch) dispatch(tr);
        return true;
      };
    };
    reactExports.useEffect(() => {
      if (color) {
        applyTextBackgroundColor(color)(editorView.state, editorView.dispatch);
        const div = document.getElementById("text-bg-color-svg");
        if (div) {
          div.setAttribute("fill", color);
        }
      }
    }, [color]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ProseMirrorMenuPopup, { open, setOpen, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ProseMirrorMenuButton,
        {
          id: "defaultEditorBGColor",
          title: "Text Highlight",
          isActive: defaultTextBGColor,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(HighlightIcon, { color: defaultTextBGColor })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ProseMirrorMenuOption, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        ColorPicker,
        {
          color,
          setColor,
          setIsOpen: setOpen,
          defaultTextColor: defaultTextBGColor
        }
      ) })
    ] });
  };
  const renderReactComponent2 = (editorView) => {
    const container = document.createElement("div");
    const root = clientExports.createRoot(container);
    root.render(
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        DropdownColorMenu2,
        {
          editorView,
          icon: `<svg xmlns="http://www.w3.org/2000/svg" height="15px" viewBox="0 -960 960 960" width="15px" fill="#666666"><path d="M80 0v-160h800V0H80Zm140-280 210-560h100l210 560h-96l-50-144H368l-52 144h-96Zm176-224h168l-82-232h-4l-82 232Z"/></svg>`
        }
      )
    );
    return container;
  };
  const textBGColor = new MenuItem({
    title: `Text highlight`,
    run: () => {
    },
    select: (state) => {
      const activeFont = textBGColorPluginKey.getState(state) || true;
      selectedTextBGColor = getTextBGColorFromSelection(state);
      const div = document.getElementById("text-bg-color-svg");
      if (div && selectedTextBGColor) {
        div.setAttribute("fill", selectedTextBGColor);
      }
      if (div && !selectedTextBGColor) {
        div.setAttribute("fill", "#fff");
      }
      return activeFont !== null;
    },
    render: (editorView) => renderReactComponent2(editorView)
  });
  const DecreaseIndentIcon = ({
    width = "15px",
    height = "15px",
    color = "#e8eaed",
    ...props
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width,
        height,
        fill: color,
        ...props,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M120-120v-80h720v80H120Zm320-160v-80h400v80H440Zm0-160v-80h400v80H440Zm0-160v-80h400v80H440ZM120-760v-80h720v80H120Zm160 440L120-480l160-160v320Z" })
      }
    );
  };
  const DecreaseIndentMenu = ({ editorView }) => {
    const applyIndentation = (state, dispatch) => {
      const { schema: schema2, selection } = state;
      const nodeType = schema2.nodes.paragraph;
      const { from, to } = selection;
      let selectedAlign = null;
      let currentPaddingLeft = 0;
      state.doc.nodesBetween(from, to, (node) => {
        if (node.type === nodeType) {
          selectedAlign = node.attrs.align || null;
          const existingPadding = parseInt(node.attrs.paddingLeft, 10) || 0;
          currentPaddingLeft = existingPadding > 0 ? existingPadding - 40 : 0;
        }
      });
      let attrs = {};
      if (currentPaddingLeft > 0) {
        attrs.paddingLeft = `${currentPaddingLeft}px`;
      }
      if (selectedAlign) {
        attrs.align = selectedAlign;
      }
      if (dispatch) {
        dispatch(state.tr.setBlockType(from, to, nodeType, attrs));
      }
      return true;
    };
    const changeIndentation = () => {
      applyIndentation(editorView.state, editorView.dispatch);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative inline-block", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        class: "ProseMirror-icon",
        title: "Decrease indent",
        ref: DecreaseIndentMenu,
        onClick: () => {
          changeIndentation();
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `note-menuitem`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "textAlignIcon", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DecreaseIndentIcon, {}) }) })
      }
    ) });
  };
  const renderReactDecreaseIndentComponent = (editorView) => {
    const container = document.createElement("div");
    const root = clientExports.createRoot(container);
    root.render(/* @__PURE__ */ jsxRuntimeExports.jsx(DecreaseIndentMenu, { editorView }), container);
    return container;
  };
  const proseMirrorMenuDecreaseIndent = new MenuItem({
    title: `Decrease indent`,
    run: () => {
    },
    select: (state) => {
      return true;
    },
    render: (editorView) => renderReactDecreaseIndentComponent(editorView)
  });
  function $parcel$interopDefault(a) {
    return a && a.__esModule ? a.default : a;
  }
  function $c770c458706daa72$export$2e2bcd8739ae039(obj, key2, value) {
    if (key2 in obj) Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    else obj[key2] = value;
    return obj;
  }
  var $fb96b826c0c5f37a$var$n, $fb96b826c0c5f37a$export$41c562ebe57d11e2, $fb96b826c0c5f37a$var$u, $fb96b826c0c5f37a$var$t, $fb96b826c0c5f37a$var$r, $fb96b826c0c5f37a$var$o, $fb96b826c0c5f37a$var$e = {}, $fb96b826c0c5f37a$var$c = [], $fb96b826c0c5f37a$var$s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  function $fb96b826c0c5f37a$var$a(n1, l1) {
    for (var u1 in l1) n1[u1] = l1[u1];
    return n1;
  }
  function $fb96b826c0c5f37a$var$h(n2) {
    var l2 = n2.parentNode;
    l2 && l2.removeChild(n2);
  }
  function $fb96b826c0c5f37a$export$c8a8987d4410bf2d(l3, u2, i1) {
    var t1, r1, o1, f1 = {};
    for (o1 in u2) "key" == o1 ? t1 = u2[o1] : "ref" == o1 ? r1 = u2[o1] : f1[o1] = u2[o1];
    if (arguments.length > 2 && (f1.children = arguments.length > 3 ? $fb96b826c0c5f37a$var$n.call(arguments, 2) : i1), "function" == typeof l3 && null != l3.defaultProps) for (o1 in l3.defaultProps) void 0 === f1[o1] && (f1[o1] = l3.defaultProps[o1]);
    return $fb96b826c0c5f37a$var$y(l3, f1, t1, r1, null);
  }
  function $fb96b826c0c5f37a$var$y(n3, i2, t2, r2, o2) {
    var f2 = {
      type: n3,
      props: i2,
      key: t2,
      ref: r2,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: null == o2 ? ++$fb96b826c0c5f37a$var$u : o2
    };
    return null == o2 && null != $fb96b826c0c5f37a$export$41c562ebe57d11e2.vnode && $fb96b826c0c5f37a$export$41c562ebe57d11e2.vnode(f2), f2;
  }
  function $fb96b826c0c5f37a$export$7d1e3a5e95ceca43() {
    return {
      current: null
    };
  }
  function $fb96b826c0c5f37a$export$ffb0004e005737fa(n4) {
    return n4.children;
  }
  function $fb96b826c0c5f37a$export$16fa2f45be04daa8(n5, l4) {
    this.props = n5, this.context = l4;
  }
  function $fb96b826c0c5f37a$var$k(n6, l5) {
    if (null == l5) return n6.__ ? $fb96b826c0c5f37a$var$k(n6.__, n6.__.__k.indexOf(n6) + 1) : null;
    for (var u3; l5 < n6.__k.length; l5++) if (null != (u3 = n6.__k[l5]) && null != u3.__e) return u3.__e;
    return "function" == typeof n6.type ? $fb96b826c0c5f37a$var$k(n6) : null;
  }
  function $fb96b826c0c5f37a$var$b(n7) {
    var l6, u4;
    if (null != (n7 = n7.__) && null != n7.__c) {
      for (n7.__e = n7.__c.base = null, l6 = 0; l6 < n7.__k.length; l6++) if (null != (u4 = n7.__k[l6]) && null != u4.__e) {
        n7.__e = n7.__c.base = u4.__e;
        break;
      }
      return $fb96b826c0c5f37a$var$b(n7);
    }
  }
  function $fb96b826c0c5f37a$var$m(n8) {
    (!n8.__d && (n8.__d = true) && $fb96b826c0c5f37a$var$t.push(n8) && !$fb96b826c0c5f37a$var$g.__r++ || $fb96b826c0c5f37a$var$o !== $fb96b826c0c5f37a$export$41c562ebe57d11e2.debounceRendering) && (($fb96b826c0c5f37a$var$o = $fb96b826c0c5f37a$export$41c562ebe57d11e2.debounceRendering) || $fb96b826c0c5f37a$var$r)($fb96b826c0c5f37a$var$g);
  }
  function $fb96b826c0c5f37a$var$g() {
    for (var n9; $fb96b826c0c5f37a$var$g.__r = $fb96b826c0c5f37a$var$t.length; ) n9 = $fb96b826c0c5f37a$var$t.sort(function(n10, l7) {
      return n10.__v.__b - l7.__v.__b;
    }), $fb96b826c0c5f37a$var$t = [], n9.some(function(n11) {
      var l8, u5, i3, t3, r3, o3;
      n11.__d && (r3 = (t3 = (l8 = n11).__v).__e, (o3 = l8.__P) && (u5 = [], (i3 = $fb96b826c0c5f37a$var$a({}, t3)).__v = t3.__v + 1, $fb96b826c0c5f37a$var$j(o3, t3, i3, l8.__n, void 0 !== o3.ownerSVGElement, null != t3.__h ? [
        r3
      ] : null, u5, null == r3 ? $fb96b826c0c5f37a$var$k(t3) : r3, t3.__h), $fb96b826c0c5f37a$var$z(u5, t3), t3.__e != r3 && $fb96b826c0c5f37a$var$b(t3)));
    });
  }
  function $fb96b826c0c5f37a$var$w(n12, l9, u6, i4, t4, r4, o4, f3, s1, a1) {
    var h1, v1, p1, _1, b1, m1, g1, w1 = i4 && i4.__k || $fb96b826c0c5f37a$var$c, A1 = w1.length;
    for (u6.__k = [], h1 = 0; h1 < l9.length; h1++) if (null != (_1 = u6.__k[h1] = null == (_1 = l9[h1]) || "boolean" == typeof _1 ? null : "string" == typeof _1 || "number" == typeof _1 || "bigint" == typeof _1 ? $fb96b826c0c5f37a$var$y(null, _1, null, null, _1) : Array.isArray(_1) ? $fb96b826c0c5f37a$var$y($fb96b826c0c5f37a$export$ffb0004e005737fa, {
      children: _1
    }, null, null, null) : _1.__b > 0 ? $fb96b826c0c5f37a$var$y(_1.type, _1.props, _1.key, null, _1.__v) : _1)) {
      if (_1.__ = u6, _1.__b = u6.__b + 1, null === (p1 = w1[h1]) || p1 && _1.key == p1.key && _1.type === p1.type) w1[h1] = void 0;
      else for (v1 = 0; v1 < A1; v1++) {
        if ((p1 = w1[v1]) && _1.key == p1.key && _1.type === p1.type) {
          w1[v1] = void 0;
          break;
        }
        p1 = null;
      }
      $fb96b826c0c5f37a$var$j(n12, _1, p1 = p1 || $fb96b826c0c5f37a$var$e, t4, r4, o4, f3, s1, a1), b1 = _1.__e, (v1 = _1.ref) && p1.ref != v1 && (g1 || (g1 = []), p1.ref && g1.push(p1.ref, null, _1), g1.push(v1, _1.__c || b1, _1)), null != b1 ? (null == m1 && (m1 = b1), "function" == typeof _1.type && _1.__k === p1.__k ? _1.__d = s1 = $fb96b826c0c5f37a$var$x(_1, s1, n12) : s1 = $fb96b826c0c5f37a$var$P(n12, _1, p1, w1, b1, s1), "function" == typeof u6.type && (u6.__d = s1)) : s1 && p1.__e == s1 && s1.parentNode != n12 && (s1 = $fb96b826c0c5f37a$var$k(p1));
    }
    for (u6.__e = m1, h1 = A1; h1--; ) null != w1[h1] && ("function" == typeof u6.type && null != w1[h1].__e && w1[h1].__e == u6.__d && (u6.__d = $fb96b826c0c5f37a$var$k(i4, h1 + 1)), $fb96b826c0c5f37a$var$N(w1[h1], w1[h1]));
    if (g1) for (h1 = 0; h1 < g1.length; h1++) $fb96b826c0c5f37a$var$M(g1[h1], g1[++h1], g1[++h1]);
  }
  function $fb96b826c0c5f37a$var$x(n13, l10, u7) {
    for (var i5, t5 = n13.__k, r5 = 0; t5 && r5 < t5.length; r5++) (i5 = t5[r5]) && (i5.__ = n13, l10 = "function" == typeof i5.type ? $fb96b826c0c5f37a$var$x(i5, l10, u7) : $fb96b826c0c5f37a$var$P(u7, i5, i5, t5, i5.__e, l10));
    return l10;
  }
  function $fb96b826c0c5f37a$export$47e4c5b300681277(n14, l11) {
    return l11 = l11 || [], null == n14 || "boolean" == typeof n14 || (Array.isArray(n14) ? n14.some(function(n15) {
      $fb96b826c0c5f37a$export$47e4c5b300681277(n15, l11);
    }) : l11.push(n14)), l11;
  }
  function $fb96b826c0c5f37a$var$P(n16, l12, u8, i6, t6, r6) {
    var o5, f4, e1;
    if (void 0 !== l12.__d) o5 = l12.__d, l12.__d = void 0;
    else if (null == u8 || t6 != r6 || null == t6.parentNode) n: if (null == r6 || r6.parentNode !== n16) n16.appendChild(t6), o5 = null;
    else {
      for (f4 = r6, e1 = 0; (f4 = f4.nextSibling) && e1 < i6.length; e1 += 2) if (f4 == t6) break n;
      n16.insertBefore(t6, r6), o5 = r6;
    }
    return void 0 !== o5 ? o5 : t6.nextSibling;
  }
  function $fb96b826c0c5f37a$var$C(n17, l13, u9, i7, t7) {
    var r7;
    for (r7 in u9) "children" === r7 || "key" === r7 || r7 in l13 || $fb96b826c0c5f37a$var$H(n17, r7, null, u9[r7], i7);
    for (r7 in l13) t7 && "function" != typeof l13[r7] || "children" === r7 || "key" === r7 || "value" === r7 || "checked" === r7 || u9[r7] === l13[r7] || $fb96b826c0c5f37a$var$H(n17, r7, l13[r7], u9[r7], i7);
  }
  function $fb96b826c0c5f37a$var$$(n18, l14, u10) {
    "-" === l14[0] ? n18.setProperty(l14, u10) : n18[l14] = null == u10 ? "" : "number" != typeof u10 || $fb96b826c0c5f37a$var$s.test(l14) ? u10 : u10 + "px";
  }
  function $fb96b826c0c5f37a$var$H(n19, l15, u11, i8, t8) {
    var r8;
    n: if ("style" === l15) {
      if ("string" == typeof u11) n19.style.cssText = u11;
      else {
        if ("string" == typeof i8 && (n19.style.cssText = i8 = ""), i8) for (l15 in i8) u11 && l15 in u11 || $fb96b826c0c5f37a$var$$(n19.style, l15, "");
        if (u11) for (l15 in u11) i8 && u11[l15] === i8[l15] || $fb96b826c0c5f37a$var$$(n19.style, l15, u11[l15]);
      }
    } else if ("o" === l15[0] && "n" === l15[1]) r8 = l15 !== (l15 = l15.replace(/Capture$/, "")), l15 = l15.toLowerCase() in n19 ? l15.toLowerCase().slice(2) : l15.slice(2), n19.l || (n19.l = {}), n19.l[l15 + r8] = u11, u11 ? i8 || n19.addEventListener(l15, r8 ? $fb96b826c0c5f37a$var$T : $fb96b826c0c5f37a$var$I, r8) : n19.removeEventListener(l15, r8 ? $fb96b826c0c5f37a$var$T : $fb96b826c0c5f37a$var$I, r8);
    else if ("dangerouslySetInnerHTML" !== l15) {
      if (t8) l15 = l15.replace(/xlink[H:h]/, "h").replace(/sName$/, "s");
      else if ("href" !== l15 && "list" !== l15 && "form" !== l15 && "tabIndex" !== l15 && "download" !== l15 && l15 in n19) try {
        n19[l15] = null == u11 ? "" : u11;
        break n;
      } catch (n) {
      }
      "function" == typeof u11 || (null != u11 && (false !== u11 || "a" === l15[0] && "r" === l15[1]) ? n19.setAttribute(l15, u11) : n19.removeAttribute(l15));
    }
  }
  function $fb96b826c0c5f37a$var$I(n20) {
    this.l[n20.type + false]($fb96b826c0c5f37a$export$41c562ebe57d11e2.event ? $fb96b826c0c5f37a$export$41c562ebe57d11e2.event(n20) : n20);
  }
  function $fb96b826c0c5f37a$var$T(n21) {
    this.l[n21.type + true]($fb96b826c0c5f37a$export$41c562ebe57d11e2.event ? $fb96b826c0c5f37a$export$41c562ebe57d11e2.event(n21) : n21);
  }
  function $fb96b826c0c5f37a$var$j(n22, u12, i9, t9, r9, o6, f5, e2, c1) {
    var s2, h2, v2, y1, p2, k1, b2, m2, g2, x1, A2, P1 = u12.type;
    if (void 0 !== u12.constructor) return null;
    null != i9.__h && (c1 = i9.__h, e2 = u12.__e = i9.__e, u12.__h = null, o6 = [
      e2
    ]), (s2 = $fb96b826c0c5f37a$export$41c562ebe57d11e2.__b) && s2(u12);
    try {
      n: if ("function" == typeof P1) {
        if (m2 = u12.props, g2 = (s2 = P1.contextType) && t9[s2.__c], x1 = s2 ? g2 ? g2.props.value : s2.__ : t9, i9.__c ? b2 = (h2 = u12.__c = i9.__c).__ = h2.__E : ("prototype" in P1 && P1.prototype.render ? u12.__c = h2 = new P1(m2, x1) : (u12.__c = h2 = new $fb96b826c0c5f37a$export$16fa2f45be04daa8(m2, x1), h2.constructor = P1, h2.render = $fb96b826c0c5f37a$var$O), g2 && g2.sub(h2), h2.props = m2, h2.state || (h2.state = {}), h2.context = x1, h2.__n = t9, v2 = h2.__d = true, h2.__h = []), null == h2.__s && (h2.__s = h2.state), null != P1.getDerivedStateFromProps && (h2.__s == h2.state && (h2.__s = $fb96b826c0c5f37a$var$a({}, h2.__s)), $fb96b826c0c5f37a$var$a(h2.__s, P1.getDerivedStateFromProps(m2, h2.__s))), y1 = h2.props, p2 = h2.state, v2) null == P1.getDerivedStateFromProps && null != h2.componentWillMount && h2.componentWillMount(), null != h2.componentDidMount && h2.__h.push(h2.componentDidMount);
        else {
          if (null == P1.getDerivedStateFromProps && m2 !== y1 && null != h2.componentWillReceiveProps && h2.componentWillReceiveProps(m2, x1), !h2.__e && null != h2.shouldComponentUpdate && false === h2.shouldComponentUpdate(m2, h2.__s, x1) || u12.__v === i9.__v) {
            h2.props = m2, h2.state = h2.__s, u12.__v !== i9.__v && (h2.__d = false), h2.__v = u12, u12.__e = i9.__e, u12.__k = i9.__k, u12.__k.forEach(function(n23) {
              n23 && (n23.__ = u12);
            }), h2.__h.length && f5.push(h2);
            break n;
          }
          null != h2.componentWillUpdate && h2.componentWillUpdate(m2, h2.__s, x1), null != h2.componentDidUpdate && h2.__h.push(function() {
            h2.componentDidUpdate(y1, p2, k1);
          });
        }
        h2.context = x1, h2.props = m2, h2.state = h2.__s, (s2 = $fb96b826c0c5f37a$export$41c562ebe57d11e2.__r) && s2(u12), h2.__d = false, h2.__v = u12, h2.__P = n22, s2 = h2.render(h2.props, h2.state, h2.context), h2.state = h2.__s, null != h2.getChildContext && (t9 = $fb96b826c0c5f37a$var$a($fb96b826c0c5f37a$var$a({}, t9), h2.getChildContext())), v2 || null == h2.getSnapshotBeforeUpdate || (k1 = h2.getSnapshotBeforeUpdate(y1, p2)), A2 = null != s2 && s2.type === $fb96b826c0c5f37a$export$ffb0004e005737fa && null == s2.key ? s2.props.children : s2, $fb96b826c0c5f37a$var$w(n22, Array.isArray(A2) ? A2 : [
          A2
        ], u12, i9, t9, r9, o6, f5, e2, c1), h2.base = u12.__e, u12.__h = null, h2.__h.length && f5.push(h2), b2 && (h2.__E = h2.__ = null), h2.__e = false;
      } else null == o6 && u12.__v === i9.__v ? (u12.__k = i9.__k, u12.__e = i9.__e) : u12.__e = $fb96b826c0c5f37a$var$L(i9.__e, u12, i9, t9, r9, o6, f5, c1);
      (s2 = $fb96b826c0c5f37a$export$41c562ebe57d11e2.diffed) && s2(u12);
    } catch (n24) {
      u12.__v = null, (c1 || null != o6) && (u12.__e = e2, u12.__h = !!c1, o6[o6.indexOf(e2)] = null), $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e(n24, u12, i9);
    }
  }
  function $fb96b826c0c5f37a$var$z(n25, u13) {
    $fb96b826c0c5f37a$export$41c562ebe57d11e2.__c && $fb96b826c0c5f37a$export$41c562ebe57d11e2.__c(u13, n25), n25.some(function(u14) {
      try {
        n25 = u14.__h, u14.__h = [], n25.some(function(n26) {
          n26.call(u14);
        });
      } catch (n27) {
        $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e(n27, u14.__v);
      }
    });
  }
  function $fb96b826c0c5f37a$var$L(l16, u15, i10, t10, r10, o7, f6, c2) {
    var s3, a2, v3, y2 = i10.props, p3 = u15.props, d1 = u15.type, _2 = 0;
    if ("svg" === d1 && (r10 = true), null != o7) {
      for (; _2 < o7.length; _2++) if ((s3 = o7[_2]) && "setAttribute" in s3 == !!d1 && (d1 ? s3.localName === d1 : 3 === s3.nodeType)) {
        l16 = s3, o7[_2] = null;
        break;
      }
    }
    if (null == l16) {
      if (null === d1) return document.createTextNode(p3);
      l16 = r10 ? document.createElementNS("http://www.w3.org/2000/svg", d1) : document.createElement(d1, p3.is && p3), o7 = null, c2 = false;
    }
    if (null === d1) y2 === p3 || c2 && l16.data === p3 || (l16.data = p3);
    else {
      if (o7 = o7 && $fb96b826c0c5f37a$var$n.call(l16.childNodes), a2 = (y2 = i10.props || $fb96b826c0c5f37a$var$e).dangerouslySetInnerHTML, v3 = p3.dangerouslySetInnerHTML, !c2) {
        if (null != o7) for (y2 = {}, _2 = 0; _2 < l16.attributes.length; _2++) y2[l16.attributes[_2].name] = l16.attributes[_2].value;
        (v3 || a2) && (v3 && (a2 && v3.__html == a2.__html || v3.__html === l16.innerHTML) || (l16.innerHTML = v3 && v3.__html || ""));
      }
      if ($fb96b826c0c5f37a$var$C(l16, p3, y2, r10, c2), v3) u15.__k = [];
      else if (_2 = u15.props.children, $fb96b826c0c5f37a$var$w(l16, Array.isArray(_2) ? _2 : [
        _2
      ], u15, i10, t10, r10 && "foreignObject" !== d1, o7, f6, o7 ? o7[0] : i10.__k && $fb96b826c0c5f37a$var$k(i10, 0), c2), null != o7) for (_2 = o7.length; _2--; ) null != o7[_2] && $fb96b826c0c5f37a$var$h(o7[_2]);
      c2 || ("value" in p3 && void 0 !== (_2 = p3.value) && (_2 !== y2.value || _2 !== l16.value || "progress" === d1 && !_2) && $fb96b826c0c5f37a$var$H(l16, "value", _2, y2.value, false), "checked" in p3 && void 0 !== (_2 = p3.checked) && _2 !== l16.checked && $fb96b826c0c5f37a$var$H(l16, "checked", _2, y2.checked, false));
    }
    return l16;
  }
  function $fb96b826c0c5f37a$var$M(n28, u16, i11) {
    try {
      "function" == typeof n28 ? n28(u16) : n28.current = u16;
    } catch (n29) {
      $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e(n29, i11);
    }
  }
  function $fb96b826c0c5f37a$var$N(n30, u17, i12) {
    var t11, r11;
    if ($fb96b826c0c5f37a$export$41c562ebe57d11e2.unmount && $fb96b826c0c5f37a$export$41c562ebe57d11e2.unmount(n30), (t11 = n30.ref) && (t11.current && t11.current !== n30.__e || $fb96b826c0c5f37a$var$M(t11, null, u17)), null != (t11 = n30.__c)) {
      if (t11.componentWillUnmount) try {
        t11.componentWillUnmount();
      } catch (n31) {
        $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e(n31, u17);
      }
      t11.base = t11.__P = null;
    }
    if (t11 = n30.__k) for (r11 = 0; r11 < t11.length; r11++) t11[r11] && $fb96b826c0c5f37a$var$N(t11[r11], u17, "function" != typeof n30.type);
    i12 || null == n30.__e || $fb96b826c0c5f37a$var$h(n30.__e), n30.__e = n30.__d = void 0;
  }
  function $fb96b826c0c5f37a$var$O(n32, l, u18) {
    return this.constructor(n32, u18);
  }
  function $fb96b826c0c5f37a$export$b3890eb0ae9dca99(u19, i13, t12) {
    var r12, o8, f7;
    $fb96b826c0c5f37a$export$41c562ebe57d11e2.__ && $fb96b826c0c5f37a$export$41c562ebe57d11e2.__(u19, i13), o8 = (r12 = "function" == typeof t12) ? null : t12 && t12.__k || i13.__k, f7 = [], $fb96b826c0c5f37a$var$j(i13, u19 = (!r12 && t12 || i13).__k = $fb96b826c0c5f37a$export$c8a8987d4410bf2d($fb96b826c0c5f37a$export$ffb0004e005737fa, null, [
      u19
    ]), o8 || $fb96b826c0c5f37a$var$e, $fb96b826c0c5f37a$var$e, void 0 !== i13.ownerSVGElement, !r12 && t12 ? [
      t12
    ] : o8 ? null : i13.firstChild ? $fb96b826c0c5f37a$var$n.call(i13.childNodes) : null, f7, !r12 && t12 ? t12 : o8 ? o8.__e : i13.firstChild, r12), $fb96b826c0c5f37a$var$z(f7, u19);
  }
  $fb96b826c0c5f37a$var$n = $fb96b826c0c5f37a$var$c.slice, $fb96b826c0c5f37a$export$41c562ebe57d11e2 = {
    __e: function(n39, l22) {
      for (var u23, i16, t14; l22 = l22.__; ) if ((u23 = l22.__c) && !u23.__) try {
        if ((i16 = u23.constructor) && null != i16.getDerivedStateFromError && (u23.setState(i16.getDerivedStateFromError(n39)), t14 = u23.__d), null != u23.componentDidCatch && (u23.componentDidCatch(n39), t14 = u23.__d), t14) return u23.__E = u23;
      } catch (l23) {
        n39 = l23;
      }
      throw n39;
    }
  }, $fb96b826c0c5f37a$var$u = 0, $fb96b826c0c5f37a$export$16fa2f45be04daa8.prototype.setState = function(n41, l24) {
    var u24;
    u24 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = $fb96b826c0c5f37a$var$a({}, this.state), "function" == typeof n41 && (n41 = n41($fb96b826c0c5f37a$var$a({}, u24), this.props)), n41 && $fb96b826c0c5f37a$var$a(u24, n41), null != n41 && this.__v && (l24 && this.__h.push(l24), $fb96b826c0c5f37a$var$m(this));
  }, $fb96b826c0c5f37a$export$16fa2f45be04daa8.prototype.forceUpdate = function(n42) {
    this.__v && (this.__e = true, n42 && this.__h.push(n42), $fb96b826c0c5f37a$var$m(this));
  }, $fb96b826c0c5f37a$export$16fa2f45be04daa8.prototype.render = $fb96b826c0c5f37a$export$ffb0004e005737fa, $fb96b826c0c5f37a$var$t = [], $fb96b826c0c5f37a$var$r = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, $fb96b826c0c5f37a$var$g.__r = 0;
  var $bd9dd35321b03dd4$var$o = 0;
  function $bd9dd35321b03dd4$export$34b9dba7ce09269b(_1, e1, n, t, f) {
    var l, s, u = {};
    for (s in e1) "ref" == s ? l = e1[s] : u[s] = e1[s];
    var a = {
      type: _1,
      props: u,
      key: n,
      ref: l,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: --$bd9dd35321b03dd4$var$o,
      __source: t,
      __self: f
    };
    if ("function" == typeof _1 && (l = _1.defaultProps)) for (s in l) void 0 === u[s] && (u[s] = l[s]);
    return $fb96b826c0c5f37a$export$41c562ebe57d11e2.vnode && $fb96b826c0c5f37a$export$41c562ebe57d11e2.vnode(a), a;
  }
  function $f72b75cf796873c7$var$set(key2, value) {
    try {
      window.localStorage[`emoji-mart.${key2}`] = JSON.stringify(value);
    } catch (error) {
    }
  }
  function $f72b75cf796873c7$var$get(key2) {
    try {
      const value = window.localStorage[`emoji-mart.${key2}`];
      if (value) return JSON.parse(value);
    } catch (error) {
    }
  }
  var $f72b75cf796873c7$export$2e2bcd8739ae039 = {
    set: $f72b75cf796873c7$var$set,
    get: $f72b75cf796873c7$var$get
  };
  const $c84d045dcc34faf5$var$CACHE = /* @__PURE__ */ new Map();
  const $c84d045dcc34faf5$var$VERSIONS = [
    {
      v: 15,
      emoji: ""
    },
    {
      v: 14,
      emoji: ""
    },
    {
      v: 13.1,
      emoji: ""
    },
    {
      v: 13,
      emoji: ""
    },
    {
      v: 12.1,
      emoji: ""
    },
    {
      v: 12,
      emoji: ""
    },
    {
      v: 11,
      emoji: ""
    },
    {
      v: 5,
      emoji: ""
    },
    {
      v: 4,
      emoji: ""
    },
    {
      v: 3,
      emoji: ""
    },
    {
      v: 2,
      emoji: ""
    },
    {
      v: 1,
      emoji: ""
    }
  ];
  function $c84d045dcc34faf5$var$latestVersion() {
    for (const { v, emoji } of $c84d045dcc34faf5$var$VERSIONS) {
      if ($c84d045dcc34faf5$var$isSupported(emoji)) return v;
    }
  }
  function $c84d045dcc34faf5$var$noCountryFlags() {
    if ($c84d045dcc34faf5$var$isSupported("")) return false;
    return true;
  }
  function $c84d045dcc34faf5$var$isSupported(emoji) {
    if ($c84d045dcc34faf5$var$CACHE.has(emoji)) return $c84d045dcc34faf5$var$CACHE.get(emoji);
    const supported = $c84d045dcc34faf5$var$isEmojiSupported(emoji);
    $c84d045dcc34faf5$var$CACHE.set(emoji, supported);
    return supported;
  }
  const $c84d045dcc34faf5$var$isEmojiSupported = (() => {
    let ctx = null;
    try {
      if (!navigator.userAgent.includes("jsdom")) ctx = document.createElement("canvas").getContext("2d", {
        willReadFrequently: true
      });
    } catch {
    }
    if (!ctx) return () => false;
    const CANVAS_HEIGHT = 25;
    const CANVAS_WIDTH = 20;
    const textSize = Math.floor(CANVAS_HEIGHT / 2);
    ctx.font = textSize + "px Arial, Sans-Serif";
    ctx.textBaseline = "top";
    ctx.canvas.width = CANVAS_WIDTH * 2;
    ctx.canvas.height = CANVAS_HEIGHT;
    return (unicode) => {
      ctx.clearRect(0, 0, CANVAS_WIDTH * 2, CANVAS_HEIGHT);
      ctx.fillStyle = "#FF0000";
      ctx.fillText(unicode, 0, 22);
      ctx.fillStyle = "#0000FF";
      ctx.fillText(unicode, CANVAS_WIDTH, 22);
      const a = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT).data;
      const count = a.length;
      let i2 = 0;
      for (; i2 < count && !a[i2 + 3]; i2 += 4) ;
      if (i2 >= count) return false;
      const x2 = CANVAS_WIDTH + i2 / 4 % CANVAS_WIDTH;
      const y = Math.floor(i2 / 4 / CANVAS_WIDTH);
      const b2 = ctx.getImageData(x2, y, 1, 1).data;
      if (a[i2] !== b2[0] || a[i2 + 2] !== b2[2]) return false;
      if (ctx.measureText(unicode).width >= CANVAS_WIDTH) return false;
      return true;
    };
  })();
  var $c84d045dcc34faf5$export$2e2bcd8739ae039 = {
    latestVersion: $c84d045dcc34faf5$var$latestVersion,
    noCountryFlags: $c84d045dcc34faf5$var$noCountryFlags
  };
  const $b22cfd0a55410b4f$var$DEFAULTS = [
    "+1",
    "grinning",
    "kissing_heart",
    "heart_eyes",
    "laughing",
    "stuck_out_tongue_winking_eye",
    "sweat_smile",
    "joy",
    "scream",
    "disappointed",
    "unamused",
    "weary",
    "sob",
    "sunglasses",
    "heart"
  ];
  let $b22cfd0a55410b4f$var$Index = null;
  function $b22cfd0a55410b4f$var$add(emoji) {
    $b22cfd0a55410b4f$var$Index || ($b22cfd0a55410b4f$var$Index = $f72b75cf796873c7$export$2e2bcd8739ae039.get("frequently") || {});
    const emojiId = emoji.id || emoji;
    if (!emojiId) return;
    $b22cfd0a55410b4f$var$Index[emojiId] || ($b22cfd0a55410b4f$var$Index[emojiId] = 0);
    $b22cfd0a55410b4f$var$Index[emojiId] += 1;
    $f72b75cf796873c7$export$2e2bcd8739ae039.set("last", emojiId);
    $f72b75cf796873c7$export$2e2bcd8739ae039.set("frequently", $b22cfd0a55410b4f$var$Index);
  }
  function $b22cfd0a55410b4f$var$get({ maxFrequentRows, perLine }) {
    if (!maxFrequentRows) return [];
    $b22cfd0a55410b4f$var$Index || ($b22cfd0a55410b4f$var$Index = $f72b75cf796873c7$export$2e2bcd8739ae039.get("frequently"));
    let emojiIds = [];
    if (!$b22cfd0a55410b4f$var$Index) {
      $b22cfd0a55410b4f$var$Index = {};
      for (let i2 in $b22cfd0a55410b4f$var$DEFAULTS.slice(0, perLine)) {
        const emojiId = $b22cfd0a55410b4f$var$DEFAULTS[i2];
        $b22cfd0a55410b4f$var$Index[emojiId] = perLine - i2;
        emojiIds.push(emojiId);
      }
      return emojiIds;
    }
    const max2 = maxFrequentRows * perLine;
    const last2 = $f72b75cf796873c7$export$2e2bcd8739ae039.get("last");
    for (let emojiId in $b22cfd0a55410b4f$var$Index) emojiIds.push(emojiId);
    emojiIds.sort((a, b2) => {
      const aScore = $b22cfd0a55410b4f$var$Index[b2];
      const bScore = $b22cfd0a55410b4f$var$Index[a];
      if (aScore == bScore) return a.localeCompare(b2);
      return aScore - bScore;
    });
    if (emojiIds.length > max2) {
      const removedIds = emojiIds.slice(max2);
      emojiIds = emojiIds.slice(0, max2);
      for (let removedId of removedIds) {
        if (removedId == last2) continue;
        delete $b22cfd0a55410b4f$var$Index[removedId];
      }
      if (last2 && emojiIds.indexOf(last2) == -1) {
        delete $b22cfd0a55410b4f$var$Index[emojiIds[emojiIds.length - 1]];
        emojiIds.splice(-1, 1, last2);
      }
      $f72b75cf796873c7$export$2e2bcd8739ae039.set("frequently", $b22cfd0a55410b4f$var$Index);
    }
    return emojiIds;
  }
  var $b22cfd0a55410b4f$export$2e2bcd8739ae039 = {
    add: $b22cfd0a55410b4f$var$add,
    get: $b22cfd0a55410b4f$var$get,
    DEFAULTS: $b22cfd0a55410b4f$var$DEFAULTS
  };
  var $8d50d93417ef682a$exports = {};
  $8d50d93417ef682a$exports = JSON.parse('{"search":"Search","search_no_results_1":"Oh no!","search_no_results_2":"That emoji couldnt be found","pick":"Pick an emoji","add_custom":"Add custom emoji","categories":{"activity":"Activity","custom":"Custom","flags":"Flags","foods":"Food & Drink","frequent":"Frequently used","nature":"Animals & Nature","objects":"Objects","people":"Smileys & People","places":"Travel & Places","search":"Search Results","symbols":"Symbols"},"skins":{"1":"Default","2":"Light","3":"Medium-Light","4":"Medium","5":"Medium-Dark","6":"Dark","choose":"Choose default skin tone"}}');
  var $b247ea80b67298d5$export$2e2bcd8739ae039 = {
    autoFocus: {
      value: false
    },
    dynamicWidth: {
      value: false
    },
    emojiButtonColors: {
      value: null
    },
    emojiButtonRadius: {
      value: "100%"
    },
    emojiButtonSize: {
      value: 36
    },
    emojiSize: {
      value: 24
    },
    emojiVersion: {
      value: 15,
      choices: [
        1,
        2,
        3,
        4,
        5,
        11,
        12,
        12.1,
        13,
        13.1,
        14,
        15
      ]
    },
    exceptEmojis: {
      value: []
    },
    icons: {
      value: "auto",
      choices: [
        "auto",
        "outline",
        "solid"
      ]
    },
    locale: {
      value: "en",
      choices: [
        "en",
        "ar",
        "be",
        "cs",
        "de",
        "es",
        "fa",
        "fi",
        "fr",
        "hi",
        "it",
        "ja",
        "ko",
        "nl",
        "pl",
        "pt",
        "ru",
        "sa",
        "tr",
        "uk",
        "vi",
        "zh"
      ]
    },
    maxFrequentRows: {
      value: 4
    },
    navPosition: {
      value: "top",
      choices: [
        "top",
        "bottom",
        "none"
      ]
    },
    noCountryFlags: {
      value: false
    },
    noResultsEmoji: {
      value: null
    },
    perLine: {
      value: 9
    },
    previewEmoji: {
      value: null
    },
    previewPosition: {
      value: "bottom",
      choices: [
        "top",
        "bottom",
        "none"
      ]
    },
    searchPosition: {
      value: "sticky",
      choices: [
        "sticky",
        "static",
        "none"
      ]
    },
    set: {
      value: "native",
      choices: [
        "native",
        "apple",
        "facebook",
        "google",
        "twitter"
      ]
    },
    skin: {
      value: 1,
      choices: [
        1,
        2,
        3,
        4,
        5,
        6
      ]
    },
    skinTonePosition: {
      value: "preview",
      choices: [
        "preview",
        "search",
        "none"
      ]
    },
    theme: {
      value: "auto",
      choices: [
        "auto",
        "light",
        "dark"
      ]
    },
    // Data
    categories: null,
    categoryIcons: null,
    custom: null,
    data: null,
    i18n: null,
    // Callbacks
    getImageURL: null,
    getSpritesheetURL: null,
    onAddCustomEmoji: null,
    onClickOutside: null,
    onEmojiSelect: null,
    // Deprecated
    stickySearch: {
      deprecated: true,
      value: true
    }
  };
  let $7adb23b0109cc36a$export$dbe3113d60765c1a = null;
  let $7adb23b0109cc36a$export$2d0294657ab35f1b = null;
  const $7adb23b0109cc36a$var$fetchCache = {};
  async function $7adb23b0109cc36a$var$fetchJSON(src) {
    if ($7adb23b0109cc36a$var$fetchCache[src]) return $7adb23b0109cc36a$var$fetchCache[src];
    const response = await fetch(src);
    const json = await response.json();
    $7adb23b0109cc36a$var$fetchCache[src] = json;
    return json;
  }
  let $7adb23b0109cc36a$var$promise = null;
  let $7adb23b0109cc36a$var$initCallback = null;
  let $7adb23b0109cc36a$var$initialized = false;
  function $7adb23b0109cc36a$export$2cd8252107eb640b(options, { caller } = {}) {
    $7adb23b0109cc36a$var$promise || ($7adb23b0109cc36a$var$promise = new Promise((resolve) => {
      $7adb23b0109cc36a$var$initCallback = resolve;
    }));
    if (options) $7adb23b0109cc36a$var$_init(options);
    else if (caller && !$7adb23b0109cc36a$var$initialized) console.warn(`\`${caller}\` requires data to be initialized first. Promise will be pending until \`init\` is called.`);
    return $7adb23b0109cc36a$var$promise;
  }
  async function $7adb23b0109cc36a$var$_init(props) {
    $7adb23b0109cc36a$var$initialized = true;
    let { emojiVersion, set: set2, locale } = props;
    emojiVersion || (emojiVersion = $b247ea80b67298d5$export$2e2bcd8739ae039.emojiVersion.value);
    set2 || (set2 = $b247ea80b67298d5$export$2e2bcd8739ae039.set.value);
    locale || (locale = $b247ea80b67298d5$export$2e2bcd8739ae039.locale.value);
    if (!$7adb23b0109cc36a$export$2d0294657ab35f1b) {
      $7adb23b0109cc36a$export$2d0294657ab35f1b = (typeof props.data === "function" ? await props.data() : props.data) || await $7adb23b0109cc36a$var$fetchJSON(`https://cdn.jsdelivr.net/npm/@emoji-mart/data@latest/sets/${emojiVersion}/${set2}.json`);
      $7adb23b0109cc36a$export$2d0294657ab35f1b.emoticons = {};
      $7adb23b0109cc36a$export$2d0294657ab35f1b.natives = {};
      $7adb23b0109cc36a$export$2d0294657ab35f1b.categories.unshift({
        id: "frequent",
        emojis: []
      });
      for (const alias in $7adb23b0109cc36a$export$2d0294657ab35f1b.aliases) {
        const emojiId = $7adb23b0109cc36a$export$2d0294657ab35f1b.aliases[alias];
        const emoji = $7adb23b0109cc36a$export$2d0294657ab35f1b.emojis[emojiId];
        if (!emoji) continue;
        emoji.aliases || (emoji.aliases = []);
        emoji.aliases.push(alias);
      }
      $7adb23b0109cc36a$export$2d0294657ab35f1b.originalCategories = $7adb23b0109cc36a$export$2d0294657ab35f1b.categories;
    } else $7adb23b0109cc36a$export$2d0294657ab35f1b.categories = $7adb23b0109cc36a$export$2d0294657ab35f1b.categories.filter((c) => {
      const isCustom = !!c.name;
      if (!isCustom) return true;
      return false;
    });
    $7adb23b0109cc36a$export$dbe3113d60765c1a = (typeof props.i18n === "function" ? await props.i18n() : props.i18n) || (locale == "en" ? /* @__PURE__ */ $parcel$interopDefault($8d50d93417ef682a$exports) : await $7adb23b0109cc36a$var$fetchJSON(`https://cdn.jsdelivr.net/npm/@emoji-mart/data@latest/i18n/${locale}.json`));
    if (props.custom) for (let i2 in props.custom) {
      i2 = parseInt(i2);
      const category = props.custom[i2];
      const prevCategory = props.custom[i2 - 1];
      if (!category.emojis || !category.emojis.length) continue;
      category.id || (category.id = `custom_${i2 + 1}`);
      category.name || (category.name = $7adb23b0109cc36a$export$dbe3113d60765c1a.categories.custom);
      if (prevCategory && !category.icon) category.target = prevCategory.target || prevCategory;
      $7adb23b0109cc36a$export$2d0294657ab35f1b.categories.push(category);
      for (const emoji of category.emojis) $7adb23b0109cc36a$export$2d0294657ab35f1b.emojis[emoji.id] = emoji;
    }
    if (props.categories) $7adb23b0109cc36a$export$2d0294657ab35f1b.categories = $7adb23b0109cc36a$export$2d0294657ab35f1b.originalCategories.filter((c) => {
      return props.categories.indexOf(c.id) != -1;
    }).sort((c1, c2) => {
      const i1 = props.categories.indexOf(c1.id);
      const i2 = props.categories.indexOf(c2.id);
      return i1 - i2;
    });
    let latestVersionSupport = null;
    let noCountryFlags = null;
    if (set2 == "native") {
      latestVersionSupport = $c84d045dcc34faf5$export$2e2bcd8739ae039.latestVersion();
      noCountryFlags = props.noCountryFlags || $c84d045dcc34faf5$export$2e2bcd8739ae039.noCountryFlags();
    }
    let categoryIndex = $7adb23b0109cc36a$export$2d0294657ab35f1b.categories.length;
    let resetSearchIndex = false;
    while (categoryIndex--) {
      const category = $7adb23b0109cc36a$export$2d0294657ab35f1b.categories[categoryIndex];
      if (category.id == "frequent") {
        let { maxFrequentRows, perLine } = props;
        maxFrequentRows = maxFrequentRows >= 0 ? maxFrequentRows : $b247ea80b67298d5$export$2e2bcd8739ae039.maxFrequentRows.value;
        perLine || (perLine = $b247ea80b67298d5$export$2e2bcd8739ae039.perLine.value);
        category.emojis = $b22cfd0a55410b4f$export$2e2bcd8739ae039.get({
          maxFrequentRows,
          perLine
        });
      }
      if (!category.emojis || !category.emojis.length) {
        $7adb23b0109cc36a$export$2d0294657ab35f1b.categories.splice(categoryIndex, 1);
        continue;
      }
      const { categoryIcons } = props;
      if (categoryIcons) {
        const icon = categoryIcons[category.id];
        if (icon && !category.icon) category.icon = icon;
      }
      let emojiIndex = category.emojis.length;
      while (emojiIndex--) {
        const emojiId = category.emojis[emojiIndex];
        const emoji = emojiId.id ? emojiId : $7adb23b0109cc36a$export$2d0294657ab35f1b.emojis[emojiId];
        const ignore = () => {
          category.emojis.splice(emojiIndex, 1);
        };
        if (!emoji || props.exceptEmojis && props.exceptEmojis.includes(emoji.id)) {
          ignore();
          continue;
        }
        if (latestVersionSupport && emoji.version > latestVersionSupport) {
          ignore();
          continue;
        }
        if (noCountryFlags && category.id == "flags") {
          if (!$e6eae5155b87f591$export$bcb25aa587e9cb13.includes(emoji.id)) {
            ignore();
            continue;
          }
        }
        if (!emoji.search) {
          resetSearchIndex = true;
          emoji.search = "," + [
            [
              emoji.id,
              false
            ],
            [
              emoji.name,
              true
            ],
            [
              emoji.keywords,
              false
            ],
            [
              emoji.emoticons,
              false
            ]
          ].map(([strings, split2]) => {
            if (!strings) return;
            return (Array.isArray(strings) ? strings : [
              strings
            ]).map((string) => {
              return (split2 ? string.split(/[-|_|\s]+/) : [
                string
              ]).map((s) => s.toLowerCase());
            }).flat();
          }).flat().filter((a) => a && a.trim()).join(",");
          if (emoji.emoticons) for (const emoticon of emoji.emoticons) {
            if ($7adb23b0109cc36a$export$2d0294657ab35f1b.emoticons[emoticon]) continue;
            $7adb23b0109cc36a$export$2d0294657ab35f1b.emoticons[emoticon] = emoji.id;
          }
          let skinIndex = 0;
          for (const skin of emoji.skins) {
            if (!skin) continue;
            skinIndex++;
            const { native } = skin;
            if (native) {
              $7adb23b0109cc36a$export$2d0294657ab35f1b.natives[native] = emoji.id;
              emoji.search += `,${native}`;
            }
            const skinShortcodes = skinIndex == 1 ? "" : `:skin-tone-${skinIndex}:`;
            skin.shortcodes = `:${emoji.id}:${skinShortcodes}`;
          }
        }
      }
    }
    if (resetSearchIndex) $c4d155af13ad4d4b$export$2e2bcd8739ae039.reset();
    $7adb23b0109cc36a$var$initCallback();
  }
  function $7adb23b0109cc36a$export$75fe5f91d452f94b(props, defaultProps, element) {
    props || (props = {});
    const _props = {};
    for (let k2 in defaultProps) _props[k2] = $7adb23b0109cc36a$export$88c9ddb45cea7241(k2, props, defaultProps, element);
    return _props;
  }
  function $7adb23b0109cc36a$export$88c9ddb45cea7241(propName, props, defaultProps, element) {
    const defaults2 = defaultProps[propName];
    let value = element && element.getAttribute(propName) || (props[propName] != null && props[propName] != void 0 ? props[propName] : null);
    if (!defaults2) return value;
    if (value != null && defaults2.value && typeof defaults2.value != typeof value) {
      if (typeof defaults2.value == "boolean") value = value == "false" ? false : true;
      else value = defaults2.value.constructor(value);
    }
    if (defaults2.transform && value) value = defaults2.transform(value);
    if (value == null || defaults2.choices && defaults2.choices.indexOf(value) == -1) value = defaults2.value;
    return value;
  }
  const $c4d155af13ad4d4b$var$SHORTCODES_REGEX = /^(?:\:([^\:]+)\:)(?:\:skin-tone-(\d)\:)?$/;
  let $c4d155af13ad4d4b$var$Pool = null;
  function $c4d155af13ad4d4b$var$get(emojiId) {
    if (emojiId.id) return emojiId;
    return $7adb23b0109cc36a$export$2d0294657ab35f1b.emojis[emojiId] || $7adb23b0109cc36a$export$2d0294657ab35f1b.emojis[$7adb23b0109cc36a$export$2d0294657ab35f1b.aliases[emojiId]] || $7adb23b0109cc36a$export$2d0294657ab35f1b.emojis[$7adb23b0109cc36a$export$2d0294657ab35f1b.natives[emojiId]];
  }
  function $c4d155af13ad4d4b$var$reset() {
    $c4d155af13ad4d4b$var$Pool = null;
  }
  async function $c4d155af13ad4d4b$var$search(value, { maxResults, caller } = {}) {
    if (!value || !value.trim().length) return null;
    maxResults || (maxResults = 90);
    await $7adb23b0109cc36a$export$2cd8252107eb640b(null, {
      caller: caller || "SearchIndex.search"
    });
    const values = value.toLowerCase().replace(/(\w)-/, "$1 ").split(/[\s|,]+/).filter((word, i2, words) => {
      return word.trim() && words.indexOf(word) == i2;
    });
    if (!values.length) return;
    let pool = $c4d155af13ad4d4b$var$Pool || ($c4d155af13ad4d4b$var$Pool = Object.values($7adb23b0109cc36a$export$2d0294657ab35f1b.emojis));
    let results, scores;
    for (const value1 of values) {
      if (!pool.length) break;
      results = [];
      scores = {};
      for (const emoji of pool) {
        if (!emoji.search) continue;
        const score = emoji.search.indexOf(`,${value1}`);
        if (score == -1) continue;
        results.push(emoji);
        scores[emoji.id] || (scores[emoji.id] = 0);
        scores[emoji.id] += emoji.id == value1 ? 0 : score + 1;
      }
      pool = results;
    }
    if (results.length < 2) return results;
    results.sort((a, b2) => {
      const aScore = scores[a.id];
      const bScore = scores[b2.id];
      if (aScore == bScore) return a.id.localeCompare(b2.id);
      return aScore - bScore;
    });
    if (results.length > maxResults) results = results.slice(0, maxResults);
    return results;
  }
  var $c4d155af13ad4d4b$export$2e2bcd8739ae039 = {
    search: $c4d155af13ad4d4b$var$search,
    get: $c4d155af13ad4d4b$var$get,
    reset: $c4d155af13ad4d4b$var$reset,
    SHORTCODES_REGEX: $c4d155af13ad4d4b$var$SHORTCODES_REGEX
  };
  const $e6eae5155b87f591$export$bcb25aa587e9cb13 = [
    "checkered_flag",
    "crossed_flags",
    "pirate_flag",
    "rainbow-flag",
    "transgender_flag",
    "triangular_flag_on_post",
    "waving_black_flag",
    "waving_white_flag"
  ];
  function $693b183b0a78708f$export$9cb4719e2e525b7a(a, b2) {
    return Array.isArray(a) && Array.isArray(b2) && a.length === b2.length && a.every((val, index) => val == b2[index]);
  }
  async function $693b183b0a78708f$export$e772c8ff12451969(frames = 1) {
    for (let _2 in [
      ...Array(frames).keys()
    ]) await new Promise(requestAnimationFrame);
  }
  function $693b183b0a78708f$export$d10ac59fbe52a745(emoji, { skinIndex = 0 } = {}) {
    const skin = emoji.skins[skinIndex] || (() => {
      skinIndex = 0;
      return emoji.skins[skinIndex];
    })();
    const emojiData = {
      id: emoji.id,
      name: emoji.name,
      native: skin.native,
      unified: skin.unified,
      keywords: emoji.keywords,
      shortcodes: skin.shortcodes || emoji.shortcodes
    };
    if (emoji.skins.length > 1) emojiData.skin = skinIndex + 1;
    if (skin.src) emojiData.src = skin.src;
    if (emoji.aliases && emoji.aliases.length) emojiData.aliases = emoji.aliases;
    if (emoji.emoticons && emoji.emoticons.length) emojiData.emoticons = emoji.emoticons;
    return emojiData;
  }
  const $fcccfb36ed0cde68$var$categories = {
    activity: {
      outline: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M12 0C5.373 0 0 5.372 0 12c0 6.627 5.373 12 12 12 6.628 0 12-5.373 12-12 0-6.628-5.372-12-12-12m9.949 11H17.05c.224-2.527 1.232-4.773 1.968-6.113A9.966 9.966 0 0 1 21.949 11M13 11V2.051a9.945 9.945 0 0 1 4.432 1.564c-.858 1.491-2.156 4.22-2.392 7.385H13zm-2 0H8.961c-.238-3.165-1.536-5.894-2.393-7.385A9.95 9.95 0 0 1 11 2.051V11zm0 2v8.949a9.937 9.937 0 0 1-4.432-1.564c.857-1.492 2.155-4.221 2.393-7.385H11zm4.04 0c.236 3.164 1.534 5.893 2.392 7.385A9.92 9.92 0 0 1 13 21.949V13h2.04zM4.982 4.887C5.718 6.227 6.726 8.473 6.951 11h-4.9a9.977 9.977 0 0 1 2.931-6.113M2.051 13h4.9c-.226 2.527-1.233 4.771-1.969 6.113A9.972 9.972 0 0 1 2.051 13m16.967 6.113c-.735-1.342-1.744-3.586-1.968-6.113h4.899a9.961 9.961 0 0 1-2.931 6.113"
        })
      }),
      solid: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M16.17 337.5c0 44.98 7.565 83.54 13.98 107.9C35.22 464.3 50.46 496 174.9 496c9.566 0 19.59-.4707 29.84-1.271L17.33 307.3C16.53 317.6 16.17 327.7 16.17 337.5zM495.8 174.5c0-44.98-7.565-83.53-13.98-107.9c-4.688-17.54-18.34-31.23-36.04-35.95C435.5 27.91 392.9 16 337 16c-9.564 0-19.59 .4707-29.84 1.271l187.5 187.5C495.5 194.4 495.8 184.3 495.8 174.5zM26.77 248.8l236.3 236.3c142-36.1 203.9-150.4 222.2-221.1L248.9 26.87C106.9 62.96 45.07 177.2 26.77 248.8zM256 335.1c0 9.141-7.474 16-16 16c-4.094 0-8.188-1.564-11.31-4.689L164.7 283.3C161.6 280.2 160 276.1 160 271.1c0-8.529 6.865-16 16-16c4.095 0 8.189 1.562 11.31 4.688l64.01 64C254.4 327.8 256 331.9 256 335.1zM304 287.1c0 9.141-7.474 16-16 16c-4.094 0-8.188-1.564-11.31-4.689L212.7 235.3C209.6 232.2 208 228.1 208 223.1c0-9.141 7.473-16 16-16c4.094 0 8.188 1.562 11.31 4.688l64.01 64.01C302.5 279.8 304 283.9 304 287.1zM256 175.1c0-9.141 7.473-16 16-16c4.094 0 8.188 1.562 11.31 4.688l64.01 64.01c3.125 3.125 4.688 7.219 4.688 11.31c0 9.133-7.468 16-16 16c-4.094 0-8.189-1.562-11.31-4.688l-64.01-64.01C257.6 184.2 256 180.1 256 175.1z"
        })
      })
    },
    custom: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 448 512",
      children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
        d: "M417.1 368c-5.937 10.27-16.69 16-27.75 16c-5.422 0-10.92-1.375-15.97-4.281L256 311.4V448c0 17.67-14.33 32-31.1 32S192 465.7 192 448V311.4l-118.3 68.29C68.67 382.6 63.17 384 57.75 384c-11.06 0-21.81-5.734-27.75-16c-8.828-15.31-3.594-34.88 11.72-43.72L159.1 256L41.72 187.7C26.41 178.9 21.17 159.3 29.1 144C36.63 132.5 49.26 126.7 61.65 128.2C65.78 128.7 69.88 130.1 73.72 132.3L192 200.6V64c0-17.67 14.33-32 32-32S256 46.33 256 64v136.6l118.3-68.29c3.838-2.213 7.939-3.539 12.07-4.051C398.7 126.7 411.4 132.5 417.1 144c8.828 15.31 3.594 34.88-11.72 43.72L288 256l118.3 68.28C421.6 333.1 426.8 352.7 417.1 368z"
      })
    }),
    flags: {
      outline: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M0 0l6.084 24H8L1.916 0zM21 5h-4l-1-4H4l3 12h3l1 4h13L21 5zM6.563 3h7.875l2 8H8.563l-2-8zm8.832 10l-2.856 1.904L12.063 13h3.332zM19 13l-1.5-6h1.938l2 8H16l3-2z"
        })
      }),
      solid: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M64 496C64 504.8 56.75 512 48 512h-32C7.25 512 0 504.8 0 496V32c0-17.75 14.25-32 32-32s32 14.25 32 32V496zM476.3 0c-6.365 0-13.01 1.35-19.34 4.233c-45.69 20.86-79.56 27.94-107.8 27.94c-59.96 0-94.81-31.86-163.9-31.87C160.9 .3055 131.6 4.867 96 15.75v350.5c32-9.984 59.87-14.1 84.85-14.1c73.63 0 124.9 31.78 198.6 31.78c31.91 0 68.02-5.971 111.1-23.09C504.1 355.9 512 344.4 512 332.1V30.73C512 11.1 495.3 0 476.3 0z"
        })
      })
    },
    foods: {
      outline: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M17 4.978c-1.838 0-2.876.396-3.68.934.513-1.172 1.768-2.934 4.68-2.934a1 1 0 0 0 0-2c-2.921 0-4.629 1.365-5.547 2.512-.064.078-.119.162-.18.244C11.73 1.838 10.798.023 9.207.023 8.579.022 7.85.306 7 .978 5.027 2.54 5.329 3.902 6.492 4.999 3.609 5.222 0 7.352 0 12.969c0 4.582 4.961 11.009 9 11.009 1.975 0 2.371-.486 3-1 .629.514 1.025 1 3 1 4.039 0 9-6.418 9-11 0-5.953-4.055-8-7-8M8.242 2.546c.641-.508.943-.523.965-.523.426.169.975 1.405 1.357 3.055-1.527-.629-2.741-1.352-2.98-1.846.059-.112.241-.356.658-.686M15 21.978c-1.08 0-1.21-.109-1.559-.402l-.176-.146c-.367-.302-.816-.452-1.266-.452s-.898.15-1.266.452l-.176.146c-.347.292-.477.402-1.557.402-2.813 0-7-5.389-7-9.009 0-5.823 4.488-5.991 5-5.991 1.939 0 2.484.471 3.387 1.251l.323.276a1.995 1.995 0 0 0 2.58 0l.323-.276c.902-.78 1.447-1.251 3.387-1.251.512 0 5 .168 5 6 0 3.617-4.187 9-7 9"
        })
      }),
      solid: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M481.9 270.1C490.9 279.1 496 291.3 496 304C496 316.7 490.9 328.9 481.9 337.9C472.9 346.9 460.7 352 448 352H64C51.27 352 39.06 346.9 30.06 337.9C21.06 328.9 16 316.7 16 304C16 291.3 21.06 279.1 30.06 270.1C39.06 261.1 51.27 256 64 256H448C460.7 256 472.9 261.1 481.9 270.1zM475.3 388.7C478.3 391.7 480 395.8 480 400V416C480 432.1 473.3 449.3 461.3 461.3C449.3 473.3 432.1 480 416 480H96C79.03 480 62.75 473.3 50.75 461.3C38.74 449.3 32 432.1 32 416V400C32 395.8 33.69 391.7 36.69 388.7C39.69 385.7 43.76 384 48 384H464C468.2 384 472.3 385.7 475.3 388.7zM50.39 220.8C45.93 218.6 42.03 215.5 38.97 211.6C35.91 207.7 33.79 203.2 32.75 198.4C31.71 193.5 31.8 188.5 32.99 183.7C54.98 97.02 146.5 32 256 32C365.5 32 457 97.02 479 183.7C480.2 188.5 480.3 193.5 479.2 198.4C478.2 203.2 476.1 207.7 473 211.6C469.1 215.5 466.1 218.6 461.6 220.8C457.2 222.9 452.3 224 447.3 224H64.67C59.73 224 54.84 222.9 50.39 220.8zM372.7 116.7C369.7 119.7 368 123.8 368 128C368 131.2 368.9 134.3 370.7 136.9C372.5 139.5 374.1 141.6 377.9 142.8C380.8 143.1 384 144.3 387.1 143.7C390.2 143.1 393.1 141.6 395.3 139.3C397.6 137.1 399.1 134.2 399.7 131.1C400.3 128 399.1 124.8 398.8 121.9C397.6 118.1 395.5 116.5 392.9 114.7C390.3 112.9 387.2 111.1 384 111.1C379.8 111.1 375.7 113.7 372.7 116.7V116.7zM244.7 84.69C241.7 87.69 240 91.76 240 96C240 99.16 240.9 102.3 242.7 104.9C244.5 107.5 246.1 109.6 249.9 110.8C252.8 111.1 256 112.3 259.1 111.7C262.2 111.1 265.1 109.6 267.3 107.3C269.6 105.1 271.1 102.2 271.7 99.12C272.3 96.02 271.1 92.8 270.8 89.88C269.6 86.95 267.5 84.45 264.9 82.7C262.3 80.94 259.2 79.1 256 79.1C251.8 79.1 247.7 81.69 244.7 84.69V84.69zM116.7 116.7C113.7 119.7 112 123.8 112 128C112 131.2 112.9 134.3 114.7 136.9C116.5 139.5 118.1 141.6 121.9 142.8C124.8 143.1 128 144.3 131.1 143.7C134.2 143.1 137.1 141.6 139.3 139.3C141.6 137.1 143.1 134.2 143.7 131.1C144.3 128 143.1 124.8 142.8 121.9C141.6 118.1 139.5 116.5 136.9 114.7C134.3 112.9 131.2 111.1 128 111.1C123.8 111.1 119.7 113.7 116.7 116.7L116.7 116.7z"
        })
      })
    },
    frequent: {
      outline: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        children: [
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
            d: "M13 4h-2l-.001 7H9v2h2v2h2v-2h4v-2h-4z"
          }),
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
            d: "M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0m0 22C6.486 22 2 17.514 2 12S6.486 2 12 2s10 4.486 10 10-4.486 10-10 10"
          })
        ]
      }),
      solid: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M256 512C114.6 512 0 397.4 0 256C0 114.6 114.6 0 256 0C397.4 0 512 114.6 512 256C512 397.4 397.4 512 256 512zM232 256C232 264 236 271.5 242.7 275.1L338.7 339.1C349.7 347.3 364.6 344.3 371.1 333.3C379.3 322.3 376.3 307.4 365.3 300L280 243.2V120C280 106.7 269.3 96 255.1 96C242.7 96 231.1 106.7 231.1 120L232 256z"
        })
      })
    },
    nature: {
      outline: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        children: [
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
            d: "M15.5 8a1.5 1.5 0 1 0 .001 3.001A1.5 1.5 0 0 0 15.5 8M8.5 8a1.5 1.5 0 1 0 .001 3.001A1.5 1.5 0 0 0 8.5 8"
          }),
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
            d: "M18.933 0h-.027c-.97 0-2.138.787-3.018 1.497-1.274-.374-2.612-.51-3.887-.51-1.285 0-2.616.133-3.874.517C7.245.79 6.069 0 5.093 0h-.027C3.352 0 .07 2.67.002 7.026c-.039 2.479.276 4.238 1.04 5.013.254.258.882.677 1.295.882.191 3.177.922 5.238 2.536 6.38.897.637 2.187.949 3.2 1.102C8.04 20.6 8 20.795 8 21c0 1.773 2.35 3 4 3 1.648 0 4-1.227 4-3 0-.201-.038-.393-.072-.586 2.573-.385 5.435-1.877 5.925-7.587.396-.22.887-.568 1.104-.788.763-.774 1.079-2.534 1.04-5.013C23.929 2.67 20.646 0 18.933 0M3.223 9.135c-.237.281-.837 1.155-.884 1.238-.15-.41-.368-1.349-.337-3.291.051-3.281 2.478-4.972 3.091-5.031.256.015.731.27 1.265.646-1.11 1.171-2.275 2.915-2.352 5.125-.133.546-.398.858-.783 1.313M12 22c-.901 0-1.954-.693-2-1 0-.654.475-1.236 1-1.602V20a1 1 0 1 0 2 0v-.602c.524.365 1 .947 1 1.602-.046.307-1.099 1-2 1m3-3.48v.02a4.752 4.752 0 0 0-1.262-1.02c1.092-.516 2.239-1.334 2.239-2.217 0-1.842-1.781-2.195-3.977-2.195-2.196 0-3.978.354-3.978 2.195 0 .883 1.148 1.701 2.238 2.217A4.8 4.8 0 0 0 9 18.539v-.025c-1-.076-2.182-.281-2.973-.842-1.301-.92-1.838-3.045-1.853-6.478l.023-.041c.496-.826 1.49-1.45 1.804-3.102 0-2.047 1.357-3.631 2.362-4.522C9.37 3.178 10.555 3 11.948 3c1.447 0 2.685.192 3.733.57 1 .9 2.316 2.465 2.316 4.48.313 1.651 1.307 2.275 1.803 3.102.035.058.068.117.102.178-.059 5.967-1.949 7.01-4.902 7.19m6.628-8.202c-.037-.065-.074-.13-.113-.195a7.587 7.587 0 0 0-.739-.987c-.385-.455-.648-.768-.782-1.313-.076-2.209-1.241-3.954-2.353-5.124.531-.376 1.004-.63 1.261-.647.636.071 3.044 1.764 3.096 5.031.027 1.81-.347 3.218-.37 3.235"
          })
        ]
      }),
      solid: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 576 512",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M332.7 19.85C334.6 8.395 344.5 0 356.1 0C363.6 0 370.6 3.52 375.1 9.502L392 32H444.1C456.8 32 469.1 37.06 478.1 46.06L496 64H552C565.3 64 576 74.75 576 88V112C576 156.2 540.2 192 496 192H426.7L421.6 222.5L309.6 158.5L332.7 19.85zM448 64C439.2 64 432 71.16 432 80C432 88.84 439.2 96 448 96C456.8 96 464 88.84 464 80C464 71.16 456.8 64 448 64zM416 256.1V480C416 497.7 401.7 512 384 512H352C334.3 512 320 497.7 320 480V364.8C295.1 377.1 268.8 384 240 384C211.2 384 184 377.1 160 364.8V480C160 497.7 145.7 512 128 512H96C78.33 512 64 497.7 64 480V249.8C35.23 238.9 12.64 214.5 4.836 183.3L.9558 167.8C-3.331 150.6 7.094 133.2 24.24 128.1C41.38 124.7 58.76 135.1 63.05 152.2L66.93 167.8C70.49 182 83.29 191.1 97.97 191.1H303.8L416 256.1z"
        })
      })
    },
    objects: {
      outline: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        children: [
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
            d: "M12 0a9 9 0 0 0-5 16.482V21s2.035 3 5 3 5-3 5-3v-4.518A9 9 0 0 0 12 0zm0 2c3.86 0 7 3.141 7 7s-3.14 7-7 7-7-3.141-7-7 3.14-7 7-7zM9 17.477c.94.332 1.946.523 3 .523s2.06-.19 3-.523v.834c-.91.436-1.925.689-3 .689a6.924 6.924 0 0 1-3-.69v-.833zm.236 3.07A8.854 8.854 0 0 0 12 21c.965 0 1.888-.167 2.758-.451C14.155 21.173 13.153 22 12 22c-1.102 0-2.117-.789-2.764-1.453z"
          }),
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
            d: "M14.745 12.449h-.004c-.852-.024-1.188-.858-1.577-1.824-.421-1.061-.703-1.561-1.182-1.566h-.009c-.481 0-.783.497-1.235 1.537-.436.982-.801 1.811-1.636 1.791l-.276-.043c-.565-.171-.853-.691-1.284-1.794-.125-.313-.202-.632-.27-.913-.051-.213-.127-.53-.195-.634C7.067 9.004 7.039 9 6.99 9A1 1 0 0 1 7 7h.01c1.662.017 2.015 1.373 2.198 2.134.486-.981 1.304-2.058 2.797-2.075 1.531.018 2.28 1.153 2.731 2.141l.002-.008C14.944 8.424 15.327 7 16.979 7h.032A1 1 0 1 1 17 9h-.011c-.149.076-.256.474-.319.709a6.484 6.484 0 0 1-.311.951c-.429.973-.79 1.789-1.614 1.789"
          })
        ]
      }),
      solid: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 384 512",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M112.1 454.3c0 6.297 1.816 12.44 5.284 17.69l17.14 25.69c5.25 7.875 17.17 14.28 26.64 14.28h61.67c9.438 0 21.36-6.401 26.61-14.28l17.08-25.68c2.938-4.438 5.348-12.37 5.348-17.7L272 415.1h-160L112.1 454.3zM191.4 .0132C89.44 .3257 16 82.97 16 175.1c0 44.38 16.44 84.84 43.56 115.8c16.53 18.84 42.34 58.23 52.22 91.45c.0313 .25 .0938 .5166 .125 .7823h160.2c.0313-.2656 .0938-.5166 .125-.7823c9.875-33.22 35.69-72.61 52.22-91.45C351.6 260.8 368 220.4 368 175.1C368 78.61 288.9-.2837 191.4 .0132zM192 96.01c-44.13 0-80 35.89-80 79.1C112 184.8 104.8 192 96 192S80 184.8 80 176c0-61.76 50.25-111.1 112-111.1c8.844 0 16 7.159 16 16S200.8 96.01 192 96.01z"
        })
      })
    },
    people: {
      outline: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        children: [
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
            d: "M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0m0 22C6.486 22 2 17.514 2 12S6.486 2 12 2s10 4.486 10 10-4.486 10-10 10"
          }),
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
            d: "M8 7a2 2 0 1 0-.001 3.999A2 2 0 0 0 8 7M16 7a2 2 0 1 0-.001 3.999A2 2 0 0 0 16 7M15.232 15c-.693 1.195-1.87 2-3.349 2-1.477 0-2.655-.805-3.347-2H15m3-2H6a6 6 0 1 0 12 0"
          })
        ]
      }),
      solid: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M0 256C0 114.6 114.6 0 256 0C397.4 0 512 114.6 512 256C512 397.4 397.4 512 256 512C114.6 512 0 397.4 0 256zM256 432C332.1 432 396.2 382 415.2 314.1C419.1 300.4 407.8 288 393.6 288H118.4C104.2 288 92.92 300.4 96.76 314.1C115.8 382 179.9 432 256 432V432zM176.4 160C158.7 160 144.4 174.3 144.4 192C144.4 209.7 158.7 224 176.4 224C194 224 208.4 209.7 208.4 192C208.4 174.3 194 160 176.4 160zM336.4 224C354 224 368.4 209.7 368.4 192C368.4 174.3 354 160 336.4 160C318.7 160 304.4 174.3 304.4 192C304.4 209.7 318.7 224 336.4 224z"
        })
      })
    },
    places: {
      outline: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        children: [
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
            d: "M6.5 12C5.122 12 4 13.121 4 14.5S5.122 17 6.5 17 9 15.879 9 14.5 7.878 12 6.5 12m0 3c-.275 0-.5-.225-.5-.5s.225-.5.5-.5.5.225.5.5-.225.5-.5.5M17.5 12c-1.378 0-2.5 1.121-2.5 2.5s1.122 2.5 2.5 2.5 2.5-1.121 2.5-2.5-1.122-2.5-2.5-2.5m0 3c-.275 0-.5-.225-.5-.5s.225-.5.5-.5.5.225.5.5-.225.5-.5.5"
          }),
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
            d: "M22.482 9.494l-1.039-.346L21.4 9h.6c.552 0 1-.439 1-.992 0-.006-.003-.008-.003-.008H23c0-1-.889-2-1.984-2h-.642l-.731-1.717C19.262 3.012 18.091 2 16.764 2H7.236C5.909 2 4.738 3.012 4.357 4.283L3.626 6h-.642C1.889 6 1 7 1 8h.003S1 8.002 1 8.008C1 8.561 1.448 9 2 9h.6l-.043.148-1.039.346a2.001 2.001 0 0 0-1.359 2.097l.751 7.508a1 1 0 0 0 .994.901H3v1c0 1.103.896 2 2 2h2c1.104 0 2-.897 2-2v-1h6v1c0 1.103.896 2 2 2h2c1.104 0 2-.897 2-2v-1h1.096a.999.999 0 0 0 .994-.901l.751-7.508a2.001 2.001 0 0 0-1.359-2.097M6.273 4.857C6.402 4.43 6.788 4 7.236 4h9.527c.448 0 .834.43.963.857L19.313 9H4.688l1.585-4.143zM7 21H5v-1h2v1zm12 0h-2v-1h2v1zm2.189-3H2.811l-.662-6.607L3 11h18l.852.393L21.189 18z"
          })
        ]
      }),
      solid: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M39.61 196.8L74.8 96.29C88.27 57.78 124.6 32 165.4 32H346.6C387.4 32 423.7 57.78 437.2 96.29L472.4 196.8C495.6 206.4 512 229.3 512 256V448C512 465.7 497.7 480 480 480H448C430.3 480 416 465.7 416 448V400H96V448C96 465.7 81.67 480 64 480H32C14.33 480 0 465.7 0 448V256C0 229.3 16.36 206.4 39.61 196.8V196.8zM109.1 192H402.9L376.8 117.4C372.3 104.6 360.2 96 346.6 96H165.4C151.8 96 139.7 104.6 135.2 117.4L109.1 192zM96 256C78.33 256 64 270.3 64 288C64 305.7 78.33 320 96 320C113.7 320 128 305.7 128 288C128 270.3 113.7 256 96 256zM416 320C433.7 320 448 305.7 448 288C448 270.3 433.7 256 416 256C398.3 256 384 270.3 384 288C384 305.7 398.3 320 416 320z"
        })
      })
    },
    symbols: {
      outline: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M0 0h11v2H0zM4 11h3V6h4V4H0v2h4zM15.5 17c1.381 0 2.5-1.116 2.5-2.493s-1.119-2.493-2.5-2.493S13 13.13 13 14.507 14.119 17 15.5 17m0-2.986c.276 0 .5.222.5.493 0 .272-.224.493-.5.493s-.5-.221-.5-.493.224-.493.5-.493M21.5 19.014c-1.381 0-2.5 1.116-2.5 2.493S20.119 24 21.5 24s2.5-1.116 2.5-2.493-1.119-2.493-2.5-2.493m0 2.986a.497.497 0 0 1-.5-.493c0-.271.224-.493.5-.493s.5.222.5.493a.497.497 0 0 1-.5.493M22 13l-9 9 1.513 1.5 8.99-9.009zM17 11c2.209 0 4-1.119 4-2.5V2s.985-.161 1.498.949C23.01 4.055 23 6 23 6s1-1.119 1-3.135C24-.02 21 0 21 0h-2v6.347A5.853 5.853 0 0 0 17 6c-2.209 0-4 1.119-4 2.5s1.791 2.5 4 2.5M10.297 20.482l-1.475-1.585a47.54 47.54 0 0 1-1.442 1.129c-.307-.288-.989-1.016-2.045-2.183.902-.836 1.479-1.466 1.729-1.892s.376-.871.376-1.336c0-.592-.273-1.178-.818-1.759-.546-.581-1.329-.871-2.349-.871-1.008 0-1.79.293-2.344.879-.556.587-.832 1.181-.832 1.784 0 .813.419 1.748 1.256 2.805-.847.614-1.444 1.208-1.794 1.784a3.465 3.465 0 0 0-.523 1.833c0 .857.308 1.56.924 2.107.616.549 1.423.823 2.42.823 1.173 0 2.444-.379 3.813-1.137L8.235 24h2.819l-2.09-2.383 1.333-1.135zm-6.736-6.389a1.02 1.02 0 0 1 .73-.286c.31 0 .559.085.747.254a.849.849 0 0 1 .283.659c0 .518-.419 1.112-1.257 1.784-.536-.651-.805-1.231-.805-1.742a.901.901 0 0 1 .302-.669M3.74 22c-.427 0-.778-.116-1.057-.349-.279-.232-.418-.487-.418-.766 0-.594.509-1.288 1.527-2.083.968 1.134 1.717 1.946 2.248 2.438-.921.507-1.686.76-2.3.76"
        })
      }),
      solid: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512",
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
          d: "M500.3 7.251C507.7 13.33 512 22.41 512 31.1V175.1C512 202.5 483.3 223.1 447.1 223.1C412.7 223.1 383.1 202.5 383.1 175.1C383.1 149.5 412.7 127.1 447.1 127.1V71.03L351.1 90.23V207.1C351.1 234.5 323.3 255.1 287.1 255.1C252.7 255.1 223.1 234.5 223.1 207.1C223.1 181.5 252.7 159.1 287.1 159.1V63.1C287.1 48.74 298.8 35.61 313.7 32.62L473.7 .6198C483.1-1.261 492.9 1.173 500.3 7.251H500.3zM74.66 303.1L86.5 286.2C92.43 277.3 102.4 271.1 113.1 271.1H174.9C185.6 271.1 195.6 277.3 201.5 286.2L213.3 303.1H239.1C266.5 303.1 287.1 325.5 287.1 351.1V463.1C287.1 490.5 266.5 511.1 239.1 511.1H47.1C21.49 511.1-.0019 490.5-.0019 463.1V351.1C-.0019 325.5 21.49 303.1 47.1 303.1H74.66zM143.1 359.1C117.5 359.1 95.1 381.5 95.1 407.1C95.1 434.5 117.5 455.1 143.1 455.1C170.5 455.1 191.1 434.5 191.1 407.1C191.1 381.5 170.5 359.1 143.1 359.1zM440.3 367.1H496C502.7 367.1 508.6 372.1 510.1 378.4C513.3 384.6 511.6 391.7 506.5 396L378.5 508C372.9 512.1 364.6 513.3 358.6 508.9C352.6 504.6 350.3 496.6 353.3 489.7L391.7 399.1H336C329.3 399.1 323.4 395.9 321 389.6C318.7 383.4 320.4 376.3 325.5 371.1L453.5 259.1C459.1 255 467.4 254.7 473.4 259.1C479.4 263.4 481.6 271.4 478.7 278.3L440.3 367.1zM116.7 219.1L19.85 119.2C-8.112 90.26-6.614 42.31 24.85 15.34C51.82-8.137 93.26-3.642 118.2 21.83L128.2 32.32L137.7 21.83C162.7-3.642 203.6-8.137 231.6 15.34C262.6 42.31 264.1 90.26 236.1 119.2L139.7 219.1C133.2 225.6 122.7 225.6 116.7 219.1H116.7z"
        })
      })
    }
  };
  const $fcccfb36ed0cde68$var$search = {
    loupe: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
        d: "M12.9 14.32a8 8 0 1 1 1.41-1.41l5.35 5.33-1.42 1.42-5.33-5.34zM8 14A6 6 0 1 0 8 2a6 6 0 0 0 0 12z"
      })
    }),
    delete: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("path", {
        d: "M10 8.586L2.929 1.515 1.515 2.929 8.586 10l-7.071 7.071 1.414 1.414L10 11.414l7.071 7.071 1.414-1.414L11.414 10l7.071-7.071-1.414-1.414L10 8.586z"
      })
    })
  };
  var $fcccfb36ed0cde68$export$2e2bcd8739ae039 = {
    categories: $fcccfb36ed0cde68$var$categories,
    search: $fcccfb36ed0cde68$var$search
  };
  function $254755d3f438722f$export$2e2bcd8739ae039(props) {
    let { id, skin, emoji } = props;
    if (props.shortcodes) {
      const matches2 = props.shortcodes.match($c4d155af13ad4d4b$export$2e2bcd8739ae039.SHORTCODES_REGEX);
      if (matches2) {
        id = matches2[1];
        if (matches2[2]) skin = matches2[2];
      }
    }
    emoji || (emoji = $c4d155af13ad4d4b$export$2e2bcd8739ae039.get(id || props.native));
    if (!emoji) return props.fallback;
    const emojiSkin = emoji.skins[skin - 1] || emoji.skins[0];
    const imageSrc = emojiSkin.src || (props.set != "native" && !props.spritesheet ? typeof props.getImageURL === "function" ? props.getImageURL(props.set, emojiSkin.unified) : `https://cdn.jsdelivr.net/npm/emoji-datasource-${props.set}@15.0.1/img/${props.set}/64/${emojiSkin.unified}.png` : void 0);
    const spritesheetSrc = typeof props.getSpritesheetURL === "function" ? props.getSpritesheetURL(props.set) : `https://cdn.jsdelivr.net/npm/emoji-datasource-${props.set}@15.0.1/img/${props.set}/sheets-256/64.png`;
    return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("span", {
      class: "emoji-mart-emoji",
      "data-emoji-set": props.set,
      children: imageSrc ? /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("img", {
        style: {
          maxWidth: props.size || "1em",
          maxHeight: props.size || "1em",
          display: "inline-block"
        },
        alt: emojiSkin.native || emojiSkin.shortcodes,
        src: imageSrc
      }) : props.set == "native" ? /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("span", {
        style: {
          fontSize: props.size,
          fontFamily: '"EmojiMart", "Segoe UI Emoji", "Segoe UI Symbol", "Segoe UI", "Apple Color Emoji", "Twemoji Mozilla", "Noto Color Emoji", "Android Emoji"'
        },
        children: emojiSkin.native
      }) : /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("span", {
        style: {
          display: "block",
          width: props.size,
          height: props.size,
          backgroundImage: `url(${spritesheetSrc})`,
          backgroundSize: `${100 * $7adb23b0109cc36a$export$2d0294657ab35f1b.sheet.cols}% ${100 * $7adb23b0109cc36a$export$2d0294657ab35f1b.sheet.rows}%`,
          backgroundPosition: `${100 / ($7adb23b0109cc36a$export$2d0294657ab35f1b.sheet.cols - 1) * emojiSkin.x}% ${100 / ($7adb23b0109cc36a$export$2d0294657ab35f1b.sheet.rows - 1) * emojiSkin.y}%`
        }
      })
    });
  }
  const $6f57cc9cd54c5aaa$var$WindowHTMLElement = typeof window !== "undefined" && window.HTMLElement ? window.HTMLElement : Object;
  class $6f57cc9cd54c5aaa$export$2e2bcd8739ae039 extends $6f57cc9cd54c5aaa$var$WindowHTMLElement {
    static get observedAttributes() {
      return Object.keys(this.Props);
    }
    update(props = {}) {
      for (let k2 in props) this.attributeChangedCallback(k2, null, props[k2]);
    }
    attributeChangedCallback(attr, _2, newValue) {
      if (!this.component) return;
      const value = $7adb23b0109cc36a$export$88c9ddb45cea7241(attr, {
        [attr]: newValue
      }, this.constructor.Props, this);
      if (this.component.componentWillReceiveProps) this.component.componentWillReceiveProps({
        [attr]: value
      });
      else {
        this.component.props[attr] = value;
        this.component.forceUpdate();
      }
    }
    disconnectedCallback() {
      this.disconnected = true;
      if (this.component && this.component.unregister) this.component.unregister();
    }
    constructor(props = {}) {
      super();
      this.props = props;
      if (props.parent || props.ref) {
        let ref = null;
        const parent = props.parent || (ref = props.ref && props.ref.current);
        if (ref) ref.innerHTML = "";
        if (parent) parent.appendChild(this);
      }
    }
  }
  class $26f27c338a96b1a6$export$2e2bcd8739ae039 extends $6f57cc9cd54c5aaa$export$2e2bcd8739ae039 {
    setShadow() {
      this.attachShadow({
        mode: "open"
      });
    }
    injectStyles(styles2) {
      if (!styles2) return;
      const style = document.createElement("style");
      style.textContent = styles2;
      this.shadowRoot.insertBefore(style, this.shadowRoot.firstChild);
    }
    constructor(props, { styles: styles2 } = {}) {
      super(props);
      this.setShadow();
      this.injectStyles(styles2);
    }
  }
  var $3d90f6e46fb2dd47$export$2e2bcd8739ae039 = {
    fallback: "",
    id: "",
    native: "",
    shortcodes: "",
    size: {
      value: "",
      transform: (value) => {
        if (!/\D/.test(value)) return `${value}px`;
        return value;
      }
    },
    // Shared
    set: $b247ea80b67298d5$export$2e2bcd8739ae039.set,
    skin: $b247ea80b67298d5$export$2e2bcd8739ae039.skin
  };
  class $331b4160623139bf$export$2e2bcd8739ae039 extends $6f57cc9cd54c5aaa$export$2e2bcd8739ae039 {
    async connectedCallback() {
      const props = $7adb23b0109cc36a$export$75fe5f91d452f94b(this.props, $3d90f6e46fb2dd47$export$2e2bcd8739ae039, this);
      props.element = this;
      props.ref = (component) => {
        this.component = component;
      };
      await $7adb23b0109cc36a$export$2cd8252107eb640b();
      if (this.disconnected) return;
      $fb96b826c0c5f37a$export$b3890eb0ae9dca99(/* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b($254755d3f438722f$export$2e2bcd8739ae039, {
        ...props
      }), this);
    }
    constructor(props) {
      super(props);
    }
  }
  $c770c458706daa72$export$2e2bcd8739ae039($331b4160623139bf$export$2e2bcd8739ae039, "Props", $3d90f6e46fb2dd47$export$2e2bcd8739ae039);
  if (typeof customElements !== "undefined" && !customElements.get("em-emoji")) customElements.define("em-emoji", $331b4160623139bf$export$2e2bcd8739ae039);
  var $1a9a8ef576b7773d$var$r, $1a9a8ef576b7773d$var$i = [], $1a9a8ef576b7773d$var$c = $fb96b826c0c5f37a$export$41c562ebe57d11e2.__b, $1a9a8ef576b7773d$var$f = $fb96b826c0c5f37a$export$41c562ebe57d11e2.__r, $1a9a8ef576b7773d$var$e = $fb96b826c0c5f37a$export$41c562ebe57d11e2.diffed, $1a9a8ef576b7773d$var$a = $fb96b826c0c5f37a$export$41c562ebe57d11e2.__c, $1a9a8ef576b7773d$var$v = $fb96b826c0c5f37a$export$41c562ebe57d11e2.unmount;
  function $1a9a8ef576b7773d$var$x() {
    var t6;
    for ($1a9a8ef576b7773d$var$i.sort(function(n11, t7) {
      return n11.__v.__b - t7.__v.__b;
    }); t6 = $1a9a8ef576b7773d$var$i.pop(); ) if (t6.__P) try {
      t6.__H.__h.forEach($1a9a8ef576b7773d$var$g), t6.__H.__h.forEach($1a9a8ef576b7773d$var$j), t6.__H.__h = [];
    } catch (u4) {
      t6.__H.__h = [], $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e(u4, t6.__v);
    }
  }
  $fb96b826c0c5f37a$export$41c562ebe57d11e2.__b = function(n12) {
    $1a9a8ef576b7773d$var$c && $1a9a8ef576b7773d$var$c(n12);
  }, $fb96b826c0c5f37a$export$41c562ebe57d11e2.__r = function(n13) {
    $1a9a8ef576b7773d$var$f && $1a9a8ef576b7773d$var$f(n13);
    var r8 = n13.__c.__H;
    r8 && (r8.__h.forEach($1a9a8ef576b7773d$var$g), r8.__h.forEach($1a9a8ef576b7773d$var$j), r8.__h = []);
  }, $fb96b826c0c5f37a$export$41c562ebe57d11e2.diffed = function(t8) {
    $1a9a8ef576b7773d$var$e && $1a9a8ef576b7773d$var$e(t8);
    var o6 = t8.__c;
    o6 && o6.__H && o6.__H.__h.length && (1 !== $1a9a8ef576b7773d$var$i.push(o6) && $1a9a8ef576b7773d$var$r === $fb96b826c0c5f37a$export$41c562ebe57d11e2.requestAnimationFrame || (($1a9a8ef576b7773d$var$r = $fb96b826c0c5f37a$export$41c562ebe57d11e2.requestAnimationFrame) || function(n14) {
      var t9, u5 = function() {
        clearTimeout(r9), $1a9a8ef576b7773d$var$b && cancelAnimationFrame(t9), setTimeout(n14);
      }, r9 = setTimeout(u5, 100);
      $1a9a8ef576b7773d$var$b && (t9 = requestAnimationFrame(u5));
    })($1a9a8ef576b7773d$var$x));
  }, $fb96b826c0c5f37a$export$41c562ebe57d11e2.__c = function(t10, u6) {
    u6.some(function(t11) {
      try {
        t11.__h.forEach($1a9a8ef576b7773d$var$g), t11.__h = t11.__h.filter(function(n15) {
          return !n15.__ || $1a9a8ef576b7773d$var$j(n15);
        });
      } catch (r10) {
        u6.some(function(n16) {
          n16.__h && (n16.__h = []);
        }), u6 = [], $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e(r10, t11.__v);
      }
    }), $1a9a8ef576b7773d$var$a && $1a9a8ef576b7773d$var$a(t10, u6);
  }, $fb96b826c0c5f37a$export$41c562ebe57d11e2.unmount = function(t12) {
    $1a9a8ef576b7773d$var$v && $1a9a8ef576b7773d$var$v(t12);
    var u7, r11 = t12.__c;
    r11 && r11.__H && (r11.__H.__.forEach(function(n17) {
      try {
        $1a9a8ef576b7773d$var$g(n17);
      } catch (n18) {
        u7 = n18;
      }
    }), u7 && $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e(u7, r11.__v));
  };
  var $1a9a8ef576b7773d$var$b = "function" == typeof requestAnimationFrame;
  function $1a9a8ef576b7773d$var$g(n19) {
    var r12 = n19.__c;
    "function" == typeof r12 && (n19.__c = void 0, r12());
  }
  function $1a9a8ef576b7773d$var$j(n20) {
    n20.__c = n20.__();
  }
  function $dc040a17866866fa$var$S(n1, t1) {
    for (var e1 in t1) n1[e1] = t1[e1];
    return n1;
  }
  function $dc040a17866866fa$var$C(n2, t2) {
    for (var e2 in n2) if ("__source" !== e2 && !(e2 in t2)) return true;
    for (var r1 in t2) if ("__source" !== r1 && n2[r1] !== t2[r1]) return true;
    return false;
  }
  function $dc040a17866866fa$export$221d75b3f55bb0bd(n3) {
    this.props = n3;
  }
  ($dc040a17866866fa$export$221d75b3f55bb0bd.prototype = new $fb96b826c0c5f37a$export$16fa2f45be04daa8()).isPureReactComponent = true, $dc040a17866866fa$export$221d75b3f55bb0bd.prototype.shouldComponentUpdate = function(n6, t5) {
    return $dc040a17866866fa$var$C(this.props, n6) || $dc040a17866866fa$var$C(this.state, t5);
  };
  var $dc040a17866866fa$var$w = $fb96b826c0c5f37a$export$41c562ebe57d11e2.__b;
  $fb96b826c0c5f37a$export$41c562ebe57d11e2.__b = function(n7) {
    n7.type && n7.type.__f && n7.ref && (n7.props.ref = n7.ref, n7.ref = null), $dc040a17866866fa$var$w && $dc040a17866866fa$var$w(n7);
  };
  var $dc040a17866866fa$var$A = $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e;
  $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e = function(n12, t10, e6) {
    if (n12.then) {
      for (var r5, u1 = t10; u1 = u1.__; ) if ((r5 = u1.__c) && r5.__c) return null == t10.__e && (t10.__e = e6.__e, t10.__k = e6.__k), r5.__c(n12, t10);
    }
    $dc040a17866866fa$var$A(n12, t10, e6);
  };
  var $dc040a17866866fa$var$O = $fb96b826c0c5f37a$export$41c562ebe57d11e2.unmount;
  function $dc040a17866866fa$export$74bf444e3cd11ea5() {
    this.__u = 0, this.t = null, this.__b = null;
  }
  function $dc040a17866866fa$var$U(n13) {
    var t11 = n13.__.__c;
    return t11 && t11.__e && t11.__e(n13);
  }
  function $dc040a17866866fa$export$998bcd577473dd93() {
    this.u = null, this.o = null;
  }
  $fb96b826c0c5f37a$export$41c562ebe57d11e2.unmount = function(n17) {
    var t13 = n17.__c;
    t13 && t13.__R && t13.__R(), t13 && true === n17.__h && (n17.type = null), $dc040a17866866fa$var$O && $dc040a17866866fa$var$O(n17);
  }, ($dc040a17866866fa$export$74bf444e3cd11ea5.prototype = new $fb96b826c0c5f37a$export$16fa2f45be04daa8()).__c = function(n18, t14) {
    var e8 = t14.__c, r7 = this;
    null == r7.t && (r7.t = []), r7.t.push(e8);
    var u4 = $dc040a17866866fa$var$U(r7.__v), o1 = false, i1 = function() {
      o1 || (o1 = true, e8.__R = null, u4 ? u4(l1) : l1());
    };
    e8.__R = i1;
    var l1 = function() {
      if (!--r7.__u) {
        if (r7.state.__e) {
          var n19 = r7.state.__e;
          r7.__v.__k[0] = function n22(t17, e9, r8) {
            return t17 && (t17.__v = null, t17.__k = t17.__k && t17.__k.map(function(t18) {
              return n22(t18, e9, r8);
            }), t17.__c && t17.__c.__P === e9 && (t17.__e && r8.insertBefore(t17.__e, t17.__d), t17.__c.__e = true, t17.__c.__P = r8)), t17;
          }(n19, n19.__c.__P, n19.__c.__O);
        }
        var t15;
        for (r7.setState({
          __e: r7.__b = null
        }); t15 = r7.t.pop(); ) t15.forceUpdate();
      }
    }, c1 = true === t14.__h;
    r7.__u++ || c1 || r7.setState({
      __e: r7.__b = r7.__v.__k[0]
    }), n18.then(i1, i1);
  }, $dc040a17866866fa$export$74bf444e3cd11ea5.prototype.componentWillUnmount = function() {
    this.t = [];
  }, $dc040a17866866fa$export$74bf444e3cd11ea5.prototype.render = function(n23, t19) {
    if (this.__b) {
      if (this.__v.__k) {
        var e10 = document.createElement("div"), r9 = this.__v.__k[0].__c;
        this.__v.__k[0] = function n24(t20, e13, r12) {
          return t20 && (t20.__c && t20.__c.__H && (t20.__c.__H.__.forEach(function(n25) {
            "function" == typeof n25.__c && n25.__c();
          }), t20.__c.__H = null), null != (t20 = $dc040a17866866fa$var$S({}, t20)).__c && (t20.__c.__P === r12 && (t20.__c.__P = e13), t20.__c = null), t20.__k = t20.__k && t20.__k.map(function(t21) {
            return n24(t21, e13, r12);
          })), t20;
        }(this.__b, e10, r9.__O = r9.__P);
      }
      this.__b = null;
    }
    var u5 = t19.__e && $fb96b826c0c5f37a$export$c8a8987d4410bf2d($fb96b826c0c5f37a$export$ffb0004e005737fa, null, n23.fallback);
    return u5 && (u5.__h = null), [
      $fb96b826c0c5f37a$export$c8a8987d4410bf2d($fb96b826c0c5f37a$export$ffb0004e005737fa, null, t19.__e ? null : n23.children),
      u5
    ];
  };
  var $dc040a17866866fa$var$T = function(n26, t22, e14) {
    if (++e14[1] === e14[0] && n26.o.delete(t22), n26.props.revealOrder && ("t" !== n26.props.revealOrder[0] || !n26.o.size)) for (e14 = n26.u; e14; ) {
      for (; e14.length > 3; ) e14.pop()();
      if (e14[1] < e14[0]) break;
      n26.u = e14 = e14[2];
    }
  };
  ($dc040a17866866fa$export$998bcd577473dd93.prototype = new $fb96b826c0c5f37a$export$16fa2f45be04daa8()).__e = function(n33) {
    var t25 = this, e16 = $dc040a17866866fa$var$U(t25.__v), r13 = t25.o.get(n33);
    return r13[0]++, function(u6) {
      var o2 = function() {
        t25.props.revealOrder ? (r13.push(u6), $dc040a17866866fa$var$T(t25, n33, r13)) : u6();
      };
      e16 ? e16(o2) : o2();
    };
  }, $dc040a17866866fa$export$998bcd577473dd93.prototype.render = function(n34) {
    this.u = null, this.o = /* @__PURE__ */ new Map();
    var t26 = $fb96b826c0c5f37a$export$47e4c5b300681277(n34.children);
    n34.revealOrder && "b" === n34.revealOrder[0] && t26.reverse();
    for (var e17 = t26.length; e17--; ) this.o.set(t26[e17], this.u = [
      1,
      0,
      this.u
    ]);
    return n34.children;
  }, $dc040a17866866fa$export$998bcd577473dd93.prototype.componentDidUpdate = $dc040a17866866fa$export$998bcd577473dd93.prototype.componentDidMount = function() {
    var n35 = this;
    this.o.forEach(function(t27, e18) {
      $dc040a17866866fa$var$T(n35, e18, t27);
    });
  };
  var $dc040a17866866fa$var$j = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103, $dc040a17866866fa$var$P = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, $dc040a17866866fa$var$V = "undefined" != typeof document, $dc040a17866866fa$var$z = function(n36) {
    return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n36);
  };
  $fb96b826c0c5f37a$export$16fa2f45be04daa8.prototype.isReactComponent = {}, [
    "componentWillMount",
    "componentWillReceiveProps",
    "componentWillUpdate"
  ].forEach(function(n39) {
    Object.defineProperty($fb96b826c0c5f37a$export$16fa2f45be04daa8.prototype, n39, {
      configurable: true,
      get: function() {
        return this["UNSAFE_" + n39];
      },
      set: function(t30) {
        Object.defineProperty(this, n39, {
          configurable: true,
          writable: true,
          value: t30
        });
      }
    });
  });
  var $dc040a17866866fa$var$H = $fb96b826c0c5f37a$export$41c562ebe57d11e2.event;
  function $dc040a17866866fa$var$Z() {
  }
  function $dc040a17866866fa$var$Y() {
    return this.cancelBubble;
  }
  function $dc040a17866866fa$var$q() {
    return this.defaultPrevented;
  }
  $fb96b826c0c5f37a$export$41c562ebe57d11e2.event = function(n40) {
    return $dc040a17866866fa$var$H && (n40 = $dc040a17866866fa$var$H(n40)), n40.persist = $dc040a17866866fa$var$Z, n40.isPropagationStopped = $dc040a17866866fa$var$Y, n40.isDefaultPrevented = $dc040a17866866fa$var$q, n40.nativeEvent = n40;
  };
  var $dc040a17866866fa$var$J = {
    configurable: true,
    get: function() {
      return this.class;
    }
  }, $dc040a17866866fa$var$K = $fb96b826c0c5f37a$export$41c562ebe57d11e2.vnode;
  $fb96b826c0c5f37a$export$41c562ebe57d11e2.vnode = function(n41) {
    var t31 = n41.type, e21 = n41.props, r14 = e21;
    if ("string" == typeof t31) {
      var u7 = -1 === t31.indexOf("-");
      for (var o3 in r14 = {}, e21) {
        var i2 = e21[o3];
        $dc040a17866866fa$var$V && "children" === o3 && "noscript" === t31 || "value" === o3 && "defaultValue" in e21 && null == i2 || ("defaultValue" === o3 && "value" in e21 && null == e21.value ? o3 = "value" : "download" === o3 && true === i2 ? i2 = "" : /ondoubleclick/i.test(o3) ? o3 = "ondblclick" : /^onchange(textarea|input)/i.test(o3 + t31) && !$dc040a17866866fa$var$z(e21.type) ? o3 = "oninput" : /^onfocus$/i.test(o3) ? o3 = "onfocusin" : /^onblur$/i.test(o3) ? o3 = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp)/.test(o3) ? o3 = o3.toLowerCase() : u7 && $dc040a17866866fa$var$P.test(o3) ? o3 = o3.replace(/[A-Z0-9]/, "-$&").toLowerCase() : null === i2 && (i2 = void 0), r14[o3] = i2);
      }
      "select" == t31 && r14.multiple && Array.isArray(r14.value) && (r14.value = $fb96b826c0c5f37a$export$47e4c5b300681277(e21.children).forEach(function(n42) {
        n42.props.selected = -1 != r14.value.indexOf(n42.props.value);
      })), "select" == t31 && null != r14.defaultValue && (r14.value = $fb96b826c0c5f37a$export$47e4c5b300681277(e21.children).forEach(function(n43) {
        n43.props.selected = r14.multiple ? -1 != r14.defaultValue.indexOf(n43.props.value) : r14.defaultValue == n43.props.value;
      })), n41.props = r14, e21.class != e21.className && ($dc040a17866866fa$var$J.enumerable = "className" in e21, null != e21.className && (r14.class = e21.className), Object.defineProperty(r14, "className", $dc040a17866866fa$var$J));
    }
    n41.$$typeof = $dc040a17866866fa$var$j, $dc040a17866866fa$var$K && $dc040a17866866fa$var$K(n41);
  };
  var $dc040a17866866fa$var$Q = $fb96b826c0c5f37a$export$41c562ebe57d11e2.__r;
  $fb96b826c0c5f37a$export$41c562ebe57d11e2.__r = function(n44) {
    $dc040a17866866fa$var$Q && $dc040a17866866fa$var$Q(n44), n44.__c;
  };
  const $ec8c39fdad15601a$var$THEME_ICONS = {
    light: "outline",
    dark: "solid"
  };
  class $ec8c39fdad15601a$export$2e2bcd8739ae039 extends $dc040a17866866fa$export$221d75b3f55bb0bd {
    renderIcon(category) {
      const { icon } = category;
      if (icon) {
        if (icon.svg) return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("span", {
          class: "flex",
          dangerouslySetInnerHTML: {
            __html: icon.svg
          }
        });
        if (icon.src) return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("img", {
          src: icon.src
        });
      }
      const categoryIcons = $fcccfb36ed0cde68$export$2e2bcd8739ae039.categories[category.id] || $fcccfb36ed0cde68$export$2e2bcd8739ae039.categories.custom;
      const style = this.props.icons == "auto" ? $ec8c39fdad15601a$var$THEME_ICONS[this.props.theme] : this.props.icons;
      return categoryIcons[style] || categoryIcons;
    }
    render() {
      let selectedCategoryIndex = null;
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("nav", {
        id: "nav",
        class: "padding",
        "data-position": this.props.position,
        dir: this.props.dir,
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
          class: "flex relative",
          children: [
            this.categories.map((category, i2) => {
              const title = category.name || $7adb23b0109cc36a$export$dbe3113d60765c1a.categories[category.id];
              const selected = !this.props.unfocused && category.id == this.state.categoryId;
              if (selected) selectedCategoryIndex = i2;
              return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("button", {
                "aria-label": title,
                "aria-selected": selected || void 0,
                title,
                type: "button",
                class: "flex flex-grow flex-center",
                onMouseDown: (e) => e.preventDefault(),
                onClick: () => {
                  this.props.onClick({
                    category,
                    i: i2
                  });
                },
                children: this.renderIcon(category)
              });
            }),
            /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
              class: "bar",
              style: {
                width: `${100 / this.categories.length}%`,
                opacity: selectedCategoryIndex == null ? 0 : 1,
                transform: this.props.dir === "rtl" ? `scaleX(-1) translateX(${selectedCategoryIndex * 100}%)` : `translateX(${selectedCategoryIndex * 100}%)`
              }
            })
          ]
        })
      });
    }
    constructor() {
      super();
      this.categories = $7adb23b0109cc36a$export$2d0294657ab35f1b.categories.filter((category) => {
        return !category.target;
      });
      this.state = {
        categoryId: this.categories[0].id
      };
    }
  }
  class $e0d4dda61265ff1e$export$2e2bcd8739ae039 extends $dc040a17866866fa$export$221d75b3f55bb0bd {
    shouldComponentUpdate(nextProps) {
      for (let k2 in nextProps) {
        if (k2 == "children") continue;
        if (nextProps[k2] != this.props[k2]) return true;
      }
      return false;
    }
    render() {
      return this.props.children;
    }
  }
  const $89bd6bb200cc8fef$var$Performance = {
    rowsPerRender: 10
  };
  class $89bd6bb200cc8fef$export$2e2bcd8739ae039 extends $fb96b826c0c5f37a$export$16fa2f45be04daa8 {
    getInitialState(props = this.props) {
      return {
        skin: $f72b75cf796873c7$export$2e2bcd8739ae039.get("skin") || props.skin,
        theme: this.initTheme(props.theme)
      };
    }
    componentWillMount() {
      this.dir = $7adb23b0109cc36a$export$dbe3113d60765c1a.rtl ? "rtl" : "ltr";
      this.refs = {
        menu: $fb96b826c0c5f37a$export$7d1e3a5e95ceca43(),
        navigation: $fb96b826c0c5f37a$export$7d1e3a5e95ceca43(),
        scroll: $fb96b826c0c5f37a$export$7d1e3a5e95ceca43(),
        search: $fb96b826c0c5f37a$export$7d1e3a5e95ceca43(),
        searchInput: $fb96b826c0c5f37a$export$7d1e3a5e95ceca43(),
        skinToneButton: $fb96b826c0c5f37a$export$7d1e3a5e95ceca43(),
        skinToneRadio: $fb96b826c0c5f37a$export$7d1e3a5e95ceca43()
      };
      this.initGrid();
      if (this.props.stickySearch == false && this.props.searchPosition == "sticky") {
        console.warn("[EmojiMart] Deprecation warning: `stickySearch` has been renamed `searchPosition`.");
        this.props.searchPosition = "static";
      }
    }
    componentDidMount() {
      this.register();
      this.shadowRoot = this.base.parentNode;
      if (this.props.autoFocus) {
        const { searchInput } = this.refs;
        if (searchInput.current) searchInput.current.focus();
      }
    }
    componentWillReceiveProps(nextProps) {
      this.nextState || (this.nextState = {});
      for (const k1 in nextProps) this.nextState[k1] = nextProps[k1];
      clearTimeout(this.nextStateTimer);
      this.nextStateTimer = setTimeout(() => {
        let requiresGridReset = false;
        for (const k2 in this.nextState) {
          this.props[k2] = this.nextState[k2];
          if (k2 === "custom" || k2 === "categories") requiresGridReset = true;
        }
        delete this.nextState;
        const nextState = this.getInitialState();
        if (requiresGridReset) return this.reset(nextState);
        this.setState(nextState);
      });
    }
    componentWillUnmount() {
      this.unregister();
    }
    async reset(nextState = {}) {
      await $7adb23b0109cc36a$export$2cd8252107eb640b(this.props);
      this.initGrid();
      this.unobserve();
      this.setState(nextState, () => {
        this.observeCategories();
        this.observeRows();
      });
    }
    register() {
      document.addEventListener("click", this.handleClickOutside);
      this.observe();
    }
    unregister() {
      var _a2;
      document.removeEventListener("click", this.handleClickOutside);
      (_a2 = this.darkMedia) == null ? void 0 : _a2.removeEventListener("change", this.darkMediaCallback);
      this.unobserve();
    }
    observe() {
      this.observeCategories();
      this.observeRows();
    }
    unobserve({ except = [] } = {}) {
      if (!Array.isArray(except)) except = [
        except
      ];
      for (const observer of this.observers) {
        if (except.includes(observer)) continue;
        observer.disconnect();
      }
      this.observers = [].concat(except);
    }
    initGrid() {
      const { categories } = $7adb23b0109cc36a$export$2d0294657ab35f1b;
      this.refs.categories = /* @__PURE__ */ new Map();
      const navKey = $7adb23b0109cc36a$export$2d0294657ab35f1b.categories.map((category) => category.id).join(",");
      if (this.navKey && this.navKey != navKey) this.refs.scroll.current && (this.refs.scroll.current.scrollTop = 0);
      this.navKey = navKey;
      this.grid = [];
      this.grid.setsize = 0;
      const addRow = (rows, category) => {
        const row = [];
        row.__categoryId = category.id;
        row.__index = rows.length;
        this.grid.push(row);
        const rowIndex = this.grid.length - 1;
        const rowRef = rowIndex % $89bd6bb200cc8fef$var$Performance.rowsPerRender ? {} : $fb96b826c0c5f37a$export$7d1e3a5e95ceca43();
        rowRef.index = rowIndex;
        rowRef.posinset = this.grid.setsize + 1;
        rows.push(rowRef);
        return row;
      };
      for (let category1 of categories) {
        const rows = [];
        let row = addRow(rows, category1);
        for (let emoji of category1.emojis) {
          if (row.length == this.getPerLine()) row = addRow(rows, category1);
          this.grid.setsize += 1;
          row.push(emoji);
        }
        this.refs.categories.set(category1.id, {
          root: $fb96b826c0c5f37a$export$7d1e3a5e95ceca43(),
          rows
        });
      }
    }
    initTheme(theme) {
      if (theme != "auto") return theme;
      if (!this.darkMedia) {
        this.darkMedia = matchMedia("(prefers-color-scheme: dark)");
        if (this.darkMedia.media.match(/^not/)) return "light";
        this.darkMedia.addEventListener("change", this.darkMediaCallback);
      }
      return this.darkMedia.matches ? "dark" : "light";
    }
    initDynamicPerLine(props = this.props) {
      if (!props.dynamicWidth) return;
      const { element, emojiButtonSize } = props;
      const calculatePerLine = () => {
        const { width } = element.getBoundingClientRect();
        return Math.floor(width / emojiButtonSize);
      };
      const observer = new ResizeObserver(() => {
        this.unobserve({
          except: observer
        });
        this.setState({
          perLine: calculatePerLine()
        }, () => {
          this.initGrid();
          this.forceUpdate(() => {
            this.observeCategories();
            this.observeRows();
          });
        });
      });
      observer.observe(element);
      this.observers.push(observer);
      return calculatePerLine();
    }
    getPerLine() {
      return this.state.perLine || this.props.perLine;
    }
    getEmojiByPos([p1, p2]) {
      const grid = this.state.searchResults || this.grid;
      const emoji = grid[p1] && grid[p1][p2];
      if (!emoji) return;
      return $c4d155af13ad4d4b$export$2e2bcd8739ae039.get(emoji);
    }
    observeCategories() {
      const navigation = this.refs.navigation.current;
      if (!navigation) return;
      const visibleCategories = /* @__PURE__ */ new Map();
      const setFocusedCategory = (categoryId) => {
        if (categoryId != navigation.state.categoryId) navigation.setState({
          categoryId
        });
      };
      const observerOptions = {
        root: this.refs.scroll.current,
        threshold: [
          0,
          1
        ]
      };
      const observer = new IntersectionObserver((entries2) => {
        for (const entry of entries2) {
          const id = entry.target.dataset.id;
          visibleCategories.set(id, entry.intersectionRatio);
        }
        const ratios = [
          ...visibleCategories
        ];
        for (const [id, ratio] of ratios) if (ratio) {
          setFocusedCategory(id);
          break;
        }
      }, observerOptions);
      for (const { root } of this.refs.categories.values()) observer.observe(root.current);
      this.observers.push(observer);
    }
    observeRows() {
      const visibleRows = {
        ...this.state.visibleRows
      };
      const observer = new IntersectionObserver((entries2) => {
        for (const entry of entries2) {
          const index = parseInt(entry.target.dataset.index);
          if (entry.isIntersecting) visibleRows[index] = true;
          else delete visibleRows[index];
        }
        this.setState({
          visibleRows
        });
      }, {
        root: this.refs.scroll.current,
        rootMargin: `${this.props.emojiButtonSize * ($89bd6bb200cc8fef$var$Performance.rowsPerRender + 5)}px 0px ${this.props.emojiButtonSize * $89bd6bb200cc8fef$var$Performance.rowsPerRender}px`
      });
      for (const { rows } of this.refs.categories.values()) {
        for (const row of rows) if (row.current) observer.observe(row.current);
      }
      this.observers.push(observer);
    }
    preventDefault(e) {
      e.preventDefault();
    }
    unfocusSearch() {
      const input = this.refs.searchInput.current;
      if (!input) return;
      input.blur();
    }
    navigate({ e, input, left, right, up, down }) {
      const grid = this.state.searchResults || this.grid;
      if (!grid.length) return;
      let [p1, p2] = this.state.pos;
      const pos = (() => {
        if (p1 == 0) {
          if (p2 == 0 && !e.repeat && (left || up)) return null;
        }
        if (p1 == -1) {
          if (!e.repeat && (right || down) && input.selectionStart == input.value.length) return [
            0,
            0
          ];
          return null;
        }
        if (left || right) {
          let row = grid[p1];
          const increment = left ? -1 : 1;
          p2 += increment;
          if (!row[p2]) {
            p1 += increment;
            row = grid[p1];
            if (!row) {
              p1 = left ? 0 : grid.length - 1;
              p2 = left ? 0 : grid[p1].length - 1;
              return [
                p1,
                p2
              ];
            }
            p2 = left ? row.length - 1 : 0;
          }
          return [
            p1,
            p2
          ];
        }
        if (up || down) {
          p1 += up ? -1 : 1;
          const row = grid[p1];
          if (!row) {
            p1 = up ? 0 : grid.length - 1;
            p2 = up ? 0 : grid[p1].length - 1;
            return [
              p1,
              p2
            ];
          }
          if (!row[p2]) p2 = row.length - 1;
          return [
            p1,
            p2
          ];
        }
      })();
      if (pos) e.preventDefault();
      else {
        if (this.state.pos[0] > -1) this.setState({
          pos: [
            -1,
            -1
          ]
        });
        return;
      }
      this.setState({
        pos,
        keyboard: true
      }, () => {
        this.scrollTo({
          row: pos[0]
        });
      });
    }
    scrollTo({ categoryId, row }) {
      const grid = this.state.searchResults || this.grid;
      if (!grid.length) return;
      const scroll = this.refs.scroll.current;
      const scrollRect = scroll.getBoundingClientRect();
      let scrollTop = 0;
      if (row >= 0) categoryId = grid[row].__categoryId;
      if (categoryId) {
        const ref = this.refs[categoryId] || this.refs.categories.get(categoryId).root;
        const categoryRect = ref.current.getBoundingClientRect();
        scrollTop = categoryRect.top - (scrollRect.top - scroll.scrollTop) + 1;
      }
      if (row >= 0) {
        if (!row) scrollTop = 0;
        else {
          const rowIndex = grid[row].__index;
          const rowTop = scrollTop + rowIndex * this.props.emojiButtonSize;
          const rowBot = rowTop + this.props.emojiButtonSize + this.props.emojiButtonSize * 0.88;
          if (rowTop < scroll.scrollTop) scrollTop = rowTop;
          else if (rowBot > scroll.scrollTop + scrollRect.height) scrollTop = rowBot - scrollRect.height;
          else return;
        }
      }
      this.ignoreMouse();
      scroll.scrollTop = scrollTop;
    }
    ignoreMouse() {
      this.mouseIsIgnored = true;
      clearTimeout(this.ignoreMouseTimer);
      this.ignoreMouseTimer = setTimeout(() => {
        delete this.mouseIsIgnored;
      }, 100);
    }
    handleEmojiOver(pos) {
      if (this.mouseIsIgnored || this.state.showSkins) return;
      this.setState({
        pos: pos || [
          -1,
          -1
        ],
        keyboard: false
      });
    }
    handleEmojiClick({ e, emoji, pos }) {
      if (!this.props.onEmojiSelect) return;
      if (!emoji && pos) emoji = this.getEmojiByPos(pos);
      if (emoji) {
        const emojiData = $693b183b0a78708f$export$d10ac59fbe52a745(emoji, {
          skinIndex: this.state.skin - 1
        });
        if (this.props.maxFrequentRows) $b22cfd0a55410b4f$export$2e2bcd8739ae039.add(emojiData, this.props);
        this.props.onEmojiSelect(emojiData, e);
      }
    }
    closeSkins() {
      if (!this.state.showSkins) return;
      this.setState({
        showSkins: null,
        tempSkin: null
      });
      this.base.removeEventListener("click", this.handleBaseClick);
      this.base.removeEventListener("keydown", this.handleBaseKeydown);
    }
    handleSkinMouseOver(tempSkin) {
      this.setState({
        tempSkin
      });
    }
    handleSkinClick(skin) {
      this.ignoreMouse();
      this.closeSkins();
      this.setState({
        skin,
        tempSkin: null
      });
      $f72b75cf796873c7$export$2e2bcd8739ae039.set("skin", skin);
    }
    renderNav() {
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b($ec8c39fdad15601a$export$2e2bcd8739ae039, {
        ref: this.refs.navigation,
        icons: this.props.icons,
        theme: this.state.theme,
        dir: this.dir,
        unfocused: !!this.state.searchResults,
        position: this.props.navPosition,
        onClick: this.handleCategoryClick
      }, this.navKey);
    }
    renderPreview() {
      const emoji = this.getEmojiByPos(this.state.pos);
      const noSearchResults = this.state.searchResults && !this.state.searchResults.length;
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
        id: "preview",
        class: "flex flex-middle",
        dir: this.dir,
        "data-position": this.props.previewPosition,
        children: [
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
            class: "flex flex-middle flex-grow",
            children: [
              /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                class: "flex flex-auto flex-middle flex-center",
                style: {
                  height: this.props.emojiButtonSize,
                  fontSize: this.props.emojiButtonSize
                },
                children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b($254755d3f438722f$export$2e2bcd8739ae039, {
                  emoji,
                  id: noSearchResults ? this.props.noResultsEmoji || "cry" : this.props.previewEmoji || (this.props.previewPosition == "top" ? "point_down" : "point_up"),
                  set: this.props.set,
                  size: this.props.emojiButtonSize,
                  skin: this.state.tempSkin || this.state.skin,
                  spritesheet: true,
                  getSpritesheetURL: this.props.getSpritesheetURL
                })
              }),
              /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                class: `margin-${this.dir[0]}`,
                children: emoji || noSearchResults ? /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                  class: `padding-${this.dir[2]} align-${this.dir[0]}`,
                  children: [
                    /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                      class: "preview-title ellipsis",
                      children: emoji ? emoji.name : $7adb23b0109cc36a$export$dbe3113d60765c1a.search_no_results_1
                    }),
                    /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                      class: "preview-subtitle ellipsis color-c",
                      children: emoji ? emoji.skins[0].shortcodes : $7adb23b0109cc36a$export$dbe3113d60765c1a.search_no_results_2
                    })
                  ]
                }) : /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                  class: "preview-placeholder color-c",
                  children: $7adb23b0109cc36a$export$dbe3113d60765c1a.pick
                })
              })
            ]
          }),
          !emoji && this.props.skinTonePosition == "preview" && this.renderSkinToneButton()
        ]
      });
    }
    renderEmojiButton(emoji, { pos, posinset, grid }) {
      const size = this.props.emojiButtonSize;
      const skin = this.state.tempSkin || this.state.skin;
      const emojiSkin = emoji.skins[skin - 1] || emoji.skins[0];
      const native = emojiSkin.native;
      const selected = $693b183b0a78708f$export$9cb4719e2e525b7a(this.state.pos, pos);
      const key2 = pos.concat(emoji.id).join("");
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b($e0d4dda61265ff1e$export$2e2bcd8739ae039, {
        selected,
        skin,
        size,
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("button", {
          "aria-label": native,
          "aria-selected": selected || void 0,
          "aria-posinset": posinset,
          "aria-setsize": grid.setsize,
          "data-keyboard": this.state.keyboard,
          title: this.props.previewPosition == "none" ? emoji.name : void 0,
          type: "button",
          class: "flex flex-center flex-middle",
          tabindex: "-1",
          onClick: (e) => this.handleEmojiClick({
            e,
            emoji
          }),
          onMouseEnter: () => this.handleEmojiOver(pos),
          onMouseLeave: () => this.handleEmojiOver(),
          style: {
            width: this.props.emojiButtonSize,
            height: this.props.emojiButtonSize,
            fontSize: this.props.emojiSize,
            lineHeight: 0
          },
          children: [
            /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
              "aria-hidden": "true",
              class: "background",
              style: {
                borderRadius: this.props.emojiButtonRadius,
                backgroundColor: this.props.emojiButtonColors ? this.props.emojiButtonColors[(posinset - 1) % this.props.emojiButtonColors.length] : void 0
              }
            }),
            /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b($254755d3f438722f$export$2e2bcd8739ae039, {
              emoji,
              set: this.props.set,
              size: this.props.emojiSize,
              skin,
              spritesheet: true,
              getSpritesheetURL: this.props.getSpritesheetURL
            })
          ]
        })
      }, key2);
    }
    renderSearch() {
      const renderSkinTone = this.props.previewPosition == "none" || this.props.skinTonePosition == "search";
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
        children: [
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
            class: "spacer"
          }),
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
            class: "flex flex-middle",
            children: [
              /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                class: "search relative flex-grow",
                children: [
                  /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("input", {
                    type: "search",
                    ref: this.refs.searchInput,
                    placeholder: $7adb23b0109cc36a$export$dbe3113d60765c1a.search,
                    onClick: this.handleSearchClick,
                    onInput: this.handleSearchInput,
                    onKeyDown: this.handleSearchKeyDown,
                    autoComplete: "off"
                  }),
                  /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("span", {
                    class: "icon loupe flex",
                    children: $fcccfb36ed0cde68$export$2e2bcd8739ae039.search.loupe
                  }),
                  this.state.searchResults && /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("button", {
                    title: "Clear",
                    "aria-label": "Clear",
                    type: "button",
                    class: "icon delete flex",
                    onClick: this.clearSearch,
                    onMouseDown: this.preventDefault,
                    children: $fcccfb36ed0cde68$export$2e2bcd8739ae039.search.delete
                  })
                ]
              }),
              renderSkinTone && this.renderSkinToneButton()
            ]
          })
        ]
      });
    }
    renderSearchResults() {
      const { searchResults } = this.state;
      if (!searchResults) return null;
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
        class: "category",
        ref: this.refs.search,
        children: [
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
            class: `sticky padding-small align-${this.dir[0]}`,
            children: $7adb23b0109cc36a$export$dbe3113d60765c1a.categories.search
          }),
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
            children: !searchResults.length ? /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
              class: `padding-small align-${this.dir[0]}`,
              children: this.props.onAddCustomEmoji && /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("a", {
                onClick: this.props.onAddCustomEmoji,
                children: $7adb23b0109cc36a$export$dbe3113d60765c1a.add_custom
              })
            }) : searchResults.map((row, i2) => {
              return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                class: "flex",
                children: row.map((emoji, ii) => {
                  return this.renderEmojiButton(emoji, {
                    pos: [
                      i2,
                      ii
                    ],
                    posinset: i2 * this.props.perLine + ii + 1,
                    grid: searchResults
                  });
                })
              });
            })
          })
        ]
      });
    }
    renderCategories() {
      const { categories } = $7adb23b0109cc36a$export$2d0294657ab35f1b;
      const hidden = !!this.state.searchResults;
      const perLine = this.getPerLine();
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
        style: {
          visibility: hidden ? "hidden" : void 0,
          display: hidden ? "none" : void 0,
          height: "100%"
        },
        children: categories.map((category) => {
          const { root, rows } = this.refs.categories.get(category.id);
          return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
            "data-id": category.target ? category.target.id : category.id,
            class: "category",
            ref: root,
            children: [
              /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                class: `sticky padding-small align-${this.dir[0]}`,
                children: category.name || $7adb23b0109cc36a$export$dbe3113d60765c1a.categories[category.id]
              }),
              /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                class: "relative",
                style: {
                  height: rows.length * this.props.emojiButtonSize
                },
                children: rows.map((row, i2) => {
                  const targetRow = row.index - row.index % $89bd6bb200cc8fef$var$Performance.rowsPerRender;
                  const visible = this.state.visibleRows[targetRow];
                  const ref = "current" in row ? row : void 0;
                  if (!visible && !ref) return null;
                  const start = i2 * perLine;
                  const end = start + perLine;
                  const emojiIds = category.emojis.slice(start, end);
                  if (emojiIds.length < perLine) emojiIds.push(...new Array(perLine - emojiIds.length));
                  return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                    "data-index": row.index,
                    ref,
                    class: "flex row",
                    style: {
                      top: i2 * this.props.emojiButtonSize
                    },
                    children: visible && emojiIds.map((emojiId, ii) => {
                      if (!emojiId) return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
                        style: {
                          width: this.props.emojiButtonSize,
                          height: this.props.emojiButtonSize
                        }
                      });
                      const emoji = $c4d155af13ad4d4b$export$2e2bcd8739ae039.get(emojiId);
                      return this.renderEmojiButton(emoji, {
                        pos: [
                          row.index,
                          ii
                        ],
                        posinset: row.posinset + ii,
                        grid: this.grid
                      });
                    })
                  }, row.index);
                })
              })
            ]
          });
        })
      });
    }
    renderSkinToneButton() {
      if (this.props.skinTonePosition == "none") return null;
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
        class: "flex flex-auto flex-center flex-middle",
        style: {
          position: "relative",
          width: this.props.emojiButtonSize,
          height: this.props.emojiButtonSize
        },
        children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("button", {
          type: "button",
          ref: this.refs.skinToneButton,
          class: "skin-tone-button flex flex-auto flex-center flex-middle",
          "aria-selected": this.state.showSkins ? "" : void 0,
          "aria-label": $7adb23b0109cc36a$export$dbe3113d60765c1a.skins.choose,
          title: $7adb23b0109cc36a$export$dbe3113d60765c1a.skins.choose,
          onClick: this.openSkins,
          style: {
            width: this.props.emojiSize,
            height: this.props.emojiSize
          },
          children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("span", {
            class: `skin-tone skin-tone-${this.state.skin}`
          })
        })
      });
    }
    renderLiveRegion() {
      const emoji = this.getEmojiByPos(this.state.pos);
      const contents = emoji ? emoji.name : "";
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
        "aria-live": "polite",
        class: "sr-only",
        children: contents
      });
    }
    renderSkins() {
      const skinToneButton = this.refs.skinToneButton.current;
      const skinToneButtonRect = skinToneButton.getBoundingClientRect();
      const baseRect = this.base.getBoundingClientRect();
      const position = {};
      if (this.dir == "ltr") position.right = baseRect.right - skinToneButtonRect.right - 3;
      else position.left = skinToneButtonRect.left - baseRect.left - 3;
      if (this.props.previewPosition == "bottom" && this.props.skinTonePosition == "preview") position.bottom = baseRect.bottom - skinToneButtonRect.top + 6;
      else {
        position.top = skinToneButtonRect.bottom - baseRect.top + 3;
        position.bottom = "auto";
      }
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
        ref: this.refs.menu,
        role: "radiogroup",
        dir: this.dir,
        "aria-label": $7adb23b0109cc36a$export$dbe3113d60765c1a.skins.choose,
        class: "menu hidden",
        "data-position": position.top ? "top" : "bottom",
        style: position,
        children: [
          ...Array(6).keys()
        ].map((i2) => {
          const skin = i2 + 1;
          const checked = this.state.skin == skin;
          return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
            children: [
              /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("input", {
                type: "radio",
                name: "skin-tone",
                value: skin,
                "aria-label": $7adb23b0109cc36a$export$dbe3113d60765c1a.skins[skin],
                ref: checked ? this.refs.skinToneRadio : null,
                defaultChecked: checked,
                onChange: () => this.handleSkinMouseOver(skin),
                onKeyDown: (e) => {
                  if (e.code == "Enter" || e.code == "Space" || e.code == "Tab") {
                    e.preventDefault();
                    this.handleSkinClick(skin);
                  }
                }
              }),
              /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("button", {
                "aria-hidden": "true",
                tabindex: "-1",
                onClick: () => this.handleSkinClick(skin),
                onMouseEnter: () => this.handleSkinMouseOver(skin),
                onMouseLeave: () => this.handleSkinMouseOver(),
                class: "option flex flex-grow flex-middle",
                children: [
                  /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("span", {
                    class: `skin-tone skin-tone-${skin}`
                  }),
                  /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("span", {
                    class: "margin-small-lr",
                    children: $7adb23b0109cc36a$export$dbe3113d60765c1a.skins[skin]
                  })
                ]
              })
            ]
          });
        })
      });
    }
    render() {
      const lineWidth = this.props.perLine * this.props.emojiButtonSize;
      return /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("section", {
        id: "root",
        class: "flex flex-column",
        dir: this.dir,
        style: {
          width: this.props.dynamicWidth ? "100%" : `calc(${lineWidth}px + (var(--padding) + var(--sidebar-width)))`
        },
        "data-emoji-set": this.props.set,
        "data-theme": this.state.theme,
        "data-menu": this.state.showSkins ? "" : void 0,
        children: [
          this.props.previewPosition == "top" && this.renderPreview(),
          this.props.navPosition == "top" && this.renderNav(),
          this.props.searchPosition == "sticky" && /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
            class: "padding-lr",
            children: this.renderSearch()
          }),
          /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
            ref: this.refs.scroll,
            class: "scroll flex-grow padding-lr",
            children: /* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b("div", {
              style: {
                width: this.props.dynamicWidth ? "100%" : lineWidth,
                height: "100%"
              },
              children: [
                this.props.searchPosition == "static" && this.renderSearch(),
                this.renderSearchResults(),
                this.renderCategories()
              ]
            })
          }),
          this.props.navPosition == "bottom" && this.renderNav(),
          this.props.previewPosition == "bottom" && this.renderPreview(),
          this.state.showSkins && this.renderSkins(),
          this.renderLiveRegion()
        ]
      });
    }
    constructor(props) {
      super();
      $c770c458706daa72$export$2e2bcd8739ae039(this, "darkMediaCallback", () => {
        if (this.props.theme != "auto") return;
        this.setState({
          theme: this.darkMedia.matches ? "dark" : "light"
        });
      });
      $c770c458706daa72$export$2e2bcd8739ae039(this, "handleClickOutside", (e) => {
        const { element } = this.props;
        if (e.target != element) {
          if (this.state.showSkins) this.closeSkins();
          if (this.props.onClickOutside) this.props.onClickOutside(e);
        }
      });
      $c770c458706daa72$export$2e2bcd8739ae039(this, "handleBaseClick", (e) => {
        if (!this.state.showSkins) return;
        if (!e.target.closest(".menu")) {
          e.preventDefault();
          e.stopImmediatePropagation();
          this.closeSkins();
        }
      });
      $c770c458706daa72$export$2e2bcd8739ae039(this, "handleBaseKeydown", (e) => {
        if (!this.state.showSkins) return;
        if (e.key == "Escape") {
          e.preventDefault();
          e.stopImmediatePropagation();
          this.closeSkins();
        }
      });
      $c770c458706daa72$export$2e2bcd8739ae039(this, "handleSearchClick", () => {
        const emoji = this.getEmojiByPos(this.state.pos);
        if (!emoji) return;
        this.setState({
          pos: [
            -1,
            -1
          ]
        });
      });
      $c770c458706daa72$export$2e2bcd8739ae039(this, "handleSearchInput", async () => {
        const input = this.refs.searchInput.current;
        if (!input) return;
        const { value } = input;
        const searchResults = await $c4d155af13ad4d4b$export$2e2bcd8739ae039.search(value);
        const afterRender = () => {
          if (!this.refs.scroll.current) return;
          this.refs.scroll.current.scrollTop = 0;
        };
        if (!searchResults) return this.setState({
          searchResults,
          pos: [
            -1,
            -1
          ]
        }, afterRender);
        const pos = input.selectionStart == input.value.length ? [
          0,
          0
        ] : [
          -1,
          -1
        ];
        const grid = [];
        grid.setsize = searchResults.length;
        let row = null;
        for (let emoji of searchResults) {
          if (!grid.length || row.length == this.getPerLine()) {
            row = [];
            row.__categoryId = "search";
            row.__index = grid.length;
            grid.push(row);
          }
          row.push(emoji);
        }
        this.ignoreMouse();
        this.setState({
          searchResults: grid,
          pos
        }, afterRender);
      });
      $c770c458706daa72$export$2e2bcd8739ae039(this, "handleSearchKeyDown", (e) => {
        const input = e.currentTarget;
        e.stopImmediatePropagation();
        switch (e.key) {
          case "ArrowLeft":
            this.navigate({
              e,
              input,
              left: true
            });
            break;
          case "ArrowRight":
            this.navigate({
              e,
              input,
              right: true
            });
            break;
          case "ArrowUp":
            this.navigate({
              e,
              input,
              up: true
            });
            break;
          case "ArrowDown":
            this.navigate({
              e,
              input,
              down: true
            });
            break;
          case "Enter":
            e.preventDefault();
            this.handleEmojiClick({
              e,
              pos: this.state.pos
            });
            break;
          case "Escape":
            e.preventDefault();
            if (this.state.searchResults) this.clearSearch();
            else this.unfocusSearch();
            break;
        }
      });
      $c770c458706daa72$export$2e2bcd8739ae039(this, "clearSearch", () => {
        const input = this.refs.searchInput.current;
        if (!input) return;
        input.value = "";
        input.focus();
        this.handleSearchInput();
      });
      $c770c458706daa72$export$2e2bcd8739ae039(this, "handleCategoryClick", ({ category, i: i2 }) => {
        this.scrollTo(i2 == 0 ? {
          row: -1
        } : {
          categoryId: category.id
        });
      });
      $c770c458706daa72$export$2e2bcd8739ae039(this, "openSkins", (e) => {
        const { currentTarget } = e;
        const rect = currentTarget.getBoundingClientRect();
        this.setState({
          showSkins: rect
        }, async () => {
          await $693b183b0a78708f$export$e772c8ff12451969(2);
          const menu = this.refs.menu.current;
          if (!menu) return;
          menu.classList.remove("hidden");
          this.refs.skinToneRadio.current.focus();
          this.base.addEventListener("click", this.handleBaseClick, true);
          this.base.addEventListener("keydown", this.handleBaseKeydown, true);
        });
      });
      this.observers = [];
      this.state = {
        pos: [
          -1,
          -1
        ],
        perLine: this.initDynamicPerLine(props),
        visibleRows: {
          0: true
        },
        ...this.getInitialState(props)
      };
    }
  }
  class $efa000751917694d$export$2e2bcd8739ae039 extends $26f27c338a96b1a6$export$2e2bcd8739ae039 {
    async connectedCallback() {
      const props = $7adb23b0109cc36a$export$75fe5f91d452f94b(this.props, $b247ea80b67298d5$export$2e2bcd8739ae039, this);
      props.element = this;
      props.ref = (component) => {
        this.component = component;
      };
      await $7adb23b0109cc36a$export$2cd8252107eb640b(props);
      if (this.disconnected) return;
      $fb96b826c0c5f37a$export$b3890eb0ae9dca99(/* @__PURE__ */ $bd9dd35321b03dd4$export$34b9dba7ce09269b($89bd6bb200cc8fef$export$2e2bcd8739ae039, {
        ...props
      }), this.shadowRoot);
    }
    constructor(props) {
      super(props, {
        styles: /* @__PURE__ */ $parcel$interopDefault($329d53ba9fd7125f$exports)
      });
    }
  }
  $c770c458706daa72$export$2e2bcd8739ae039($efa000751917694d$export$2e2bcd8739ae039, "Props", $b247ea80b67298d5$export$2e2bcd8739ae039);
  if (typeof customElements !== "undefined" && !customElements.get("em-emoji-picker")) customElements.define("em-emoji-picker", $efa000751917694d$export$2e2bcd8739ae039);
  var $329d53ba9fd7125f$exports = {};
  $329d53ba9fd7125f$exports = ':host {\n  width: min-content;\n  height: 435px;\n  min-height: 230px;\n  border-radius: var(--border-radius);\n  box-shadow: var(--shadow);\n  --border-radius: 10px;\n  --category-icon-size: 18px;\n  --font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", sans-serif;\n  --font-size: 15px;\n  --preview-placeholder-size: 21px;\n  --preview-title-size: 1.1em;\n  --preview-subtitle-size: .9em;\n  --shadow-color: 0deg 0% 0%;\n  --shadow: .3px .5px 2.7px hsl(var(--shadow-color) / .14), .4px .8px 1px -3.2px hsl(var(--shadow-color) / .14), 1px 2px 2.5px -4.5px hsl(var(--shadow-color) / .14);\n  display: flex;\n}\n\n[data-theme="light"] {\n  --em-rgb-color: var(--rgb-color, 34, 36, 39);\n  --em-rgb-accent: var(--rgb-accent, 34, 102, 237);\n  --em-rgb-background: var(--rgb-background, 255, 255, 255);\n  --em-rgb-input: var(--rgb-input, 255, 255, 255);\n  --em-color-border: var(--color-border, rgba(0, 0, 0, .05));\n  --em-color-border-over: var(--color-border-over, rgba(0, 0, 0, .1));\n}\n\n[data-theme="dark"] {\n  --em-rgb-color: var(--rgb-color, 222, 222, 221);\n  --em-rgb-accent: var(--rgb-accent, 58, 130, 247);\n  --em-rgb-background: var(--rgb-background, 21, 22, 23);\n  --em-rgb-input: var(--rgb-input, 0, 0, 0);\n  --em-color-border: var(--color-border, rgba(255, 255, 255, .1));\n  --em-color-border-over: var(--color-border-over, rgba(255, 255, 255, .2));\n}\n\n#root {\n  --color-a: rgb(var(--em-rgb-color));\n  --color-b: rgba(var(--em-rgb-color), .65);\n  --color-c: rgba(var(--em-rgb-color), .45);\n  --padding: 12px;\n  --padding-small: calc(var(--padding) / 2);\n  --sidebar-width: 16px;\n  --duration: 225ms;\n  --duration-fast: 125ms;\n  --duration-instant: 50ms;\n  --easing: cubic-bezier(.4, 0, .2, 1);\n  width: 100%;\n  text-align: left;\n  border-radius: var(--border-radius);\n  background-color: rgb(var(--em-rgb-background));\n  position: relative;\n}\n\n@media (prefers-reduced-motion) {\n  #root {\n    --duration: 0;\n    --duration-fast: 0;\n    --duration-instant: 0;\n  }\n}\n\n#root[data-menu] button {\n  cursor: auto;\n}\n\n#root[data-menu] .menu button {\n  cursor: pointer;\n}\n\n:host, #root, input, button {\n  color: rgb(var(--em-rgb-color));\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  line-height: normal;\n}\n\n*, :before, :after {\n  box-sizing: border-box;\n  min-width: 0;\n  margin: 0;\n  padding: 0;\n}\n\n.relative {\n  position: relative;\n}\n\n.flex {\n  display: flex;\n}\n\n.flex-auto {\n  flex: none;\n}\n\n.flex-center {\n  justify-content: center;\n}\n\n.flex-column {\n  flex-direction: column;\n}\n\n.flex-grow {\n  flex: auto;\n}\n\n.flex-middle {\n  align-items: center;\n}\n\n.flex-wrap {\n  flex-wrap: wrap;\n}\n\n.padding {\n  padding: var(--padding);\n}\n\n.padding-t {\n  padding-top: var(--padding);\n}\n\n.padding-lr {\n  padding-left: var(--padding);\n  padding-right: var(--padding);\n}\n\n.padding-r {\n  padding-right: var(--padding);\n}\n\n.padding-small {\n  padding: var(--padding-small);\n}\n\n.padding-small-b {\n  padding-bottom: var(--padding-small);\n}\n\n.padding-small-lr {\n  padding-left: var(--padding-small);\n  padding-right: var(--padding-small);\n}\n\n.margin {\n  margin: var(--padding);\n}\n\n.margin-r {\n  margin-right: var(--padding);\n}\n\n.margin-l {\n  margin-left: var(--padding);\n}\n\n.margin-small-l {\n  margin-left: var(--padding-small);\n}\n\n.margin-small-lr {\n  margin-left: var(--padding-small);\n  margin-right: var(--padding-small);\n}\n\n.align-l {\n  text-align: left;\n}\n\n.align-r {\n  text-align: right;\n}\n\n.color-a {\n  color: var(--color-a);\n}\n\n.color-b {\n  color: var(--color-b);\n}\n\n.color-c {\n  color: var(--color-c);\n}\n\n.ellipsis {\n  white-space: nowrap;\n  max-width: 100%;\n  width: auto;\n  text-overflow: ellipsis;\n  overflow: hidden;\n}\n\n.sr-only {\n  width: 1px;\n  height: 1px;\n  position: absolute;\n  top: auto;\n  left: -10000px;\n  overflow: hidden;\n}\n\na {\n  cursor: pointer;\n  color: rgb(var(--em-rgb-accent));\n}\n\na:hover {\n  text-decoration: underline;\n}\n\n.spacer {\n  height: 10px;\n}\n\n[dir="rtl"] .scroll {\n  padding-left: 0;\n  padding-right: var(--padding);\n}\n\n.scroll {\n  padding-right: 0;\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n\n.scroll::-webkit-scrollbar {\n  width: var(--sidebar-width);\n  height: var(--sidebar-width);\n}\n\n.scroll::-webkit-scrollbar-track {\n  border: 0;\n}\n\n.scroll::-webkit-scrollbar-button {\n  width: 0;\n  height: 0;\n  display: none;\n}\n\n.scroll::-webkit-scrollbar-corner {\n  background-color: rgba(0, 0, 0, 0);\n}\n\n.scroll::-webkit-scrollbar-thumb {\n  min-height: 20%;\n  min-height: 65px;\n  border: 4px solid rgb(var(--em-rgb-background));\n  border-radius: 8px;\n}\n\n.scroll::-webkit-scrollbar-thumb:hover {\n  background-color: var(--em-color-border-over) !important;\n}\n\n.scroll:hover::-webkit-scrollbar-thumb {\n  background-color: var(--em-color-border);\n}\n\n.sticky {\n  z-index: 1;\n  background-color: rgba(var(--em-rgb-background), .9);\n  -webkit-backdrop-filter: blur(4px);\n  backdrop-filter: blur(4px);\n  font-weight: 500;\n  position: sticky;\n  top: -1px;\n}\n\n[dir="rtl"] .search input[type="search"] {\n  padding: 10px 2.2em 10px 2em;\n}\n\n[dir="rtl"] .search .loupe {\n  left: auto;\n  right: .7em;\n}\n\n[dir="rtl"] .search .delete {\n  left: .7em;\n  right: auto;\n}\n\n.search {\n  z-index: 2;\n  position: relative;\n}\n\n.search input, .search button {\n  font-size: calc(var(--font-size)  - 1px);\n}\n\n.search input[type="search"] {\n  width: 100%;\n  background-color: var(--em-color-border);\n  transition-duration: var(--duration);\n  transition-property: background-color, box-shadow;\n  transition-timing-function: var(--easing);\n  border: 0;\n  border-radius: 10px;\n  outline: 0;\n  padding: 10px 2em 10px 2.2em;\n  display: block;\n}\n\n.search input[type="search"]::-ms-input-placeholder {\n  color: inherit;\n  opacity: .6;\n}\n\n.search input[type="search"]::placeholder {\n  color: inherit;\n  opacity: .6;\n}\n\n.search input[type="search"], .search input[type="search"]::-webkit-search-decoration, .search input[type="search"]::-webkit-search-cancel-button, .search input[type="search"]::-webkit-search-results-button, .search input[type="search"]::-webkit-search-results-decoration {\n  -webkit-appearance: none;\n  -ms-appearance: none;\n  appearance: none;\n}\n\n.search input[type="search"]:focus {\n  background-color: rgb(var(--em-rgb-input));\n  box-shadow: inset 0 0 0 1px rgb(var(--em-rgb-accent)), 0 1px 3px rgba(65, 69, 73, .2);\n}\n\n.search .icon {\n  z-index: 1;\n  color: rgba(var(--em-rgb-color), .7);\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n}\n\n.search .loupe {\n  pointer-events: none;\n  left: .7em;\n}\n\n.search .delete {\n  right: .7em;\n}\n\nsvg {\n  fill: currentColor;\n  width: 1em;\n  height: 1em;\n}\n\nbutton {\n  -webkit-appearance: none;\n  -ms-appearance: none;\n  appearance: none;\n  cursor: pointer;\n  color: currentColor;\n  background-color: rgba(0, 0, 0, 0);\n  border: 0;\n}\n\n#nav {\n  z-index: 2;\n  padding-top: 12px;\n  padding-bottom: 12px;\n  padding-right: var(--sidebar-width);\n  position: relative;\n}\n\n#nav button {\n  color: var(--color-b);\n  transition: color var(--duration) var(--easing);\n}\n\n#nav button:hover {\n  color: var(--color-a);\n}\n\n#nav svg, #nav img {\n  width: var(--category-icon-size);\n  height: var(--category-icon-size);\n}\n\n#nav[dir="rtl"] .bar {\n  left: auto;\n  right: 0;\n}\n\n#nav .bar {\n  width: 100%;\n  height: 3px;\n  background-color: rgb(var(--em-rgb-accent));\n  transition: transform var(--duration) var(--easing);\n  border-radius: 3px 3px 0 0;\n  position: absolute;\n  bottom: -12px;\n  left: 0;\n}\n\n#nav button[aria-selected] {\n  color: rgb(var(--em-rgb-accent));\n}\n\n#preview {\n  z-index: 2;\n  padding: calc(var(--padding)  + 4px) var(--padding);\n  padding-right: var(--sidebar-width);\n  position: relative;\n}\n\n#preview .preview-placeholder {\n  font-size: var(--preview-placeholder-size);\n}\n\n#preview .preview-title {\n  font-size: var(--preview-title-size);\n}\n\n#preview .preview-subtitle {\n  font-size: var(--preview-subtitle-size);\n}\n\n#nav:before, #preview:before {\n  content: "";\n  height: 2px;\n  position: absolute;\n  left: 0;\n  right: 0;\n}\n\n#nav[data-position="top"]:before, #preview[data-position="top"]:before {\n  background: linear-gradient(to bottom, var(--em-color-border), transparent);\n  top: 100%;\n}\n\n#nav[data-position="bottom"]:before, #preview[data-position="bottom"]:before {\n  background: linear-gradient(to top, var(--em-color-border), transparent);\n  bottom: 100%;\n}\n\n.category:last-child {\n  min-height: calc(100% + 1px);\n}\n\n.category button {\n  font-family: -apple-system, BlinkMacSystemFont, Helvetica Neue, sans-serif;\n  position: relative;\n}\n\n.category button > * {\n  position: relative;\n}\n\n.category button .background {\n  opacity: 0;\n  background-color: var(--em-color-border);\n  transition: opacity var(--duration-fast) var(--easing) var(--duration-instant);\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n\n.category button:hover .background {\n  transition-duration: var(--duration-instant);\n  transition-delay: 0s;\n}\n\n.category button[aria-selected] .background {\n  opacity: 1;\n}\n\n.category button[data-keyboard] .background {\n  transition: none;\n}\n\n.row {\n  width: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n\n.skin-tone-button {\n  border: 1px solid rgba(0, 0, 0, 0);\n  border-radius: 100%;\n}\n\n.skin-tone-button:hover {\n  border-color: var(--em-color-border);\n}\n\n.skin-tone-button:active .skin-tone {\n  transform: scale(.85) !important;\n}\n\n.skin-tone-button .skin-tone {\n  transition: transform var(--duration) var(--easing);\n}\n\n.skin-tone-button[aria-selected] {\n  background-color: var(--em-color-border);\n  border-top-color: rgba(0, 0, 0, .05);\n  border-bottom-color: rgba(0, 0, 0, 0);\n  border-left-width: 0;\n  border-right-width: 0;\n}\n\n.skin-tone-button[aria-selected] .skin-tone {\n  transform: scale(.9);\n}\n\n.menu {\n  z-index: 2;\n  white-space: nowrap;\n  border: 1px solid var(--em-color-border);\n  background-color: rgba(var(--em-rgb-background), .9);\n  -webkit-backdrop-filter: blur(4px);\n  backdrop-filter: blur(4px);\n  transition-property: opacity, transform;\n  transition-duration: var(--duration);\n  transition-timing-function: var(--easing);\n  border-radius: 10px;\n  padding: 4px;\n  position: absolute;\n  box-shadow: 1px 1px 5px rgba(0, 0, 0, .05);\n}\n\n.menu.hidden {\n  opacity: 0;\n}\n\n.menu[data-position="bottom"] {\n  transform-origin: 100% 100%;\n}\n\n.menu[data-position="bottom"].hidden {\n  transform: scale(.9)rotate(-3deg)translateY(5%);\n}\n\n.menu[data-position="top"] {\n  transform-origin: 100% 0;\n}\n\n.menu[data-position="top"].hidden {\n  transform: scale(.9)rotate(3deg)translateY(-5%);\n}\n\n.menu input[type="radio"] {\n  clip: rect(0 0 0 0);\n  width: 1px;\n  height: 1px;\n  border: 0;\n  margin: 0;\n  padding: 0;\n  position: absolute;\n  overflow: hidden;\n}\n\n.menu input[type="radio"]:checked + .option {\n  box-shadow: 0 0 0 2px rgb(var(--em-rgb-accent));\n}\n\n.option {\n  width: 100%;\n  border-radius: 6px;\n  padding: 4px 6px;\n}\n\n.option:hover {\n  color: #fff;\n  background-color: rgb(var(--em-rgb-accent));\n}\n\n.skin-tone {\n  width: 16px;\n  height: 16px;\n  border-radius: 100%;\n  display: inline-block;\n  position: relative;\n  overflow: hidden;\n}\n\n.skin-tone:after {\n  content: "";\n  mix-blend-mode: overlay;\n  background: linear-gradient(rgba(255, 255, 255, .2), rgba(0, 0, 0, 0));\n  border: 1px solid rgba(0, 0, 0, .8);\n  border-radius: 100%;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  box-shadow: inset 0 -2px 3px #000, inset 0 1px 2px #fff;\n}\n\n.skin-tone-1 {\n  background-color: #ffc93a;\n}\n\n.skin-tone-2 {\n  background-color: #ffdab7;\n}\n\n.skin-tone-3 {\n  background-color: #e7b98f;\n}\n\n.skin-tone-4 {\n  background-color: #c88c61;\n}\n\n.skin-tone-5 {\n  background-color: #a46134;\n}\n\n.skin-tone-6 {\n  background-color: #5d4437;\n}\n\n[data-index] {\n  justify-content: space-between;\n}\n\n[data-emoji-set="twitter"] .skin-tone:after {\n  box-shadow: none;\n  border-color: rgba(0, 0, 0, .5);\n}\n\n[data-emoji-set="twitter"] .skin-tone-1 {\n  background-color: #fade72;\n}\n\n[data-emoji-set="twitter"] .skin-tone-2 {\n  background-color: #f3dfd0;\n}\n\n[data-emoji-set="twitter"] .skin-tone-3 {\n  background-color: #eed3a8;\n}\n\n[data-emoji-set="twitter"] .skin-tone-4 {\n  background-color: #cfad8d;\n}\n\n[data-emoji-set="twitter"] .skin-tone-5 {\n  background-color: #a8805d;\n}\n\n[data-emoji-set="twitter"] .skin-tone-6 {\n  background-color: #765542;\n}\n\n[data-emoji-set="google"] .skin-tone:after {\n  box-shadow: inset 0 0 2px 2px rgba(0, 0, 0, .4);\n}\n\n[data-emoji-set="google"] .skin-tone-1 {\n  background-color: #f5c748;\n}\n\n[data-emoji-set="google"] .skin-tone-2 {\n  background-color: #f1d5aa;\n}\n\n[data-emoji-set="google"] .skin-tone-3 {\n  background-color: #d4b48d;\n}\n\n[data-emoji-set="google"] .skin-tone-4 {\n  background-color: #aa876b;\n}\n\n[data-emoji-set="google"] .skin-tone-5 {\n  background-color: #916544;\n}\n\n[data-emoji-set="google"] .skin-tone-6 {\n  background-color: #61493f;\n}\n\n[data-emoji-set="facebook"] .skin-tone:after {\n  border-color: rgba(0, 0, 0, .4);\n  box-shadow: inset 0 -2px 3px #000, inset 0 1px 4px #fff;\n}\n\n[data-emoji-set="facebook"] .skin-tone-1 {\n  background-color: #f5c748;\n}\n\n[data-emoji-set="facebook"] .skin-tone-2 {\n  background-color: #f1d5aa;\n}\n\n[data-emoji-set="facebook"] .skin-tone-3 {\n  background-color: #d4b48d;\n}\n\n[data-emoji-set="facebook"] .skin-tone-4 {\n  background-color: #aa876b;\n}\n\n[data-emoji-set="facebook"] .skin-tone-5 {\n  background-color: #916544;\n}\n\n[data-emoji-set="facebook"] .skin-tone-6 {\n  background-color: #61493f;\n}\n\n';
  const EmojiIcon = ({
    width = "15px",
    height = "15px",
    color = "#e8eaed",
    ...props
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width,
        height,
        fill: color,
        ...props,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M620-520q25 0 42.5-17.5T680-580q0-25-17.5-42.5T620-640q-25 0-42.5 17.5T560-580q0 25 17.5 42.5T620-520Zm-280 0q25 0 42.5-17.5T400-580q0-25-17.5-42.5T340-640q-25 0-42.5 17.5T280-580q0 25 17.5 42.5T340-520Zm140 260q68 0 123.5-38.5T684-400H276q25 63 80.5 101.5T480-260Zm0 180q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-400Zm0 320q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Z" })
      }
    );
  };
  const Emoji = ({ applyEmoji }) => {
    const pickerContainerRef = reactExports.useRef(null);
    reactExports.useEffect(() => {
      const pickerOptions = {
        onEmojiSelect: (emoji) => {
          applyEmoji(emoji.native);
        },
        theme: "light",
        previewPosition: "none",
        perLine: 7,
        emojiSize: 18
      };
      const picker = new $efa000751917694d$export$2e2bcd8739ae039(pickerOptions);
      pickerContainerRef.current.appendChild(picker);
      return () => {
        if (pickerContainerRef.current) {
          pickerContainerRef.current.innerHTML = "";
        }
      };
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: pickerContainerRef });
  };
  const insertEmoji = (emoji) => (state, dispatch) => {
    var _a2;
    const { from, to } = state.selection;
    const tr = (_a2 = state == null ? void 0 : state.tr) == null ? void 0 : _a2.replaceWith(
      from,
      to,
      state.schema.text(emoji)
    );
    if (dispatch) dispatch(tr);
    return true;
  };
  const PopupInsertEmojiMenu = ({ editorView, href, title }) => {
    const [isOpen, setIsOpen] = reactExports.useState(false);
    const dropdownButtonRef = reactExports.useRef(null);
    const dropdownMenuRef = reactExports.useRef(null);
    const handleClickOutside = (event) => {
      if (dropdownMenuRef.current && !dropdownMenuRef.current.contains(event.target) && dropdownButtonRef.current && !dropdownButtonRef.current.contains(event.target)) {
        setIsOpen(false);
      }
    };
    reactExports.useEffect(() => {
      if (isOpen) {
        document.addEventListener("mousedown", handleClickOutside);
      } else {
        document.removeEventListener("mousedown", handleClickOutside);
      }
      return () => {
        document.removeEventListener("mousedown", handleClickOutside);
      };
    }, [isOpen]);
    const toggleMenu = () => {
      setIsOpen((prevState) => !prevState);
    };
    const applyEmoji = (emoji) => {
      insertEmoji(emoji)(editorView.state, editorView.dispatch);
      setIsOpen(false);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative inline-block", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "ProseMirror-icon note-menuitem",
          title: "Insert Link",
          ref: dropdownButtonRef,
          onClick: toggleMenu,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(EmojiIcon, {})
        }
      ),
      isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          ref: dropdownMenuRef,
          className: "emoji-picker-wrapper absolute md:left-[180px] max-sm:-right-[190px] transform -translate-x-1/2 top-full mt-2 bg-white shadow-lg rounded-sm z-10",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Emoji, { applyEmoji })
        }
      )
    ] });
  };
  const renderReactEmojiComponent = (editorView) => {
    const container = document.createElement("div");
    const root = clientExports.createRoot(container);
    root.render(/* @__PURE__ */ jsxRuntimeExports.jsx(PopupInsertEmojiMenu, { editorView }));
    return container;
  };
  const proseMirrorMenuEmoji = new MenuItem({
    title: `Insert emoji`,
    run: (state, dispatch, view) => {
    },
    select: (state) => {
      return true;
    },
    render: (editorView) => renderReactEmojiComponent(editorView)
  });
  const textFonts = [
    {
      label: "Sans Serif",
      key: "sans-serif"
    },
    {
      label: "Serif",
      key: "serif"
    },
    {
      label: "Monospace",
      key: "monospace"
    },
    {
      label: "Georgia",
      key: "Georgia"
    },
    {
      label: "Tahoma",
      key: "Tahoma"
    },
    {
      label: "Trebuchet MS",
      key: "Trebuchet MS"
    },
    {
      label: "Verdana",
      key: "Verdana"
    }
  ];
  const getFontFamilyFromSelection = (state) => {
    var _a2;
    const { from, to, empty: empty2 } = state.selection;
    const markType = state.schema.marks.fontFamily;
    let fontFamily = null;
    if (!markType) return null;
    if (empty2) {
      const storedMark = (_a2 = state.storedMarks) == null ? void 0 : _a2.find((m) => m.type === markType);
      if (storedMark) {
        return storedMark.attrs.font;
      }
      const marksAtCursor = state.selection.$from.marks();
      const mark = marksAtCursor.find((m) => m.type === markType);
      if (mark) {
        return mark.attrs.font;
      }
    }
    state.doc.nodesBetween(from, to, (node) => {
      if (node.marks && node.marks.length) {
        const mark = node.marks.find((m) => m.type === markType);
        if (mark) {
          fontFamily = mark.attrs.font;
          return false;
        }
      }
    });
    return fontFamily;
  };
  const fontSelectionPluginKey = new PluginKey("fontSelection");
  const fontSelectionPlugin = new Plugin({
    key: fontSelectionPluginKey,
    state: {
      init(_config, state) {
        return getFontFamilyFromSelection(state) || null;
      },
      apply(tr, value, oldState, newState) {
        if (tr.docChanged || tr.selectionSet) {
          return getFontFamilyFromSelection(newState) || null;
        }
        return value;
      }
    }
  });
  let defaultEditorFont = null;
  const DropdownFontMenu = ({ editorView, activeFont2 }) => {
    const [open, setOpen] = React.useState(false);
    const [font, setFont] = reactExports.useState(textFonts[0]);
    const applyFontFamily = (font2) => {
      return (state, dispatch) => {
        const { schema: schema2, selection } = state;
        const { from, to } = selection;
        const markType = schema2.marks.fontFamily;
        if (!markType) return false;
        const attrs = { font: font2 };
        const tr = state.tr;
        if (selection.empty) {
          tr.addStoredMark(markType.create(attrs));
        } else {
          tr.addMark(from, to, markType.create(attrs));
        }
        if (dispatch) dispatch(tr);
        setOpen(false);
        return true;
      };
    };
    reactExports.useEffect(() => {
      if (defaultEditorFont) setFont(defaultEditorFont);
    }, [defaultEditorFont]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative inline-block", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ProseMirrorMenuPopup, { open, setOpen, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ProseMirrorMenuButton,
        {
          id: "defaultEditorFont",
          title: "Font Family",
          isActive: defaultEditorFont,
          variant: "outline",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `block !text-[12px]  min-w-[85px] font-[${defaultEditorFont ? defaultEditorFont == null ? void 0 : defaultEditorFont.key : font.key}]`, children: defaultEditorFont ? defaultEditorFont == null ? void 0 : defaultEditorFont.label : font.label })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ProseMirrorMenuOption, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "space-y-2 note-dd-Select-menu list-none min-w-[105px] list-inside dark:text-gray-400", children: textFonts.map((textFont) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "li",
        {
          className: `cursor-pointer min-w-[100px] !text-[12px] font-[${textFont.key}] note-dd-Select-menu-options hover:bg-[#e5f5f8] dark:text-[#666666] py-1 ${(defaultEditorFont == null ? void 0 : defaultEditorFont.key) === textFont.key ? "bg-gray-100" : "bg-none"}`,
          onClick: () => {
            setFont(textFont);
            defaultEditorFont = textFont;
            applyFontFamily(textFont.key)(
              editorView.state,
              editorView.dispatch
            );
          },
          children: textFont.label
        },
        textFont.key
      )) }) })
    ] }) });
  };
  const renderReactFontComponent = (editorView) => {
    const container = document.createElement("div");
    const root = clientExports.createRoot(container);
    root.render(/* @__PURE__ */ jsxRuntimeExports.jsx(DropdownFontMenu, { editorView }));
    return container;
  };
  const fontMenuItem = new MenuItem({
    title: `Fonts`,
    // run: (state, dispatch, editorView) => {
    //   const newFont = fontSelectionPluginKey.getState(state); // Example selected font
    //   const tr = state.tr;
    //   console.log("newFont", newFont);
    //   // Set the font selection in the plugin state
    //   tr.setMeta(fontSelectionPluginKey, newFont);
    //   // Dispatch the transaction to update the plugin state
    //   dispatch(tr);
    //   // Update the editor state so the plugin state is re-read and the component can re-render
    //   editorView.updateState(state); // This will trigger a re-render in ProseMirror and React
    // },
    run: () => {
    },
    select: (state) => {
      var _a2, _b2, _c2;
      const activeFont = fontSelectionPluginKey.getState(state) || true;
      const selectedEditorFont = getFontFamilyFromSelection(state);
      const font = textFonts.find((font2) => font2.key === (selectedEditorFont == null ? void 0 : selectedEditorFont.replace(/^"(.*)"$/, "$1")));
      defaultEditorFont = font;
      const div = document.getElementById("defaultEditorFont-icon");
      (_a2 = document.getElementById("defaultEditorFont-icon")) == null ? void 0 : _a2.classList.add(...`!text-[12px] min-w-[85px] font-[${defaultEditorFont ? defaultEditorFont == null ? void 0 : defaultEditorFont.key : ""}]`.split(" "));
      if (div && selectedEditorFont && font) {
        div.textContent = font.label;
        (_b2 = document.getElementById("defaultEditorFont")) == null ? void 0 : _b2.classList.add("note-active-state");
      }
      if (div && !selectedEditorFont) {
        div.textContent = "Sans Serif";
        (_c2 = document.getElementById("defaultEditorFont")) == null ? void 0 : _c2.classList.remove("note-active-state");
      }
      return activeFont !== null;
    },
    render: (editorView) => renderReactFontComponent(editorView)
    // active: (state) => {
    //   const selectedFont = fontSelectionPluginKey.getState(state);
    //   return selectedFont ? true : false;
    // },
  });
  const textFontSizes = [
    {
      label: "8",
      value: "8pt"
    },
    {
      label: "10",
      value: "10pt"
    },
    {
      label: "12",
      value: "12pt"
    },
    {
      label: "14",
      value: "14pt"
    },
    {
      label: "16",
      value: "16pt"
    },
    {
      label: "18",
      value: "18pt"
    },
    {
      label: "20",
      value: "20pt"
    },
    {
      label: "22",
      value: "22pt"
    },
    {
      label: "24",
      value: "24pt"
    },
    {
      label: "26",
      value: "26pt"
    }
  ];
  const getFontSizeFromSelection = (state) => {
    var _a2;
    const { from, to, empty: empty2 } = state.selection;
    const markType = state.schema.marks.fontSize;
    let fontSize = null;
    if (!markType) return null;
    if (empty2) {
      const storedMark = (_a2 = state.storedMarks) == null ? void 0 : _a2.find((m) => m.type === markType);
      if (storedMark) {
        return storedMark.attrs.fontSize;
      }
      const marksAtCursor = state.selection.$from.marks();
      const mark = marksAtCursor.find((m) => m.type === markType);
      if (mark) {
        return mark.attrs.fontSize;
      }
    }
    state.doc.nodesBetween(from, to, (node) => {
      if (node.marks && node.marks.length) {
        const mark = node.marks.find((m) => m.type === markType);
        if (mark) {
          fontSize = mark.attrs.fontSize;
          return false;
        }
      }
    });
    return fontSize;
  };
  const fontSizeSelectionPluginKey = new PluginKey(
    "fontSizeSelection"
  );
  const fontSizeSelectionPlugin = new Plugin({
    key: fontSizeSelectionPluginKey,
    state: {
      init(_config, state) {
        return getFontSizeFromSelection(state) || null;
      },
      apply(tr, value, oldState, newState) {
        if (tr.docChanged || tr.selectionSet) {
          return getFontSizeFromSelection(newState) || null;
        }
        return value;
      }
    }
  });
  let defaultEditorFontSize = null;
  const DropdownFontSizeMenu = ({ editorView, activeFont2 }) => {
    const [open, setOpen] = React.useState(false);
    const [font, setFont] = reactExports.useState(textFontSizes[0]);
    const applyFontSize = (fontSize) => {
      return (state, dispatch) => {
        const { schema: schema2, selection } = state;
        const { from, to } = selection;
        const markType = schema2.marks.fontSize;
        if (!markType) return false;
        const attrs = { fontSize };
        const tr = state.tr;
        if (selection.empty) {
          tr.addStoredMark(markType.create(attrs));
        } else {
          tr.addMark(from, to, markType.create(attrs));
        }
        if (dispatch) dispatch(tr);
        setOpen(false);
        return true;
      };
    };
    reactExports.useEffect(() => {
      if (defaultEditorFontSize) setFont(defaultEditorFontSize);
    }, [defaultEditorFontSize]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative inline-block", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ProseMirrorMenuPopup, { open, setOpen, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ProseMirrorMenuButton,
        {
          id: "defaultEditorFontSize",
          title: "Font Size",
          isActive: defaultEditorFontSize,
          variant: "outline",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "block text-[12px] min-w-[16px]", children: defaultEditorFontSize ? defaultEditorFontSize == null ? void 0 : defaultEditorFontSize.label : font.label })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ProseMirrorMenuOption, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "space-y-2 note-dd-Select-menu text-gray-500 list-none list-inside dark:text-gray-400", children: textFontSizes.map((textFont) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "li",
        {
          className: `cursor-pointer note-dd-Select-menu-options !text-[12px] min-w-[30px] hover:bg-[#e5f5f8] dark:text-[#666666] py-1 ${(defaultEditorFontSize == null ? void 0 : defaultEditorFontSize.value) === textFont.value ? "bg-gray-100" : ""}`,
          onClick: () => {
            setFont(textFont);
            defaultEditorFontSize = textFont;
            applyFontSize(textFont.value)(
              editorView.state,
              editorView.dispatch
            );
          },
          children: textFont.label
        },
        textFont.value
      )) }) })
    ] }) });
  };
  const renderReactFontSizeComponent = (editorView) => {
    const container = document.createElement("div");
    const root = clientExports.createRoot(container);
    root.render(/* @__PURE__ */ jsxRuntimeExports.jsx(DropdownFontSizeMenu, { editorView }));
    return container;
  };
  const fontSizeMenuItem = new MenuItem({
    title: `Font Size`,
    // run: (state, dispatch, editorView) => {
    //   const newFont = fontSizeSelectionPluginKey.getState(state); // Example selected font
    //   const tr = state.tr;
    //   console.log("newFont", newFont);
    //   // Set the font selection in the plugin state
    //   tr.setMeta(fontSizeSelectionPluginKey, newFont);
    //   // Dispatch the transaction to update the plugin state
    //   dispatch(tr);
    //   // Update the editor state so the plugin state is re-read and the component can re-render
    //   editorView.updateState(state); // This will trigger a re-render in ProseMirror and React
    // },
    run: () => {
    },
    select: (state) => {
      var _a2, _b2, _c2;
      const activeFont = fontSizeSelectionPluginKey.getState(state) || true;
      const selectedEditorFontSize = getFontSizeFromSelection(state);
      const fontSize = textFontSizes.find(
        (font) => font.value === selectedEditorFontSize
      );
      defaultEditorFontSize = fontSize;
      const div = document.getElementById("defaultEditorFontSize-icon");
      (_a2 = document.getElementById("defaultEditorFontSize-icon")) == null ? void 0 : _a2.classList.add(..."!text-[12px] min-w-[16px]".split(" "));
      if (div && selectedEditorFontSize) {
        div.textContent = fontSize == null ? void 0 : fontSize.label;
        (_b2 = document.getElementById("defaultEditorFontSize")) == null ? void 0 : _b2.classList.add("note-active-state");
      }
      if (div && !selectedEditorFontSize) {
        div.textContent = "8";
        (_c2 = document.getElementById("defaultEditorFontSize")) == null ? void 0 : _c2.classList.remove("note-active-state");
      }
      return activeFont !== null;
    },
    render: (editorView) => renderReactFontSizeComponent(editorView)
    // active: (state) => {
    //   const selectedFontSize = fontSizeSelectionPluginKey.getState(state);
    //   return selectedFontSize ? true : false;
    // },
  });
  const ImageIcon = ({
    width = "15px",
    height = "15px",
    color = "#e8eaed",
    ...props
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width,
        height,
        fill: color,
        ...props,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M360-400h400L622-580l-92 120-62-80-108 140Zm-40 160q-33 0-56.5-23.5T240-320v-480q0-33 23.5-56.5T320-880h480q33 0 56.5 23.5T880-800v480q0 33-23.5 56.5T800-240H320Zm0-80h480v-480H320v480ZM160-80q-33 0-56.5-23.5T80-160v-560h80v560h560v80H160Zm160-720v480-480Z" })
      }
    );
  };
  const insertImage = (view, src, width, height) => {
    const { state, dispatch } = view;
    const { schema: schema2 } = state;
    const { selection } = state;
    const position = selection.$cursor ? selection.$cursor.pos : selection.from;
    const imageNode = schema2.nodes.image.create({
      src,
      width,
      height,
      class: `w-${width} h-${height}`
    });
    const newParagraphNode = schema2.nodes.paragraph.create({}, "");
    const transaction = state.tr.insert(position, imageNode).insert(position + imageNode.nodeSize + 1, newParagraphNode);
    dispatch(transaction);
  };
  const EditorImageUploadMenu = ({
    editorView,
    imageUploadUrl,
    setIsLoadingUploading,
    setUploadProgress
  }) => {
    const token = getAuthToken();
    const boldButtonRef = reactExports.useRef(null);
    const fileInputRef = reactExports.useRef(null);
    const uploadImage = () => {
      var _a2;
      (_a2 = fileInputRef.current) == null ? void 0 : _a2.click();
    };
    const handleFileChange = async (event) => {
      const file = event.target.files[0];
      if (!file) {
        event.target.value = "";
        return;
      }
      const formData = new FormData();
      formData.append("file", file);
      const image = new Image();
      image.src = URL.createObjectURL(file);
      image.onload = async () => {
        const maxWidth = 1e3;
        const maxHeight = 1e3;
        let width = image.width;
        let height = image.height;
        if (width > maxWidth || height > maxHeight) {
          const aspectRatio = width / height;
          if (width > height) {
            width = maxWidth;
            height = Math.round(maxWidth / aspectRatio);
          } else {
            height = maxHeight;
            width = Math.round(maxHeight * aspectRatio);
          }
        }
        await uploadImageToAPI(editorView, formData, width, height);
      };
    };
    const uploadImageToAPI = async (pmView, formData, width, height) => {
      setIsLoadingUploading(true);
      try {
        const response = await axios({
          method: "POST",
          url: imageUploadUrl,
          data: formData,
          headers: {
            "Content-Type": "multipart/form-data",
            Authorization: `Bearer ${token}`
          },
          onUploadProgress: (progressEvent) => {
            const percentCompleted = Math.round(
              progressEvent.loaded * 100 / progressEvent.total
            );
            setUploadProgress(percentCompleted);
          }
        });
        const imageUrl = response.data.data.url;
        const imageName = response.data.data.name;
        insertImage(pmView, imageUrl, width, height);
        setUploadProgress(0);
        setIsLoadingUploading(false);
      } catch (error) {
        setIsLoadingUploading(false);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "ProseMirror-icon note-menuitem",
          title: "Insert image",
          ref: boldButtonRef,
          onClick: uploadImage,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ImageIcon, {})
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "file",
          ref: fileInputRef,
          accept: "image/*",
          className: "hidden",
          onChange: handleFileChange
        }
      )
    ] });
  };
  const renderReactImageUploadComponent = (editorView, imageUploadUrl, setIsLoadingUploading, setUploadProgress) => {
    const container = document.createElement("div");
    const root = clientExports.createRoot(container);
    root.render(
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        EditorImageUploadMenu,
        {
          editorView,
          imageUploadUrl,
          setIsLoadingUploading,
          setUploadProgress
        }
      )
    );
    return container;
  };
  const customMenuItemImage = (imageUploadUrl, setIsLoadingUploading, setUploadProgress) => new MenuItem({
    title: `Insert image`,
    run: () => {
    },
    select: (state) => {
      return true;
    },
    render: (editorView) => renderReactImageUploadComponent(
      editorView,
      imageUploadUrl,
      setIsLoadingUploading,
      setUploadProgress
    )
  });
  const IncreaseIndentIcon = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { ...props, xmlns: "http://www.w3.org/2000/svg", height: "24px", viewBox: "0 -960 960 960", width: "24px", fill: "#e8eaed", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M120-120v-80h720v80H120Zm320-160v-80h400v80H440Zm0-160v-80h400v80H440Zm0-160v-80h400v80H440ZM120-760v-80h720v80H120Zm0 440v-320l160 160-160 160Z" }) });
  const IncreaseIndentMenu = ({ editorView }) => {
    const applyIndentation = (state, dispatch) => {
      const { schema: schema2, selection } = state;
      const nodeType = schema2.nodes.paragraph;
      const { from, to } = selection;
      let selectedAlign = null;
      let currentPaddingLeft = 40;
      state.doc.nodesBetween(from, to, (node) => {
        if (node.type === nodeType) {
          selectedAlign = node.attrs.align;
          const existingPadding = parseInt(node.attrs.paddingLeft, 10) || 0;
          currentPaddingLeft = existingPadding > 0 ? existingPadding + 40 : 40;
        }
      });
      let attrs = {
        paddingLeft: `${currentPaddingLeft}px`
      };
      if (selectedAlign) attrs.align = selectedAlign;
      if (dispatch) {
        dispatch(
          state.tr.setBlockType(from, to, nodeType, attrs)
        );
      }
      return true;
    };
    const changeIndentation = () => {
      applyIndentation(editorView.state, editorView.dispatch);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative inline-block", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        class: "ProseMirror-icon",
        title: "Increase indent",
        ref: IncreaseIndentMenu,
        onClick: () => {
          changeIndentation();
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `note-menuitem`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "textAlignIcon", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IncreaseIndentIcon, {}) }) })
      }
    ) });
  };
  const renderReactIncreaseIndentComponent = (editorView) => {
    const container = document.createElement("div");
    const root = clientExports.createRoot(container);
    root.render(/* @__PURE__ */ jsxRuntimeExports.jsx(IncreaseIndentMenu, { editorView }));
    return container;
  };
  const proseMirrorMenuIncreaseIndent = new MenuItem({
    title: `Increase indent`,
    run: () => {
    },
    select: (state) => {
      return true;
    },
    render: (editorView) => renderReactIncreaseIndentComponent(editorView)
  });
  const LinkIcon = ({
    width = "15px",
    height = "15px",
    color = "#e8eaed",
    ...props
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        version: "1.0",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 22.000000 34.000000",
        preserveAspectRatio: "xMidYMid meet",
        width,
        height,
        fill: color,
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "g",
          {
            transform: "translate(0.000000,34.000000) scale(0.100000,-0.100000)",
            stroke: "none",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: "M56 275 c-12 -33 -7 -85 9 -85 11 0 15 11 15 41 0 39 1 40 33 37 29\r\n-3 32 -6 35 -40 5 -56 24 -46 20 10 l-3 47 -51 3 c-40 2 -53 -1 -58 -13z"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: "M102 169 c4 -79 23 -81 23 -2 0 37 -4 58 -13 61 -10 3 -12 -11 -10\r\n-59z"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: "M56 143 c-12 -12 -6 -81 8 -92 8 -7 34 -11 58 -9 l43 3 3 53 c2 31\r\n-1 52 -7 52 -6 0 -11 -18 -11 -40 0 -39 -1 -40 -35 -40 -33 0 -35 2 -35 34 0\r\n34 -11 52 -24 39z"
                }
              )
            ]
          }
        )
      }
    );
  };
  const normalizeUrl = (text2) => {
    if (!/^https?:\/\//i.test(text2)) {
      return `http://${text2}`;
    }
    return text2;
  };
  const insertLink = (state, dispatch, linkText, url, blank) => {
    const { schema: schema2, selection, tr } = state;
    const { from, to, empty: empty2 } = selection;
    const linkType = schema2.marks.link;
    const href = normalizeUrl(url);
    let text2 = linkText;
    if (!empty2) {
      text2 = state.doc.textBetween(from, to, " ");
    }
    let title = text2;
    let attrs = { href, title, ...{ target: blank ? "_blank" : "_self" } };
    if (dispatch) {
      if (empty2) {
        tr.insertText(text2, from);
        tr.addMark(from, from + text2.length, linkType.create(attrs));
      } else {
        tr.addMark(from, to, linkType.create(attrs));
      }
      dispatch(tr);
    }
    return true;
  };
  const PopupInsertLinkMenu = ({ editorView, href, title }) => {
    const [open, setOpen] = reactExports.useState(false);
    const [isSetLinkText, setIsSetLinkText] = reactExports.useState(false);
    const [linkText, setLinkText] = reactExports.useState("");
    const [url, setUrl] = reactExports.useState("");
    const [blank, setBlank] = reactExports.useState(true);
    const inputRef = reactExports.useRef(null);
    const inputRef2 = reactExports.useRef(null);
    const { selection } = editorView.state;
    const { from, to } = selection;
    const selectedText = editorView.state.doc.textBetween(from, to, " ");
    const resetMenu = () => {
      setLinkText("");
      setIsSetLinkText(false);
      setUrl("");
      setBlank(true);
    };
    reactExports.useEffect(() => {
      if (selectedText) {
        setLinkText(selectedText);
        setIsSetLinkText(true);
        setUrl("");
      } else {
        resetMenu();
      }
    }, [selectedText]);
    reactExports.useEffect(() => {
      if (inputRef.current) {
        inputRef.current.focus();
      }
    }, []);
    const onChangeCheckbox = () => {
      setBlank((prev) => !prev);
    };
    const onSubmit = () => {
      insertLink(editorView.state, editorView.dispatch, linkText, url, blank);
      setOpen(false);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative inline-block", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ProseMirrorMenuPopup, { open, setOpen, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ProseMirrorMenuButton,
        {
          id: "linkText",
          title: "Insert Link",
          isActive: linkText,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(LinkIcon, {})
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ProseMirrorMenuOption, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2 px-2 note-dd-Select-menu list-none list-inside dark:text-gray-400", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-sm mb-0", children: "Create Link" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "!text-xs", children: "Link text" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              ref: inputRef,
              onClick: () => inputRef.current.focus(),
              height: "medium",
              placeholder: "",
              defaultValue: linkText,
              onChange: (e) => {
                setLinkText(e.target.value);
                if (e.target.value) {
                  setIsSetLinkText(true);
                } else {
                  setIsSetLinkText(false);
                }
              },
              className: "!bg-white !text-black !border-gray-200"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "!text-xs", children: "Url" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              ref: inputRef2,
              onClick: () => inputRef2.current.focus(),
              height: "medium",
              placeholder: "",
              defaultValue: url,
              onChange: (e) => {
                setUrl(e.target.value);
                if (!isSetLinkText) setLinkText(e.target.value);
              },
              className: "!bg-white !text-black !border-gray-200"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            label: "Open in new tab",
            checked: blank,
            onChange: onChangeCheckbox,
            labelClassName: `!text-xs`
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              size: "sm",
              className: "w-full",
              onClick: onSubmit,
              disabled: !linkText || !url,
              children: "Apply"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              size: "sm",
              variant: "outline",
              className: "w-full",
              onClick: () => {
                resetMenu();
                setOpen(false);
              },
              children: "Cancel"
            }
          )
        ] })
      ] }) })
    ] }) });
  };
  const renderReactInsertLinkComponent = (editorView) => {
    const container = document.createElement("div");
    const root = clientExports.createRoot(container);
    root.render(/* @__PURE__ */ jsxRuntimeExports.jsx(PopupInsertLinkMenu, { editorView }));
    return container;
  };
  const insertLinkMenuItem = new MenuItem({
    title: `Select Alignment`,
    run: (state, dispatch, view) => {
    },
    select: (state) => {
      return true;
    },
    render: (editorView) => renderReactInsertLinkComponent(editorView)
  });
  const ItalicIcon = ({
    width = "15px",
    height = "15px",
    color = "#e8eaed",
    ...props
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width,
        height,
        fill: color,
        ...props,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M200-200v-100h160l120-360H320v-100h400v100H580L460-300h140v100H200Z" })
      }
    );
  };
  const isItalicMarkActive = (state, markType) => {
    const { from, to, empty: empty2 } = state.selection;
    if (empty2) {
      return !!markType.isInSet(
        state.storedMarks || state.selection.$from.marks()
      );
    } else {
      let hasMark = false;
      state.doc.nodesBetween(from, to, (node) => {
        if (node.marks.some((mark) => mark.type === markType)) {
          hasMark = true;
        }
      });
      return hasMark;
    }
  };
  const EditorItalicMenu = ({ editorView }) => {
    const boldButtonRef = reactExports.useRef(null);
    const [selectedEditorItalic, setSelectedEditorItalic] = reactExports.useState(false);
    const toggleMenu = () => {
      const { state, dispatch } = editorView;
      setSelectedEditorItalic(!selectedEditorItalic);
      toggleMark(state.schema.marks.em)(state, dispatch);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative inline-block", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "ProseMirror-icon",
        title: "Italic",
        ref: boldButtonRef,
        onClick: toggleMenu,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            id: "selectedEditorItalic",
            className: `note-menuitem ${selectedEditorItalic ? "note-active-state" : ""}`,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(ItalicIcon, {})
          }
        )
      }
    ) });
  };
  const renderReactItalicComponent = (editorView) => {
    const container = document.createElement("div");
    const root = clientExports.createRoot(container);
    root.render(/* @__PURE__ */ jsxRuntimeExports.jsx(EditorItalicMenu, { editorView }));
    return container;
  };
  const italicItem = new MenuItem({
    title: `Italic`,
    run: () => {
    },
    select: (state) => {
      const editorListButton = document.querySelector("#selectedEditorItalic");
      if (editorListButton && isItalicMarkActive(state, state.schema.marks.em)) {
        editorListButton.classList.add("note-active-state");
      }
      if (editorListButton && !isItalicMarkActive(state, state.schema.marks.em)) {
        editorListButton.classList.remove("note-active-state");
      }
      return true;
    },
    render: (editorView) => renderReactItalicComponent(editorView)
  });
  const listTypes = [
    {
      label: "Bullet",
      key: "bullet",
      icon: `<svg xmlns="http://www.w3.org/2000/svg" height="15px" viewBox="0 -960 960 960" width="14px" fill="#5f6368"><path d="M360-200v-80h480v80H360Zm0-240v-80h480v80H360Zm0-240v-80h480v80H360ZM200-160q-33 0-56.5-23.5T120-240q0-33 23.5-56.5T200-320q33 0 56.5 23.5T280-240q0 33-23.5 56.5T200-160Zm0-240q-33 0-56.5-23.5T120-480q0-33 23.5-56.5T200-560q33 0 56.5 23.5T280-480q0 33-23.5 56.5T200-400Zm0-240q-33 0-56.5-23.5T120-720q0-33 23.5-56.5T200-800q33 0 56.5 23.5T280-720q0 33-23.5 56.5T200-640Z"/></svg>`
    },
    {
      label: "Ordered",
      key: "ordered",
      icon: `<svg xmlns="http://www.w3.org/2000/svg" height="15px" viewBox="0 -960 960 960" width="14px" fill="#5f6368"><path d="M120-80v-60h100v-30h-60v-60h60v-30H120v-60h120q17 0 28.5 11.5T280-280v40q0 17-11.5 28.5T240-200q17 0 28.5 11.5T280-160v40q0 17-11.5 28.5T240-80H120Zm0-280v-110q0-17 11.5-28.5T160-510h60v-30H120v-60h120q17 0 28.5 11.5T280-560v70q0 17-11.5 28.5T240-450h-60v30h100v60H120Zm60-280v-180h-60v-60h120v240h-60Zm180 440v-80h480v80H360Zm0-240v-80h480v80H360Zm0-240v-80h480v80H360Z"/></svg>`
    }
  ];
  const isListActive = (state, nodeType) => {
    let { $from } = state.selection;
    for (let d = $from.depth; d > 0; d--) {
      if ($from.node(d).type === nodeType) return true;
    }
    return false;
  };
  let defaultEditorList = null;
  const DropdownListMenu = ({ editorView }) => {
    const [open, setOpen] = React.useState(false);
    const [textList, setTextList] = reactExports.useState(listTypes[0]);
    const [selectedEditorList, setSelectedEditorList] = reactExports.useState("");
    const toggleListMenu = (listType) => {
      const { state, dispatch } = editorView;
      const { schema: schema2 } = state;
      const isBulletList = isListActive(state, schema2.nodes.bullet_list);
      const isOrderedList = isListActive(state, schema2.nodes.ordered_list);
      const isAnyList = isBulletList || isOrderedList;
      if (isAnyList) {
        liftListItem(schema2.nodes.list_item)(state, dispatch);
      }
      if (!isListActive(state, schema2.nodes[listType.key + "_list"])) {
        wrapInList(schema2.nodes[listType.key + "_list"])(
          editorView.state,
          editorView.dispatch
        );
      }
      setOpen(false);
    };
    reactExports.useEffect(() => {
      if (defaultEditorList) setTextList(defaultEditorList);
    }, [defaultEditorList]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative inline-block", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ProseMirrorMenuPopup, { open, setOpen, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ProseMirrorMenuButton,
        {
          id: "selectedEditorList",
          title: "List styles",
          isActive: selectedEditorList,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgRenderer, { svgContent: textList == null ? void 0 : textList.icon })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ProseMirrorMenuOption, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "space-y-2 note-dd-Select-menu list-none list-inside dark:text-gray-400", children: listTypes.map((listType) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "li",
        {
          className: `cursor-pointer note-dd-Select-menu-options hover:bg-[#e5f5f8] py-1 ${(defaultEditorList == null ? void 0 : defaultEditorList.key) === listType.key ? "bg-gray-100" : "bg-none"}`,
          onClick: () => {
            toggleListMenu(listType);
            setSelectedEditorList(listType.icon);
            defaultEditorList = listType;
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgRenderer, { svgContent: listType.icon })
        },
        listType.key
      )) }) })
    ] }) });
  };
  const renderReactListComponent = (editorView) => {
    const container = document.createElement("div");
    const root = clientExports.createRoot(container);
    root.render(/* @__PURE__ */ jsxRuntimeExports.jsx(DropdownListMenu, { editorView }));
    return container;
  };
  const listMenuItem = new MenuItem({
    title: `List styles`,
    run: () => {
    },
    select: (state) => {
      var _a2, _b2, _c2;
      const { schema: schema2, selection } = state;
      const isBulletList = isListActive(state, schema2.nodes.bullet_list);
      const isOrderedList = isListActive(state, schema2.nodes.ordered_list);
      const editorListButton = document.querySelector("#selectedEditorList-icon");
      console.log("editorListButton", editorListButton);
      if (editorListButton && isBulletList) {
        editorListButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="15px" viewBox="0 -960 960 960" width="14px" fill="#e8eaed"><path d="M360-200v-80h480v80H360Zm0-240v-80h480v80H360Zm0-240v-80h480v80H360ZM200-160q-33 0-56.5-23.5T120-240q0-33 23.5-56.5T200-320q33 0 56.5 23.5T280-240q0 33-23.5 56.5T200-160Zm0-240q-33 0-56.5-23.5T120-480q0-33 23.5-56.5T200-560q33 0 56.5 23.5T280-480q0 33-23.5 56.5T200-400Zm0-240q-33 0-56.5-23.5T120-720q0-33 23.5-56.5T200-800q33 0 56.5 23.5T280-720q0 33-23.5 56.5T200-640Z"/></svg>`;
        (_a2 = document.getElementById("selectedEditorList")) == null ? void 0 : _a2.classList.add("note-active-state");
        defaultEditorList = listTypes[0];
      }
      if (editorListButton && isOrderedList) {
        editorListButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="15px" viewBox="0 -960 960 960" width="14px" fill="#e8eaed"><path d="M120-80v-60h100v-30h-60v-60h60v-30H120v-60h120q17 0 28.5 11.5T280-280v40q0 17-11.5 28.5T240-200q17 0 28.5 11.5T280-160v40q0 17-11.5 28.5T240-80H120Zm0-280v-110q0-17 11.5-28.5T160-510h60v-30H120v-60h120q17 0 28.5 11.5T280-560v70q0 17-11.5 28.5T240-450h-60v30h100v60H120Zm60-280v-180h-60v-60h120v240h-60Zm180 440v-80h480v80H360Zm0-240v-80h480v80H360Zm0-240v-80h480v80H360Z"/></svg>`;
        (_b2 = document.getElementById("selectedEditorList")) == null ? void 0 : _b2.classList.add("note-active-state");
        defaultEditorList = listTypes[1];
      }
      if (editorListButton && !isBulletList && !isOrderedList && editorListButton) {
        editorListButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="15px" viewBox="0 -960 960 960" width="14px" fill="#e8eaed"><path d="M360-200v-80h480v80H360Zm0-240v-80h480v80H360Zm0-240v-80h480v80H360ZM200-160q-33 0-56.5-23.5T120-240q0-33 23.5-56.5T200-320q33 0 56.5 23.5T280-240q0 33-23.5 56.5T200-160Zm0-240q-33 0-56.5-23.5T120-480q0-33 23.5-56.5T200-560q33 0 56.5 23.5T280-480q0 33-23.5 56.5T200-400Zm0-240q-33 0-56.5-23.5T120-720q0-33 23.5-56.5T200-800q33 0 56.5 23.5T280-720q0 33-23.5 56.5T200-640Z"/></svg>`;
        (_c2 = document.getElementById("selectedEditorList")) == null ? void 0 : _c2.classList.remove("note-active-state");
        defaultEditorList = "";
      }
      return true;
    },
    render: (editorView) => renderReactListComponent(editorView)
  });
  const UnderlineIcon = ({
    width = "15px",
    height = "15px",
    color = "#e8eaed",
    ...props
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width,
        height,
        fill: color,
        ...props,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M200-120v-80h560v80H200Zm280-160q-101 0-157-63t-56-167v-330h103v336q0 56 28 91t82 35q54 0 82-35t28-91v-336h103v330q0 104-56 167t-157 63Z" })
      }
    );
  };
  const isUnderlineMarkActive = (state, markType) => {
    const { from, to, empty: empty2 } = state.selection;
    if (empty2) {
      return !!markType.isInSet(
        state.storedMarks || state.selection.$from.marks()
      );
    } else {
      let hasMark = false;
      state.doc.nodesBetween(from, to, (node) => {
        if (node.marks.some((mark) => mark.type === markType)) {
          hasMark = true;
        }
      });
      return hasMark;
    }
  };
  const EditorUnderlineMenu = ({ editorView }) => {
    const boldButtonRef = reactExports.useRef(null);
    const [selectedEditorUnderline, setSelectedEditorUnderline] = reactExports.useState(false);
    const toggleMenu = () => {
      const { state, dispatch } = editorView;
      setSelectedEditorUnderline(!selectedEditorUnderline);
      toggleMark(state.schema.marks.underline)(state, dispatch);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative inline-block", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "ProseMirror-icon",
        title: "Underline",
        ref: boldButtonRef,
        onClick: toggleMenu,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            id: "selectedEditorUnderline",
            className: `note-menuitem ${selectedEditorUnderline ? "note-active-state" : ""}`,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(UnderlineIcon, {})
          }
        )
      }
    ) });
  };
  const renderReactUnderlineComponent = (editorView) => {
    const container = document.createElement("div");
    const root = clientExports.createRoot(container);
    root.render(/* @__PURE__ */ jsxRuntimeExports.jsx(EditorUnderlineMenu, { editorView }));
    return container;
  };
  const underlineMenuItem = new MenuItem({
    title: `Underline`,
    run: () => {
    },
    select: (state) => {
      const editorListButton = document.querySelector("#selectedEditorUnderline");
      if (editorListButton && isUnderlineMarkActive(state, state.schema.marks.underline)) {
        editorListButton.classList.add("note-active-state");
      }
      if (editorListButton && !isUnderlineMarkActive(state, state.schema.marks.underline)) {
        editorListButton.classList.remove("note-active-state");
      }
      return true;
    },
    render: (editorView) => renderReactUnderlineComponent(editorView)
  });
  const clearFormattingNote = (state, dispatch) => {
    const { schema: schema2, selection } = state;
    const { from, to } = selection;
    if (!dispatch) return false;
    let tr = state.tr;
    schema2.marks && Object.keys(schema2.marks).forEach((markName) => {
      const markType = schema2.marks[markName];
      if (markType) {
        tr = tr.removeMark(from, to, markType);
      }
    });
    const paragraphType = schema2.nodes.paragraph;
    if (paragraphType) {
      setBlockType(paragraphType)(state, dispatch);
    }
    dispatch(tr);
    return true;
  };
  const clearFormattingNoteMenuItem = new MenuItem({
    title: "Clear Formatting",
    icon: {
      dom: (() => {
        const span = document.createElement("span");
        span.innerHTML = `
        <svg version="1.0" xmlns="http://www.w3.org/2000/svg"
          width="15px" height="15px" viewBox="0 0 30.000000 38.000000"
          preserveAspectRatio="xMidYMid meet">

          <g transform="translate(0.000000,38.000000) scale(0.100000,-0.100000)"
          fill="#666666" stroke="none">
          <path d="M47 334 c-15 -15 -6 -24 23 -24 35 0 35 -2 14 -82 -11 -42 -12 -64
          -5 -71 15 -15 17 -11 38 73 l19 75 38 3 c23 2 36 8 33 15 -4 13 -148 23 -160
          11z"/>
          <path d="M140 162 c0 -5 9 -17 20 -27 l20 -18 -20 -22 c-29 -31 -26 -54 3 -27
          29 27 35 27 64 0 18 -16 23 -18 23 -6 0 8 -9 23 -20 33 l-20 18 22 24 c28 30
          15 43 -15 15 l-24 -22 -18 20 c-19 21 -35 26 -35 12z"/>
          <path d="M40 110 c0 -5 20 -10 45 -10 25 0 45 5 45 10 0 6 -20 10 -45 10 -25
          0 -45 -4 -45 -10z"/>
          </g>
        </svg>
      `;
        span.className = "note-menuitem";
        return span;
      })()
    },
    enable: (state) => true,
    // enable: (state) => !state.selection.empty,
    run: clearFormattingNote
  });
  function useEditor() {
    const [font, setFont] = useAtom(fontState);
    const [isLoadingUploading, setIsLoadingUploading] = useAtom(isLoadingUploadingState);
    const [uploadProgress, setUploadProgress] = useAtom(uploadProgressState);
    const [uploadedAttachments, setUploadedAttachments] = useAtom(attachmentsState);
    const [linkData, setLinkDataState] = useAtom(linkDataState);
    const [getLinkData] = useAtom(linkDataState);
    return {
      font,
      setFont,
      isLoadingUploading,
      setIsLoadingUploading,
      uploadProgress,
      setUploadProgress,
      uploadedAttachments,
      setUploadedAttachments,
      linkData,
      setLinkDataState,
      getLinkData
    };
  }
  const ProseMirrorEditor = ({
    initialData = "",
    attachments = [],
    setEditorContent,
    id = "new",
    imageUploadUrl,
    attachmentUploadUrl,
    attachmentUploadMethod = "POST",
    setAttachmentId = null,
    refetch = null,
    objectId,
    setIsUploading,
    menuConfig = {
      boldItem: true,
      italicItem: true,
      underlineMenuItem: true,
      fontMenuItem: true,
      fontSizeMenuItem: true,
      textColor: true,
      textBGColor: true,
      clearFormattingNoteMenuItem: true,
      blockquoteItem: true,
      alignmentDropdown: true,
      listMenuItem: true,
      insertLinkMenuItem: true,
      proseMirrorMenuDecreaseIndent: false,
      proseMirrorMenuIncreaseIndent: false,
      proseMirrorMenuEmoji: false,
      imageUploader: true,
      attachmentUploader: true
    }
  }) => {
    const editorMenuConfig = {
      boldItem: (menuConfig == null ? void 0 : menuConfig.boldItem) ?? true,
      italicItem: (menuConfig == null ? void 0 : menuConfig.italicItem) ?? true,
      underlineMenuItem: (menuConfig == null ? void 0 : menuConfig.underlineMenuItem) ?? true,
      fontMenuItem: (menuConfig == null ? void 0 : menuConfig.fontMenuItem) ?? true,
      fontSizeMenuItem: (menuConfig == null ? void 0 : menuConfig.fontSizeMenuItem) ?? true,
      textColor: (menuConfig == null ? void 0 : menuConfig.textColor) ?? true,
      textBGColor: (menuConfig == null ? void 0 : menuConfig.textBGColor) ?? true,
      clearFormattingNoteMenuItem: (menuConfig == null ? void 0 : menuConfig.clearFormattingNoteMenuItem) ?? true,
      blockquoteItem: (menuConfig == null ? void 0 : menuConfig.blockquoteItem) ?? true,
      alignmentDropdown: (menuConfig == null ? void 0 : menuConfig.alignmentDropdown) ?? true,
      listMenuItem: (menuConfig == null ? void 0 : menuConfig.listMenuItem) ?? true,
      insertLinkMenuItem: (menuConfig == null ? void 0 : menuConfig.insertLinkMenuItem) ?? true,
      proseMirrorMenuDecreaseIndent: (menuConfig == null ? void 0 : menuConfig.proseMirrorMenuDecreaseIndent) ?? true,
      proseMirrorMenuIncreaseIndent: (menuConfig == null ? void 0 : menuConfig.proseMirrorMenuIncreaseIndent) ?? true,
      proseMirrorMenuEmoji: (menuConfig == null ? void 0 : menuConfig.proseMirrorMenuEmoji) ?? true,
      imageUploader: (menuConfig == null ? void 0 : menuConfig.imageUploader) ?? true,
      attachmentUploader: (menuConfig == null ? void 0 : menuConfig.attachmentUploader) ?? true
    };
    const {
      isLoadingUploading,
      setIsLoadingUploading,
      uploadProgress,
      setUploadProgress,
      uploadedAttachments,
      setUploadedAttachments
    } = useEditor();
    const editorRef = reactExports.useRef(null);
    const [pmState, setPmState] = reactExports.useState();
    const [editorShema, setEditorSchema] = reactExports.useState(null);
    const [initialDoc, setInitialDoc] = reactExports.useState(null);
    reactExports.useEffect(() => {
      if (attachments.length > 0) {
        setUploadedAttachments(attachments);
      } else {
        setUploadedAttachments([]);
      }
    }, []);
    const imageNodeSpec = {
      inline: false,
      // Defines the image as a block-level element
      attrs: {
        src: {},
        // The source URL of the image (required)
        width: { default: "" },
        // Image width
        height: { default: "" },
        // Image height
        style: { default: "" },
        // Style for alignment or other container-level styles
        wrap: { default: false }
        // Boolean to check if image is wrapped with <figure>
      },
      group: "block",
      draggable: false,
      selectable: false,
      parseDOM: [
        // Image wrapped in a <figure> tag
        {
          tag: "figure",
          getAttrs(dom) {
            const img = dom.querySelector("img");
            return {
              src: img ? img.getAttribute("src") : "",
              width: img ? img.getAttribute("width") : "",
              height: img ? img.getAttribute("height") : "",
              style: dom.getAttribute("style") || "",
              // Capture figure's style (e.g., text-align)
              wrap: true
              // Mark that the image is wrapped
            };
          }
        },
        // Image without <figure> wrapper
        {
          tag: "img",
          getAttrs(dom) {
            return {
              src: dom.getAttribute("src"),
              width: dom.getAttribute("width"),
              height: dom.getAttribute("height"),
              style: "",
              // No wrapper, so no additional style from <figure>
              wrap: false
              // Not wrapped in a <figure>
            };
          }
        }
      ],
      toDOM(node) {
        if (node.attrs.wrap) {
          return [
            "figure",
            { style: node.attrs.style || "" },
            // Apply text-align or other styles if present
            [
              "img",
              {
                src: node.attrs.src,
                width: node.attrs.width,
                height: node.attrs.height
              }
            ]
          ];
        } else {
          return [
            "img",
            {
              src: node.attrs.src,
              width: node.attrs.width,
              height: node.attrs.height
            }
          ];
        }
      }
    };
    reactExports.useEffect(() => {
      const linkMark = {
        attrs: {
          href: {},
          title: { default: "" },
          target: {}
        },
        inclusive: false,
        parseDOM: [
          {
            tag: "a[href]",
            getAttrs(dom) {
              return {
                href: dom.getAttribute("href"),
                title: dom.getAttribute("title") || dom.textContent,
                // Use text content if no title
                target: dom.getAttribute("target")
              };
            }
          }
        ],
        toDOM(node) {
          return [
            "a",
            {
              href: node.attrs.href,
              title: node.attrs.title,
              target: node.attrs.target
            },
            0
            // This means the text inside will be editable
          ];
        }
      };
      const paragraphNode = {
        content: "inline*",
        group: "block",
        attrs: {
          align: { default: null },
          paddingLeft: { default: 0 }
          // New attribute for padding
        },
        parseDOM: [
          {
            tag: "p",
            // getAttrs: (dom) => ({
            //   align: dom?.style?.textAlign || null,
            // }),
            getAttrs: (dom) => {
              var _a2, _b2;
              return {
                align: ((_a2 = dom == null ? void 0 : dom.style) == null ? void 0 : _a2.textAlign) || null,
                paddingLeft: ((_b2 = dom == null ? void 0 : dom.style) == null ? void 0 : _b2.paddingLeft) ? parseInt(dom.style.paddingLeft, 10) : 0
              };
            }
          }
        ],
        toDOM(node) {
          const { align, paddingLeft } = node.attrs;
          return [
            "p",
            {
              style: `
              ${align ? `text-align: ${align};` : ""}
              ${paddingLeft ? `padding-left: ${paddingLeft}` : ""}
            `
              // "data-mce-style": `padding-left: ${paddingLeft}px;`, // TinyMCE compatibility
            },
            0
          ];
        }
      };
      const alignmentMark = {
        attrs: { align: { default: "left" } },
        // Default alignment is 'left'
        parseDOM: [
          {
            style: "text-align",
            getAttrs: (value) => ({ align: value })
          }
        ],
        toDOM: (mark) => ["span", { style: `text-align: ${mark.attrs.align};` }]
      };
      const nodes2 = schema.spec.nodes.update("paragraph", paragraphNode).addToEnd("image", imageNodeSpec);
      const nodesWithList = addListNodes(nodes2, "paragraph block*", "block");
      const schema$1 = new Schema({
        nodes: nodesWithList,
        marks: {
          link: linkMark,
          alignment: alignmentMark,
          em: {
            toDOM: () => ["em", 0],
            parseDOM: [{ tag: "em" }]
          },
          strong: {
            toDOM: () => ["strong", 0],
            parseDOM: [{ tag: "strong" }]
          },
          underline: {
            toDOM: () => ["u", 0],
            parseDOM: [{ tag: "u" }]
          },
          textColor: {
            attrs: { color: {} },
            parseDOM: [
              {
                style: "color",
                getAttrs: (value) => ({ color: value })
              }
            ],
            toDOM: (mark) => ["span", { style: `color: ${mark.attrs.color}` }, 0]
          },
          fontSize: {
            attrs: { fontSize: {} },
            parseDOM: [
              {
                style: "font-size",
                getAttrs: (value) => ({ fontSize: value })
              }
            ],
            toDOM: (mark) => [
              "span",
              { style: `font-size: ${mark.attrs.fontSize}` },
              0
            ]
          },
          textBackgroundColor: {
            attrs: { color: {} },
            parseDOM: [
              {
                style: "background-color",
                getAttrs: (value) => ({ color: value })
              }
            ],
            toDOM: (mark) => [
              "span",
              { style: `background-color: ${mark.attrs.color}` },
              0
            ]
          },
          fontFamily: {
            attrs: { font: {} },
            parseDOM: [
              {
                style: "font-family",
                getAttrs: (value) => ({ font: value })
              }
            ],
            toDOM: (mark) => [
              "span",
              { style: `font-family: ${mark.attrs.font}` },
              0
            ]
          }
        }
      });
      setEditorSchema(schema$1);
    }, []);
    reactExports.useEffect(() => {
      if (!editorShema) return;
      const initialContent = document.createElement("div");
      initialContent.innerHTML = initialData;
      const mInitialDoc = DOMParser$1.fromSchema(editorShema).parse(initialContent);
      setInitialDoc(mInitialDoc);
    }, [editorShema]);
    reactExports.useEffect(() => {
      if (!editorShema && !initialDoc) return;
      const schema2 = editorShema;
      const imageUploader = () => {
        return customMenuItemImage(
          imageUploadUrl,
          setIsLoadingUploading,
          setUploadProgress
        );
      };
      const attachmentUploader = () => {
        return customMenuItemAttachment(
          attachmentUploadUrl,
          attachmentUploadMethod,
          setUploadedAttachments,
          setIsLoadingUploading,
          setUploadProgress,
          setAttachmentId
        );
      };
      const menuBarContent = [
        [
          editorMenuConfig.boldItem && boldItem,
          editorMenuConfig.italicItem && italicItem,
          editorMenuConfig.underlineMenuItem && underlineMenuItem
        ].filter(Boolean),
        // Remove undefined/false items
        [
          editorMenuConfig.fontMenuItem && fontMenuItem,
          editorMenuConfig.fontSizeMenuItem && fontSizeMenuItem
        ].filter(Boolean),
        // Remove undefined/false items
        [
          editorMenuConfig.textColor && textColor,
          editorMenuConfig.textBGColor && textBGColor
        ].filter(Boolean),
        // Remove undefined/false items
        [
          editorMenuConfig.clearFormattingNoteMenuItem && clearFormattingNoteMenuItem
        ].filter(Boolean),
        // Remove undefined/false items
        [
          editorMenuConfig.blockquoteItem && blockquoteItem
        ].filter(Boolean),
        // Remove undefined/false items
        [
          editorMenuConfig.alignmentDropdown && alignmentDropdown
        ].filter(Boolean),
        // Remove undefined/false items
        [
          editorMenuConfig.listMenuItem && listMenuItem
        ].filter(Boolean),
        // Remove undefined/false items
        [
          editorMenuConfig.insertLinkMenuItem && insertLinkMenuItem
        ].filter(Boolean),
        // Remove undefined/false items
        [
          editorMenuConfig.proseMirrorMenuDecreaseIndent && proseMirrorMenuDecreaseIndent,
          editorMenuConfig.proseMirrorMenuIncreaseIndent && proseMirrorMenuIncreaseIndent
        ].filter(Boolean),
        // Remove undefined/false items
        [
          editorMenuConfig.proseMirrorMenuEmoji && proseMirrorMenuEmoji
        ].filter(Boolean),
        // Remove undefined/false items
        [
          editorMenuConfig.imageUploader && imageUploader(),
          editorMenuConfig.attachmentUploader && attachmentUploader()
        ].filter(Boolean)
        // Remove undefined/false items
      ];
      const menu = menuBar({
        content: menuBarContent
      });
      const customEnterHandler = (state, dispatch) => {
        const { schema: schema22, selection } = state;
        const { $from, $to } = selection;
        const tr = state.tr;
        if (!dispatch) return false;
        const parentNode2 = $from.node(-1);
        if (parentNode2 && parentNode2.type.name === "blockquote") {
          if ($from.parent.textContent.length === 0) {
            lift(state, dispatch);
            return true;
          }
        }
        const listItem2 = $from.node(-1);
        if ($from.parent.textContent.length === 0) {
          if (listItem2 && listItem2.type.name === "list_item") {
            liftListItem(schema22.nodes.list_item)(state, dispatch);
            return true;
          }
        }
        if (listItem2 && listItem2.type.name === "list_item") {
          tr.split($from.pos, 2);
        } else {
          tr.split($from.pos);
        }
        const activeMarks = state.storedMarks || $from.marks();
        activeMarks.forEach((mark) => {
          tr.addStoredMark(schema22.marks[mark.type.name].create(mark.attrs));
        });
        dispatch(tr);
        return true;
      };
      const editor = new EditorView(editorRef.current, {
        state: EditorState.create({
          doc: initialDoc,
          schema: schema2,
          plugins: [
            history(),
            // Enables history tracking
            keymap({
              Enter: chainCommands(exitCode, customEnterHandler, splitBlock),
              Tab: (state, dispatch) => {
                return sinkListItem(state.schema.nodes.list_item)(
                  state,
                  dispatch
                );
              },
              "Shift-Enter": baseKeymap["Enter"],
              // Allow Shift+Enter to add a line break instead of a new list item
              "Mod-z": undo,
              // Ctrl + Z or Cmd + Z for undo
              "Mod-y": redo
              // Ctrl + Y or Cmd + Shift + Z for redo
            }),
            keymap(baseKeymap),
            menu,
            fontSelectionPlugin,
            fontSizeSelectionPlugin,
            textColorPlugin,
            textBGColorPlugin
          ]
        }),
        nodeViews: {
          image: ProseMirrorImageResizeView(),
          link: ProseMirrorLinkView
        },
        dispatchTransaction(transaction) {
          const newState = editor.state.apply(transaction);
          editor.updateState(newState);
          setEditorContent(newState.doc.textContent);
          setPmState(newState);
        }
      });
      return () => {
        editor.destroy();
      };
    }, [editorShema, initialDoc]);
    reactExports.useEffect(() => {
      return () => {
      };
    }, []);
    const getContentString = () => {
      let fragment = DOMSerializer.fromSchema(editorShema).serializeFragment(
        pmState.doc.content
      );
      let tmp = document.createElement("div");
      tmp.appendChild(fragment);
      return tmp.innerHTML;
    };
    reactExports.useEffect(() => {
      if (pmState) {
        const { doc: doc2 } = pmState;
        const isEmpty = doc2.content.childCount === 1 && doc2.textContent.trim() === "";
        const content = isEmpty ? "" : getContentString();
        setEditorContent(content);
      }
    }, [pmState == null ? void 0 : pmState.doc.toJSON()]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      console.log("editor", true),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          ref: editorRef,
          id: "prosemirror-editor",
          className: "text-[#000] prosemirror-editor dark:bg-white bg-white rounded border border-secondary pt-0"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Attachments,
        {
          setUploadedAttachments,
          attachments: uploadedAttachments,
          objectId,
          id,
          isLoadingUploading,
          uploadProgress,
          preview: false
        }
      )
    ] });
  };
  const EditIcon = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      ...props,
      xmlns: "http://www.w3.org/2000/svg",
      height: "1rem",
      viewBox: "0 -960 960 960",
      width: "1rem",
      fill: "currentColor",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M200-200h57l391-391-57-57-391 391v57Zm-80 80v-170l528-527q12-11 26.5-17t30.5-6q16 0 31 6t26 18l55 56q12 11 17.5 26t5.5 30q0 16-5.5 30.5T817-647L290-120H120Zm640-584-56-56 56 56Zm-141 85-28-29 57 57-29-28Z" })
    }
  );
  const ExpandIcon = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      width: "1em",
      height: "1em",
      fill: "currentColor",
      viewBox: "0 0 1024 1024",
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m855 160.1-189.2 23.5c-6.6.8-9.3 8.8-4.7 13.5l54.7 54.7-153.5 153.5a8.03 8.03 0 0 0 0 11.3l45.1 45.1c3.1 3.1 8.2 3.1 11.3 0l153.6-153.6 54.7 54.7a7.94 7.94 0 0 0 13.5-4.7L863.9 169a7.9 7.9 0 0 0-8.9-8.9zM416.6 562.3a8.03 8.03 0 0 0-11.3 0L251.8 715.9l-54.7-54.7a7.94 7.94 0 0 0-13.5 4.7L160.1 855c-.6 5.2 3.7 9.5 8.9 8.9l189.2-23.5c6.6-.8 9.3-8.8 4.7-13.5l-54.7-54.7 153.6-153.6c3.1-3.1 3.1-8.2 0-11.3l-45.2-45z" })
    }
  );
  const ShrinkIcon = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      width: "1em",
      height: "1em",
      fill: "currentColor",
      viewBox: "0 0 1024 1024",
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m881.7 187.4-45.1-45.1a8.03 8.03 0 0 0-11.3 0L667.8 299.9l-54.7-54.7a7.94 7.94 0 0 0-13.5 4.7L576.1 439c-.6 5.2 3.7 9.5 8.9 8.9l189.2-23.5c6.6-.8 9.3-8.8 4.7-13.5l-54.7-54.7 157.6-157.6c3-3 3-8.1-.1-11.2zM439 576.1l-189.2 23.5c-6.6.8-9.3 8.9-4.7 13.5l54.7 54.7-157.5 157.5a8.03 8.03 0 0 0 0 11.3l45.1 45.1c3.1 3.1 8.2 3.1 11.3 0l157.6-157.6 54.7 54.7a7.94 7.94 0 0 0 13.5-4.7L447.9 585a7.9 7.9 0 0 0-8.9-8.9z" })
    }
  );
  const NoteSkeleton = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg mt-2 bg-cleanWhite border dark:border-none dark:bg-dark-300 md:p-4 p-2 ", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-end mb-6 items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { variant: !recorBtnCustom ? "default" : "create", className: "text-white", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "mr-2", children: [
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(IconPlus, { className: "!w-3 !h-3" }),
          " "
        ] }),
        " ",
        "Create Note"
      ] }) }),
      Array.from({ length: 4 }).map((_2, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2 animate-pulse", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "border border-gray-200 dark:border-gray-600 dark:bg-dark-500 bg-white shadow-md rounded-md mt-1 p-2 dark:text-white text-sm cursor-pointer",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "h-3 bg-gray-300 dark:bg-dark-white rounded-sm w-[16px] inline-block " }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center w-full", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-semibold  whitespace-nowrap", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "h-3 bg-gray-300 dark:bg-dark-white rounded-sm w-[100px] inline-block " }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-400 dark:text-white text-xs ", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "h-2 bg-gray-300 dark:bg-dark-white rounded-sm w-[80px] inline-block " }) }) })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: `py-3 pr-3 pl-6 hover:border-blue-500 hover:bg-gray-100 hover:dark:bg-gray-600 rounded-md relative group`,
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative line-clamp-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex flex-col gap-3", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "h-3 bg-gray-300 dark:bg-dark-white rounded-sm w-[150px] inline-block " }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "h-3 bg-gray-300 dark:bg-dark-white rounded-sm w-[250px] inline-block " }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "h-3 bg-gray-300 dark:bg-dark-white rounded-sm w-[180px] inline-block " })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      className: `bg-gradient-to-t from-white dark:from-dark-500 to-transparent h-8 absolute bottom-0 right-0 left-0`
                    }
                  )
                ] })
              }
            ) })
          ] })
        }
      ) }, i2))
    ] });
  };
  const NoteCard = ({
    note,
    objectId,
    id,
    imageUploadUrl,
    attachmentUploadUrl,
    refetch,
    setToaster,
    permissions
  }) => {
    var _a2;
    const [isOpen, setIsOpen] = reactExports.useState(false);
    const [isOpenEditor, setIsOpenEditor] = reactExports.useState(false);
    const [editorContent, setEditorContent] = reactExports.useState(note.hs_note_body);
    const [isUploading, setIsUploading] = reactExports.useState(false);
    moduleStylesOptions.noteStyle;
    const editorRef = reactExports.useRef(null);
    const formatDate2 = (timestamp) => {
      const date = new Date(timestamp);
      return date.toLocaleDateString();
    };
    const formatTime = (timestamp) => {
      const date = new Date(timestamp);
      return date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    };
    let portalId;
    if (env$1.VITE_DATA_SOURCE_SET != true) {
      portalId = (_a2 = getPortal()) == null ? void 0 : _a2.portalId;
    }
    const updateNoteMutation = useMutation(
      async (newNote) => {
        return await Client.notes.updateNote({
          objectId,
          id,
          note: newNote,
          note_id: note.hs_object_id,
          portalId
        });
      },
      {
        onSuccess: (res) => {
          const queryClient2 = new QueryClient();
          queryClient2.invalidateQueries(["data"]);
          refetch();
          setToaster({
            message: res.statusMsg,
            type: "success"
          });
          setIsOpenEditor(false);
        },
        onError: (error) => {
          console.error("Error creating note:", error);
          setToaster({
            message: error.response.data.errorMessage,
            type: "error"
          });
        }
      }
    );
    const { isLoading: isLoadingUpdate } = updateNoteMutation;
    const handleUpdateNote = () => {
      const payload = {
        noteBody: editorContent
      };
      updateNoteMutation.mutate(payload);
    };
    const noteViewConfig = {
      ADD_ATTR: ["target"]
      // ALLOWED_ATTR: ["style", "src", "width", "height", "alt"],
      // ALLOWED_TAGS: ["p", "a", "figure", "img", "br"],
      // ALLOW_DATA_ATTR: true, // If data attributes are required
      // KEEP_CONTENT: true // Keep empty tags
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: `border ${(note == null ? void 0 : note.createdBy) === "Hubspot" ? `bg-[var(--note-hs-bg)] dark:bg-dark-300 dark:border-gray-700  ` : `bg-[var(--note-wp-bg)] dark:bg-dark-500 dark:border-gray-600`} border-gray-200  shadow-md rounded-md mt-1 p-2 dark:text-white text-sm cursor-pointer`,
        onClick: () => {
          setIsOpen(!isOpen);
          setIsOpenEditor(false);
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${(note == null ? void 0 : note.createdBy) === "Hubspot" ? `text-[var(--note-hs-text)]` : `text-[var(--note-wp-text)]`} dark:text-white`, children: isOpen ? /* @__PURE__ */ jsxRuntimeExports.jsx(Chevron, { className: "rotate-[270deg] origin-center -webkit-transform" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Chevron, { className: "rotate-180 origin-center -webkit-transform" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center w-full", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: `text-sm font-semibold  whitespace-nowrap ${(note == null ? void 0 : note.createdBy) === "Hubspot" ? `text-[var(--note-hs-text)]` : `text-[var(--note-wp-text)]`} dark:text-white`, children: [
                "Note",
                (note == null ? void 0 : note.createdByName) || (note == null ? void 0 : note.createdByEmail) ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${(note == null ? void 0 : note.createdBy) === "Hubspot" ? `text-[var(--note-hs-text)]` : `text-[var(--note-wp-text)]`} dark:text-white font-normal ml-1 inline-block text-xs`, children: [
                  "by ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: " border rounded-full px-2 py-1 text-xs ml-2 font-normal inline-block", children: (note == null ? void 0 : note.createdByName) || (note == null ? void 0 : note.createdByEmail) })
                ] }) : null
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: `${(note == null ? void 0 : note.createdBy) === "Hubspot" ? `text-[var(--note-hs-text)]` : `text-[var(--note-wp-text)]`} dark:text-white text-xs`, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "mr-1", children: [
                  " ",
                  formatDate2(note.hs_createdate),
                  " "
                ] }),
                formatTime(note.hs_createdate)
              ] }) })
            ] })
          ] }),
          isOpenEditor && permissions && permissions.update ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `p-4 cursor-text`,
              onClick: (e) => e.stopPropagation(),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `edit-note`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ProseMirrorEditor,
                  {
                    ref: editorRef,
                    initialData: escapeHTML(note.hs_note_body),
                    attachments: note.hs_attachment_ids || [],
                    setEditorContent,
                    id,
                    imageUploadUrl,
                    attachmentUploadUrl: `${attachmentUploadUrl}/${note.hs_object_id}`,
                    attachmentUploadMethod: "PUT",
                    setAttachmentId: null,
                    refetch,
                    objectId,
                    setIsUploading
                  },
                  id
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-x-2 mt-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      disabled: isLoadingUpdate || editorContent === "" || isUploading,
                      onClick: handleUpdateNote,
                      className: "text-white",
                      size: "sm",
                      isLoading: isLoadingUpdate,
                      children: "Save"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      disabled: isLoadingUpdate || isUploading,
                      size: "sm",
                      variant: "outline",
                      onClick: () => {
                        setIsOpenEditor(false);
                        setIsOpen(!isOpen);
                      },
                      children: "Cancel"
                    }
                  )
                ] })
              ]
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `text-black ${!isOpen ? "relative line-clamp-3 h-[50px] overflow-hidden" : ""}
              `,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    className: `py-3 pr-3 pl-6 ${!isOpen ? "rounded-md dark:bg-white mt-2" : `${permissions.update && (note == null ? void 0 : note.createdBy) != "Hubspot" ? "cursor-text hover:bg-secondaryBgHover hover:border-secondary" : "cursor-auto"} bg-white mt-2 border border-[transparent] dark:border-[transparent] rounded-md relative group`} EditorView`,
                    onClick: (e) => {
                      if (isOpen && (note == null ? void 0 : note.createdBy) != "Hubspot") {
                        e.stopPropagation();
                        setIsOpenEditor(true);
                      }
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "break-words", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(HtmlParser, { html: purify.sanitize(note.hs_note_body, noteViewConfig) }) }) }),
                      permissions.update === true && (note == null ? void 0 : note.createdBy) != "Hubspot" ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-2 right-2 opacity-0 group-hover:opacity-100 text-secondary transition-opacity", children: /* @__PURE__ */ jsxRuntimeExports.jsx(EditIcon, {}) }) : null
                    ]
                  }
                ),
                isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: (e) => e.stopPropagation(), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Attachments,
                  {
                    attachments: note.hs_attachment_ids || [],
                    objectId,
                    id,
                    remove: false
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: `${!isOpen ? ` ${(note == null ? void 0 : note.createdBy) === "Hubspot" ? `from-[var(--note-hs-bg)]` : `from-[var(--note-wp-bg)]`} bg-gradient-to-t dark:from-dark-500 to-transparent h-8 absolute bottom-0 right-0 left-0` : ""}`
                  }
                )
              ]
            }
          )
        ] })
      }
    ) }, note.hs_object_id);
  };
  const Notes = ({ tabName = "", item, path, objectId, id, permissions }) => {
    var _a2, _b2, _c2;
    const [showDialog, setShowDialog] = reactExports.useState(false);
    const [isUploading, setIsUploading] = reactExports.useState(false);
    const { me } = useMe$1();
    const [editorContent, setEditorContent] = reactExports.useState("");
    const [imageUploadUrl, setImageUploadUrl] = reactExports.useState("");
    const [attachmentUploadUrl, setAttachmentUploadUrl] = reactExports.useState("");
    const [page, setPage] = reactExports.useState(1);
    const { setToaster } = useToaster$1();
    const [attachmentId, setAttachmentId] = reactExports.useState("");
    const { sync, setSync } = useSync();
    const [expandDialog, setExpandDialog] = reactExports.useState(false);
    let portalId;
    if (env$1.VITE_DATA_SOURCE_SET != true) {
      portalId = (_a2 = getPortal()) == null ? void 0 : _a2.portalId;
    }
    const limit = 10;
    const { data, error, isLoading, refetch, isFetching } = useQuery({
      queryKey: ["data", page],
      queryFn: async () => await Client.notes.all({
        objectId,
        id,
        limit,
        page,
        portalId,
        cache: sync ? false : true
      }),
      onSuccess: (data2) => {
        setSync(false);
      },
      onError: (error2) => {
        setSync(false);
        console.error("Error fetching file details:", error2);
      },
      refetchInterval: sync ? env$1.VITE_NOTE_INTERVAL_TIME : false
    });
    reactExports.useEffect(() => {
      if (sync) refetch();
    }, [sync]);
    const { mutate: handleSaveNote, isLoading: isPosting } = useMutation({
      mutationKey: ["TableFormData"],
      mutationFn: async () => {
        return await Client.notes.createnote({
          objectId,
          id,
          noteBody: editorContent,
          attachmentId,
          portalId
        });
      },
      onSuccess: (response) => {
        refetch();
        setShowDialog(false);
        setToaster({
          message: response.statusMsg,
          type: "success"
        });
        setExpandDialog(false);
        setAttachmentId("");
      },
      onError: (error2) => {
        console.error("Error creating note:", error2);
        setToaster({
          message: error2.response.data.errorMessage,
          type: "error"
        });
        setAttachmentId("");
      }
    });
    const expandToggleButton = () => {
      setExpandDialog(!expandDialog);
    };
    reactExports.useEffect(() => {
      var _a3;
      const portalId2 = (_a3 = getPortal()) == null ? void 0 : _a3.portalId;
      setImageUploadUrl(
        `${env$1.VITE_PUBLIC_REST_API_ENDPOINT}/api/${hubId}/${portalId2}/hubspot-object-notes/images/${objectId}/${id}`
      );
      setAttachmentUploadUrl(
        `${env$1.VITE_PUBLIC_REST_API_ENDPOINT}/api/${hubId}/${portalId2}/hubspot-object-notes/attachments/${objectId}/${id}`
      );
    }, []);
    reactExports.useEffect(() => {
      const queryClient2 = new QueryClient();
      return () => {
        queryClient2.cancelQueries(["data"]);
        setPage(1);
      };
    }, [objectId, id]);
    reactExports.useEffect(() => {
      refetch();
      setPage(1);
    }, [id, objectId]);
    if (error && !id && objectId == "0-2" && tabName === "home") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center text-center p-4 min-h-[300px] max-h-[400px]  justify-center gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-yellow-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CautionCircle, {}) }),
        "Primary Company not found."
      ] });
    }
    if (error) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center text-center p-4 min-h-[300px] max-h-[400px]  justify-center gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-yellow-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CautionCircle, {}) }),
        (_c2 = (_b2 = error == null ? void 0 : error.response) == null ? void 0 : _b2.data) == null ? void 0 : _c2.detailedMessage
      ] });
    }
    const results = data && data.data && data.data.results;
    const totalNotes = data && data.data && data.data.total;
    const numOfPages = Math.ceil(totalNotes / limit);
    if (isLoading || isFetching) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(NoteSkeleton, {});
    }
    const getObjectName = () => {
      let displayValue = "";
      if (item) {
        for (const key2 of Object.keys(item)) {
          const valueObject = item[key2];
          if (valueObject && valueObject.isPrimaryDisplayProperty && valueObject.value) {
            displayValue = isObject$1(valueObject.value) ? valueObject.value.label : valueObject.value;
          }
        }
      }
      return displayValue || me.firstName;
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border dark:border-none dark:bg-dark-300 md:p-4 p-2 rounded-lg bg-cleanWhite ", children: [
      permissions && permissions.create && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-end mb-6 items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { variant: !recorBtnCustom ? "default" : "create", onClick: () => setShowDialog(true), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "mr-2", children: [
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(IconPlus, { className: "!w-3 !h-3" }),
          " "
        ] }),
        " ",
        "Create Note"
      ] }) }),
      results && results.rows && results.rows.length > 0 ? results.rows.map((note, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        NoteCard,
        {
          note,
          objectId,
          id,
          imageUploadUrl,
          attachmentUploadUrl,
          refetch,
          setToaster,
          permissions
        },
        index
      )) : /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyMessageCard, { name: "note" }),
      totalNotes > limit && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Pagination,
        {
          numOfPages,
          currentPage: page,
          setCurrentPage: setPage
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Dialog,
        {
          open: showDialog,
          onClose: setShowDialog,
          className: `!p-0 relative mx-auto bg-white dark:bg-white overflow-y-auto max-h-[95vh] ${expandDialog ? "lg:w-[calc(100vw-25vw)] md:w-[calc(100vw-5vw)] w-[calc(100vw-20px)]" : "lg:w-[830px] md:w-[720px] w-[calc(100vw-28px)] "} `,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sticky top-0 z-50", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center bg-[#516f90] p-4 sticky top-0 z-50", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-semibold text-white dark:text-white mb-0", children: "Note" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 items-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      disabled: isPosting || isUploading,
                      variant: "outline",
                      onClick: expandToggleButton,
                      className: "text-white dark:text-white cursor-pointer",
                      children: expandDialog ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { title: "Shrink window", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ShrinkIcon, { width: "22px", height: "22px" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { title: "Make window expand", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandIcon, { width: "22px", height: "22px" }) })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      disabled: isPosting || isUploading,
                      variant: "outline",
                      onClick: () => setShowDialog(false),
                      className: "text-white dark:text-white",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, { width: "24px", height: "24px" })
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center px-4 bg-white py-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 dark:!text-gray-600 text-xs", children: "For" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "border rounded-full px-2 py-1 text-xs ml-2 dark:!text-gray-600", children: getObjectName() })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-4 modal-editor", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              ProseMirrorEditor,
              {
                id: objectId,
                attachments: [],
                setEditorContent,
                imageUploadUrl,
                attachmentUploadUrl,
                attachmentUploadMethod: "POST",
                setAttachmentId,
                refetch,
                objectId,
                setIsUploading
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end gap-3 darkbg-[#516f90] sticky bottom-0 z-50 bg-white px-4 pb-4 pt-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  disabled: isPosting || isUploading,
                  variant: "outline",
                  onClick: () => {
                    setShowDialog(false);
                    setExpandDialog(false);
                    setAttachmentId("");
                  },
                  className: `dark:!text-white`,
                  children: "Cancel"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  disabled: isPosting || editorContent.trim() === "" || isUploading,
                  onClick: handleSaveNote,
                  isLoading: isPosting,
                  children: "Create Note"
                }
              )
            ] })
          ]
        }
      )
    ] });
  };
  const DetailsSidebarSkeleton = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: Array(4).fill("").map((_2, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-[var(--right-tables-background-color)] dark:bg-dark-300 p-4 rounded-lg animate-pulse", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bg-gray-300 dark:bg-dark-white w-20 h-4 rounded-sm" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bg-gray-500 w-4 h-2 rounded-sm" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-300 dark:bg-dark-white w-full h-4 rounded-sm mt-2" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-300 dark:bg-dark-white w-full h-4 rounded-sm mt-2" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-300 dark:bg-dark-white w-40 h-4 rounded-sm mt-2 ml-auto" })
    ] }, index)) });
  };
  const Tabs = ({ children, activeTab, setActiveTab = null, className }) => {
    const [selectedValue, setSelectedValue] = reactExports.useState(activeTab);
    const handleTabClick = (value) => {
      setSelectedValue(value);
      if (setActiveTab != null) setActiveTab(value);
    };
    const tabs = React.Children.toArray(children).filter(
      (child) => child.type === TabsList
    );
    const contents = React.Children.toArray(children).filter(
      (child) => child.type === TabsContent
    );
    if (tabs.length !== 1 || contents.length !== children.length - 1) {
      throw new Error(
        "Tabs component requires exactly one TabsList and content for each tab trigger."
      );
    }
    const filteredTabls = React.Children.toArray(tabs[0].props.children);
    const tabsList = React.Children.map(filteredTabls, (trigger) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabsTrigger,
      {
        className: "rounded-md",
        value: trigger.props.value,
        isActive: selectedValue === trigger.props.value,
        onClick: handleTabClick,
        children: trigger.props.children
      },
      trigger.props.value
    ));
    const tabContents = contents.map((content) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabsContent,
      {
        hidden: selectedValue !== content.props.value,
        children: content.props.children
      },
      content.props.value
    ));
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `Tabs ${className}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsList, { children: tabsList }),
      tabContents
    ] });
  };
  const TabsList = ({ children, className }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "ul",
    {
      className: `flex flex-wrap p-1 text-sm font-medium text-center list-none text-gray-500 dark:text-gray-400 TabsList ${className}`,
      children
    }
  );
  const TabsTrigger = ({ value, isActive, onClick, children }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "li",
    {
      className: `TabsTrigger ${isActive ? "active" : ""}`,
      role: "tab",
      "aria-selected": isActive,
      onClick: () => onClick(value),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: `inline-block px-4 py-2 rounded-md cursor-pointer mx-1 
    ${isActive ? "bg-cleanWhite dark:bg-dark-400 text-white" : "hover:bg-gray-50 dark:hover:bg-dark-500 dark:bg-dark-300"}
  `,
          "aria-current": "page",
          children
        }
      )
    }
  );
  const TabsContent = ({ value, hidden, children }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: `TabsContent ${hidden ? "hidden" : ""}`,
      role: "tabpanel",
      "aria-labelledby": `tab-${value}`,
      children
    }
  );
  const Tickets = ({
    path,
    objectId,
    id,
    parentObjectTypeId,
    parentObjectRowId,
    permissions,
    companyAsMediator,
    title,
    ticketTableTitle
  }) => {
    var _a2;
    const hubspotObjectTypeId = "0-5";
    const mediatorObjectTypeId = getParam$1("mediatorObjectTypeId");
    const mediatorObjectRecordId = getParam$1("mediatorObjectRecordId");
    const param = `?parentObjectTypeId=${objectId}&parentObjectRecordId=${id}&isPrimaryCompany=${companyAsMediator}`;
    let portalId;
    if (env$1.VITE_DATA_SOURCE_SET != true) {
      portalId = (_a2 = getPortal()) == null ? void 0 : _a2.portalId;
    }
    const detailsUrl = `?parentObjectTypeId=${parentObjectTypeId}&parentObjectRecordId=${parentObjectRowId}&mediatorObjectTypeId=${mediatorObjectTypeId ? mediatorObjectTypeId : parentObjectTypeId}&mediatorObjectRecordId=${mediatorObjectRecordId ? mediatorObjectRecordId : parentObjectRowId}&isForm=false&isPrimaryCompany=${companyAsMediator}`;
    const defaultObjectIds = JSON.parse(env$1.VITE_HUBSPOT_DEFAULT_OBJECT_IDS);
    const apis = {
      tableAPI: `/api/${hubId}/${portalId}/hubspot-object-data/${defaultObjectIds.tickets}?parentObjectTypeId=${parentObjectTypeId}&parentObjectRecordId=${parentObjectRowId}&mediatorObjectTypeId=${mediatorObjectTypeId ? mediatorObjectTypeId : parentObjectTypeId}&mediatorObjectRecordId=${mediatorObjectRecordId ? mediatorObjectRecordId : parentObjectRowId}&isPrimaryCompany=${companyAsMediator}`,
      // tableAPI: `/api/${hubId}/${portalId}/hubspot-object-data/${hubspotObjectTypeId}/${id}`,
      stagesAPI: `/api/${hubId}/${portalId}/hubspot-object-pipelines/${defaultObjectIds.tickets}/`,
      // concat pipelineId
      formAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/${defaultObjectIds.tickets}/fields?isPrimaryCompany=${companyAsMediator}&parentObjectTypeId=${parentObjectTypeId}`,
      formDataAPI: `/api/:hubId/:portalId/hubspot-object-data/${defaultObjectIds.tickets}/:objectId?parentObjectTypeId=${parentObjectTypeId}&parentObjectRecordId=${parentObjectRowId}&mediatorObjectTypeId=${mediatorObjectTypeId ? mediatorObjectTypeId : parentObjectTypeId}&mediatorObjectRecordId=${mediatorObjectRecordId ? mediatorObjectRecordId : parentObjectRowId}&isForm=true&isPrimaryCompany=${companyAsMediator}`,
      createAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/${defaultObjectIds.tickets}/fields${param}`,
      createExistingAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/:fromObjectTypeId/:fromRecordId/associations/:toObjectTypeId${param}`,
      removeExistingAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/:fromObjectTypeId/:fromRecordId/disassociate/:toObjectTypeId${param}`,
      updateAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/${defaultObjectIds.tickets}/fields/:formId${param}`
      // concat ticketId
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DynamicComponentView,
      {
        hubspotObjectTypeId,
        path,
        ticketTableTitle,
        title,
        apis,
        viewName: "ticket",
        detailsUrl,
        componentName: "ticket",
        defPermissions: permissions,
        isShowTitle: false
      }
    );
  };
  const Select = ({
    label,
    name = "",
    options = [],
    value = "",
    control,
    filled = null,
    onChangeSelect = null,
    setValue = null,
    size = "medium",
    className,
    apiEndPoint = null,
    optionlabel = "label",
    optionValue = "value",
    disabled = false,
    ...props
  }) => {
    const getValue = (value2) => {
      if (value2 && typeof value2 === "object") value2.label;
      return value2;
    };
    const handleChange = (value2) => {
      if (onChangeSelect) {
        onChangeSelect(filled, value2);
      }
      if (setValue) {
        const mValue = value2.length > 0 ? value2 : "";
        setValue(filled.name, mValue);
      }
    };
    reactExports.useEffect(() => {
      if (disabled && options.length === 1) {
        handleChange(options[0].value);
      }
    }, []);
    const heightClasses = {
      small: "p-1.5 text-xs",
      semiMedium: "py-2",
      medium: "p-2 text-sm",
      large: "py-5"
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Controller,
      {
        control,
        name,
        defaultValue: value,
        render: ({ field }) => apiEndPoint != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectApiData,
          {
            apiEndPoint,
            handleChange,
            optionlabel,
            optionValue,
            options
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "select",
          {
            ...field,
            onChange: (e) => {
              field.onChange(e);
              handleChange(e.target.value);
            },
            value: getValue(field.value),
            className: classNames(
              "w-full rounded-md bg-cleanWhite px-2 text-sm transition-colors border-2 dark:border-gray-600 focus:ring-0 focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 dark:bg-gray-700 dark:text-gray-200 dark:placeholder-gray-400 py-2",
              heightClasses[size],
              className
            ),
            disabled,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "option",
                {
                  value: "",
                  className: "dark:placeholder-gray-400  dark:text-gray-200",
                  selected: "selected",
                  disabled: true,
                  hidden: true,
                  children: label
                }
              ),
              options.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "option",
                {
                  value: getValue(option.value),
                  children: option.label
                },
                getValue(option.value)
              ))
            ]
          }
        )
      }
    );
  };
  const SelectApiData = ({
    apiEndPoint,
    handleChange,
    optionlabel,
    optionValue,
    options
  }) => {
    const [allOptions, setAllOptions] = reactExports.useState(options);
    const [filtered, setfiltered] = reactExports.useState([]);
    const [selected, setSelected] = reactExports.useState([]);
    const [input, setInput] = reactExports.useState("");
    const [showDropdown, setShowDropdown] = reactExports.useState(false);
    const wrapperRef = reactExports.useRef(null);
    const { setToaster } = useToaster$1();
    const { mutate: callAPI, isLoading } = useMutation({
      mutationKey: ["getOptionsData"],
      mutationFn: async () => {
        try {
          const response = await Client.form.options({
            API: apiEndPoint
          });
          return response;
        } catch (error) {
          throw error;
        }
      },
      onSuccess: async (response) => {
        setAllOptions(response.data.results);
      },
      onError: (error) => {
        let errorMessage = "An unexpected error occurred.";
        setToaster({ message: errorMessage, type: "error" });
      }
    });
    reactExports.useEffect(() => {
      const handleClickOutside = (event) => {
        if (wrapperRef.current && !wrapperRef.current.contains(event.target)) {
          setShowDropdown(false);
        }
      };
      document.addEventListener("mousedown", handleClickOutside);
      return () => document.removeEventListener("mousedown", handleClickOutside);
    }, []);
    const filterData = (data) => {
      const filteredData = data.filter((opt) => {
        const matched = selected.find(
          (val) => val[optionValue] === opt[optionValue]
        );
        return !matched;
      });
      setfiltered(filteredData);
    };
    reactExports.useEffect(() => {
      if (allOptions.length > 0) filterData(allOptions);
    }, [selected, allOptions]);
    const handleSelect = (value) => {
      const filtered2 = selected.find(
        (item) => item[optionValue] === value[optionValue]
      );
      if (!filtered2) {
        setSelected([...selected, value]);
        handleChange([...selected, value]);
      }
      setInput("");
      setShowDropdown(false);
    };
    const handleRemove = (value) => {
      const filtered2 = selected.filter(
        (item) => item[optionValue] !== value[optionValue]
      );
      setSelected(filtered2);
      handleChange(filtered2);
    };
    const handleRemoveAll = () => {
      setSelected([]);
      handleChange([]);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        ref: wrapperRef,
        className: "multiselected-dropdown relative w-full rounded-md bg-cleanWhite px-2 text-sm transition-colors border-2 dark:border-gray-600 focus:ring-0 focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 dark:bg-gray-700 py-1",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: "flex flex-wrap items-center",
              onClick: (e) => {
                e.stopPropagation();
                if (allOptions.length < 1) callAPI();
                setShowDropdown((prev) => !prev);
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-1 flex-wrap w-[calc(100%-40px)]", children: [
                  selected.map((tag) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "div",
                    {
                      className: "flex items-center bg-indigo-100 dark:bg-dark-300  border border-gray-300 rounded px-2 py-1 text-sm  dark:text-gray-300",
                      children: [
                        tag[optionlabel],
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "span",
                          {
                            className: "ml-1 text-gray-600 hover:text-red-500 cursor-pointer",
                            onClick: (e) => {
                              e.stopPropagation();
                              handleRemove(tag);
                            },
                            asChild: true,
                            children: ""
                          }
                        )
                      ]
                    },
                    tag[optionValue]
                  )),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      className: "flex-1 min-w-[100px] p-1 outline-none bg-transparent",
                      value: input,
                      onChange: (e) => setInput(e.target.value)
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-[40px] h-full", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-px h-full bg-gray-300" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ml-auto flex items-center space-x-1", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "span",
                      {
                        className: "text-gray-500 hover:text-red-500 text-xl cursor-pointer",
                        onClick: (e) => {
                          e.stopPropagation();
                          handleRemoveAll();
                        },
                        asChild: true,
                        children: ""
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "span",
                      {
                        className: "text-gray-500 hover:text-blue-500 text-xl cursor-pointer",
                        asChild: true,
                        children: ""
                      }
                    )
                  ] }) })
                ] })
              ]
            }
          ),
          showDropdown && isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "z-[16] absolute left-0 right-0 top-full mt-2 z-10 max-h-40 overflow-y-auto shadow rounded-md bg-cleanWhite transition-colors border dark:border-gray-600 dark:bg-gray-700", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center", children: "Loading..." }) }),
          showDropdown && filtered.length > 0 && !isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: `z-[16] absolute bottom-full mb-2 left-0 right-0 mt-2 z-10 max-h-40 overflow-y-auto shadow rounded-md bg-cleanWhite transition-colors border dark:border-gray-600 dark:bg-gray-700`,
              children: filtered.map((opt) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "px-3 py-2 hover:bg-indigo-100 dark:hover:bg-dark-300 cursor-pointer dark:text-gray-100",
                  onClick: () => handleSelect(opt),
                  children: opt[optionlabel]
                },
                opt[optionValue]
              ))
            }
          )
        ]
      }
    );
  };
  React.forwardRef(({ children, className, right }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: classNames(
        "absolute text-sm w-64 px-3 py-2 bg-cleanWhite border dark:bg-dark-300 dark:text-white  shadow-lg mt-1 z-50 rounded-md",
        { "right-8": right },
        className
      ),
      ref,
      children
    }
  ));
  React.forwardRef(({ children, className }, ref) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: classNames("w-full rounded-md text-center py-2", className),
        ref,
        children
      }
    );
  });
  const DashboardTableExistingForm = ({
    resetRef,
    setOpenModal,
    portalId,
    onSubmit,
    validationSchema,
    serverError,
    existingData,
    setAddAnother,
    submitLoading,
    onChangeSelect
  }) => {
    const [options, setOptions] = reactExports.useState([]);
    const [errorMessage, setErrorMessage] = reactExports.useState("");
    const { mutate: callAPI, isLoading } = useMutation({
      mutationKey: ["getExistingOptionsData"],
      mutationFn: async () => {
        try {
          const response = await Client.form.options({
            API: `/api/${hubId}/${portalId}/hubspot-object-forms/${existingData.formId}/${existingData.objectTypeId}`
          });
          return response;
        } catch (error) {
          throw error;
        }
      },
      onSuccess: async (response) => {
        var _a2;
        const transformed = (_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.results.map(({ label, ID }) => ({
          label,
          value: ID
        }));
        setOptions(transformed);
      },
      onError: (error) => {
        setErrorMessage(error.response.data.detailedMessage);
      }
    });
    reactExports.useEffect(() => {
      if (options.length < 1) callAPI();
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center items-center min-h-[230px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center pb-4", children: "Loading..." }) }) : errorMessage ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center text-warning pb-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: errorMessage }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4 flex justify-end items-end gap-2 flex-wrap sticky bottom-0 bg-white dark:bg-dark-200 p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outline",
          onClick: () => setOpenModal(false),
          disabled: submitLoading,
          children: "Cancel"
        }
      ) })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
      Form,
      {
        onSubmit,
        validationSchema,
        serverError,
        className: "dark:bg-dark-200 !m-0",
        children: ({ register, control, setValue, formState: { errors }, reset }) => {
          var _a2, _b2;
          resetRef.current = reset;
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-800 dark:text-gray-200", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { className: "", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { className: "text-xs font-semibold text-gray-800 dark:text-gray-300 focus:text-blue-600", children: (_a2 = existingData == null ? void 0 : existingData.labels) == null ? void 0 : _a2.plural }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Select,
                {
                  label: `Select ${(_b2 = existingData == null ? void 0 : existingData.labels) == null ? void 0 : _b2.plural}`,
                  name: existingData.name,
                  options,
                  control,
                  filled: existingData,
                  onChangeSelect,
                  apiEndPoint: `/api/${hubId}/${portalId}/hubspot-object-forms/${existingData.formId}/${existingData.objectTypeId}`,
                  setValue
                }
              ) }),
              errors[existingData.name] && /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, { className: "text-red-600 dark:text-red-400", children: errors[existingData.name].message })
            ] }) }, existingData.name) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4 flex justify-end items-end gap-2 flex-wrap sticky bottom-0 bg-white dark:bg-dark-200 p-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outline",
                  onClick: () => setOpenModal(false),
                  disabled: submitLoading,
                  children: "Cancel"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  className: " ",
                  isLoading: submitLoading,
                  onClick: () => setAddAnother(false),
                  disabled: submitLoading,
                  children: "Add"
                }
              )
            ] })
          ] });
        }
      }
    ) });
  };
  const ArrowDropDownIcon = ({ width = "34px", height = "30px", ...props }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        height,
        viewBox: "0 -960 960 960",
        width,
        fill: "#e8eaed",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M480-360 280-560h400L480-360Z" })
      }
    );
  };
  const ChevronLeftIcon = ({ width = "34px", height = "30px", ...props }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        height,
        viewBox: "0 -960 960 960",
        width,
        fill: "#e8eaed",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M560-240 320-480l240-240 56 56-184 184 184 184-56 56Z" })
      }
    );
  };
  const ChevronRightIcon = ({ width = "34px", height = "30px", ...props }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        height,
        viewBox: "0 -960 960 960",
        width,
        fill: "#e8eaed",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M504-480 320-664l56-56 240 240-240 240-56-56 184-184Z" })
      }
    );
  };
  const DatePicker = ({
    defaultValue,
    dateFormat,
    setOpenDatePicker,
    openDatePicker,
    handelChangeDate
  }) => {
    const ref = reactExports.useRef(null);
    const yearRefs = reactExports.useRef({});
    const today = defaultValue ? new Date(defaultValue) : /* @__PURE__ */ new Date();
    const [selectedDate, setSelectedDate] = reactExports.useState(today);
    const [viewDate, setViewDate] = reactExports.useState(today);
    const [open, setOpen] = reactExports.useState(false);
    const [showYearSelect, setShowYearSelect] = reactExports.useState(false);
    const [showMonthSelect, setShowMonthSelect] = reactExports.useState(false);
    reactExports.useEffect(() => {
      setOpen(openDatePicker);
    }, [openDatePicker]);
    const setChangedDateValue = (value) => {
      setViewDate(value);
      handelChangeDate(formatDate$1(value));
    };
    const months = [...Array(12)].map(
      (_2, i2) => new Date(0, i2).toLocaleString("default", { month: "long" })
    );
    const years = Array.from({ length: 100 }, (_2, i2) => 1970 + i2);
    const firstDay = new Date(
      viewDate.getFullYear(),
      viewDate.getMonth(),
      1
    ).getDay();
    const daysInMonth = new Date(
      viewDate.getFullYear(),
      viewDate.getMonth() + 1,
      0
    ).getDate();
    const prevMonthDays = new Date(
      viewDate.getFullYear(),
      viewDate.getMonth(),
      0
    ).getDate();
    const totalCells = 42;
    const calendarDays = [];
    for (let i2 = 0; i2 < totalCells; i2++) {
      const dayNumber = i2 - firstDay + 1;
      if (i2 < firstDay) {
        calendarDays.push({
          day: prevMonthDays - firstDay + i2 + 1,
          date: new Date(
            viewDate.getFullYear(),
            viewDate.getMonth() - 1,
            prevMonthDays - firstDay + i2 + 1
          ),
          currentMonth: false
        });
      } else if (dayNumber > daysInMonth) {
        calendarDays.push({
          day: dayNumber - daysInMonth,
          date: new Date(
            viewDate.getFullYear(),
            viewDate.getMonth() + 1,
            dayNumber - daysInMonth
          ),
          currentMonth: false
        });
      } else {
        calendarDays.push({
          day: dayNumber,
          date: new Date(viewDate.getFullYear(), viewDate.getMonth(), dayNumber),
          currentMonth: true
        });
      }
    }
    const handleDateClick = (dateObj) => {
      setSelectedDate(dateObj.date);
      setChangedDateValue(dateObj.date);
      setOpen(false);
      setOpenDatePicker(false);
      setShowYearSelect(false);
      setShowMonthSelect(false);
    };
    const handleYearClick = (year) => {
      const newDate = new Date(
        year,
        selectedDate.getMonth(),
        selectedDate.getDate()
      );
      setChangedDateValue(newDate);
      setSelectedDate(newDate);
      setShowYearSelect(false);
      setShowMonthSelect(false);
    };
    const handleMonthClick = (monthIndex) => {
      const newDate = new Date(viewDate.getFullYear(), monthIndex, 1);
      setChangedDateValue(newDate);
      setShowMonthSelect(false);
    };
    const handleToday = () => {
      setSelectedDate(today);
      setChangedDateValue(today);
      handelChangeDate(formatDate$1(today));
      setOpen(false);
      setOpenDatePicker(false);
    };
    const handleClear = () => {
      setSelectedDate(null);
      handelChangeDate("");
      setOpen(false);
      setOpenDatePicker(false);
    };
    reactExports.useEffect(() => {
      const handleClickOutside = (e) => {
        if (ref.current && !ref.current.contains(e.target)) {
          setOpen(false);
          setOpenDatePicker(false);
        }
      };
      document.addEventListener("mousedown", handleClickOutside);
      return () => document.removeEventListener("mousedown", handleClickOutside);
    }, []);
    reactExports.useEffect(() => {
      if (showYearSelect && yearRefs.current[viewDate.getFullYear()]) {
        yearRefs.current[viewDate.getFullYear()].scrollIntoView({
          behavior: "smooth",
          block: "center"
        });
      }
    }, [showYearSelect, viewDate]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative", ref, children: open && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white text-gray-800 rounded-lg shadow-lg p-2 w-[260px] transition-all duration-300 overflow-hidden", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-2", children: [
        showYearSelect || showMonthSelect ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "rounded-full hover:bg-gray-100 cursor-pointer",
            onClick: () => showYearSelect ? setChangedDateValue(
              new Date(
                viewDate.getFullYear() - 12,
                viewDate.getMonth(),
                1
              )
            ) : showMonthSelect ? setChangedDateValue(
              new Date(
                viewDate.getFullYear(),
                viewDate.getMonth() - 1,
                1
              )
            ) : setChangedDateValue(
              new Date(
                viewDate.getFullYear(),
                viewDate.getMonth() - 1,
                1
              )
            ),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronLeftIcon, { width: "18px", height: "18px", className: "text-gray-500" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 items-center font-medium", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              onClick: () => {
                setShowMonthSelect(!showMonthSelect);
                setShowYearSelect(false);
              },
              className: "hover:text-primary flex items-center justify-center cursor-pointer text-sm",
              children: [
                months[viewDate.getMonth()],
                " ",
                /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowDropDownIcon, { className: "text-gray-500" })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              onClick: () => {
                setShowYearSelect(!showYearSelect);
                setShowMonthSelect(false);
              },
              className: "hover:text-primary flex items-center justify-center cursor-pointer text-sm",
              children: [
                viewDate.getFullYear(),
                " ",
                /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowDropDownIcon, { className: "text-gray-500" })
              ]
            }
          )
        ] }),
        showYearSelect || showMonthSelect ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "rounded-full hover:bg-gray-100 cursor-pointer",
            onClick: () => showYearSelect ? setChangedDateValue(
              new Date(
                viewDate.getFullYear() + 12,
                viewDate.getMonth(),
                1
              )
            ) : showMonthSelect ? setChangedDateValue(
              new Date(
                viewDate.getFullYear(),
                viewDate.getMonth() + 1,
                1
              )
            ) : setChangedDateValue(
              new Date(
                viewDate.getFullYear(),
                viewDate.getMonth() + 1,
                1
              )
            ),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightIcon, { width: "18px", height: "18px", className: "text-gray-500" })
          }
        )
      ] }),
      showYearSelect ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-4 gap-2 overflow-y-auto h-[250px]", children: years.map((year) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          ref: (el) => yearRefs.current[year] = el,
          onClick: () => handleYearClick(year),
          className: `text-center py-2 cursor-pointer rounded-full text-sm ${year === viewDate.getFullYear() ? "bg-primary text-white" : "hover:bg-gray-100"}`,
          children: year
        },
        year
      )) }) : showMonthSelect ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-[250px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-3 gap-1 overflow-y-auto ", children: months.map((month, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          onClick: () => handleMonthClick(index),
          className: `text-center py-1 cursor-pointer rounded-full text-sm ${index === viewDate.getMonth() ? "bg-primary text-white" : "hover:bg-gray-100"}`,
          children: month
        },
        index
      )) }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-7 text-center text-xs text-gray-500 mb-2 font-medium", children: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"].map((d) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: d }, d)) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-7 gap-1 text-center text-xs mb-2", children: calendarDays.map((item, idx) => {
          const isSelected = selectedDate && item.date.toDateString() === selectedDate.toDateString();
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: `py-2 cursor-pointer rounded-full ${isSelected ? "bg-primary text-white" : item.currentMonth ? "hover:bg-gray-200" : "text-gray-400"}`,
              onClick: () => handleDateClick(item),
              children: item.day
            },
            idx
          );
        }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              onClick: handleToday,
              className: "w-full mr-2 py-1 bg-gray-100 hover:bg-gray-200 rounded text-center text-sm cursor-pointer",
              children: "Today"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              onClick: handleClear,
              className: "w-full ml-2 py-1 bg-gray-100 hover:bg-gray-200 rounded text-center text-sm cursor-pointer",
              children: "Clear"
            }
          )
        ] })
      ] })
    ] }) });
  };
  const TimePicker = ({
    defaultValue,
    setOpenTimePicker,
    openTimePicker,
    handelChangeTime
  }) => {
    const ref = reactExports.useRef(null);
    const [open, setOpen] = reactExports.useState(false);
    reactExports.useEffect(() => {
      setOpen(openTimePicker);
    }, [openTimePicker]);
    reactExports.useEffect(() => {
      const handleClickOutside = (e) => {
        if (ref.current && !ref.current.contains(e.target)) {
          setOpen(false);
          setOpenTimePicker(false);
        }
      };
      document.addEventListener("mousedown", handleClickOutside);
      return () => document.removeEventListener("mousedown", handleClickOutside);
    }, []);
    const generateHalfHourTimesWithGMT = () => {
      const times = [];
      for (let i2 = 0; i2 < 24 * 2; i2++) {
        const hours = Math.floor(i2 / 2);
        const minutes = i2 % 2 * 30;
        const date = new Date(Date.UTC(1970, 0, 1, hours - 5, minutes - 30));
        const formatter = new Intl.DateTimeFormat("en-US", {
          hour: "numeric",
          minute: "2-digit",
          hour12: true,
          timeZone: "Asia/Kolkata"
        });
        const gmtOffset = calculateGMToffset(date);
        const formatted = { time: formatter.format(date), timeZone: gmtOffset };
        times.push(formatted);
      }
      return times;
    };
    const timeList = generateHalfHourTimesWithGMT();
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative", ref, children: open && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: " bg-white text-gray-800 rounded-md shadow-lg w-[200px] h-[220px] transition-all duration-300 overflow-y-scroll text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "text-gray-900 ", children: timeList.map((time) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "li",
      {
        className: "w-full px-4 py-2 cursor-pointer hover:bg-secondary hover:text-white text-[12px]",
        onClick: () => {
          handelChangeTime(time);
          setOpenTimePicker(false);
        },
        children: [
          time.time,
          " ",
          time.timeZone
        ]
      }
    )) }) }) });
  };
  const usePosition = (containerSelector = ".object-create-form") => {
    const [position, setPosition] = reactExports.useState("bottom");
    const ref = reactExports.useRef(null);
    reactExports.useEffect(() => {
      const calculatePosition = () => {
        if (ref.current) {
          const inputRect = ref.current.getBoundingClientRect();
          const container = document.querySelector(containerSelector);
          if (!container) {
            setPosition("bottom");
            return;
          }
          const containerRect = container.getBoundingClientRect();
          const spaceAbove = inputRect.top - containerRect.top;
          const spaceBelow = containerRect.bottom - inputRect.bottom;
          if (spaceAbove > 340 && spaceAbove > spaceBelow) {
            setPosition("top");
          } else {
            setPosition("bottom");
          }
        }
      };
      calculatePosition();
      window.addEventListener("resize", calculatePosition);
      return () => {
        window.removeEventListener("resize", calculatePosition);
      };
    }, [containerSelector]);
    return [position, ref];
  };
  const DateTimeInput = React.forwardRef(
    ({
      className,
      type = "text",
      height = "medium",
      icon: Icon = "",
      variant = "normal",
      defaultValue = "",
      dateFormat = "dd-mm-yyyy",
      setValue,
      time = true,
      // New prop to control time picker visibility
      ...rest
    }, ref) => {
      const [openDatePicker, setOpenDatePicker] = reactExports.useState(false);
      const [openTimePicker, setOpenTimePicker] = reactExports.useState(false);
      const [inputValueDate, setInputValueDate] = reactExports.useState("");
      const [inputValueTime, setInputValueTime] = reactExports.useState("");
      const [inputValue, setInputValue] = reactExports.useState("");
      const [position, positionRef] = usePosition(".object-create-form");
      reactExports.useEffect(() => {
        if (defaultValue) {
          const formatedDateTime = formatTimestampIST(defaultValue);
          setInputValueDate(formatedDateTime.date);
          if (time) {
            setInputValueTime(formatedDateTime.time);
            setInputValue((formatedDateTime == null ? void 0 : formatedDateTime.time) ? `${formatedDateTime.date} ${formatedDateTime.time}` : formatedDateTime.date);
          } else {
            setInputValue(formatedDateTime.date);
          }
        }
      }, [defaultValue, time]);
      reactExports.useEffect(() => {
        const value = parseISTToTimestamp(inputValue).toString();
        setValue(rest.name, value === "NaN" ? "" : value);
      }, [inputValue]);
      const handelChangeDate = (date) => {
        if (time) {
          const newDateTime = inputValueTime ? `${date} ${inputValueTime}` : date;
          setInputValue(newDateTime);
        } else {
          setInputValue(date);
        }
        setInputValueDate(date);
      };
      const handelChangeTime = (time2) => {
        const newTime = `${time2.time} ${time2.timeZone}`;
        const newDateTime = `${inputValueDate} ${newTime}`;
        setInputValueTime(newTime);
        setInputValue(newDateTime);
      };
      const heightClasses = {
        small: "py-1",
        semiMedium: "py-2",
        medium: "py-2",
        large: "py-5"
      };
      const classes2 = {
        root: "w-full rounded-md bg-cleanWhite px-2 text-sm transition-colors border border-2 dark:border-gray-600 focus:ring-0 focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 dark:bg-gray-700 dark:text-gray-200 dark:placeholder-gray-400 py-2",
        normal: ""
      };
      const rootClassName = classNames(
        classes2.root,
        {
          [classes2.normal]: variant === "normal"
        },
        Icon && "pl-8",
        heightClasses[height],
        className
      );
      delete rest.className;
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: time ? "flex max-sm:flex-col gap-2" : "", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            className: "hidden",
            value: inputValue,
            ref,
            ...Object.fromEntries(
              Object.entries(rest).filter(
                ([key2]) => key2 !== "dateFormat" && key2 !== "type" && key2 !== "defaultValue"
              )
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative dark:bg-dark-300 flex items-center rounded-lg w-full", children: [
          Icon && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute left-2 top-1/2 -translate-y-1/2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "h-6 w-6 text-gray-500" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              placeholder: dateFormat.toUpperCase(),
              className: rootClassName,
              value: inputValueDate,
              onClick: () => setOpenDatePicker(!openDatePicker),
              readOnly: true
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `absolute ${position === "top" ? "bottom-full mb-2" : "top-full mt-2"} right-0 z-50`, ref: positionRef, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            DatePicker,
            {
              defaultValue,
              dateFormat,
              setOpenDatePicker,
              openDatePicker,
              handelChangeDate
            }
          ) })
        ] }),
        time && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative dark:bg-dark-300 flex items-center rounded-lg w-full", children: [
          Icon && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute left-2 top-1/2 -translate-y-1/2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "h-6 w-6 text-gray-500" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              placeholder: "HH:MM",
              className: rootClassName,
              value: inputValueTime,
              onClick: () => setOpenTimePicker(!openTimePicker),
              readOnly: true
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `absolute ${position === "top" ? "bottom-full mb-2" : "top-full mt-2"} right-0 z-50`, ref: positionRef, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            TimePicker,
            {
              defaultValue,
              setOpenTimePicker,
              openTimePicker,
              handelChangeTime
            }
          ) })
        ] })
      ] }) });
    }
  );
  const DashboardTableEditor = ({ title, value, setValue, ...rest }, ref) => {
    const [inputValue, setInputValue] = reactExports.useState("");
    const menuConfig = {
      imageUploader: false,
      attachmentUploader: false,
      proseMirrorMenuDecreaseIndent: true,
      proseMirrorMenuIncreaseIndent: true,
      proseMirrorMenuEmoji: true
    };
    reactExports.useEffect(() => {
      setValue(rest.name, inputValue);
    }, [inputValue]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ProseMirrorEditor,
      {
        ref,
        initialData: value,
        setEditorContent: setInputValue,
        id: `editor-${title}`,
        menuConfig
      },
      title
    );
  };
  const DashboardTableForm = ({
    type = "create",
    openModal,
    setOpenModal,
    title,
    path,
    portalId,
    hubspotObjectTypeId,
    apis,
    refetch,
    companyAsMediator,
    urlParam,
    parentObjectTypeId,
    parentObjectRowId,
    info,
    isShowExistingRecord = false,
    specPipeLine,
    pipeLineId
  }) => {
    const [activeTab, setActiveTab] = reactExports.useState("addNew");
    const [validationSchema, setValidationSchema] = reactExports.useState([]);
    const [properties, setProperties] = reactExports.useState([]);
    const [objects, setObjects] = reactExports.useState([]);
    const [existingData, setExistingData] = reactExports.useState(null);
    const [data, setData] = reactExports.useState([]);
    const [addAnother, setAddAnother] = reactExports.useState(false);
    const { breadcrumbs } = useBreadcrumb();
    const [dialogTitle, setDialogTitle] = reactExports.useState("");
    const [objectName, setObjectName] = reactExports.useState("");
    const { setSync } = useSync();
    const { setToaster } = useToaster$1();
    const [serverError, setServerError] = reactExports.useState(null);
    const resetRef = reactExports.useRef(null);
    const { mutate: getData, isLoading } = useMutation({
      mutationKey: ["TableFormData"],
      mutationFn: async () => {
        return await Client.form.fields({ API: apis.formAPI });
      },
      onSuccess: (response) => {
        if (response.statusCode === "200") {
          setData(response.data.results);
          setValidationSchema(createValidationSchema(response.data.results));
        }
      },
      onError: () => {
        setProperties([]);
        setObjects([]);
      }
    });
    reactExports.useEffect(() => {
      getData();
    }, []);
    const createValidationSchema = (data2) => {
      const schemaShape = {};
      data2.forEach((field) => {
        var _a2, _b2;
        const isDomain = field.name === "domain";
        if (field.requiredField && field.fieldRole === "OBJECTS") {
          schemaShape[field.name] = anyType().refine((val) => Array.isArray(val) && val.length > 0, {
            message: `${((_a2 = field == null ? void 0 : field.labels) == null ? void 0 : _a2.plural) || (field == null ? void 0 : field.customLabel) || (field == null ? void 0 : field.label)} must be a non-empty list.`
          });
        } else if ((field.requiredField || field.primaryProperty) && !isDomain) {
          schemaShape[field.name] = stringType().nonempty({
            message: `${((_b2 = field == null ? void 0 : field.labels) == null ? void 0 : _b2.plural) || (field == null ? void 0 : field.customLabel) || (field == null ? void 0 : field.label)} is required.`
          });
        } else if (isDomain) {
          schemaShape[field.name] = stringType().refine(
            (value) => {
              const domainRegex = /^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
              return domainRegex.test(value);
            },
            {
              message: "Invalid domain format"
            }
          );
        } else {
          if (field.fieldRole === "OBJECTS") {
            schemaShape[field.name] = anyType().nullable();
          } else {
            schemaShape[field.name] = stringType().nullable();
          }
        }
      });
      return objectType(schemaShape);
    };
    const { mutate: addData, isLoading: submitLoading } = useMutation({
      mutationKey: ["addData"],
      mutationFn: async ({ formData, addAnother: addAnother2 }) => {
        try {
          const mUrlParam = updateParamsFromUrl(apis.createAPI, {
            ...getQueryParamsToObject(urlParam),
            addAnother: addAnother2 ? "true" : "false"
          });
          const API_ENDPOINT = removeAllParams(apis.createAPI);
          const API = addParam(API_ENDPOINT, mUrlParam);
          const response = await Client.form.create({
            // API: `${apis.createAPI}${ apis.createAPI.includes('isPrimaryCompany') || !companyAsMediator ? `` : `?isPrimaryCompany=${companyAsMediator}`}`,
            API,
            data: formData
          });
          return response;
        } catch (error) {
          throw error;
        }
      },
      onSuccess: async (response, variables) => {
        var _a2;
        setToaster({ message: response == null ? void 0 : response.statusMsg, type: "success" });
        if (!addAnother) {
          setSync(true);
        }
        if (!variables.addAnother) {
          setOpenModal(false);
        } else {
          (_a2 = resetRef.current) == null ? void 0 : _a2.call(resetRef);
        }
      },
      onError: (error) => {
        let errorMessage = "An unexpected error occurred.";
        if (error.response && error.response.data) {
          const errorData = error.response.data.detailedMessage;
          const errors = error.response.data.validationErrors;
          setServerError(errors);
          errorMessage = typeof errorData === "object" ? JSON.stringify(errorData) : errorData;
        }
        setToaster({ message: errorMessage, type: "error" });
      }
    });
    const { mutate: addExistingData, isLoading: submitExistingDataLoading } = useMutation({
      mutationKey: ["addExistingData"],
      mutationFn: async ({ formData }) => {
        try {
          const response = await Client.form.createExisting({
            API: apis.createExistingAPI,
            params: {
              fromObjectTypeId: parentObjectTypeId,
              fromRecordId: parentObjectRowId,
              toObjectTypeId: hubspotObjectTypeId
            },
            data: formData
          });
          return response;
        } catch (error) {
          throw error;
        }
      },
      onSuccess: async (response) => {
        var _a2;
        await setToaster({ message: response == null ? void 0 : response.statusMsg, type: "success" });
        setSync(true);
        setOpenModal(false);
        (_a2 = resetRef.current) == null ? void 0 : _a2.call(resetRef);
      },
      onError: (error) => {
        let errorMessage = "An unexpected error occurred.";
        if (error.response && error.response.data) {
          const errorData = error.response.data.detailedMessage;
          const errors = error.response.data.validationErrors;
          setServerError(errors);
          errorMessage = typeof errorData === "object" ? JSON.stringify(errorData) : errorData;
        }
        setToaster({ message: errorMessage, type: "error" });
      }
    });
    const { mutate: getStags, isLoading: stageLoading } = useMutation({
      mutationKey: ["getStageData"],
      mutationFn: async (pipelineId) => {
        try {
          const response = await Client.form.stages({
            API: `${apis.stagesAPI}${pipelineId}/stages`
          });
          return response;
        } catch (error) {
          throw error;
        }
      },
      onSuccess: async (response) => {
        const updatedProperties = data.map(
          (property) => property.name === "hs_pipeline_stage" || property.name === "dealstage" ? { ...property, options: response.data } : property
        );
        console.log("updatedProperties", updatedProperties);
        setData(updatedProperties);
      },
      onError: (error) => {
        let errorMessage = "An unexpected error occurred.";
        setToaster({ message: errorMessage, type: "error" });
      }
    });
    function formPaylod(data1, data2) {
      const propertyNames = data1.filter((item) => item.fieldRole === "PROPERTIES").map((item) => item.name);
      const objectNames = data1.filter((item) => item.fieldRole === "OBJECTS").map((item) => item.name);
      const objects2 = data1.filter((item) => item.fieldRole === "OBJECTS");
      const objectTypeMap = objects2.reduce((acc, obj) => {
        acc[obj.name] = obj.objectTypeId;
        return acc;
      }, {});
      const propertyPayload = {};
      const objectPayload = [];
      for (const key2 in data2) {
        if (propertyNames.includes(key2) && !objectNames.includes(key2)) {
          propertyPayload[key2] = data2[key2];
        } else if (objectNames.includes(key2)) {
          const value = data2[key2];
          const recordId = Array.isArray(value) ? value.map((v) => v.ID) : [];
          objectPayload.push({
            objectTypeId: objectTypeMap[key2],
            recordId
          });
        }
      }
      objects2.forEach((obj) => {
        if (!objectPayload.find((o) => o.objectTypeId === obj.objectTypeId)) {
          objectPayload.push({
            objectTypeId: obj.objectTypeId,
            recordId: []
          });
        }
      });
      return {
        propertyPayload,
        objectPayload
      };
    }
    const onSubmit = (formData) => {
      if (activeTab === "addExisting") {
        const key2 = Object.keys(formData)[0];
        const payload = {
          addIds: formData[key2].map((item) => Number(item.value))
        };
        addExistingData({ formData: payload });
      } else {
        const payload = formPaylod(data, formData);
        addData({ formData: payload, addAnother });
      }
    };
    const onChangeSelect = (filled, selectedValue) => {
      if (filled.name === "hs_pipeline" || filled.name === "pipeline") {
        getStags(selectedValue);
      }
    };
    const onChangeActiveTab = (active) => {
      setActiveTab(active);
      if (active === "addExisting") {
        const data2 = {
          name: title,
          labels: {
            singular: title,
            plural: title
          },
          objectTypeId: hubspotObjectTypeId,
          requiredField: true,
          formId: (info == null ? void 0 : info.parentDefaultForm) || (info == null ? void 0 : info.defaultForm),
          fieldRole: "OBJECTS"
        };
        setExistingData(data2);
        setValidationSchema(createValidationSchema([{ ...data2 }]));
      }
    };
    const nameTrancate = (name) => {
      return name.length > 30 ? `${(name == null ? void 0 : name.slice(0, 30)) + "..."}` : name;
    };
    reactExports.useEffect(() => {
      var _a2;
      const last2 = breadcrumbs[breadcrumbs.length - 1];
      if (type === "association" && breadcrumbs && breadcrumbs.length > 0) {
        setObjectName(title);
        setDialogTitle(`${activeTab == "addNew" ? `Create a new ${title} for ${nameTrancate(last2.name)}` : `Associate an Existing ${title} with ${nameTrancate(last2.name)}`}`);
      } else {
        const singularLastName = ((_a2 = last2 == null ? void 0 : last2.name) == null ? void 0 : _a2.endsWith("s")) ? last2 == null ? void 0 : last2.name.slice(0, -1) : last2 == null ? void 0 : last2.name;
        setObjectName(singularLastName);
        setDialogTitle(`${activeTab == "addNew" ? `Create a new ${title.includes("with") ? nameTrancate(title == null ? void 0 : title.replace("with", "for")) : nameTrancate(title)}` : `Associate an Existing ${nameTrancate(title)}`}`);
      }
    }, [breadcrumbs, activeTab]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Dialog,
      {
        open: openModal,
        onClose: setOpenModal,
        className: "bg-cleanWhite dark:bg-dark-200  rounded-md max-h-[95vh] lg:w-[830px] md:w-[720px] w-[calc(100vw-28px)] overflow-y-auto px-4 !py-0 object-create-form",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: " py-4 sticky top-0 bg-white dark:bg-dark-200 z-[15]", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-start text-xl dark:text-white font-semibold ", children: dialogTitle }),
            (type === "association" || type === "association_new") && isShowExistingRecord && // <div className="border dark:border-none rounded-lg  bg-graySecondary dark:bg-dark-300 border-flatGray w-fit dark:border-gray-700 my-4">
            //   <Tabs
            //     activeTab={activeTab}
            //     setActiveTab={onChangeActiveTab}
            //     onValueChange={onChangeActiveTab}
            //     className="rounded-md "
            //   >
            //     <TabsList>
            //       <TabsTrigger className="rounded-md !bg-primary" value="addNew">
            //         <p className="text-black dark:text-white">
            //           Create New {objectName}
            //         </p>
            //       </TabsTrigger>
            //       <TabsTrigger className="rounded-md !bg-primary" value="addExisting">
            //         <p className="text-black dark:text-white">
            //           Add Existing {objectName}
            //         </p>
            //       </TabsTrigger>
            //     </TabsList>
            //     <TabsContent value="addNew"></TabsContent>
            //     <TabsContent value="addExisting"></TabsContent>
            //   </Tabs>
            // </div>
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: " grid grid-cols-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Button,
                {
                  onClick: () => onChangeActiveTab("addNew"),
                  variant: activeTab == "addNew" ? "default" : "outline",
                  className: `w-full !rounded-none ${activeTab != "addNew" ? "dark:hover:!bg-dark-500 dark:!bg-dark-300 border-primary dark:border-[#e5e7eb]" : ""}`,
                  children: [
                    "Create New ",
                    objectName
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Button,
                {
                  onClick: () => onChangeActiveTab("addExisting"),
                  variant: activeTab == "addExisting" ? "default" : "outline",
                  className: `w-full !rounded-none ${activeTab != "addExisting" ? "dark:hover:!bg-dark-500 dark:!bg-dark-300 border-primary dark:border-[#e5e7eb]" : ""}`,
                  children: [
                    "Add Existing ",
                    objectName
                  ]
                }
              )
            ] })
          ] }),
          isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loader-line" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full text-left", children: activeTab === "addNew" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            Form,
            {
              onSubmit,
              validationSchema,
              serverError,
              className: "dark:bg-dark-200 !m-0",
              children: ({
                register,
                control,
                setValue,
                formState: { errors },
                reset,
                getValues
              }) => {
                resetRef.current = () => {
                  const currentValues = getValues();
                  reset();
                  data.forEach((field) => {
                    if (field == null ? void 0 : field.hidden) {
                      setValue(field.name, currentValues[field.name]);
                    }
                  });
                };
                return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-800 dark:text-gray-200", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4", children: data.map((filled) => {
                    var _a2, _b2;
                    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: filled.fieldRole === "PROPERTIES" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { className: `${(filled == null ? void 0 : filled.hidden) ? "hidden" : "visible"}`, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { className: "text-xs font-semibold text-gray-800 dark:text-gray-300 focus:text-blue-600", children: filled.customLabel }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: filled.fieldType == "select" || filled.fieldType == "checkbox" || filled.fieldType == "radio" || filled.name == "dealstage" && filled.fieldType == "radio" && hubspotObjectTypeId === env$1.VITE_HUBSPOT_DEFAULT_OBJECT_IDS.deals ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Select,
                        {
                          label: `Select ${filled.customLabel}`,
                          name: filled.name,
                          options: (filled.name === "hs_pipeline" || filled.name === "pipeline") && specPipeLine ? filled.options.filter((option) => option.value === pipeLineId) : filled.options,
                          control,
                          filled,
                          onChangeSelect,
                          disabled: filled == null ? void 0 : filled.hidden,
                          setValue: (filled == null ? void 0 : filled.hidden) ? setValue : null
                        }
                      ) : filled.fieldType === "textarea" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Textarea,
                        {
                          height: "medium",
                          placeholder: filled.customLabel,
                          className: "w-full rounded-md bg-cleanWhite px-2 text-sm transition-colors border-2 dark:border-gray-600 focus:ring-0 focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 dark:bg-gray-700 dark:text-gray-200 dark:placeholder-gray-400 py-2",
                          ...register(filled.name)
                        }
                      ) : filled.fieldType === "html" ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "create-object-editor", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardTableEditor,
                        {
                          title: filled.label,
                          value: filled.value,
                          setValue,
                          ...register(filled.name)
                        }
                      ) }) : filled.fieldType === "date" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DateTimeInput,
                        {
                          type: filled.type,
                          dateFormat: "dd-mm-yyyy",
                          height: "small",
                          className: "",
                          setValue,
                          defaultValue: "",
                          ...register(filled.name)
                        }
                      ) : filled.fieldType === "number" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Input,
                        {
                          type: "number",
                          placeholder: filled.customLabel,
                          className: "",
                          ...register(filled.name)
                        }
                      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Input,
                        {
                          placeholder: filled.customLabel,
                          className: "",
                          ...register(filled.name)
                        }
                      ) }) }),
                      errors[filled.name] && /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, { className: "text-red-600 dark:text-red-400", children: errors[filled.name].message })
                    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { className: "", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { className: "text-xs font-semibold text-gray-800 dark:text-gray-300 focus:text-blue-600", children: (filled == null ? void 0 : filled.label) || ((_a2 = filled == null ? void 0 : filled.labels) == null ? void 0 : _a2.plural) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Select,
                        {
                          label: `Select ${(filled == null ? void 0 : filled.label) || ((_b2 = filled == null ? void 0 : filled.labels) == null ? void 0 : _b2.plural)}`,
                          name: filled.name,
                          options: [],
                          control,
                          filled,
                          onChangeSelect,
                          apiEndPoint: `/api/${hubId}/${portalId}/hubspot-object-forms/${filled == null ? void 0 : filled.formId}/${filled == null ? void 0 : filled.objectTypeId}`,
                          optionlabel: "label",
                          optionValue: "ID",
                          setValue
                        }
                      ) }),
                      errors[filled.name] && /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, { className: "text-red-600 dark:text-red-400", children: errors[filled.name].message })
                    ] }) }, filled.name);
                  }) }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4 flex justify-end items-end gap-2 flex-wrap sticky bottom-0 bg-white dark:bg-dark-200 p-4", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        variant: "outline",
                        onClick: () => setOpenModal(false),
                        disabled: submitLoading,
                        children: "Cancel"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        className: " ",
                        isLoading: submitLoading && !addAnother,
                        onClick: () => setAddAnother(false),
                        disabled: submitLoading,
                        children: "Create"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        className: " ",
                        isLoading: submitLoading && addAnother,
                        onClick: () => setAddAnother(true),
                        disabled: submitLoading,
                        children: "Create and add another"
                      }
                    )
                  ] })
                ] });
              }
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            DashboardTableExistingForm,
            {
              resetRef,
              setOpenModal,
              portalId,
              onSubmit,
              validationSchema,
              serverError,
              existingData,
              setAddAnother,
              submitLoading: submitExistingDataLoading,
              onChangeSelect,
              title: title.includes("with") ? title.replace("with", "") : title
            }
          ) })
        ] })
      }
    ) });
  };
  const IconTickSmall = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { fill: "none", viewBox: "0 0 15 15", height: "1rem", width: ".825rem", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      stroke: "currentColor",
      strokeLinecap: "square",
      d: "M1 7l4.5 4.5L14 3"
    }
  ) });
  const TickIcon = (props) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ...props,
        xmlns: "http://www.w3.org/2000/svg",
        x: "0px",
        y: "0px",
        width: "100",
        height: "100",
        viewBox: "0 0 48 48",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              fill: "#c8e6c9",
              d: "M44,24c0,11.045-8.955,20-20,20S4,35.045,4,24S12.955,4,24,4S44,12.955,44,24z"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              fill: "#4caf50",
              d: "M34.586,14.586l-13.57,13.586l-5.602-5.586l-2.828,2.828l8.434,8.414l16.395-16.414L34.586,14.586z"
            }
          )
        ]
      }
    );
  };
  const OutlineSearch = ({
    color = "currentColor",
    width = "12px",
    height = "12px",
    ...props
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        width: "1em",
        height: "1em",
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            fill: "currentColor",
            d: "M15.5 14h-.79l-.28-.27A6.47 6.47 0 0 0 16 9.5A6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5S14 7.01 14 9.5S11.99 14 9.5 14"
          }
        )
      }
    );
  };
  const CheckboxField = ({ editRow, saveData, setValue, name, control, setSelectedValues, selectedValues = [] }) => {
    const [isDropdownOpen, setDropdownOpen] = reactExports.useState(false);
    const [searchTerm, setSearchTerm] = reactExports.useState("");
    const dropdownRef = reactExports.useRef(null);
    const searchInputRef = reactExports.useRef(null);
    const handleCheckboxChange = (value) => {
      let updatedValues = [...selectedValues];
      if (updatedValues.includes(value)) {
        updatedValues = updatedValues.filter((item) => item !== value);
      } else {
        updatedValues.push(value);
      }
      setSelectedValues(updatedValues);
      setValue(name, updatedValues);
      handleSave(updatedValues);
    };
    const handleSave = (updatedValues) => {
      const selectedLabels = updatedValues.map(
        (value) => {
          var _a2;
          return (_a2 = editRow.options.find((option) => option.value === value)) == null ? void 0 : _a2.label;
        }
      );
      const savedData = {
        [editRow.key]: selectedLabels.join(";")
      };
      return savedData;
    };
    const toggleDropdown = () => setDropdownOpen((prev) => !prev);
    const handleOutsideClick = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setDropdownOpen(false);
      }
    };
    const filteredOptions = editRow.options.filter(
      (option) => option.label.toLowerCase().includes(searchTerm.toLowerCase())
    );
    reactExports.useEffect(() => {
      document.addEventListener("mousedown", handleOutsideClick);
      return () => {
        document.removeEventListener("mousedown", handleOutsideClick);
      };
    }, []);
    reactExports.useEffect(() => {
      var _a2;
      if (isDropdownOpen) {
        (_a2 = searchInputRef.current) == null ? void 0 : _a2.focus();
      }
    }, [isDropdownOpen]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "border relative dark:border-gray-600 rounded text-xs p-2 !pr-4 cursor-pointer flex flex-wrap gap-2 items-center min-h-[43px]",
          onClick: toggleDropdown,
          children: [
            selectedValues.length > 0 ? selectedValues.map(
              (value) => {
                var _a2;
                return value && value !== "" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "span",
                  {
                    className: "border border-secondary px-1 py-1 rounded flex items-center",
                    children: [
                      ((_a2 = editRow.options.find((option) => option.value === value)) == null ? void 0 : _a2.label) || value,
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "span",
                        {
                          className: "cursor-pointer inline ml-2",
                          onClick: (e) => {
                            e.stopPropagation();
                            handleCheckboxChange(value);
                          },
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, { className: "w-4 h-4 text-blue-700" })
                        }
                      )
                    ]
                  },
                  value
                ) : null;
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-400", children: "Select options..." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-auto absolute top-1/2 right-1 transform -translate-y-1/2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Chevron, { transform: `${isDropdownOpen ? "rotate(90)" : "rotate(270)"}`, className: `w-4 h-4 transition-transform -webkit-transform` }) })
          ]
        }
      ),
      isDropdownOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          ref: dropdownRef,
          className: "absolute left-1/2 transform -translate-x-1/2 bg-white dark:bg-dark-200 border dark:border-gray-600 rounded shadow-md mt-2 z-10 w-full min-w-[275px] max-h-40 overflow-y-auto",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(OutlineSearch, { className: "absolute left-1 top-1/2 transform -translate-y-1/2 w-5 h-5 text-gray-500" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  ref: searchInputRef,
                  type: "text",
                  placeholder: "Search...",
                  value: searchTerm,
                  onChange: (e) => setSearchTerm(e.target.value),
                  className: "w-full py-1 pl-8 pr-4 rounded-sm border dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-primary-500"
                }
              )
            ] }) }),
            filteredOptions.length > 0 ? filteredOptions.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "label",
              {
                className: "flex items-center p-2 hover:bg-gray-100 hover:dark:bg-dark-300 cursor-pointer",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "checkbox",
                      checked: selectedValues.includes(option.value),
                      onChange: () => handleCheckboxChange(option.value),
                      className: "mr-2"
                    }
                  ),
                  option.label
                ]
              },
              option.value
            )) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-2 text-gray-400", children: "No options match your search." })
          ]
        }
      )
    ] });
  };
  const DetailsViewEditor = ({
    openModal,
    setOpenModal,
    title,
    value,
    setEditRow,
    name,
    setValue,
    objectId,
    id,
    urlParam,
    refetch
  }) => {
    const editorRef = reactExports.useRef(null);
    const [expandDialog, setExpandDialog] = reactExports.useState(false);
    const { setToaster } = useToaster$1();
    const [editorContent, setEditorContent] = reactExports.useState(value);
    const menuConfig = {
      imageUploader: false,
      attachmentUploader: false,
      proseMirrorMenuDecreaseIndent: true,
      proseMirrorMenuIncreaseIndent: true,
      proseMirrorMenuEmoji: true
    };
    const { mutate: saveData, isLoading } = useMutation({
      mutationKey: ["saveData"],
      mutationFn: async (payload) => {
        try {
          const response = await Client.details.update({
            data: {
              [name]: editorContent
            },
            params: {
              objectTypeId: objectId,
              recordId: id
            },
            queryParams: urlParam
          });
          return response;
        } catch (error) {
          throw error;
        }
      },
      onSuccess: async (data) => {
        refetch();
        setEditRow(null);
        setToaster({ message: data.statusMsg, type: "success" });
      },
      onError: (error) => {
        let errorMessage = "An unexpected error occurred.";
        setToaster({ message: errorMessage, type: "error" });
      }
    });
    const expandToggleButton = () => {
      setExpandDialog(!expandDialog);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Dialog,
      {
        open: openModal,
        onClose: setOpenModal,
        className: `!p-0 relative mx-auto bg-white dark:bg-white overflow-y-auto max-h-[95vh] ${expandDialog ? "lg:w-[calc(100vw-25vw)] md:w-[calc(100vw-5vw)] w-[calc(100vw-20px)]" : "lg:w-[830px] md:w-[720px] w-[calc(100vw-28px)] "} `,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-4 bg-[#516f90] p-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-lg font-semibold text-white dark:text-white mb-0", children: [
              "Edit ",
              title
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  disabled: isLoading,
                  variant: "outline",
                  onClick: expandToggleButton,
                  className: "text-white dark:text-white cursor-pointer",
                  children: expandDialog ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { title: "Shrink window", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ShrinkIcon, { width: "22px", height: "22px" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { title: "Make window expand", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandIcon, { width: "22px", height: "22px" }) })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  disabled: isLoading,
                  variant: "outline",
                  onClick: () => setEditRow(null),
                  className: "text-white dark:text-white",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, { width: "24px", height: "24px" })
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "px-4 pb-4 updateRichText", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ProseMirrorEditor,
              {
                ref: editorRef,
                initialData: editorContent,
                setEditorContent,
                id: `editor-${title}`,
                menuConfig
              },
              title
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4 flex justify-end gap-3 darkbg-[#516f90] ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  disabled: isLoading,
                  variant: "outline",
                  onClick: () => {
                    setEditRow(null);
                    setExpandDialog(false);
                  },
                  className: `dark:!text-white`,
                  children: "Cancel"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  disabled: isLoading,
                  onClick: () => saveData(),
                  isLoading,
                  children: "Save"
                }
              )
            ] })
          ] })
        ]
      }
    ) });
  };
  const DetailsViewUpdateDD = ({
    control,
    optionData,
    data,
    objectTypeId,
    onChangeSelect = null
  }) => {
    const { setToaster } = useToaster$1();
    const [options, setOptions] = reactExports.useState([]);
    const getValue = (value, type = "label") => {
      if (value && typeof value === "object")
        return type === "label" ? value.label : value.value;
      return value;
    };
    const { mutate: getStags, isLoading } = useMutation({
      mutationKey: ["getStageData1"],
      mutationFn: async (props) => {
        const { pipelineId, isNewValue } = props;
        try {
          const response = await Client.details.stages({
            params: {
              objectTypeId,
              pipelineId
            }
          });
          return response;
        } catch (error) {
          throw error;
        }
      },
      onSuccess: async (response) => {
        setOptions([]);
        setOptions((value) => response.data);
      },
      onError: (error) => {
        let errorMessage = "An unexpected error occurred.";
        setToaster({ message: errorMessage, type: "error" });
      }
    });
    reactExports.useEffect(() => {
      if (!optionData.apidata && ((optionData == null ? void 0 : optionData.key) === "dealstage" || (optionData == null ? void 0 : optionData.key) === "hs_pipeline_stage")) {
        const dataLoop = typeof data === "object" && !Array.isArray(data) ? Object.keys(data) : data;
        const found2 = dataLoop.find(
          (item) => item.key === "hs_pipeline" || item.key === "pipeline"
        );
        if (found2) getStags({ pipelineId: getValue(found2.value, "value"), isNewValue: true, setValue: null });
      } else {
        setOptions(optionData.options);
      }
    }, [data, optionData]);
    if (isLoading) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Loading" });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Select,
      {
        label: `Select`,
        size: "semiMedium",
        name: optionData.key,
        options,
        control,
        filled: optionData,
        onChangeSelect
      }
    ) });
  };
  const DetailsViewUpdateDialog = ({
    setEditRow,
    pipelineDialog,
    setPipelineDialog,
    objectId,
    value,
    editRow,
    data,
    saveData,
    isLoading,
    setEditRowKey
  }) => {
    const [initialValues, setInitialValues] = reactExports.useState(null);
    const [pipelines, setPipelines] = reactExports.useState(null);
    const [stages, setStages] = reactExports.useState({ options: [], key: "" });
    const [isDealEdit, setIsDealEdit] = reactExports.useState(false);
    const { setToaster } = useToaster$1();
    const getValue = (value2, type = "label") => {
      if (value2 && typeof value2 === "object")
        return type === "label" ? value2.label : value2.value;
      return value2;
    };
    const { mutate: getStags, isLoading: sdfsf } = useMutation({
      mutationKey: ["getStageData1"],
      mutationFn: async (props) => {
        const { pipelineId, isNewValue, setValue } = props;
        try {
          const response = await Client.details.stages({
            params: {
              objectTypeId: objectId,
              pipelineId
            }
          });
          return { response, pipelineId, isNewValue, setValue };
        } catch (error) {
          throw error;
        }
      },
      onSuccess: async ({ response, pipelineId, isNewValue, setValue }) => {
        const key2 = isDealEdit ? "dealstage" : "hs_pipeline_stage";
        setStages({
          options: response.data,
          // "isSecondaryDisplayProperty":true,
          // "label":"Ticket status",
          // value: { label: "New", value: "987017750" },
          // "isEditableField":true,
          // "fieldType":"select",
          // "isPrimaryDisplayProperty":false,
          key: key2,
          apidata: true
        });
        if (isNewValue) {
          const defaultItem = response.data.find((item) => item.defaultItem === true);
          setValue(key2, (defaultItem == null ? void 0 : defaultItem.value) || "");
        }
      },
      onError: (error) => {
        let errorMessage = "An unexpected error occurred.";
        setToaster({ message: errorMessage, type: "error" });
      }
    });
    reactExports.useEffect(() => {
      if (initialValues) {
        setPipelines(editRow);
        if (editRow.value) {
          const dataLoop = typeof data === "object" && !Array.isArray(data) ? Object.keys(data) : data;
          const filterStage = dataLoop.find(
            (item) => (
              // item.key === "hs_pipeline_stage" || item.key === "dealstage" || item.key === "pipeline"
              item.key === "hs_pipeline_stage" || item.key === "dealstage"
            )
          );
          if ((filterStage == null ? void 0 : filterStage.key) == "dealstage") {
            setIsDealEdit(true);
          }
          setStages(filterStage);
        }
      } else {
        setPipelines(editRow);
      }
    }, [initialValues]);
    reactExports.useEffect(() => {
      const dataLoop = typeof data === "object" && !Array.isArray(data) ? Object.keys(data) : data;
      const filterStage = dataLoop.find(
        (item) => (
          // item.key === "hs_pipeline_stage" || item.key === "pipeline" || item.key === "dealstage"
          item.key === "hs_pipeline_stage" || item.key === "dealstage"
        )
      );
      let defValue = {};
      defValue[editRow.key] = getValue(editRow.value, "value");
      if (filterStage) {
        defValue[filterStage.key] = getValue(filterStage.value, "value");
      } else {
        defValue["hs_pipeline_stage"] = null;
      }
      setInitialValues(defValue);
    }, []);
    const createValidationSchemaPipeline = (data2) => {
      const schemaShape = {};
      schemaShape[value.key] = z$2.string().nonempty({
        message: `${value.customLabel || value.label} is required.`
      });
      const dataLoop = typeof data2 === "object" && !Array.isArray(data2) ? Object.keys(data2) : data2;
      dataLoop.forEach((field) => {
        if (field.key === "hs_pipeline_stage" || field.key === "pipeline" || field.key === "dealstage") {
          schemaShape[field.key] = z$2.string().nonempty({
            message: `${field.customLabel || field.label} is required.`
          });
        }
      });
      if (!Object.prototype.hasOwnProperty.call(schemaShape, "dealstage") && !Object.prototype.hasOwnProperty.call(schemaShape, "hs_pipeline_stage")) {
        schemaShape["hs_pipeline_stage"] = z$2.string().nonempty({
          message: `Stage is required.`
        });
      }
      return z$2.object(schemaShape);
    };
    const validationSchemaPipeline = createValidationSchemaPipeline(data);
    const onSubmitPipeline = (data2) => {
      saveData(data2);
    };
    const onChangeSelect = (value2, setValue) => {
      getStags({ pipelineId: value2, isNewValue: true, setValue });
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Dialog,
      {
        open: pipelineDialog,
        onClose: () => setPipelineDialog(false),
        className: "",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-md lg:w-[480px] md:w-[410px] w-[calc(100vw-60px)]  flex-col gap-6 flex", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-start text-xl dark:text-white font-semibold", children: "Select Pipeline" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: initialValues && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Form,
            {
              onSubmit: onSubmitPipeline,
              validationSchema: validationSchemaPipeline,
              initialValues,
              className: "dark:bg-dark-500 m-0",
              children: ({
                getValues,
                register,
                control,
                watch,
                formState: { errors },
                setValue
              }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-gray-800 dark:text-gray-200 text-left flex flex-col gap-2", children: [
                  pipelines && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { className: "", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { className: "text-xs font-semibold text-gray-800 dark:text-gray-300 focus:text-blue-600", children: "Select Pipeline" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DetailsViewUpdateDD,
                      {
                        label: `Select Pipeline`,
                        optionData: pipelines,
                        control,
                        data,
                        objectTypeId: objectId,
                        onChangeSelect: (fvalue, value2) => onChangeSelect(value2, setValue)
                      }
                    ) }),
                    errors.hs_pipeline && /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, { className: "text-red-600 dark:text-red-400", children: errors.hs_pipeline.message })
                  ] }) }),
                  stages && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { className: "", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { className: "text-xs font-semibold text-gray-800 dark:text-gray-300 focus:text-blue-600", children: "Select Stage" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DetailsViewUpdateDD,
                      {
                        label: `Select Stage`,
                        optionData: stages,
                        control,
                        data,
                        objectTypeId: objectId
                      }
                    ) }),
                    errors.hs_pipeline_stage && /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, { className: "text-red-600 dark:text-red-400", children: errors.hs_pipeline_stage.message })
                  ] }) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4 flex justify-end items-end gap-1", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      variant: "outline",
                      disabled: isLoading,
                      onClick: () => {
                        setPipelineDialog(false);
                        setEditRow(null);
                        setEditRowKey(null);
                      },
                      children: "Cancel"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: " ", isLoading, children: "Save" })
                ] })
              ] })
            }
          ) })
        ] })
      }
    );
  };
  const DetailsViewUpdate = ({
    renderValue,
    objectId,
    id,
    refetch,
    value,
    item,
    urlParam,
    isUpdating,
    setIsUpdating,
    editRowKey,
    setEditRowKey
  }) => {
    const [editRow, setEditRow] = reactExports.useState(null);
    const { setToaster } = useToaster$1();
    const [pipelineDialog, setPipelineDialog] = reactExports.useState(false);
    const [data, setData] = reactExports.useState([]);
    const [stages, setStages] = reactExports.useState(null);
    const [initialValues, setInitialValues] = reactExports.useState(false);
    const [selectedValues, setSelectedValues] = reactExports.useState();
    reactExports.useEffect(() => {
      if (typeof item === "object" && !Array.isArray(item)) {
        let arrayKeys = Object.keys(item);
        let dataArray = [];
        arrayKeys.forEach((element) => {
          dataArray.push({ ...item[element], key: element });
        });
        setData(dataArray);
      } else {
        setData(item);
      }
    }, [item]);
    const getValue = (value2, type = "label") => {
      if (value2 && typeof value2 === "object")
        return type === "label" ? value2.label : value2.value;
      return value2;
    };
    const createValidationSchema = (data2) => {
      const schemaShape = {};
      schemaShape[value.key] = z$2.string().nonempty({
        message: `${value.label} is required.`
      });
      return z$2.object(schemaShape);
    };
    const validationSchema = createValidationSchema();
    const { mutate: saveData, isLoading } = useMutation({
      mutationKey: ["saveData"],
      mutationFn: async (payload) => {
        try {
          const response = await Client.details.update({
            data: payload,
            params: {
              objectTypeId: objectId,
              recordId: id
            },
            queryParams: urlParam
          });
          return response;
        } catch (error) {
          throw error;
        }
      },
      onSuccess: async (data2) => {
        setPipelineDialog(false);
        setEditRow(null);
        refetch();
        setToaster({ message: data2.statusMsg, type: "success" });
        setIsUpdating(false);
        setEditRowKey(null);
      },
      onError: (error) => {
        let errorMessage = "An unexpected error occurred.";
        setToaster({ message: errorMessage, type: "error" });
        setIsUpdating(false);
        setEditRowKey(null);
      }
    });
    reactExports.useEffect(() => {
      if (setIsUpdating) {
        setIsUpdating(isLoading);
      }
    }, [isLoading, setIsUpdating]);
    const setEditRowValueFunction = (row) => {
      if (row && (row.key === "hs_pipeline" || row.key === "pipeline")) {
        setPipelineDialog(true);
      }
      if (row && row.fieldType === "checkbox") {
        setSelectedValues(
          Array.isArray(row.value) ? row.value.map((item2) => item2.value) : []
        );
      }
      setEditRow(row);
      const mValue = value.value;
      setInitialValues({
        [value.key]: typeof mValue === "object" && mValue !== null && "value" in mValue ? mValue.value : mValue
      });
    };
    reactExports.useEffect(() => {
    }, [selectedValues]);
    const onSubmit = (data2) => {
      if (!data2 && editRow.fieldType != "checkbox") {
        return;
      }
      if (editRow.fieldType === "checkbox") {
        const formattedData = {
          [editRow.key]: selectedValues.map(
            (value2) => {
              var _a2;
              return (_a2 = editRow.options.find((option) => option.value === value2)) == null ? void 0 : _a2.value;
            }
          ).join(";")
        };
        saveData(formattedData);
      } else {
        saveData(data2);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "gap-2", children: editRow && !pipelineDialog ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Form,
        {
          onSubmit,
          validationSchema,
          initialValues,
          className: " m-0",
          children: ({ register, control, setValue, formState: { errors } }) => {
            var _a2;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 w-full items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-800 flex-1 dark:text-gray-200", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { className: "!mb-0 w-full", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: editRow.fieldType === "select" || editRow.fieldType === "radio" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DetailsViewUpdateDD,
                  {
                    optionData: editRow,
                    control,
                    data,
                    objectTypeId: objectId
                  }
                ) : editRow.fieldType === "textarea" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Textarea,
                  {
                    rows: "4",
                    placeholder: `Enter ${editRow.label}`,
                    defaultValue: getValue(editRow.value),
                    ...register(editRow.key)
                  }
                ) : editRow.fieldType === "html" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DetailsViewEditor,
                  {
                    openModal: true,
                    setOpenModal: null,
                    title: editRow.label,
                    value: editRow.value,
                    setEditRow,
                    saveData,
                    control,
                    setValue,
                    name: editRow.key,
                    isLoading,
                    objectId,
                    id,
                    urlParam,
                    refetch
                  }
                ) : editRow.fieldType === "checkbox" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  CheckboxField,
                  {
                    editRow,
                    saveData,
                    control,
                    setValue,
                    name: editRow.key,
                    setSelectedValues,
                    selectedValues: selectedValues || []
                  }
                ) : editRow.fieldType === "date" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DateTimeInput,
                  {
                    type: editRow.type,
                    dateFormat: "dd-mm-yyyy",
                    height: "small",
                    className: "",
                    setValue,
                    defaultValue: editRow.value,
                    ...register(editRow.key)
                  }
                ) : editRow.fieldType === "number" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    type: "number",
                    placeholder: `Enter ${editRow.label}`,
                    height: "small",
                    className: "",
                    defaultValue: getValue(editRow.value),
                    ...register(editRow.key)
                  }
                ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    placeholder: `Enter ${editRow.label}`,
                    height: "small",
                    className: "",
                    defaultValue: getValue(editRow.value),
                    ...register(editRow.key)
                  }
                ) }),
                editRow.fieldType != "checkbox" && errors[editRow.key] && /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, { className: "text-red-600 dark:text-red-400", children: (_a2 = errors[editRow.key]) == null ? void 0 : _a2.message })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "hubSpot",
                    size: "hubSpot",
                    isLoading,
                    onClick: () => onSubmit(),
                    disabled: isLoading && isUpdating,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-secondary dark:text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconTickSmall, {}) })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "hubSpot",
                    size: "hubSpot",
                    onClick: () => {
                      setEditRow(null);
                      setEditRowKey(null);
                    },
                    disabled: isLoading,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-secondary dark:text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {}) })
                  }
                )
              ] })
            ] });
          }
        }
      ) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: renderValue || "--" }),
        value.isEditableField && (value.key === "pipeline" || value.key === "hs_pipeline") && value.options.length < 2 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "hubSpot",
            size: "hubSpot",
            onClick: () => {
              setEditRowValueFunction(value);
              setEditRowKey(value.key);
            },
            disabled: isUpdating || editRowKey && editRowKey !== value.key,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-secondary dark:text-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx(EditIcon, {}) })
          }
        )
      ] }) }),
      pipelineDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DetailsViewUpdateDialog,
        {
          setEditRow,
          pipelineDialog,
          setPipelineDialog,
          objectId,
          value,
          editRow,
          data,
          saveData,
          isLoading,
          setEditRowKey
        }
      )
    ] });
  };
  const DetailsAssociations = ({
    // key,
    association = null,
    isActive,
    parentObjectTypeId,
    parentObjectRowId,
    parentObjectTypeName,
    refetch,
    // objectId,
    // id,
    companyAsMediator = false,
    // urlParam,
    parentPermissions,
    info
  }) => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
    const [associationData, setAssociationData] = reactExports.useState(null);
    const mediatorObjectTypeId = getParam$1("mediatorObjectTypeId");
    const mediatorObjectRecordId = getParam$1("mediatorObjectRecordId");
    const [permissions, setPermissions] = reactExports.useState();
    const [showAddDialog, setShowAddDialog] = reactExports.useState(false);
    const [isExpanded, setIsExpanded] = reactExports.useState(false);
    const hubspotObjectTypeId = association == null ? void 0 : association.objectTypeId;
    const param = `parentObjectTypeId=${parentObjectTypeId}&parentObjectRecordId=${parentObjectRowId}&mediatorObjectTypeId=${mediatorObjectTypeId ? mediatorObjectTypeId : parentObjectTypeId}&mediatorObjectRecordId=${mediatorObjectRecordId ? mediatorObjectRecordId : parentObjectRowId}&isPrimaryCompany=${companyAsMediator}`;
    const portalId = (_a2 = getPortal()) == null ? void 0 : _a2.portalId;
    const [viewUrl, setViewUrl] = reactExports.useState("");
    const [isUpdating, setIsUpdating] = reactExports.useState(false);
    const [editRowKey, setEditRowKey] = reactExports.useState(null);
    const associationApis = {
      tableAPI: `/api/${hubId}/${portalId}/hubspot-object-data/${hubspotObjectTypeId}${param}`,
      stagesAPI: `/api/${hubId}/${portalId}/hubspot-object-pipelines/${hubspotObjectTypeId}/`,
      // concat pipelineId
      formAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/${hubspotObjectTypeId}/fields?${param}`,
      formDataAPI: `/api/${hubId}/${portalId}/hubspot-object-data/${hubspotObjectTypeId}/:objectId${param + "&isForm=true"}`,
      createAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/${hubspotObjectTypeId}/fields`,
      createExistingAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/:fromObjectTypeId/:fromRecordId/associations/:toObjectTypeId?${param}`,
      removeExistingAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/:fromObjectTypeId/:fromRecordId/disassociate/:toObjectTypeId?${param}`,
      updateAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/${hubspotObjectTypeId}/fields/:formId${param}`
    };
    const toggleContent = () => {
      setIsExpanded((prev) => !prev);
    };
    reactExports.useEffect(() => {
      var _a3, _b3;
      if (association) {
        const mViewUrl = `/association/${(_a3 = association == null ? void 0 : association.labels) == null ? void 0 : _a3.plural}?parentObjectTypeId=${parentObjectTypeId}&parentObjectRecordId=${parentObjectRowId}&objectTypeName=${(_b3 = association == null ? void 0 : association.labels) == null ? void 0 : _b3.plural}&objectTypeId=${association == null ? void 0 : association.objectTypeId}&parentObjectTypeName=${parentObjectTypeName}&mediatorObjectTypeId=${mediatorObjectTypeId ? mediatorObjectTypeId : parentObjectTypeId}&mediatorObjectRecordId=${mediatorObjectRecordId ? mediatorObjectRecordId : parentObjectRowId}&isPrimaryCompany=${companyAsMediator}`;
        setViewUrl(mViewUrl);
        setPermissions(association == null ? void 0 : association.configurations.object);
        setAssociationData(association);
      }
    }, [association]);
    const refetchSetData = (response) => {
      var _a3, _b3;
      if ((_a3 = response == null ? void 0 : response.data) == null ? void 0 : _a3.data) {
        let data = associationData;
        let newData = (_b3 = response == null ? void 0 : response.data) == null ? void 0 : _b3.data;
        if (data.data.length > 0) {
          data.data.unshift(newData);
        } else {
          data.data.push(newData);
        }
        if (data.data.length > data.limit) {
          data.data.pop();
        }
        data.total += 1;
        setAssociationData(data);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
      associationData && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "mb-6 px-4 text-[var(--right-tables-text-color)] bg-[var(--right-tables-background-color)] rounded-lg w-full max-w-md dark:bg-dark-300",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between w-full text-sm font-medium py-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-x-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: toggleContent, className: "cursor-pointer ", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { id: "toggleButton", content: isExpanded ? "Shrink" : "Expand", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-secondary dark:text-white", children: isExpanded ? /* @__PURE__ */ jsxRuntimeExports.jsx(Chevron, { className: "rotate-[270deg] origin-center -webkit-transform" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Chevron, { className: "rotate-180 origin-center -webkit-transform" }) }) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Link$1,
                  {
                    className: "font-bold border-input rounded-md text-xs dark:text-white whitespace-nowrap",
                    to: viewUrl,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-secondary  hover:underline underline-offset-4  dark:text-white", children: (_b2 = associationData == null ? void 0 : associationData.labels) == null ? void 0 : _b2.plural }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2 px-2 py-1 rounded-md bg-secondary dark:bg-white dark:text-dark-300 text-white text-xs", children: associationData == null ? void 0 : associationData.total })
                    ] })
                  }
                )
              ] }),
              ((associationData == null ? void 0 : associationData.objectTypeId) === "0-5" ? (permissions == null ? void 0 : permissions.create) && ((_c2 = parentPermissions == null ? void 0 : parentPermissions.ticket) == null ? void 0 : _c2.create) : permissions == null ? void 0 : permissions.create) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-end cursor-pointer", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Button,
                {
                  className: "font-semibold text-xs",
                  variant: "link",
                  size: "link",
                  onClick: (event) => {
                    event.stopPropagation();
                    setShowAddDialog(true);
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mr-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconPlus, { className: "!w-3 !h-3" }) }),
                    "Add"
                  ]
                }
              ) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: `flex flex-col space-y-4 transition-all duration-300 ease-in-out ${isExpanded ? "max-h-auto" : "max-h-[344px] overflow-y-auto hide-scrollbar"}`,
                children: associationData.total === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  EmptyMessageCard,
                  {
                    name: (_d2 = associationData == null ? void 0 : associationData.labels) == null ? void 0 : _d2.plural,
                    type: "col",
                    imgWidth: "110px",
                    className: "p-4 dark:bg-[#3e3e3e] bg-[var(--right-tables-card-background-color)] rounded-md text-xs font-semibold dark:text-white !mt-0"
                  }
                ) : associationData.data && associationData.data.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-col flex lg:gap-6 gap-3 rounded-md text-[var(--right-tables-text-color)] dark:text-white", children: associationData.data.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: "border dark:border-gray-600 p-2 rounded-md bg-[var(--right-tables-card-background-color)] dark:bg-dark-500 overflow-y-auto hide-scrollbar",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("table", { className: "!bg-transparent text-[var(--right-tables-text-color)]", children: /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: item && sortData(item, "associations").map((value, index2) => {
                      var _a3, _b3, _c3, _d3, _e3, _f3;
                      return /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "!pr-1 text-xs !px-[2px] odd:!py-2 even:!py-0  text-[var(--right-tables-text-color)] whitespace-wrap md:w-[90px] w-[80px]  align-center dark:text-white", children: [
                          value.label,
                          ":"
                        ] }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "!pl-1 text-xs !px-[2px] odd:!py-2 even:!py-0  text-[var(--right-tables-text-color)] align-center dark:text-white", children: (value == null ? void 0 : value.isEditableField) && ((_b3 = (_a3 = associationData == null ? void 0 : associationData.configurations) == null ? void 0 : _a3.object) == null ? void 0 : _b3.update) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                          DetailsViewUpdate,
                          {
                            renderValue: renderCellContent({
                              companyAsMediator,
                              value: value.value,
                              column: value,
                              itemId: item.hs_object_id.value,
                              path: `/${(_c3 = associationData == null ? void 0 : associationData.labels) == null ? void 0 : _c3.plural}`,
                              hubspotObjectTypeId: associationData == null ? void 0 : associationData.objectTypeId,
                              type: "associations",
                              associationPath: value.isPrimaryDisplayProperty ? `/${setParamHash(
                                replaceQuestionMarkToRegex(
                                  isObject$1(value.value) && value.value.label ? value.value.label : value.value
                                )
                              )}/${associationData == null ? void 0 : associationData.objectTypeId}/${item.hs_object_id.value}?parentObjectTypeId=${parentObjectTypeId}&parentObjectRecordId=${parentObjectRowId}&mediatorObjectTypeId=${mediatorObjectTypeId ? mediatorObjectTypeId : parentObjectTypeId}&mediatorObjectRecordId=${mediatorObjectRecordId ? mediatorObjectRecordId : parentObjectRowId}&isPrimaryCompany=${companyAsMediator}&parentObjectName=${(_d3 = associationData == null ? void 0 : associationData.labels) == null ? void 0 : _d3.plural}` : "",
                              detailsView: true,
                              hoverRow: null,
                              item: null,
                              urlParam: null
                            }),
                            value,
                            refetch,
                            id: item.hs_object_id.value,
                            objectId: associationData == null ? void 0 : associationData.objectTypeId,
                            item,
                            isUpdating,
                            setIsUpdating,
                            editRowKey,
                            setEditRowKey
                          }
                        ) : renderCellContent({
                          companyAsMediator,
                          value: value.value,
                          column: value,
                          itemId: item.hs_object_id.value,
                          path: `/${(_e3 = associationData == null ? void 0 : associationData.labels) == null ? void 0 : _e3.plural}`,
                          hubspotObjectTypeId: associationData == null ? void 0 : associationData.objectTypeId,
                          type: "associations",
                          associationPath: value.isPrimaryDisplayProperty ? `/${setParamHash(
                            isObject$1(value.value) && value.value.label ? value.value.label : value.value
                          )}/${associationData == null ? void 0 : associationData.objectTypeId}/${item.hs_object_id.value}?parentObjectTypeId=${parentObjectTypeId}&parentObjectRecordId=${parentObjectRowId}&mediatorObjectTypeId=${mediatorObjectTypeId ? mediatorObjectTypeId : parentObjectTypeId}&mediatorObjectRecordId=${mediatorObjectRecordId ? mediatorObjectRecordId : parentObjectRowId}&isPrimaryCompany=${companyAsMediator}&parentObjectName=${(_f3 = associationData == null ? void 0 : associationData.labels) == null ? void 0 : _f3.plural}` : "",
                          detailsView: true,
                          hoverRow: null,
                          item: null,
                          urlParam: null
                        }) })
                      ] }, index2);
                    }) }) })
                  },
                  index
                )) })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-right py-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Link$1,
              {
                className: "text-secondary hover:underline font-bold border-input rounded-md text-xs dark:text-white whitespace-nowrap",
                to: viewUrl,
                children: [
                  "View associated ",
                  (_e2 = associationData == null ? void 0 : associationData.labels) == null ? void 0 : _e2.plural
                ]
              }
            ) })
          ]
        }
      ),
      showAddDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DashboardTableForm,
        {
          type: "association",
          openModal: showAddDialog,
          setOpenModal: setShowAddDialog,
          title: (_f2 = associationData == null ? void 0 : associationData.labels) == null ? void 0 : _f2.singular,
          path: (_g2 = associationData == null ? void 0 : associationData.labels) == null ? void 0 : _g2.plural,
          portalId,
          hubspotObjectTypeId,
          apis: associationApis,
          urlParam: param,
          refetch: refetchSetData,
          parentObjectTypeId,
          parentObjectRowId,
          info,
          isShowExistingRecord: (_h2 = association == null ? void 0 : association.configurations) == null ? void 0 : _h2.object.existing_record
        }
      )
    ] });
  };
  const getDisplayData = (objectId, items) => {
    if (!Array.isArray(items) || items.length === 0) return {};
    const getUserCurrency = () => {
      var _a2;
      return ((_a2 = getUserDetails()) == null ? void 0 : _a2.companyCurrency) || "USD";
    };
    const findValue = (key2) => {
      const field = items.find((item) => item.key === key2);
      if (!field || field.value === null || field.value === void 0) return "";
      let currencyCode = getUserCurrency();
      if (key2 === "amount") {
        const currencyField = items.find((item) => item.key === "deal_currency_code");
        if (currencyField && currencyField.value) {
          currencyCode = typeof currencyField.value === "object" ? currencyField.value.value : currencyField.value;
        }
        if (field.showCurrencySymbol) {
          return `${Currency(currencyCode)} ${formatAmount(field.value)}`;
        }
      }
      return typeof field.value === "object" && field.value.label ? field.value.label : field.value;
    };
    const primaryItem = items.find((item) => item.isPrimaryDisplayProperty);
    let primaryValue = primaryItem ? primaryItem.value : null;
    switch (objectId) {
      case "0-1":
        return {
          primary: `${findValue("firstname")} ${findValue("lastname")}`.trim(),
          secondary: findValue("email") ? `${findValue("email")}` : null
        };
      case "0-2":
        return {
          primary: primaryValue,
          domain: findValue("domain") || null
        };
      case "0-3":
        return {
          primary: primaryValue,
          amount: findValue("amount") ? `Amount: ${findValue("amount")}` : "Amount: --",
          stage: `Stage: ${findValue("dealstage")}`
        };
      case "0-5":
        return {
          primary: primaryValue,
          date: findValue("closedate") ? `Close date: ${formatDate(findValue("closedate"))}` : `Created date: ${findValue("createdate") ? formatDate(findValue("createdate")) : " --"}`,
          stage: `Status: ${findValue("hs_pipeline_stage")}`
        };
      default:
        return {
          primary: primaryValue || (items.length > 0 ? items[0].value : "")
        };
    }
  };
  const DetailsHeaderCard = ({
    item,
    objectId
  }) => {
    const displayData = getDisplayData(objectId, item);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "relative min-h-36 rounded-lg w-full flex items-center justify-between overflow-hidden bg-custom-gradient",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex flex-col justify-center p-4 text-[var(--details-page-text-color)] z-10", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-2xl font-semibold mb-2", children: displayData == null ? void 0 : displayData.primary }),
          (displayData == null ? void 0 : displayData.secondary) && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs font-normal text-[var(--details-page-text-color)] line-clamp-2", children: displayData == null ? void 0 : displayData.secondary }),
          (displayData == null ? void 0 : displayData.amount) && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs font-normal text-[var(--details-page-text-color)] line-clamp-2", children: displayData == null ? void 0 : displayData.amount }),
          (displayData == null ? void 0 : displayData.domain) && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs font-normal text-[var(--details-page-text-color)] line-clamp-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: (displayData == null ? void 0 : displayData.domain) ? `https://${displayData.domain}` : "", className: "hover:underline flex items-center gap-1", target: "_blank", rel: "noreferrer", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: displayData == null ? void 0 : displayData.domain }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(OpenIcon, {})
          ] }) }),
          (displayData == null ? void 0 : displayData.date) && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-[var(--details-page-text-color)] mt-1", children: displayData == null ? void 0 : displayData.date }),
          (displayData == null ? void 0 : displayData.stage) && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-[var(--details-page-text-color)] mt-1", children: displayData == null ? void 0 : displayData.stage })
        ] })
      }
    );
  };
  const DetailsPagination = ({ objectId, states }) => {
    const {
      limit,
      setAfter,
      page,
      setPage,
      totalItems,
      numOfPages
    } = useTable();
    const handlePageChange = async (page2) => {
      await setPage(page2);
      await setAfter((page2 - 1) * limit);
      setActivePageFucntion(page2);
    };
    const setActivePageFucntion = (page2) => {
      setSelectRouteMenuConfig(objectId, page2);
    };
    const setSelectRouteMenuConfig = (key2, page2) => {
      var _a2;
      let routeMenuConfigs = getRouteMenuConfig();
      routeMenuConfigs[key2] = {
        ...routeMenuConfigs[key2],
        details: {
          overview: {
            page: page2,
            preData: true
          },
          activeTab: ((_a2 = routeMenuConfigs[key2]) == null ? void 0 : _a2.activeTab) || "overview"
        }
      };
      setRouteMenuConfig(routeMenuConfigs);
    };
    reactExports.useEffect(() => {
      var _a2, _b2, _c2;
      let routeMenuConfigs = getRouteMenuConfig();
      const activePage = ((_c2 = (_b2 = (_a2 = routeMenuConfigs[objectId]) == null ? void 0 : _a2.details) == null ? void 0 : _b2.overview) == null ? void 0 : _c2.page) || 1;
      handlePageChange(activePage);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between max-md:flex-col px-3 gap-x-2 max-sm:mt-3 text-sm", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-x-2 text-sm", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "rounded-md font-medium dark:text-gray-300", children: totalItems }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-secondary font-normal text-sm dark:text-gray-300", children: "Results" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Pagination,
        {
          numOfPages: numOfPages || 1,
          currentPage: page,
          setCurrentPage: handlePageChange
        }
      ) })
    ] });
  };
  const DetailsView = ({
    item,
    propertyName,
    showIframe,
    objectId,
    id,
    refetch,
    permissions,
    isLoading,
    urlParam
  }) => {
    const [iframeViewDialog, setIframeViewDialog] = reactExports.useState(false);
    const [iframeUrls, setIframeUrls] = reactExports.useState([]);
    const [currentIframeIndex, setCurrentIframeIndex] = reactExports.useState(0);
    const [isUpdating, setIsUpdating] = reactExports.useState(false);
    const [editRowKey, setEditRowKey] = reactExports.useState(null);
    const iframeSettings = Array.isArray(propertyName) ? propertyName : [];
    const getDisplayType = (key2) => {
      const setting = iframeSettings.find((setting2) => setting2.properties_value === key2);
      return (setting == null ? void 0 : setting.property_value_show_as) || "button";
    };
    const getActionType = (key2) => {
      const setting = iframeSettings.find((setting2) => setting2.properties_value === key2);
      return (setting == null ? void 0 : setting.on_click_action) || "showIframe";
    };
    const isValidUrl2 = (url) => {
      try {
        new URL(url);
        return true;
      } catch (e) {
        return false;
      }
    };
    const getPropertyValueType = (key2, value = "") => {
      const setting = iframeSettings.find((setting2) => setting2.properties_value === key2);
      const displayType = getDisplayType(key2);
      const actionType = getActionType(key2);
      if (!value) {
        return "--";
      }
      const isValid2 = isValidUrl2(value);
      const buttonName = (setting == null ? void 0 : setting.button_name) || "View";
      if (displayType === "button") {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "py-2 pl-1 text-sm dark:text-white break-all gap-2", children: actionType === "showIframe" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            className: "break-all",
            size: "xsm",
            onClick: () => handleViewClick(value),
            children: buttonName
          }
        ) : isValid2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: "", size: "xsm", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "a",
          {
            href: value,
            target: "_blank",
            rel: "noopener noreferrer",
            className: "break-all",
            children: buttonName
          }
        ) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dark:text-white flex gap-1 items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-yellow-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CautionCircle, { width: "14px", height: "14px" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red-700 text-xs", children: "Please add a valid link" })
        ] }) });
      }
      if (displayType === "link") {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "py-2 pl-1 text-sm dark:text-white break-all gap-2", children: actionType === "showIframe" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "span",
          {
            className: "text-secondary text-xs dark:text-white flex gap-1 items-center cursor-pointer break-all hover:underline",
            onClick: () => handleViewClick(value),
            children: [
              value,
              /* @__PURE__ */ jsxRuntimeExports.jsx(IframeIcon, {})
            ]
          }
        ) : isValid2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "a",
          {
            href: value,
            target: "_blank",
            rel: "noopener noreferrer",
            className: "text-secondary text-xs dark:text-white flex gap-1 items-center break-all",
            children: [
              value,
              /* @__PURE__ */ jsxRuntimeExports.jsx(OpenIcon, {})
            ]
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dark:text-white flex gap-1 items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-yellow-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CautionCircle, { width: "14px", height: "14px" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red-700 text-xs", children: "Please add a valid link" })
        ] }) });
      }
      return null;
    };
    const isImageUrl = (url) => {
      const imageExtensions = [".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp"];
      const hasImageExtension = imageExtensions.some(
        (ext) => {
          var _a2;
          return (_a2 = url.toLowerCase()) == null ? void 0 : _a2.endsWith(ext);
        }
      );
      const containsImagePattern = url.includes("images.unsplash.com") || url.includes("photo");
      return hasImageExtension || containsImagePattern;
    };
    const handleViewClick = (urls) => {
      const urlArray = urls.split(",").map((url) => url.trim());
      setIframeUrls(urlArray);
      setCurrentIframeIndex(0);
      setIframeViewDialog(true);
    };
    const handleNext = () => {
      setCurrentIframeIndex(
        (prevIndex) => prevIndex < iframeUrls.length - 1 ? prevIndex + 1 : prevIndex
      );
    };
    const handlePrevious = () => {
      setCurrentIframeIndex(
        (prevIndex) => prevIndex > 0 ? prevIndex - 1 : prevIndex
      );
    };
    if (isLoading && !item) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(OverviewSkeleton, {});
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "py-3 dark:bg-dark-300 bg-cleanWhite rounded-md mt-5 dark:text-white", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("table", { className: "w-full dark:bg-[#2a2a2a]", children: /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: (item == null ? void 0 : item.length) > 0 && item.filter((item2) => !item2.hidden).map((value, index) => {
        const key2 = value.key;
        const propertyConfig = propertyName.find((p) => p.properties_value === key2);
        if (showIframe && propertyConfig) {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "py-2 pr-1 text-sm dark:text-white lg:w-[200px] w-[130px] whitespace-wrap align-top", children: [
              value == null ? void 0 : value.label,
              ":"
            ] }),
            (value == null ? void 0 : value.value) ? getPropertyValueType(key2, value == null ? void 0 : value.value) : "--"
          ] }, key2);
        } else {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "py-2 pr-1 text-sm dark:text-white lg:w-[200px] w-[130px] whitespace-wrap align-top", children: [
              value == null ? void 0 : value.label,
              ":"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "py-2 pl-1 text-sm dark:text-white break-all gap-2", children: (value == null ? void 0 : value.isEditableField) && (permissions == null ? void 0 : permissions.update) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              DetailsViewUpdate,
              {
                renderValue: renderCellContent({
                  companyAsMediator: false,
                  value: value == null ? void 0 : value.value,
                  column: value,
                  itemId: null,
                  path: null,
                  hubspotObjectTypeId: null,
                  type: "details",
                  associationPath: null,
                  detailsView: null,
                  hoverRow: null,
                  item,
                  urlParam: item
                }),
                value,
                refetch,
                id,
                objectId,
                item,
                urlParam,
                isUpdating,
                setIsUpdating,
                editRowKey,
                setEditRowKey
              }
            ) : renderCellContent({
              companyAsMediator: false,
              value: value == null ? void 0 : value.value,
              column: value,
              itemId: null,
              path: null,
              hubspotObjectTypeId: null,
              type: "details",
              associationPath: null,
              detailsView: null,
              hoverRow: null,
              item,
              urlParam: null
            }) })
          ] }, value == null ? void 0 : value.key);
        }
      }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IframeViewDialog,
        {
          open: iframeViewDialog,
          onClose: () => setIframeViewDialog(false),
          iframeUrls,
          currentIframeIndex,
          handleNext,
          handlePrevious,
          isImageUrl
        }
      )
    ] });
  };
  const ApiDetails = ({ path, objectId, id, propertyName, showIframe, getPreData = null, preData = null, states = { isLoading: false } }) => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2;
    const [item, setItems] = reactExports.useState([]);
    const [images, setImages] = reactExports.useState([]);
    const [info, setInfo] = reactExports.useState(null);
    const [associations, setAssociations] = reactExports.useState({});
    useMe$1();
    const [configurations, setConfigurations] = reactExports.useState({
      fileManager: false,
      note: false,
      ticket: false
    });
    getParam$1("t");
    const companyAsMediator = getParam$1("isPrimaryCompany") || false;
    const [activeTab, setActiveTab] = reactExports.useState("overview");
    const [permissions, setPermissions] = reactExports.useState(null);
    const urlParam = getQueryParamsFromCurrentUrl();
    const [galleryDialog, setGalleryDialog] = reactExports.useState(false);
    const { sync, setSync } = useSync();
    const [sidebarDetailsOpen, setSidebarDetailsOpen] = reactExports.useState(false);
    const { isLargeScreen } = useResponsive();
    const [userToggled, setUserToggled] = reactExports.useState(false);
    const [isLoadedFirstTime, setIsLoadedFirstTime] = reactExports.useState(false);
    useTable();
    const { isLoading: isLoadingList } = states;
    const router2 = useRouter();
    const { pathname } = router2.state.location;
    reactExports.useEffect(() => {
      if (!userToggled) {
        setSidebarDetailsOpen(isLargeScreen);
      }
    }, [isLargeScreen, userToggled]);
    const toggleSidebar = () => {
      setUserToggled(true);
      setSidebarDetailsOpen((prev) => !prev);
    };
    reactExports.useEffect(() => {
      const resetOnResize = () => {
        setUserToggled(false);
      };
      window.addEventListener("resize", resetOnResize);
      return () => window.removeEventListener("resize", resetOnResize);
    }, [pathname]);
    [
      "overview",
      ((_a2 = permissions == null ? void 0 : permissions.fileManager) == null ? void 0 : _a2.display) && "files",
      ((_b2 = permissions == null ? void 0 : permissions.note) == null ? void 0 : _b2.display) && "notes",
      ((_c2 = permissions == null ? void 0 : permissions.ticket) == null ? void 0 : _c2.display) && "tickets"
    ].filter(Boolean);
    const setActiveTabFucntion = (active) => {
      setActiveTab(active);
      setSelectRouteMenuConfig(objectId, active);
    };
    const setSelectRouteMenuConfig = (key2, activeTab2) => {
      var _a3, _b3;
      const routeMenuConfigs = getRouteMenuConfig();
      let detailsConfig = {
        activeTab: activeTab2,
        overview: ((_b3 = (_a3 = routeMenuConfigs[key2]) == null ? void 0 : _a3.details) == null ? void 0 : _b3.overview) || null
      };
      routeMenuConfigs[key2] = { ...routeMenuConfigs[key2], details: detailsConfig };
      setRouteMenuConfig(routeMenuConfigs);
    };
    reactExports.useEffect(() => {
      var _a3, _b3;
      let routeMenuConfigs = getRouteMenuConfig();
      if (routeMenuConfigs && routeMenuConfigs.hasOwnProperty(objectId)) {
        const activeTab2 = (_b3 = (_a3 = routeMenuConfigs[objectId]) == null ? void 0 : _a3.details) == null ? void 0 : _b3.activeTab;
        setActiveTab(activeTab2 === "list" || !activeTab2 ? "overview" : activeTab2);
      } else {
        setActiveTab("overview");
      }
      getData();
    }, [pathname]);
    let portalId;
    if (env$1.VITE_DATA_SOURCE_SET != true) {
      portalId = (_d2 = getPortal()) == null ? void 0 : _d2.portalId;
    }
    const setSuccessResponse = (data) => {
      var _a3;
      setSync(false);
      const associations2 = (_a3 = data == null ? void 0 : data.data) == null ? void 0 : _a3.associations;
      setAssociations(associations2);
      const mConfigurations = data == null ? void 0 : data.configurations;
      setConfigurations(mConfigurations);
      const mInfo = data == null ? void 0 : data.info;
      setInfo(mInfo);
      const details = data == null ? void 0 : data.data;
      const sortedItems = sortData(details, "details");
      setItems(sortedItems);
      setPermissions(data.configurations);
      setIsLoadedFirstTime(true);
    };
    const {
      mutate: getDetails,
      error,
      isLoading
    } = useMutation({
      mutationKey: ["DetailsData", path, id],
      mutationFn: async () => await Client.objects.byObjectId({
        objectId,
        id,
        urlParam,
        portalId,
        hubId,
        cache: sync ? false : true
      }),
      onSuccess: (data) => {
        setSuccessResponse(data);
      },
      onError: (error2) => {
        setSync(false);
        setIsLoadedFirstTime(true);
        console.error("Error fetching file details:", error2);
      }
    });
    const getData = () => {
      getDetails();
    };
    reactExports.useEffect(() => {
      if (sync) getData();
    }, [sync]);
    const refetchGetData = () => {
      setSync(true);
    };
    if (error) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center text-center p-4  h-[calc(100%-var(--nav-height))] justify-center gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-yellow-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CautionCircle, {}) }),
        ((_f2 = (_e2 = error == null ? void 0 : error.response) == null ? void 0 : _e2.data) == null ? void 0 : _f2.detailedMessage) || ""
      ] });
    }
    if (!isLoadedFirstTime || sync === true && isLoading) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: " flex relative z-[1] bg-cleanWhite h-[calc(98vh-var(--nav-height))] dark:bg-dark-200 overflow-hidden  md:p-4 p-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: `${isLargeScreen ? "w-[calc(100%_-330px)]  pr-4 pb-4" : "w-full"} lg:h-[calc(100vh-var(--nav-height))] hide-scrollbar overflow-y-auto overflow-x-hidden`,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(DetailsSkeleton, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: ` bg-cleanWhite transition-transform duration-200 ease-in-out 
        lg:h-[calc(100vh-100px)] h-full hide-scrollbar overflow-visible z-50 
        ${isLargeScreen ? "w-[330px] right-0 static rounded-md dark:bg-dark-200 " : "fixed w-full inset-0 bg-gray-500 dark:bg-dark-300 bg-opacity-50 dark:bg-opacity-50 backdrop-blur-md backdrop-filter right-0 top-0 bottom-0 transform translate-x-full"} 
        ${!isLargeScreen && sidebarDetailsOpen ? "translate-x-0" : ""}`,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-full hide-scrollbar ml-auto lg:max-w-auto lg:p-0 p-3 bg-cleanWhite dark:bg-dark-200 max-w-[350px] overflow-visible", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DetailsSidebarSkeleton, {}) })
          }
        )
      ] }) });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: `dark:bg-dark-200 w-[100%] md:p-4 p-3 !pt-0 md:pb-0 rounded-tl-xl hide-scrollbar h-[calc(100vh-var(--nav-height))] overflow-hidden `,
        children: item.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: " flex relative bg-cleanWhite  h-full dark:bg-dark-200 overflow-hidden", children: [
          associations && !isLargeScreen && !sidebarDetailsOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-full dark:bg-dark-200 z-[52] absolute right-[10px] top-[10px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "rounded-full p-2 dark:bg-cleanWhite bg-[var(--sidebar-background-color)] text-[var(--sidebar-text-color)] dark:text-dark-200 animate-pulseEffect dark:animate-pulseEffectDark",
              onClick: toggleSidebar,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(DetailsIcon, {})
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              id: "details-scrollable-container",
              className: `${isLargeScreen ? "w-[calc(100%_-330px)]  pr-4 pb-4" : "w-full"} lg:h-full hide-scrollbar overflow-y-auto overflow-x-hidden md:pt-4 pt-3`,
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: ``, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DetailsHeaderCard,
                  {
                    bgImageClass: "bg-custom-bg",
                    path,
                    item,
                    objectId
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(IframeViewDialog, {}),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border dark:border-none rounded-lg  bg-graySecondary dark:bg-dark-300 border-flatGray w-fit dark:border-gray-700 my-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Tabs,
                  {
                    activeTab,
                    setActiveTab: setActiveTabFucntion,
                    onValueChange: setActiveTabFucntion,
                    className: "rounded-md ",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { className: "rounded-md", value: "overview", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-black dark:text-white", children: "Overview" }) }),
                        permissions && ((_g2 = permissions == null ? void 0 : permissions.fileManager) == null ? void 0 : _g2.display) && /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { className: "rounded-md", value: "files", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-black dark:text-white", children: "Files" }) }),
                        permissions && ((_h2 = permissions == null ? void 0 : permissions.note) == null ? void 0 : _h2.display) && /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { className: "rounded-md", value: "notes", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-black dark:text-white", children: "Notes" }) }),
                        permissions && ((_i2 = permissions == null ? void 0 : permissions.ticket) == null ? void 0 : _i2.display) && /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { className: "rounded-md", value: "tickets", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-black dark:text-white", children: [
                          ((_j2 = permissions == null ? void 0 : permissions.ticket) == null ? void 0 : _j2.display_label) ? (_k2 = permissions == null ? void 0 : permissions.ticket) == null ? void 0 : _k2.display_label : "Tickets",
                          (associations == null ? void 0 : associations.TICKET) && ((_l2 = associations.TICKET) == null ? void 0 : _l2.total) > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2 px-2 py-1 rounded-md bg-secondary dark:bg-white dark:text-dark-300 text-white text-xs", children: associations.TICKET.total })
                        ] }) })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "overview" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "files" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "notes" })
                    ]
                  }
                ) }),
                activeTab === "overview" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DetailsView,
                  {
                    propertyName,
                    showIframe,
                    item,
                    objectId,
                    id,
                    refetch: refetchGetData,
                    permissions: permissions ? permissions.object : null,
                    isLoading,
                    urlParam
                  }
                ),
                activeTab === "files" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Files,
                  {
                    fileId: id,
                    path,
                    objectId,
                    id,
                    permissions: permissions ? permissions.fileManager : null
                  }
                ),
                activeTab === "notes" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Notes,
                  {
                    item,
                    path,
                    objectId,
                    id,
                    permissions: permissions ? permissions.note : null
                  }
                ),
                activeTab === "tickets" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Tickets,
                  {
                    path,
                    objectId,
                    id,
                    parentObjectTypeId: objectId,
                    parentObjectRowId: id,
                    permissions: permissions ? permissions.ticket : null,
                    companyAsMediator,
                    title: ((_m2 = permissions == null ? void 0 : permissions.ticket) == null ? void 0 : _m2.display_label) || "Tickets",
                    ticketTableTitle: ((_n2 = permissions == null ? void 0 : permissions.ticket) == null ? void 0 : _n2.display_label) || "Tickets"
                  }
                ),
                images.length > 0 && activeTab === "photos" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DetailsGallery,
                  {
                    images,
                    setGalleryDialog
                  }
                ),
                preData && activeTab === "overview" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  isLoadingList ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loader", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loader-line" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "w-full" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(DetailsPagination, { objectId, states })
                ] })
              ] })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: ` bg-cleanWhite transition-transform duration-200 ease-in-out 
            lg:h-[calc(100vh-var(--nav-height))] h-full hide-scrollbar overflow-visible max-lg:z-[52] lg:mt-[1px]
            ${isLargeScreen ? "w-[330px] right-0 static rounded-md dark:bg-dark-200 " : "fixed w-full inset-0 bg-gray-500 dark:bg-dark-300 bg-opacity-50 dark:bg-opacity-50 backdrop-blur-md backdrop-filter right-0 top-0 bottom-0 transform translate-x-full"} 
            ${!isLargeScreen && sidebarDetailsOpen ? "translate-x-0" : ""}`,
              children: [
                !isLargeScreen && sidebarDetailsOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-full dark:bg-dark-200 z-50 absolute right-[10px] top-[60px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "rounded-full p-2 dark:bg-cleanWhite bg-[var(--sidebar-background-color)] text-[var(--sidebar-text-color)] dark:text-dark-200 animate-pulseEffect dark:animate-pulseEffectDark",
                    onClick: () => setSidebarDetailsOpen(false),
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, {})
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-full hide-scrollbar ml-auto lg:max-w-auto lg:p-0 p-3 bg-cleanWhite dark:bg-dark-200 max-w-[350px] overflow-visible md:!py-4", children: associations && Object.entries(associations).filter(
                  ([, association]) => (association == null ? void 0 : association.objectTypeId) !== "0-5"
                ).map(([key2, association]) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DetailsAssociations,
                  {
                    association,
                    isActive: true,
                    parentObjectTypeName: sanitizeForBase64(path),
                    parentObjectTypeId: objectId,
                    parentObjectRowId: id,
                    refetch: getData,
                    objectId,
                    id,
                    companyAsMediator,
                    urlParam,
                    parentPermissions: permissions,
                    info
                  },
                  key2
                )) })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Dialog,
            {
              open: galleryDialog,
              onClose: setGalleryDialog,
              className: "w-[50%]",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: " bg-cleanWhite dark:bg-dark-200 dark:text-white rounded-md flex-col justify-start items-center gap-6 inline-flex", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-2 gap-4", children: images.map((url, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: url,
                  alt: `Image ${index + 1}`,
                  className: "w-full h-auto"
                },
                index
              )) }) })
            }
          )
        ] })
      }
    );
  };
  const TableDetails = ({ objectId, getData, states }) => {
    var _a2, _b2;
    const { sync } = useSync();
    const { after } = useTable();
    const {
      setIsLoading,
      apiResponse
    } = states;
    reactExports.useEffect(() => {
      if (!apiResponse) {
        setIsLoading(true);
        getData();
      }
    }, [apiResponse]);
    reactExports.useEffect(() => {
      if (sync) {
        getData();
      }
    }, [sync]);
    const prevAfter = reactExports.useRef("");
    reactExports.useEffect(() => {
      if (prevAfter.current !== after) {
        getData(after);
        prevAfter.current = after;
      }
    }, [after]);
    return apiResponse && (apiResponse == null ? void 0 : apiResponse.data) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      ApiDetails,
      {
        objectId,
        path: "",
        id: (_b2 = (_a2 = apiResponse == null ? void 0 : apiResponse.data) == null ? void 0 : _a2.hs_object_id) == null ? void 0 : _b2.value,
        propertyName: "",
        showIframe: "",
        getPreData: getData,
        preData: apiResponse,
        states
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "No data..." });
  };
  const EnterIcon = ({ width = "34px", height = "30px", ...props }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width, height, ...props, viewBox: "0 0 370 208", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { "clip-path": "url(#clip0_7241_66)", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "5.5", y: "5.5", width: "359", height: "197", rx: "54.5", stroke: "currentColor", "stroke-width": "11" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M128.605 123.383V133.719H96.8184V123.383H128.605ZM101.371 74V133.719H88V74H101.371ZM124.504 98.0352V108.043H96.8184V98.0352H124.504ZM128.646 74V84.377H96.8184V74H128.646Z", fill: "currentColor" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M147.062 98.8145V133.719H134.225V89.3398H146.283L147.062 98.8145ZM145.381 109.971L142.182 110.053C142.182 106.717 142.592 103.723 143.412 101.07C144.232 98.418 145.395 96.1621 146.898 94.3027C148.43 92.416 150.248 90.9805 152.354 89.9961C154.486 89.0117 156.838 88.5195 159.408 88.5195C161.486 88.5195 163.387 88.8203 165.109 89.4219C166.832 90.0234 168.309 90.9941 169.539 92.334C170.797 93.6465 171.754 95.3965 172.41 97.584C173.066 99.7441 173.395 102.41 173.395 105.582V133.719H160.516V105.541C160.516 103.682 160.256 102.246 159.736 101.234C159.217 100.223 158.451 99.5117 157.439 99.1016C156.455 98.6914 155.252 98.4863 153.83 98.4863C152.326 98.4863 151.041 98.7871 149.975 99.3887C148.908 99.9629 148.033 100.77 147.35 101.809C146.666 102.848 146.16 104.064 145.832 105.459C145.531 106.854 145.381 108.357 145.381 109.971Z", fill: "currentColor" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M204.32 89.3398V98.3223H177.988V89.3398H204.32ZM184.018 78.3477H196.855V119.814C196.855 121.045 197.006 121.988 197.307 122.645C197.607 123.301 198.1 123.766 198.783 124.039C199.467 124.285 200.342 124.408 201.408 124.408C202.174 124.408 202.83 124.381 203.377 124.326C203.924 124.271 204.43 124.203 204.895 124.121V133.391C203.801 133.746 202.639 134.02 201.408 134.211C200.178 134.43 198.838 134.539 197.389 134.539C194.627 134.539 192.234 134.088 190.211 133.186C188.215 132.283 186.684 130.861 185.617 128.92C184.551 126.951 184.018 124.395 184.018 121.25V78.3477Z", fill: "currentColor" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M231.391 134.539C227.863 134.539 224.705 133.979 221.916 132.857C219.127 131.736 216.762 130.191 214.82 128.223C212.906 126.227 211.443 123.93 210.432 121.332C209.42 118.734 208.914 115.959 208.914 113.006V111.447C208.914 108.139 209.379 105.09 210.309 102.301C211.238 99.5117 212.592 97.0918 214.369 95.041C216.174 92.9629 218.389 91.3633 221.014 90.2422C223.639 89.0938 226.633 88.5195 229.996 88.5195C233.141 88.5195 235.943 89.0391 238.404 90.0781C240.865 91.0898 242.943 92.5527 244.639 94.4668C246.334 96.3535 247.619 98.6367 248.494 101.316C249.396 103.969 249.848 106.949 249.848 110.258V115.508H214.082V107.264H237.297V106.279C237.297 104.721 237.01 103.354 236.436 102.178C235.889 101.002 235.068 100.1 233.975 99.4707C232.908 98.8145 231.555 98.4863 229.914 98.4863C228.355 98.4863 227.057 98.8145 226.018 99.4707C224.979 100.127 224.145 101.057 223.516 102.26C222.914 103.436 222.477 104.816 222.203 106.402C221.93 107.961 221.793 109.643 221.793 111.447V113.006C221.793 114.729 222.025 116.301 222.49 117.723C222.955 119.145 223.639 120.361 224.541 121.373C225.443 122.385 226.537 123.178 227.822 123.752C229.107 124.326 230.57 124.613 232.211 124.613C234.234 124.613 236.162 124.23 237.994 123.465C239.826 122.672 241.412 121.441 242.752 119.773L248.74 126.623C247.838 127.936 246.566 129.207 244.926 130.438C243.312 131.641 241.371 132.625 239.102 133.391C236.832 134.156 234.262 134.539 231.391 134.539Z", fill: "currentColor" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M268.92 99.6758V133.719H256.123V89.3398H268.141L268.92 99.6758ZM282.168 89.0117L281.963 100.947C281.416 100.865 280.705 100.797 279.83 100.742C278.955 100.66 278.203 100.619 277.574 100.619C275.934 100.619 274.512 100.824 273.309 101.234C272.133 101.617 271.148 102.191 270.355 102.957C269.59 103.723 269.016 104.68 268.633 105.828C268.25 106.949 268.059 108.248 268.059 109.725L265.639 108.535C265.639 105.609 265.926 102.93 266.5 100.496C267.074 98.0625 267.908 95.957 269.002 94.1797C270.096 92.375 271.436 90.9805 273.021 89.9961C274.607 89.0117 276.412 88.5195 278.436 88.5195C279.092 88.5195 279.762 88.5605 280.445 88.6426C281.129 88.7246 281.703 88.8477 282.168 89.0117Z", fill: "currentColor" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_7241_66", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "370", height: "208", fill: "white" }) }) })
    ] });
  };
  const DashboardTableHeader = ({
    title,
    componentName,
    permissions,
    hubspotObjectTypeId,
    // activePipeline,
    setActiveTab,
    // search,
    handelChangePipeline,
    pipelines,
    // setSearchTerm,
    // setCurrentPage,
    // setItemsPerPage,
    handleSearch,
    setShowAddDialog,
    // pageLimit,
    defPermissions,
    specPipeLine,
    isHome
  }) => {
    const pageLimit2 = env$1.VITE_TABLE_PAGE_LIMIT;
    const {
      view,
      search,
      setSearch,
      selectedPipeline,
      setSelectedPipeline,
      setPage,
      setLimit
      // permissions
    } = useTable();
    const [showPipelineFilter, setShowPippelineFilter] = reactExports.useState(false);
    reactExports.useEffect(() => {
      if (!(defPermissions == null ? void 0 : defPermissions.pipeline_id)) setShowPippelineFilter((pipelines == null ? void 0 : pipelines.length) === 1 ? false : true);
    }, [pipelines]);
    const handelPipeline = async (value) => {
      await setSelectedPipeline(isHome ? "home" : hubspotObjectTypeId, pipelines, value);
      await handelChangePipeline(value);
      setPage(1);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between mb-6 md:items-center max-sm:flex-col-reverse max-sm:items-end gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 justify-between max-sm:flex-col-reverse max-sm:w-full", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 justify-between", children: [
          (hubspotObjectTypeId === "0-3" || hubspotObjectTypeId === "0-5") && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex p-1 bg-graySecondary dark:bg-dark-200 rounded-md gap-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: () => {
                  if (view != "LIST") setActiveTab("LIST");
                },
                className: `py-1 px-3 inline-flex dark:text-gray-200 items-center gap-x-2 -ms-px first:ms-0 first:rounded-s-md hover:bg-gray-50 dark:hover:bg-dark-500 last:rounded-e-md text-sm font-medium text-gray-800 ${view === "BOARD" ? " bg-graySecondary dark:bg-dark-200" : "bg-white dark:bg-dark-400"}`,
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "svg",
                  {
                    fill: "currentcolor",
                    width: "20px",
                    height: "23px",
                    viewBox: "0 0 32 32",
                    version: "1.1",
                    xmlns: "http://www.w3.org/2000/svg",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: "list" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8 8v4h16v-4h-16zM8 18h16v-4h-16v4zM8 24h16v-4h-16v4z" })
                    ]
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: () => {
                  if (view != "BOARD") setActiveTab("BOARD");
                },
                className: `py-1 px-3 inline-flex dark:text-gray-200 items-center gap-x-2 -ms-px first:ms-0 hover:bg-gray-50 dark:hover:bg-dark-500 first:rounded-s-md last:rounded-e-md text-sm font-medium text-gray-800 ${view === "BOARD" ? "bg-white dark:bg-dark-400" : " bg-graySecondary dark:bg-dark-200"}`,
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "svg",
                  {
                    width: "15px",
                    height: "15px",
                    viewBox: "0 0 16 16",
                    fill: "none",
                    xmlns: "http://www.w3.org/2000/svg",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("g", { id: "SVGRepo_bgCarrier", "stroke-width": "0" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "g",
                        {
                          id: "SVGRepo_tracerCarrier",
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "SVGRepo_iconCarrier", children: [
                        " ",
                        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 1H1V5H7V1Z", fill: "currentcolor" }),
                        " ",
                        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 7H1V15H7V7Z", fill: "currentcolor" }),
                        " ",
                        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 1H15V9H9V1Z", fill: "currentcolor" }),
                        " ",
                        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15 11H9V15H15V11Z", fill: "currentcolor" }),
                        " "
                      ] })
                    ]
                  }
                )
              }
            )
          ] }),
          (hubspotObjectTypeId === "0-3" || hubspotObjectTypeId === "0-5") && !specPipeLine && (showPipelineFilter ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[180px]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              className: "w-full rounded-md bg-cleanWhite px-2 text-sm transition-colors border-2 dark:border-gray-600 focus:ring-0 focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 dark:bg-gray-700 dark:text-gray-200 dark:placeholder-gray-400 py-2",
              value: selectedPipeline,
              onChange: (e) => {
                var _a2;
                return handelPipeline(((_a2 = e.target) == null ? void 0 : _a2.value) || "");
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", disabled: view === "BOARD", selected: true, children: "All Pipelines" }),
                pipelines.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: item.pipelineId, children: item.label }))
              ]
            }
          ) }) : null)
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: " md:flex md:items-center md:gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip, { id: "searchInput", content: "Press enter to search", place: "right", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                placeholder: "Search...",
                height: "semiMedium",
                icon: SearchIcon,
                value: search,
                onChange: async (e) => {
                  await setSearch(e.target.value);
                  if (e.target.value === "") handleSearch();
                },
                onKeyDown: async (e) => {
                  if (e.key === "Enter") {
                    await setPage(1);
                    await setLimit(pageLimit2);
                    handleSearch();
                  }
                },
                className: "pr-12"
              }
            ),
            search && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "text-gray-500 absolute right-2 top-1/2 -translate-y-1/2 cursor-pointer",
                onClick: handleSearch,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(EnterIcon, {})
              }
            )
          ] }),
          search && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: async () => {
                await setSearch("");
                await setPage(1);
                await setLimit(pageLimit2);
                handleSearch();
              },
              variant: "link",
              size: "link",
              children: "Clear All"
            }
          )
        ] })
      ] }),
      hubSpotUserDetails.sideMenu[0].tabName !== title && (componentName === "ticket" ? defPermissions == null ? void 0 : defPermissions.create : permissions == null ? void 0 : permissions.create) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-end", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { variant: !recorBtnCustom ? "default" : "create", onClick: () => setShowAddDialog(true), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconPlus, { className: "!w-3 !h-3" }) }),
        "Create ",
        title
      ] }) })
    ] });
  };
  function IconUnlink(props) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        height: "1rem",
        width: "1rem",
        ...props,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M304.1 405.9c4.7 4.7 4.7 12.3 0 17l-44.7 44.7c-59.3 59.3-155.7 59.3-215 0-59.3-59.3-59.3-155.7 0-215l44.7-44.7c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17l-44.7 44.7c-28.1 28.1-28.1 73.8 0 101.8 28.1 28.1 73.8 28.1 101.8 0l44.7-44.7c4.7-4.7 12.3-4.7 17 0l39.6 39.6zm-56.6-260.2c4.7 4.7 12.3 4.7 17 0l44.7-44.7c28.1-28.1 73.8-28.1 101.8 0 28.1 28.1 28.1 73.8 0 101.8l-44.7 44.7c-4.7 4.7-4.7 12.3 0 17l39.6 39.6c4.7 4.7 12.3 4.7 17 0l44.7-44.7c59.3-59.3 59.3-155.7 0-215-59.3-59.3-155.7-59.3-215 0l-44.7 44.7c-4.7 4.7-4.7 12.3 0 17l39.6 39.6zm234.8 359.3l22.6-22.6c9.4-9.4 9.4-24.6 0-33.9L63.6 7c-9.4-9.4-24.6-9.4-33.9 0L7 29.7c-9.4 9.4-9.4 24.6 0 33.9l441.4 441.4c9.4 9.4 24.6 9.4 33.9 0z" })
      }
    );
  }
  const DisassociateButton = ({
    item,
    apis,
    parentObjectTypeId,
    parentObjectRecordId,
    hubspotObjectTypeId,
    refetch,
    componentName
  }) => {
    const [serverError, setServerError] = reactExports.useState(null);
    const { setToaster } = useToaster$1();
    const [openModal, setOpenModal] = reactExports.useState(false);
    const { setSync } = useSync();
    const { breadcrumbs } = useBreadcrumb();
    const [parentObjectname, setParentObjectname] = reactExports.useState("");
    const [objectTypeNameSingular, setObjectTypeNameSingular] = reactExports.useState("");
    const [parentObjectTypeNameSingular, setParentObjectTypeNameSingular] = reactExports.useState("");
    reactExports.useEffect(() => {
      if (!(breadcrumbs == null ? void 0 : breadcrumbs.length)) return;
      const getSingular = (name) => (name == null ? void 0 : name.endsWith("s")) ? name.slice(0, -1) : name || "";
      const [thirdLast, secondLast, last2] = breadcrumbs.slice(-3);
      if (componentName !== "ticket") {
        setParentObjectname(getSingular(thirdLast == null ? void 0 : thirdLast.name));
        setObjectTypeNameSingular(getSingular(last2 == null ? void 0 : last2.name));
        setParentObjectTypeNameSingular(secondLast == null ? void 0 : secondLast.name);
      } else {
        setObjectTypeNameSingular("Ticket");
        setParentObjectname(getSingular(secondLast == null ? void 0 : secondLast.name));
        setParentObjectTypeNameSingular((last2 == null ? void 0 : last2.name) || "");
      }
    }, [breadcrumbs]);
    const { mutate: removeExistingData, isLoading } = useMutation({
      mutationKey: ["removeExistingData"],
      mutationFn: async ({ formData }) => {
        try {
          const response = await Client.form.removeExisting({
            API: apis.removeExistingAPI,
            params: {
              fromObjectTypeId: parentObjectTypeId,
              fromRecordId: parentObjectRecordId,
              toObjectTypeId: hubspotObjectTypeId
            },
            data: formData
          });
          return response;
        } catch (error) {
          throw error;
        }
      },
      onSuccess: async (response) => {
        await setToaster({ message: response == null ? void 0 : response.statusMsg, type: "success" });
        setSync(true);
        setOpenModal(false);
      },
      onError: (error) => {
        let errorMessage = "An unexpected error occurred.";
        if (error.response && error.response.data) {
          const errorData = error.response.data.detailedMessage;
          const errors = error.response.data.validationErrors;
          setServerError(errors);
          errorMessage = typeof errorData === "object" ? JSON.stringify(errorData) : errorData;
        }
        setToaster({ message: errorMessage, type: "error" });
      }
    });
    const handleConfirm = () => {
      const payload = {
        removeIds: [item.hs_object_id]
      };
      removeExistingData({ formData: payload });
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Button,
        {
          size: "xsm",
          variant: "outline",
          className: "hover:bg-gray-200",
          onClick: () => setOpenModal(true),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconUnlink, { fill: "currentColor", className: "w-[10px] h-[10px]" }) }),
            "Disassociate"
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Dialog,
        {
          open: openModal,
          onClose: setOpenModal,
          className: "bg-cleanWhite dark:bg-dark-200 rounded-md sm:max-w-[450px] mx-2",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-start text-xl font-semibold dark:text-white mb-2 whitespace-normal break-words", children: `Are you sure you want to disassociate this ${objectTypeNameSingular}?` }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "whitespace-normal break-words dark:text-white", children: [
                "This will remove the ",
                objectTypeNameSingular,
                " from the ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold", children: parentObjectTypeNameSingular }),
                " ",
                parentObjectname,
                ". The ",
                objectTypeNameSingular,
                " will remain available, but it will no longer be linked to this ",
                parentObjectname,
                "."
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end gap-3 pt-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outline",
                  disabled: isLoading,
                  onClick: () => setOpenModal(false),
                  children: "Cancel"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleConfirm, disabled: isLoading, children: "Confirm" })
            ] })
          ]
        }
      )
    ] });
  };
  const DashboardTableData = ({
    getData,
    apiResponse,
    // numOfPages,
    viewName,
    companyAsMediator,
    path,
    hubspotObjectTypeId,
    detailsView,
    hoverRow,
    urlParam,
    handleRowHover,
    componentName,
    // currentPage,
    // setCurrentPage,
    // sortConfig,
    // setSortConfig,
    // setAfter,
    // itemsPerPage,
    // setItemsPerPage,
    detailsUrl,
    apis
  }) => {
    const {
      page,
      setPage,
      sort,
      setSort,
      setAfter,
      limit,
      numOfPages
    } = useTable();
    const mUrlParam = Object.fromEntries(
      Object.entries(urlParam || {}).filter(([key2]) => key2 !== "cache" && key2 !== "limit")
    );
    const mediatorObjectTypeId = getParam$1("mediatorObjectTypeId");
    const mediatorObjectRecordId = getParam$1("mediatorObjectRecordId");
    const objectTypeId = getParam$1("objectTypeId");
    getParam$1("objectTypeName");
    const isPrimaryCompany = getParam$1("isPrimaryCompany");
    const parentObjectTypeId = getParam$1("parentObjectTypeId");
    const parentObjectRecordId = getParam$1("parentObjectRecordId");
    const [tableHeader, setTableHeader] = reactExports.useState([]);
    const [tableData, setTableData] = reactExports.useState([]);
    const [currentItems, setCurrentItems] = reactExports.useState(0);
    const [totalItems, setTotalItems] = reactExports.useState(0);
    const [activeDisassociatedButton, setActiveDisassociatedButton] = reactExports.useState(null);
    const mapResponseData = (data) => {
      const results = data.data.results.rows || [];
      const columns = data.data.results.columns || [];
      setTableData(results);
      setTotalItems(data.data.total || 0);
      setCurrentItems(results.length);
      setTableHeader(sortData(columns));
    };
    reactExports.useEffect(() => {
      mapResponseData(apiResponse);
    }, [apiResponse]);
    const handleSort = (column) => {
      let newSortConfig = column;
      if (sort === column) {
        newSortConfig = `-${column}`;
      } else if (sort === `-${column}`) {
        newSortConfig = column;
      }
      setSort(newSortConfig);
      getData();
    };
    const handlePageChange = async (page2) => {
      await setPage(page2);
      await setAfter((page2 - 1) * limit);
      getData();
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto relative rounded-md  dark:bg-dark-300", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { className: "w-full", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
          tableHeader.filter((column) => !column.hidden).map((column) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            TableHead,
            {
              className: "whitespace-nowrap dark:text-white dark:bg-dark-500 cursor-pointer",
              onClick: () => handleSort(column.key),
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex columns-center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold text-xs", children: formatColumnLabel(column.value) }),
                sort === column.key && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "svg",
                  {
                    xmlns: "http://www.w3.org/2000/svg",
                    viewBox: "0 -960 960 960",
                    width: "24px",
                    className: "dark:fill-white cursor-pointer",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m280-400 200-200 200 200H280Z" })
                  }
                ),
                sort === `-${column.key}` && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "svg",
                  {
                    xmlns: "http://www.w3.org/2000/svg",
                    viewBox: "0 -960 960 960",
                    width: "24px",
                    className: "dark:fill-white cursor-pointer",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M480-360 280-560h400L480-360Z" })
                  }
                )
              ] })
            },
            column.key
          )),
          parentObjectTypeId && parentObjectRecordId && /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { className: "whitespace-nowrap dark:text-white dark:bg-dark-500 sticky right-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex columns-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold text-xs", children: "Action" }) }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { children: tableData.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          TableRow,
          {
            onMouseEnter: () => handleRowHover(item),
            onMouseLeave: () => handleRowHover(null),
            className: "relative",
            children: [
              tableHeader.filter((column) => !column.hidden).map((column) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                TableCell,
                {
                  className: "whitespace-nowrap dark:border-gray-600  text-sm dark:bg-dark-300 border-b",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dark:text-white", children: renderCellContent({
                    companyAsMediator,
                    value: item[column.key],
                    column,
                    itemId: item.hs_object_id,
                    path: path == "/association" ? `/${getParam$1("objectTypeName")}` : item[column.key],
                    hubspotObjectTypeId: path == "/association" ? getParam$1("objectTypeId") : hubspotObjectTypeId,
                    type: "list",
                    // associationPath: viewName === "ticket" ? `/${item[column.key]}/${env.HUBSPOT_DEFAULT_OBJECT_IDS.tickets}/${item.hs_object_id}${detailsUrl}` : (path == "/association" ? `/${objectTypeName}/${objectTypeId}/${item.hs_object_id}?parentObjectTypeId=${parentObjectTypeId}&parentObjectRecordId=${parentObjectRecordId}&mediatorObjectTypeId=${mediatorObjectTypeId}&mediatorObjectRecordId=${mediatorObjectRecordId}&isPrimaryCompany=${isPrimaryCompany}` : ""),
                    associationPath: viewName === "ticket" ? `/${item[column.key]}/${env$1.HUBSPOT_DEFAULT_OBJECT_IDS.tickets}/${item.hs_object_id}${detailsUrl}` : path == "/association" ? `/${item[column.key]}/${objectTypeId}/${item.hs_object_id}?parentObjectTypeId=${parentObjectTypeId}&parentObjectRecordId=${parentObjectRecordId}&mediatorObjectTypeId=${mediatorObjectTypeId}&mediatorObjectRecordId=${mediatorObjectRecordId}&isPrimaryCompany=${isPrimaryCompany}` : "",
                    detailsView,
                    hoverRow,
                    item,
                    urlParam: toQueryString(mUrlParam)
                  }) })
                },
                column.value
              )),
              parentObjectTypeId && parentObjectRecordId && /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: `whitespace-nowrap dark:border-gray-600 text-sm bg-white dark:bg-dark-300 border-b z-[${activeDisassociatedButton === index ? 51 : 50}] sticky right-0`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => setActiveDisassociatedButton(index), className: "flex items-center space-x-2 gap-x-5", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DisassociateButton, { componentName, item, apis, parentObjectTypeId, parentObjectRecordId, hubspotObjectTypeId, refetch: getData }) }) })
            ]
          },
          index
        )) })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between max-md:flex-col  md:px-4 px-3 gap-x-2 max-sm:mt-3 text-sm", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-x-2 text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-secondary leading-5 text-sm dark:text-gray-300", children: "Showing" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "border border-secondary dark:text-gray-300 font-medium w-8 h-8 flex items-center justify-center rounded-md dark:border-white", children: currentItems || 0 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-secondary dark:text-gray-300", children: "/" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "rounded-md font-medium dark:text-gray-300", children: totalItems }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-secondary font-normal text-sm dark:text-gray-300", children: "Results" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Pagination,
          {
            numOfPages: numOfPages || 1,
            currentPage: page,
            setCurrentPage: handlePageChange
          }
        ) })
      ] })
    ] });
  };
  const BoardView = ({
    hubspotObjectTypeId,
    activeCardData,
    // activePipeline,
    isLoadingPipelines,
    urlParam,
    companyAsMediator,
    getData,
    // setAfter,
    // currentPage,
    // setCurrentPage,
    // setItemsPerPage,
    // itemsPerPage,
    isLoading,
    path,
    viewName,
    detailsView,
    detailsUrl,
    defPermissions
  }) => {
    var _a2;
    const { setPage, setAfter, limit, setLimit, selectedPipeline } = useTable();
    const { gridData: data, setGridData: setData } = useTable();
    let portalId;
    if (env$1.VITE_DATA_SOURCE_SET != true) {
      portalId = (_a2 = getPortal()) == null ? void 0 : _a2.portalId;
    }
    const DragContext = reactExports.createContext();
    function Drag({ draggable = true, handleDrop: handleDrop2, children }) {
      const [dragType, setDragType] = reactExports.useState(null);
      const [dragItem, setDragItem] = reactExports.useState(null);
      const [isDragging, setIsDragging] = reactExports.useState(null);
      const [drop, setDrop] = reactExports.useState(null);
      reactExports.useEffect(() => {
        if (dragItem) {
          document.body.style.cursor = "grabbing";
        } else {
          document.body.style.cursor = "default";
        }
      }, [dragItem]);
      const dragStart = function(e, dragId, dragType2) {
        e.stopPropagation();
        e.dataTransfer.effectAllowed = "move";
        setDragItem(dragId);
        setDragType(dragType2);
      };
      const drag = function(e, dragId, dragType2) {
        e.stopPropagation();
        setIsDragging(true);
      };
      const dragEnd = function(e) {
        setDragItem(null);
        setDragType(null);
        setIsDragging(false);
        setDrop(null);
      };
      const onDrop = function(e) {
        e.preventDefault();
        handleDrop2({ dragItem, dragType, drop });
        setDragItem(null);
        setDragType(null);
        setIsDragging(false);
        setDrop(null);
      };
      let contextData = {
        draggable,
        dragItem,
        dragType,
        isDragging,
        dragStart,
        drag,
        dragEnd,
        drop,
        setDrop,
        onDrop
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DragContext.Provider, { value: contextData, children: typeof children === "function" ? children({ activeItem: dragItem, activeType: dragType, isDragging }) : children });
    }
    Drag.DragItem = function({ as, dragId, dragType, ...props }) {
      const { draggable, dragStart, drag, dragEnd, dragItem } = reactExports.useContext(DragContext);
      let Component = as || "div";
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Component,
        {
          onDragStart: (e) => dragStart(e, dragId, dragType),
          onDrag: drag,
          draggable,
          onDragEnd: dragEnd,
          ...props
        }
      );
    };
    Drag.DropZone = function({
      as,
      dropId,
      dropType,
      remember,
      children,
      style,
      ...props
    }) {
      const { dragItem, dragType, setDrop, drop, onDrop } = reactExports.useContext(DragContext);
      function handleDragOver(e) {
        if (e.preventDefault) {
          e.preventDefault();
        }
        return false;
      }
      function handleLeave() {
        if (!remember) {
          setDrop(null);
        }
      }
      let Component = as || "div";
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Component,
        {
          onDragEnter: (e) => dragItem && dropType === dragType && setDrop(dropId),
          onDragOver: handleDragOver,
          onDrop,
          ...props,
          children: [
            children,
            drop === dropId && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-[0px]", onDragLeave: handleLeave })
          ]
        }
      );
    };
    Drag.DropZones = function({
      dropType,
      prevId,
      nextId,
      split: split2 = "y",
      remember,
      children,
      ...props
    }) {
      const { dragType, isDragging } = reactExports.useContext(DragContext);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ...props, children: [
        children,
        dragType === dropType && isDragging && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `absolute inset-[0px] flex ${split2 === "x" ? "flex-row" : "flex-column"}`,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Drag.DropZone,
                {
                  dropId: prevId,
                  className: "w-full h-full",
                  dropType,
                  remember
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Drag.DropZone,
                {
                  dropId: nextId,
                  className: "w-full h-full",
                  dropType,
                  remember
                }
              )
            ]
          }
        )
      ] });
    };
    Drag.DropGuide = function({ as, dropId, dropType, ...props }) {
      const { drop, dragType } = reactExports.useContext(DragContext);
      let Component = as || "div";
      return dragType === dropType && drop === dropId ? /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { ...props }) : null;
    };
    function Card({ dragItem, item, columns }) {
      const mUrlParam = Object.fromEntries(
        Object.entries(urlParam || {}).filter(
          ([key2]) => key2 !== "cache" && key2 !== "limit"
        )
      );
      function getSortedByBoardViewOrder(columns2) {
        return columns2.filter((col) => col.boardViewOrder !== null).sort((a, b2) => {
          const aOrder = a.boardViewOrder;
          const bOrder = b2.boardViewOrder;
          if (aOrder === -1 && bOrder !== -1) return -1;
          if (bOrder === -1 && aOrder !== -1) return 1;
          return aOrder - bOrder;
        });
      }
      const mediatorObjectTypeId = getParam$1("mediatorObjectTypeId");
      const mediatorObjectRecordId = getParam$1("mediatorObjectRecordId");
      const objectTypeId = getParam$1("objectTypeId");
      const isPrimaryCompany = getParam$1("isPrimaryCompany");
      const parentObjectTypeId = getParam$1("parentObjectTypeId");
      const parentObjectRecordId = getParam$1("parentObjectRecordId");
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: `text-sm rounded-md bg-white border border-gray-300  dark:border-gray-600 shadow-sm p-3 mx-3 my-2 dark:bg-dark-300 dark:text-white ${dragItem ? " rotate-6" : ""}`,
          children: columns && getSortedByBoardViewOrder(columns).map((column) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: renderCellContent({
            companyAsMediator,
            value: item[column.key],
            column,
            itemId: item == null ? void 0 : item.hs_object_id,
            path: path == "/association" ? `/${getParam$1("objectTypeName")}` : item[column.key],
            hubspotObjectTypeId: path == "/association" ? getParam$1("objectTypeId") : hubspotObjectTypeId,
            type: "list",
            associationPath: viewName === "ticket" ? `/${item[column.key]}/${env$1.VITE_HUBSPOT_DEFAULT_OBJECT_IDS.tickets}/${item.hs_object_id}${detailsUrl}` : path == "/association" ? `/${item[column.key]}/${objectTypeId}/${item.hs_object_id}?parentObjectTypeId=${parentObjectTypeId}&parentObjectRecordId=${parentObjectRecordId}&mediatorObjectTypeId=${mediatorObjectTypeId}&mediatorObjectRecordId=${mediatorObjectRecordId}&isPrimaryCompany=${isPrimaryCompany}` : "",
            detailsView,
            hoverRow: null,
            item,
            urlParam: toQueryString(mUrlParam)
          }) }))
        }
      );
    }
    function List({ name, dragItem, children, count }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `w-[280px] rounded-xs whitespace-nowrap dark:text-white bg-[#f5f8fa] dark:bg-dark-500 mx-0 my-0 pb-1 shrink-0 grow-0 ${dragItem ? " rotate-6" : ""}`,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between px-3 py-2 border-b dark:border-b-gray-600 sticky top-0 z-[2] bg-[#f5f8fa] dark:bg-dark-500", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "font-medium text-xs my-1 uppercase text-gray-700 dark:text-white", children: name }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm", children: count })
            ] }),
            children
          ]
        }
      );
    }
    const { setToaster } = useToaster$1();
    const handlePageChange = async (mLimit) => {
      await setPage(1);
      await setLimit(mLimit);
      await setAfter((1 - 1) * limit);
      await getData();
    };
    reactExports.useEffect(() => {
      var _a3, _b2;
      if (!isLoading) {
        if ((activeCardData == null ? void 0 : activeCardData.total) > 0) {
          if (hubspotObjectTypeId == "0-3") {
            if (((_a3 = activeCardData == null ? void 0 : activeCardData.results) == null ? void 0 : _a3.length) > 0) {
              setData("deals", activeCardData == null ? void 0 : activeCardData.results);
            }
          } else {
            if (((_b2 = activeCardData == null ? void 0 : activeCardData.results) == null ? void 0 : _b2.length) > 0) {
              setData("tickets", activeCardData == null ? void 0 : activeCardData.results);
            }
          }
        } else {
          removeTicketsDeals();
        }
      }
    }, [activeCardData, isLoading]);
    const { mutate: updateDealsByPipeline } = useMutation({
      mutationKey: ["updateDealsDataByPipeline"],
      mutationFn: async ({ recordId, stageId }) => {
        console.log("stageId", stageId);
        return await Client.Deals.updatePipelineDeal({
          API_ENDPOINT: `api/${hubId}/${portalId}/hubspot-object-forms/${hubspotObjectTypeId}/properties/${recordId}?${objectToQueryParams(
            urlParam
          )}`,
          data: hubspotObjectTypeId == "0-3" ? { pipeline: defPermissions && (defPermissions == null ? void 0 : defPermissions.pipeline_id) ? defPermissions.pipeline_id : selectedPipeline, dealstage: stageId } : { hs_pipeline: defPermissions && (defPermissions == null ? void 0 : defPermissions.pipeline_id) ? defPermissions.pipeline_id : selectedPipeline, hs_pipeline_stage: stageId }
        });
      },
      onSuccess: (resp) => {
        setToaster({ message: resp.statusMsg, type: "success" });
      },
      onError: (error) => {
      }
    });
    const removeTicketsDeals = () => {
      setData("reset", []);
    };
    function handleDrop({ dragItem, dragType, drop }) {
      if (dragType === "card") {
        let [newListPosition, newCardPosition] = drop.split("-").map((string) => parseInt(string));
        let stageId = data[newListPosition].id;
        let recordId = dragItem;
        let newData = structuredClone(data);
        let oldCardPosition;
        let oldListPosition = data.findIndex((list) => {
          oldCardPosition = list.cards.findIndex((card2) => card2.id === dragItem);
          return oldCardPosition >= 0;
        });
        let card = data[oldListPosition].cards[oldCardPosition];
        if (newListPosition === oldListPosition && oldCardPosition < newCardPosition) {
          newCardPosition--;
        }
        newData[oldListPosition].cards.splice(oldCardPosition, 1);
        newData[newListPosition].cards.splice(newCardPosition, 0, card);
        newData[oldListPosition].count -= 1;
        newData[newListPosition].count += 1;
        newData[newListPosition].data.results.columns = newData[oldListPosition].data.results.columns;
        setData("directly", newData);
        updateDealsByPipeline({ recordId, stageId });
      }
    }
    return data.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "md:mb-4 mb-3 flex flex-col h-[66vh] overflow-auto relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Drag, { handleDrop, children: ({ activeItem, activeType, isDragging }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Drag.DropZone, { className: "flex overflow-x-auto flex-1 self-start", children: [
      data.map((list, listPosition) => {
        var _a3, _b2;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Drag.DropZone,
            {
              dropId: listPosition,
              dropType: "list",
              remember: true,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Drag.DropGuide,
                {
                  dropId: listPosition,
                  dropType: "list",
                  className: "rounded-md bg-gray-200 dark:bg-dark-300 h-96 mx-2 my-5 w-64 shrink-0 grow-0"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Drag.DropZones,
            {
              className: `min-w-[280px] relative flex flex-col h-full bg-[#f5f8fa] dark:bg-dark-500 border dark:border-gray-600 overflow-y-auto hide-scrollbar
                      ${listPosition === 0 ? "rounded-s-md border-r-1  border-l-1" : "border-l-0"} 
                      ${listPosition === data.length - 1 ? "rounded-e-md" : ""}`,
              prevId: listPosition,
              nextId: listPosition + 1,
              dropType: "list",
              split: "x",
              remember: true,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Drag.DragItem,
                  {
                    dragType: "list",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      List,
                      {
                        count: list.count || 0,
                        name: list.name,
                        dragItem: activeItem === list.id && activeType === "list",
                        children: [
                          data[listPosition].cards.map((card, cardPosition) => {
                            var _a4, _b3;
                            return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                              Drag.DropZones,
                              {
                                className: "relative",
                                prevId: `${listPosition}-${cardPosition}`,
                                nextId: `${listPosition}-${cardPosition + 1}`,
                                dropType: "card",
                                remember: true,
                                children: [
                                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                                    Drag.DropGuide,
                                    {
                                      dropId: `${listPosition}-${cardPosition}`,
                                      className: "rounded-md bg-gray-200 dark:bg-dark-300 h-24 m-2",
                                      dropType: "card"
                                    }
                                  ),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                                    Drag.DragItem,
                                    {
                                      dragId: card.id,
                                      className: `cursor-pointer ${activeItem === card.id && activeType === "card" && isDragging ? "hidden" : "translate-x-0"}`,
                                      dragType: "card",
                                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                                        Card,
                                        {
                                          dragItem: activeItem === (card == null ? void 0 : card.id) && activeType === "card",
                                          item: card,
                                          columns: ((_b3 = (_a4 = list == null ? void 0 : list.data) == null ? void 0 : _a4.results) == null ? void 0 : _b3.columns) || []
                                        }
                                      )
                                    }
                                  )
                                ]
                              },
                              card.id
                            );
                          }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            Drag.DropZone,
                            {
                              dropId: `${listPosition}-${data[listPosition].cards.length}`,
                              dropType: "card",
                              remember: true,
                              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                                Drag.DropGuide,
                                {
                                  dropId: `${listPosition}-${data[listPosition].cards.length}`,
                                  className: "rounded-md bg-gray-200 dark:bg-dark-300 h-24 m-2",
                                  dropType: "card"
                                }
                              )
                            }
                          )
                        ]
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Drag.DropZone,
                  {
                    dropId: `${listPosition}-${data[listPosition].cards.length}`,
                    className: "grow",
                    dropType: "card",
                    remember: true
                  }
                ),
                ((_b2 = (_a3 = data[listPosition]) == null ? void 0 : _a3.data) == null ? void 0 : _b2.hasMore) ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-[#f5f8fa] dark:bg-dark-500 flex items-center justify-center p-2 sticky bottom-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    onClick: () => handlePageChange(limit + 10),
                    size: "sm",
                    isLoading,
                    variant: "secondary",
                    children: "Show more"
                  }
                ) }) : null
              ]
            }
          )
        ] }, list.id);
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Drag.DropZone, { dropId: data.length, dropType: "list", remember: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Drag.DropGuide,
        {
          dropId: data.length,
          dropType: "list",
          className: "rounded-md bg-gray-200 dark:bg-dark-300 h-96 mx-2 my-5 w-64 shrink-0 grow-0 bg-"
        }
      ) })
    ] }) }) }) : null;
  };
  const formatKey = (key2) => {
    return key2 && typeof key2 === "string" ? key2 == null ? void 0 : key2.replace(/_/g, " ").replace(/\b\w/g, (l) => l.toUpperCase()) : "";
  };
  const DashboardTable = ({
    hubspotObjectTypeId,
    path,
    inputValue,
    title,
    tableTitle,
    apis,
    detailsView = true,
    editView = false,
    viewName = "",
    detailsUrl = "",
    componentName,
    defPermissions = null,
    companyAsMediator,
    pipeLineId,
    specPipeLine,
    getData,
    states,
    isHome,
    pipelines,
    isLoadingPipelines = false,
    changeTab = null
  }) => {
    var _a2, _b2, _c2, _d2;
    const {
      numOfPages,
      view,
      setView,
      setSelectRouteMenuConfig
    } = useTable();
    const {
      isLoading,
      urlParam,
      setUrlParam,
      apiResponse,
      info,
      activeCardData,
      permissions,
      isLoadingHoldData,
      setIsLoadingHoldData
    } = states;
    const [showAddDialog, setShowAddDialog] = reactExports.useState(false);
    const [showEditDialog, setShowEditDialog] = reactExports.useState(false);
    const [showEditData, setShowEditData] = reactExports.useState(false);
    const [openModal, setOpenModal] = reactExports.useState(false);
    const [modalData, setModalData] = reactExports.useState(null);
    const [hoverRow, setHoverRow] = reactExports.useState(null);
    const isPrimaryCompany = getParam$1("isPrimaryCompany");
    const parentObjectTypeId = getParam$1("parentObjectTypeId");
    const parentObjectRecordId = getParam$1("parentObjectRecordId");
    let portalId;
    if (env$1.VITE_DATA_SOURCE_SET != true) {
      portalId = (_a2 = getPortal()) == null ? void 0 : _a2.portalId;
    }
    const handleRowHover = (row) => {
      setHoverRow(row);
    };
    const handleSearch = () => {
      getData();
    };
    const setActiveTab = (selectView) => {
      const objectId = isHome ? "home" : hubspotObjectTypeId;
      setIsLoadingHoldData(true);
      const routeMenuConfig = {
        [objectId]: {
          activeTab: selectView === "BOARD" ? "grid" : "list"
        }
      };
      setSelectRouteMenuConfig(routeMenuConfig);
      setView(selectView);
      changeTab(selectView);
    };
    const handelChangePipeline = async (pipeLineId2) => {
      getData();
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: ` ${hubSpotUserDetails.sideMenu[0].tabName === title || componentName === "ticket" ? "mt-0" : "md:mt-4 mt-3"} rounded-md overflow-hidden bg-cleanWhite border dark:border-none dark:bg-dark-300 md:p-4 p-2 !pb-0 md:mb-4 mb-2`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            DashboardTableHeader,
            {
              title,
              componentName,
              permissions,
              hubspotObjectTypeId,
              view,
              setActiveTab,
              handelChangePipeline,
              pipelines,
              handleSearch,
              setShowAddDialog,
              defPermissions,
              specPipeLine,
              isHome
            }
          ),
          !isLoading && !view != "BOARD" && (((_b2 = apiResponse == null ? void 0 : apiResponse.data) == null ? void 0 : _b2.total) === 0 || ((_c2 = apiResponse == null ? void 0 : apiResponse.data) == null ? void 0 : _c2.total) == null) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center pb-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              EmptyMessageCard,
              {
                name: hubSpotUserDetails.sideMenu[0].tabName === title ? "item" : title
              }
            ),
            permissions && permissions.association && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-secondary text-base md:text-2xl dark:text-gray-300mt-3", children: permissions.associationMessage })
          ] }),
          view === "BOARD" && (hubspotObjectTypeId === "0-3" || hubspotObjectTypeId === "0-5") && /* @__PURE__ */ jsxRuntimeExports.jsx(
            BoardView,
            {
              hubspotObjectTypeId,
              activeCardData,
              pipelines,
              isLoadingPipelines,
              urlParam,
              companyAsMediator,
              getData,
              isLoading,
              path,
              viewName,
              detailsUrl,
              defPermissions
            }
          ),
          !isLoading && view === "LIST" && ((_d2 = apiResponse == null ? void 0 : apiResponse.data) == null ? void 0 : _d2.total) > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            DashboardTableData,
            {
              getData,
              apiResponse,
              numOfPages,
              viewName,
              companyAsMediator,
              path,
              hubspotObjectTypeId,
              detailsView,
              hoverRow,
              urlParam,
              handleRowHover,
              componentName,
              detailsUrl,
              apis
            }
          ),
          env$1.VITE_DATA_SOURCE_SET === true && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Dialog,
            {
              open: openModal,
              onClose: setOpenModal,
              className: "bg-cleanWhite dark:bg-dark-200  rounded-md sm:min-w-[430px]",
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-md flex-col gap-6 flex", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-start text-xl font-semibold", children: "Details" }),
                modalData && Object.keys(modalData).map((key2) => {
                  var _a3;
                  return /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      className: "flex justify-between items-center w-full gap-1 border-b",
                      children: key2 !== "iframe_file" && key2 !== "id" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-start dark:text-white", children: [
                          formatKey(key2),
                          " -"
                        ] }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dark:text-white text-end", children: modalData[key2] })
                      ] }) : key2 === "iframe_file" ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: (_a3 = modalData[key2]) == null ? void 0 : _a3.replace(";", ",") }) : ""
                    },
                    key2
                  );
                }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pt-3 text-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => setOpenModal(false), children: "Close" }) })
              ] })
            }
          ),
          showAddDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(
            DashboardTableForm,
            {
              type: parentObjectTypeId ? "association_new" : "",
              openModal: showAddDialog,
              setOpenModal: setShowAddDialog,
              title: tableTitle,
              path,
              portalId,
              hubspotObjectTypeId,
              apis,
              refetch: getData,
              companyAsMediator: companyAsMediator || isPrimaryCompany,
              urlParam,
              parentObjectTypeId,
              parentObjectRowId: parentObjectRecordId,
              info,
              specPipeLine,
              pipeLineId
            }
          ),
          showEditDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(
            DashboardTableForm,
            {
              openModal: showEditDialog,
              setOpenModal: setShowEditDialog,
              title: tableTitle,
              path,
              portalId,
              hubspotObjectTypeId,
              apis,
              showEditData,
              refetch: getData,
              urlParam
            }
          )
        ]
      }
    );
  };
  const DynamicComponentView = ({
    hubspotObjectTypeId,
    path,
    title,
    showIframe,
    propertyName,
    companyAsMediator,
    pipeLineId,
    specPipeLine,
    objectDescription,
    componentName = null,
    defPermissions = null,
    apis,
    isShowTitle = true,
    objectUserProperties,
    objectUserPropertiesView,
    isHome = false,
    ticketTableTitle = null
  }) => {
    var _a2, _b2;
    hubspotObjectTypeId = hubspotObjectTypeId || getParam$1("objectTypeId");
    getParam$1("objectTypeName");
    getQueryParamsFromCurrentUrl();
    const [sidebarRightOpen, setSidebarRightOpen] = reactExports.useState(false);
    const { isLargeScreen, isMediumScreen, isSmallScreen } = useResponsive();
    const [userToggled, setUserToggled] = reactExports.useState(false);
    const { breadcrumbs } = useBreadcrumb();
    const [tableTitle, setTableTitle] = reactExports.useState(null);
    const [singularTableTitle, setSingularTableTitle] = reactExports.useState("");
    const [associatedtableTitleSingular, setAssociatedtableTitleSingular] = reactExports.useState("");
    const [errorMessage, setErrorMessage] = reactExports.useState("");
    const { sync, setSync } = useSync();
    const [isLoadedFirstTime, setIsLoadedFirstTime] = reactExports.useState(false);
    const [cacheEnabled, setCacheEnabled] = reactExports.useState(true);
    const [userData2, setUserData] = reactExports.useState();
    const router2 = useRouter();
    const { pathname } = router2.state.location;
    const [isLoading, setIsLoading] = reactExports.useState(null);
    const [urlParam, setUrlParam] = reactExports.useState(null);
    const [apiResponse, setApiResponse] = reactExports.useState(null);
    const [pipelines, setPipelines] = reactExports.useState([]);
    const [info, setInfo] = reactExports.useState(null);
    const [totalRecord, setTotalRecord] = reactExports.useState(null);
    const [activeCardData, setActiveCardData] = reactExports.useState(null);
    const [permissions, setPermissions] = reactExports.useState(null);
    const [isLoadingHoldData, setIsLoadingHoldData] = reactExports.useState(null);
    const [pageView, setPageView] = reactExports.useState(null);
    const {
      limit,
      setLimit,
      setTotalItems,
      setNumOfPages,
      setView,
      view,
      getTableParam,
      resetTableParam,
      setSelectedPipeline,
      selectedPipeline,
      setDefaultPipeline,
      setPage,
      setSelectRouteMenuConfig
    } = useTable();
    reactExports.useEffect(() => {
      let routeMenuConfigs = getRouteMenuConfig();
      const objectId = isHome ? "home" : hubspotObjectTypeId;
      if (routeMenuConfigs && routeMenuConfigs.hasOwnProperty(objectId)) {
        const activeTab = routeMenuConfigs[objectId].activeTab;
        setIsLoadingHoldData(true);
        setView(activeTab === "grid" ? "BOARD" : "LIST");
        setSelectedPipeline(routeMenuConfigs[objectId].activePipeline);
      } else {
        setIsLoadingHoldData(true);
        setView("LIST");
      }
    }, []);
    const fetchUserProfile = async ({ portalId: portalId2, cache }) => {
      if (!portalId2) return null;
      const response = await Client.user.profile({ portalId: portalId2, cache });
      return response == null ? void 0 : response.data;
    };
    const { data: userNewData, error, isLoading: propertyIsLoading, refetch } = useQuery({
      queryKey: ["userProfilePage", cacheEnabled],
      queryFn: () => fetchUserProfile({ portalId, cache: sync ? false : true }),
      onSuccess: (data) => {
        if (data) {
          setUserData(data);
        }
        setSync(false);
        setIsLoadedFirstTime(true);
      },
      onError: (error2) => {
        console.error("Error fetching profile:", error2);
        setSync(false);
        setIsLoadedFirstTime(true);
      }
    });
    reactExports.useEffect(() => {
      if (sync) {
        refetch();
      }
    }, [sync]);
    const { mutate: getData, isLoading: isLoadingAPiData } = useMutation({
      mutationKey: ["TableData"],
      mutationFn: async () => {
        var _a3, _b3, _c2, _d2;
        const objectId = isHome ? "home" : hubspotObjectTypeId;
        let routeMenuConfigs = getRouteMenuConfig();
        let param2;
        if (((_a3 = routeMenuConfigs[objectId]) == null ? void 0 : _a3.details) === true) {
          const details = (_b3 = routeMenuConfigs[objectId]) == null ? void 0 : _b3.details;
          const currentPage = ((_c2 = details == null ? void 0 : details.overview) == null ? void 0 : _c2.page) || 1;
          const isPage = ((_d2 = details == null ? void 0 : details.overview) == null ? void 0 : _d2.preData) && currentPage > 1;
          param2 = getTableParam(companyAsMediator, isPage ? currentPage : 1);
        } else {
          param2 = getTableParam(companyAsMediator, null);
        }
        if (companyAsMediator) param2.mediatorObjectTypeId = "0-2";
        if ((defPermissions == null ? void 0 : defPermissions.pipeline_id) && componentName === "ticket") {
          param2.filterValue = defPermissions == null ? void 0 : defPermissions.pipeline_id;
        } else {
          if (selectedPipeline && (hubspotObjectTypeId === "0-3" || hubspotObjectTypeId === "0-5")) {
            param2.filterValue = selectedPipeline;
          } else if (hubspotObjectTypeId != "0-3" || hubspotObjectTypeId != "0-5") {
            param2.filterValue = "";
          }
        }
        const API_ENDPOINT = removeAllParams(apis.tableAPI);
        if (componentName != "ticket") {
          setIsLoading(true);
        }
        setUrlParam(param2);
        return await Client.objects.all({
          API_ENDPOINT,
          param: updateParamsFromUrl(apis.tableAPI, param2)
        });
      },
      onSuccess: (data) => {
        var _a3, _b3, _c2, _d2, _e2, _f2, _g2;
        const objectId = isHome ? "home" : hubspotObjectTypeId;
        setErrorMessage("");
        const tableViewIsList = (_b3 = (_a3 = data == null ? void 0 : data.configurations) == null ? void 0 : _a3.object) == null ? void 0 : _b3.list_view;
        setPageView(tableViewIsList === false ? "single" : "table");
        setApiResponse(data);
        setSync(false);
        let routeMenuConfigs = getRouteMenuConfig();
        if (tableViewIsList && ((_c2 = routeMenuConfigs[objectId]) == null ? void 0 : _c2.listView) === false) {
          routeMenuConfigs[objectId] = {
            ...routeMenuConfigs[objectId],
            listView: tableViewIsList,
            details: null
          };
          getData();
        } else {
          routeMenuConfigs[objectId] = {
            ...routeMenuConfigs[objectId],
            listView: tableViewIsList
          };
          if (data.statusCode === "200") {
            setInfo(data.info);
            const tableViewIsList2 = (_e2 = (_d2 = data == null ? void 0 : data.configurations) == null ? void 0 : _d2.object) == null ? void 0 : _e2.list_view;
            const totalData = tableViewIsList2 === false ? (_f2 = data == null ? void 0 : data.pagination) == null ? void 0 : _f2.total : (_g2 = data == null ? void 0 : data.data) == null ? void 0 : _g2.total;
            setTotalItems(totalData || 0);
            if (componentName != "ticket") {
              setIsLoading(false);
            }
            setTotalRecord(totalData || 0);
            if (view === "BOARD") {
              setActiveCardData(data == null ? void 0 : data.data);
            } else {
              const ItemsPerPage = limit;
              setLimit(ItemsPerPage);
              const totalPage = tableViewIsList2 === false ? Math.ceil(totalData / 1) : Math.ceil(totalData / ItemsPerPage);
              setNumOfPages(totalPage);
            }
            if (defPermissions) {
              setPermissions(data == null ? void 0 : data.configurations[componentName]);
            } else {
              setPermissions(data == null ? void 0 : data.configurations["object"]);
            }
          } else {
            setPermissions(null);
          }
        }
        setRouteMenuConfig(routeMenuConfigs);
        setIsLoadingHoldData(false);
      },
      onError: (error2) => {
        var _a3, _b3;
        setErrorMessage(((_b3 = (_a3 = error2 == null ? void 0 : error2.response) == null ? void 0 : _a3.data) == null ? void 0 : _b3.detailedMessage) || "");
        setApiResponse(null);
        setSync(false);
        setPermissions(null);
        setIsLoadingHoldData(false);
        if (componentName != "ticket") {
          setIsLoading(false);
        }
      }
    });
    let portalId;
    if (env$1.VITE_DATA_SOURCE_SET != true) {
      portalId = (_a2 = getPortal()) == null ? void 0 : _a2.portalId;
    }
    const toggleSidebar = () => {
      setUserToggled(true);
      setSidebarRightOpen((prev) => !prev);
    };
    reactExports.useEffect(() => {
      if (!userToggled) {
        if (isLargeScreen) {
          setSidebarRightOpen(true);
        } else if (isMediumScreen || isSmallScreen) {
          setSidebarRightOpen(false);
        }
      }
    }, [isLargeScreen, isMediumScreen, isSmallScreen, userToggled]);
    reactExports.useEffect(() => {
      const resetOnResize = () => {
        setUserToggled(false);
      };
      window.addEventListener("resize", resetOnResize);
      return () => window.removeEventListener("resize", resetOnResize);
    }, []);
    reactExports.useEffect(() => {
      var _a3;
      if (breadcrumbs && breadcrumbs.length > 0) {
        const last2 = breadcrumbs[breadcrumbs.length - 1];
        const previous = breadcrumbs[breadcrumbs.length - 2];
        const singularLastName = ((_a3 = last2 == null ? void 0 : last2.name) == null ? void 0 : _a3.endsWith("s")) ? last2.name.slice(0, -1) : last2.name;
        setAssociatedtableTitleSingular(singularLastName);
        if (componentName != "ticket") {
          setTableTitle(
            (previous == null ? void 0 : previous.name) ? { last: last2, previous } : { last: last2 }
          );
          setSingularTableTitle(
            (previous == null ? void 0 : previous.name) ? `${singularLastName} with ${previous == null ? void 0 : previous.name}` : singularLastName
          );
        } else {
          const ticketTableTitleSingular = ticketTableTitle.endsWith("s") ? ticketTableTitle.slice(0, -1) : ticketTableTitle;
          setTableTitle(
            { last: { name: title } }
          );
          setSingularTableTitle(
            (previous == null ? void 0 : previous.name) ? `${ticketTableTitleSingular} with ${singularLastName} ` : ticketTableTitleSingular
          );
        }
      }
    }, [breadcrumbs]);
    const { mutate: getPipelines, isLoadingPipelines } = useMutation({
      mutationKey: ["PipelineData"],
      mutationFn: async () => {
        return await Client.Deals.pipelines({
          API_ENDPOINT: `api/${hubId}/${portalId}/hubspot-object-pipelines/${hubspotObjectTypeId}`,
          param: {
            cache: sync ? false : true
          }
        });
      },
      onSuccess: async (data) => {
        const objectId = isHome ? "home" : hubspotObjectTypeId;
        await setPipelines(data.data);
        await setDefaultPipeline(data, objectId);
        await getData();
      },
      onError: () => {
        setPipelines([]);
      }
    });
    reactExports.useEffect(() => {
      if (specPipeLine) {
        const objectId = isHome ? "home" : hubspotObjectTypeId;
        setSelectedPipeline(pipeLineId);
        setIsLoadingHoldData(true);
        const routeMenuConfig = {
          [objectId]: {
            activePipeline: pipeLineId
          }
        };
        setSelectRouteMenuConfig(routeMenuConfig);
        setUrlParam({
          filterPropertyName: "hs_pipeline",
          filterOperator: "eq",
          filterValue: pipeLineId
        });
      }
    }, [specPipeLine]);
    reactExports.useEffect(() => {
      const fetchData = async () => {
        await setErrorMessage("");
        await resetTableParam();
        await setApiResponse(null);
        await setPageView(null);
        if ((hubspotObjectTypeId === "0-3" || hubspotObjectTypeId === "0-5") && !(defPermissions == null ? void 0 : defPermissions.pipeline_id)) {
          await getPipelines();
        }
      };
      fetchData();
    }, []);
    reactExports.useEffect(() => {
      const fetchData = async () => {
        if (sync) {
          if ((hubspotObjectTypeId === "0-3" || hubspotObjectTypeId === "0-5") && !(defPermissions == null ? void 0 : defPermissions.pipeline_id)) {
            await getPipelines();
          } else {
            getData();
          }
        }
      };
      fetchData();
    }, [sync, hubspotObjectTypeId, defPermissions]);
    reactExports.useEffect(() => {
      const fetchData = async () => {
        setPage(1);
        if ((hubspotObjectTypeId === "0-3" || hubspotObjectTypeId === "0-5") && !(defPermissions == null ? void 0 : defPermissions.pipeline_id)) {
          await getPipelines();
        } else {
          try {
            await getData();
          } catch (err2) {
            console.error("Error running getData", err2);
          }
        }
      };
      fetchData();
    }, [companyAsMediator, hubspotObjectTypeId, defPermissions]);
    const changeTab = async (view2) => {
      await ((hubspotObjectTypeId === "0-3" || hubspotObjectTypeId === "0-5") && !(defPermissions == null ? void 0 : defPermissions.pipeline_id)) ? getPipelines() : getData();
    };
    if (isLoadingAPiData === true) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: ` ${hubSpotUserDetails.sideMenu[0].tabName === title || componentName === "ticket" ? "mt-0" : "mt-[calc(var(--nav-height)-1px)]"} rounded-md overflow-hidden bg-cleanWhite border dark:border-none dark:bg-dark-300 md:p-4 p-2 !pb-0 md:mb-4 mb-2`,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              DashboardTableHeaderSkeleton,
              {
                hubspotObjectTypeId,
                title
              }
            ),
            view === "BOARD" && activeCardData ? /* @__PURE__ */ jsxRuntimeExports.jsx(BoardViewSkeleton, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(TableSkeleton, {})
          ]
        }
      );
    }
    if (errorMessage) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center text-center p-4 min-h-[300px] max-h-[400px]  justify-center gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-yellow-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CautionCircle, {}) }),
        errorMessage
      ] });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      pageView === "single" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-[var(--sidebar-background-color)] mt-[calc(var(--nav-height)-1px)] dark:bg-dark-300", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `bg-cleanWhite dark:bg-dark-200`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        TableDetails,
        {
          objectId: hubspotObjectTypeId,
          getData,
          states: {
            isLoading,
            setIsLoading,
            urlParam,
            setUrlParam,
            apiResponse,
            setApiResponse,
            info,
            setInfo,
            totalRecord,
            setTotalRecord,
            activeCardData,
            setActiveCardData,
            permissions,
            setPermissions,
            isLoadingHoldData,
            setIsLoadingHoldData,
            pageView,
            setPageView
          }
        },
        pathname
      ) }) }),
      pageView === "table" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-[var(--sidebar-background-color)] dark:bg-dark-300", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `dark:bg-dark-200 ${isShowTitle && "mt-[calc(var(--nav-height)-1px)] pt-3 md:pl-4 md:pt-4 md:pr-3 pl-3 pr-3"} h-[calc(100vh-var(--nav-height))] overflow-x-auto hide-scrollbar bg-cleanWhite dark:text-white`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex relative z-[2] gap-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-2 flex-1", children: isShowTitle && hubSpotUserDetails.sideMenu[0].tabName != title && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("ol", { className: "flex dark:text-white flex-wrap", children: tableTitle && Object.entries(tableTitle).map(
            ([key2, value], index, array) => {
              return /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex items-center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Link,
                  {
                    className: "text-xl font-semibold text-[#0091AE] capitalize dark:text-white hover:underline",
                    to: value == null ? void 0 : value.path,
                    children: getParamHash(
                      formatCustomObjectLabel(value == null ? void 0 : value.name)
                    )
                  }
                ),
                index < array.length - 1 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mx-1 text-xl font-semibold text-[#0091AE]", children: "associated with" })
              ] }, key2);
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "dark:text-white leading-5 text-sm flex items-center", children: !isLoading ? `${totalRecord} records` : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-4 w-20 bg-gray-300 dark:bg-white dark:opacity-20 rounded-sm animate-pulse mr-1 mt-1" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dark:text-white words-break", children: objectDescription ? /* @__PURE__ */ jsxRuntimeExports.jsx(HtmlParser, { html: purify.sanitize(objectDescription) }) : "" })
        ] }) }) }),
        objectUserProperties && objectUserProperties.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          HomeCompanyCard,
          {
            companyDetailsModalOption: false,
            propertiesList: objectUserProperties,
            userData: userData2 == null ? void 0 : userData2.response,
            isLoading: propertyIsLoading,
            isLoadedFirstTime,
            iframePropertyName: objectUserProperties,
            className: `!md:px-0 !px-0 !md:p-0 !pb-0`,
            usedInDynamicComponent: true,
            viewStyle: objectUserPropertiesView
          },
          pathname
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4 w-full overflow-hidden relative", children: [
          hubSpotUserDetails.sideMenu[0].tabName === title && !isLargeScreen && !sidebarRightOpen ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-full dark:bg-dark-200 z-[52] absolute right-[10px] top-[10px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "rounded-full p-2 dark:bg-cleanWhite bg-[var(--sidebar-background-color)] text-[var(--sidebar-text-color)] dark:text-dark-200 animate-pulseEffect dark:animate-pulseEffectDark",
              onClick: toggleSidebar,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(DetailsIcon, {})
            }
          ) }) : "",
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            DashboardTable,
            {
              hubspotObjectTypeId,
              path,
              title: title == "Association" ? associatedtableTitleSingular : title || ((_b2 = hubSpotUserDetails.sideMenu[0]) == null ? void 0 : _b2.label),
              tableTitle: singularTableTitle || hubSpotUserDetails.sideMenu[0].label,
              propertyName,
              showIframe,
              apis,
              componentName: componentName || "object",
              defPermissions,
              companyAsMediator,
              pipeLineId,
              specPipeLine,
              getData,
              states: {
                isLoading,
                setIsLoading,
                urlParam,
                setUrlParam,
                apiResponse,
                setApiResponse,
                info,
                setInfo,
                totalRecord,
                setTotalRecord,
                activeCardData,
                setActiveCardData,
                permissions,
                setPermissions,
                isLoadingHoldData,
                setIsLoadingHoldData,
                pageView,
                setPageView
              },
              isHome,
              pipelines,
              isLoadingPipelines,
              changeTab
            },
            pathname
          ) }, hubspotObjectTypeId)
        ] })
      ] }) }, pathname)
    ] });
  };
  const UserDetails = ({ path, objectId, id, userPermissions, isLoading, isLoadedFirstTime, userCompanyId }) => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
    const [item, setItems] = reactExports.useState([]);
    const [images, setImages] = reactExports.useState([]);
    const [configurations, setConfigurations] = reactExports.useState({
      fileManager: false,
      note: false,
      ticket: false
    });
    const param = getQueryParamsFromCurrentUrl();
    const [activeTab, setActiveTab] = reactExports.useState("files");
    const [permissions, setPermissions] = reactExports.useState(userPermissions);
    getQueryParamsFromCurrentUrl();
    const [galleryDialog, setGalleryDialog] = reactExports.useState(false);
    const [sidebarDetailsOpen, setSidebarDetailsOpen] = reactExports.useState(false);
    const { isLargeScreen } = useResponsive();
    const [userToggled, setUserToggled] = reactExports.useState(false);
    const [totalRecord, setTotalRecord] = reactExports.useState(0);
    const hubspotObjectTypeId = "0-5";
    const getInitialFilter = (type) => {
      return homeTabsDataTypeFilter[type] === "contact" ? "0-1" : homeTabsDataTypeFilter[type] === "company" ? "0-2" : "0-1";
    };
    const [selectedFileDataFilter, setSelectedFileDataFilter] = reactExports.useState(() => getInitialFilter("files"));
    const [selectedNotesDataFilter, setSelectedNotesDataFilter] = reactExports.useState(() => getInitialFilter("notes"));
    const [selectedTicketsDataFilter, setSelectedTicketsDataFilter] = reactExports.useState(() => getInitialFilter("tickets"));
    const userDataFilter = [
      { label: "Owned by organization", value: "0-2" },
      { label: "Owned by me", value: "0-1" }
    ];
    const FilterDropdown = ({
      value,
      onChange,
      className = "w-[200px] rounded-md bg-cleanWhite px-2 text-sm transition-colors border-2 dark:border-gray-600 focus:ring-0 focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 dark:bg-gray-700 dark:text-gray-200 dark:placeholder-gray-400 py-2"
    }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "select",
      {
        className,
        value,
        onChange: (e) => {
          var _a3;
          return onChange(((_a3 = e.target) == null ? void 0 : _a3.value) || "");
        },
        children: userDataFilter.map((filter) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: filter.value, children: filter.label }, filter.value))
      }
    );
    reactExports.useEffect(() => {
      if (!userToggled) {
        setSidebarDetailsOpen(isLargeScreen);
      }
    }, [isLargeScreen, userToggled]);
    reactExports.useEffect(() => {
      const resetOnResize = () => {
        setUserToggled(false);
      };
      window.addEventListener("resize", resetOnResize);
      return () => window.removeEventListener("resize", resetOnResize);
    }, []);
    reactExports.useEffect(() => {
      setConfigurations(userPermissions);
      setPermissions(userPermissions);
    }, [userPermissions]);
    const setActiveTabFucntion = (active) => {
      setActiveTab(active);
      const routeMenuConfig = {
        key: "home",
        details: {
          activeTab: active
        }
      };
      setSelectRouteMenuConfig(routeMenuConfig);
    };
    const setSelectRouteMenuConfig = (routeMenuConfig) => {
      let routeMenuConfigs = getRouteMenuConfig() || {};
      const { key: key2, details } = routeMenuConfig;
      routeMenuConfigs[key2] = { ...routeMenuConfigs[key2], details };
      setRouteMenuConfig(routeMenuConfigs);
    };
    reactExports.useEffect(() => {
      var _a3, _b3;
      let routeMenuConfigs = getRouteMenuConfig();
      if (routeMenuConfigs && routeMenuConfigs.hasOwnProperty("home")) {
        const activeTab2 = (_b3 = (_a3 = routeMenuConfigs.home) == null ? void 0 : _a3.details) == null ? void 0 : _b3.activeTab;
        setActiveTabFucntion(activeTab2 || "files");
      } else {
        setActiveTabFucntion("files");
      }
    }, []);
    let portalId;
    if (env$1.VITE_DATA_SOURCE_SET != true) {
      portalId = (_a2 = getPortal()) == null ? void 0 : _a2.portalId;
    }
    const apis = {
      tableAPI: `/api/${hubId}/${portalId}/hubspot-object-data/${hubspotObjectTypeId}${param}`,
      stagesAPI: `/api/${hubId}/${portalId}/hubspot-object-pipelines/${hubspotObjectTypeId}/`,
      // concat pipelineId
      formAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/${hubspotObjectTypeId}/fields${param ? param + `&parentObjectTypeId=${selectedTicketsDataFilter}` : `?parentObjectTypeId=${selectedTicketsDataFilter}`}`,
      formDataAPI: `/api/:hubId/:portalId/hubspot-object-data/${hubspotObjectTypeId}/:objectId${param ? param + "&isForm=true" : "?isForm=true"}`,
      createAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/${hubspotObjectTypeId}/fields${param}`,
      createExistingAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/:fromObjectTypeId/:fromRecordId/associations/:toObjectTypeId${param}`,
      removeExistingAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/:fromObjectTypeId/:fromRecordId/disassociate/:toObjectTypeId${param}`,
      updateAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/${hubspotObjectTypeId}/fields/:formId${param}`
      // concat ticketId
    };
    if (!isLoadedFirstTime) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: `dark:bg-dark-200 w-[100%] rounded-tl-xl hide-scrollbar overflow-hidden `,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-[calc(100vh_-136px)]", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DetailsSkeleton, { header: false, tabs: 3, active: "file" }) }) })
        }
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: `dark:bg-dark-200 w-[100%] rounded-tl-xl hide-scrollbar overflow-hidden `,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: " flex relative bg-cleanWhite  dark:bg-dark-200 overflow-hidden", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `w-full hide-scrollbar overflow-y-auto overflow-x-hidden`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: ``, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex md:flex-row flex-col md:items-center justify-between my-4 gap-3`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border rounded-lg dark:border-none bg-graySecondary  dark:bg-dark-300 border-flatGray w-fit", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Tabs,
                {
                  activeTab,
                  setActiveTab: setActiveTabFucntion,
                  className: "rounded-md",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { children: [
                      permissions && ((_b2 = permissions == null ? void 0 : permissions.fileManager) == null ? void 0 : _b2.display) && /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { className: "rounded-md", value: "files", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-black dark:text-white", children: "Files" }) }),
                      permissions && ((_c2 = permissions == null ? void 0 : permissions.note) == null ? void 0 : _c2.display) && /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { className: "rounded-md", value: "notes", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-black dark:text-white", children: "Notes" }) }),
                      permissions && ((_d2 = permissions == null ? void 0 : permissions.ticket) == null ? void 0 : _d2.display) && /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { className: "rounded-md", value: "tickets", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-black dark:text-white", children: [
                        ((_e2 = permissions == null ? void 0 : permissions.ticket) == null ? void 0 : _e2.display_label) ? (_f2 = permissions == null ? void 0 : permissions.ticket) == null ? void 0 : _f2.display_label : "Tickets",
                        totalRecord > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2 px-2 py-1 rounded-md bg-secondary dark:bg-white dark:text-dark-300 text-white text-xs", children: totalRecord })
                      ] }) })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "overview" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "files" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "notes" })
                  ]
                }
              ) }),
              activeTab === "files" && homeTabsDataTypeFilter.files === "all" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                FilterDropdown,
                {
                  value: selectedFileDataFilter,
                  onChange: setSelectedFileDataFilter
                }
              ),
              activeTab === "notes" && homeTabsDataTypeFilter.notes === "all" && objectId && id && /* @__PURE__ */ jsxRuntimeExports.jsx(
                FilterDropdown,
                {
                  value: selectedNotesDataFilter,
                  onChange: setSelectedNotesDataFilter
                }
              ),
              activeTab === "tickets" && homeTabsDataTypeFilter.tickets === "all" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                FilterDropdown,
                {
                  value: selectedTicketsDataFilter,
                  onChange: setSelectedTicketsDataFilter
                }
              )
            ] }),
            activeTab === "files" && /* @__PURE__ */ jsxRuntimeExports.jsx(Files, { tabName: "home", fileId: selectedFileDataFilter == "0-2" ? userCompanyId : id, path, objectId: selectedFileDataFilter, id: selectedFileDataFilter == "0-2" ? userCompanyId : id, permissions: permissions ? permissions.fileManager : null }),
            activeTab === "notes" && objectId && id && /* @__PURE__ */ jsxRuntimeExports.jsx(Notes, { tabName: "home", item, path, objectId: selectedNotesDataFilter, id: selectedNotesDataFilter == "0-2" ? userCompanyId : id, permissions: permissions ? permissions.note : null }),
            activeTab === "tickets" && // <Tickets
            //     path={path}
            //     objectId={objectId}
            //     id={id}
            //     parentObjectTypeId={objectId}
            //     parentObjectRowId={id}
            //     permissions={permissions ? permissions.ticket : null}
            //     companyAsMediator={false}
            //     profileTicket={true}
            // />
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              DynamicComponentView,
              {
                hubspotObjectTypeId,
                path,
                title: ((_g2 = permissions == null ? void 0 : permissions.ticket) == null ? void 0 : _g2.display_label) || "Tickets",
                ticketTableTitle: ((_h2 = permissions == null ? void 0 : permissions.ticket) == null ? void 0 : _h2.display_label) || "Tickets",
                apis,
                componentName: "ticket",
                defPermissions: permissions ? permissions.ticket : null,
                editView: true,
                setTotalRecord,
                isShowTitle: false,
                isHome: true,
                companyAsMediator: selectedTicketsDataFilter == "0-2" ? true : false
              }
            ),
            images.length > 0 && activeTab === "photos" && /* @__PURE__ */ jsxRuntimeExports.jsx(
              DetailsGallery,
              {
                images,
                setGalleryDialog
              }
            )
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Dialog,
            {
              open: galleryDialog,
              onClose: setGalleryDialog,
              className: "w-[50%]",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: " bg-cleanWhite dark:bg-dark-200 dark:text-white rounded-md flex-col justify-start items-center gap-6 inline-flex", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-2 gap-4", children: images.map((url, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: url,
                  alt: `Image ${index + 1}`,
                  className: "w-full h-auto"
                },
                index
              )) }) })
            }
          )
        ] })
      }
    );
  };
  const HomeSidebarSkeleton = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: `space-y-4 transition-all duration-300 ease-in-out overflow-hidden max-h-[270px]`, children: Array(2).fill("").map((_2, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-start text-rstextcolor bg-rscardbackhround dark:text-white dark:bg-dark-500 p-2 flex-col gap-1 border !border-transparent dark:!border-gray-600 rounded-md justify-between", children: [...Array(6)].map((_22, j2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "animate-pulse gap-1 flex items-center justify-between w-full",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 text-xs whitespace-wrap align-top dark:text-white text-rstextcolor !p-[3px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "h-3 bg-rstextcolor dark:bg-white rounded-sm w-full inline-block opacity-30" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 dark:text-white text-xs whitespace-wrap text-rstextcolor break-all  !p-[3px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "h-3 bg-rstextcolor dark:bg-white rounded-sm w-full inline-block opacity-30" }) })
          ]
        },
        j2
      )) }, i2)) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-between p-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-8 w-8 bg-gray-300 dark:bg-dark-white dark:bg-opacity-20 rounded-md animate-pulse" }),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-6 w-6 bg-gray-300 dark:bg-dark-white dark:bg-opacity-20 rounded-md animate-pulse" }),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-8 w-8 bg-gray-300 dark:bg-dark-white dark:bg-opacity-20 rounded-md animate-pulse" }),
        " "
      ] }) })
    ] }) });
  };
  const SidebarTable = ({ hubspotObjectTypeId, path, inputValue, pipeLineId, specPipeLine, title, companyAsMediator, apis, detailsView = true, editView = false }) => {
    var _a2;
    const [showAddDialog, setShowAddDialog] = reactExports.useState(false);
    const [tableData, setTableData] = reactExports.useState([]);
    const [currentTableData, setCurrentTableData] = reactExports.useState([]);
    const [totalItems, setTotalItems] = reactExports.useState(0);
    const [itemsPerPage, setItemsPerPage] = reactExports.useState(10);
    const [currentPage, setCurrentPage] = reactExports.useState(1);
    const [tableHeader, setTableHeader] = reactExports.useState([]);
    const [after, setAfter] = reactExports.useState("");
    const [sortConfig, setSortConfig] = reactExports.useState("-hs_createdate");
    const [filterPropertyName, setFilterPropertyName] = reactExports.useState(null);
    const [filterOperator, setFilterOperator] = reactExports.useState(null);
    const [filterValue, setFilterValue] = reactExports.useState(null);
    const [numOfPages, setNumOfPages] = reactExports.useState(Math.ceil(totalItems / itemsPerPage));
    const { sync, setSync } = useSync();
    const [isExpanded, setIsExpanded] = reactExports.useState(false);
    const [hoverRow, setHoverRow] = reactExports.useState(null);
    const [permissions, setPermissions] = reactExports.useState(null);
    const [urlParam, setUrlParam] = reactExports.useState(null);
    const [singularModalTitle, setSingularModalTitle] = reactExports.useState(null);
    reactExports.useEffect(() => {
      setNumOfPages(Math.ceil(totalItems / itemsPerPage));
    }, [totalItems, itemsPerPage]);
    reactExports.useEffect(() => {
      const hash = location.hash;
      const queryIndex = hash.indexOf("?");
      const queryParams = new URLSearchParams(hash.substring(queryIndex));
      setFilterPropertyName(queryParams.get("filterPropertyName"));
      setFilterOperator(queryParams.get("filterOperator"));
      setFilterValue(queryParams.get("filterValue"));
    }, [location.search]);
    const mapResponseData = (data) => {
      if (env$1.VITE_DATA_SOURCE_SET === true) {
        const results = data.data.results || [];
        const foundItem = results.find((item) => {
          return item.name === path ? path == null ? void 0 : path.replace("/", "") : "";
        });
        setCurrentTableData(foundItem.results.rows);
        setTotalItems(foundItem.results.rows.length || 0);
        setItemsPerPage(foundItem.results.rows.length > 0 ? itemsPerPage : 0);
        if (foundItem.results.rows.length > 0) {
          setTableHeader(sortData(foundItem.results.columns));
        } else {
          setTableHeader([]);
        }
      } else {
        const results = data.data.results.rows || [];
        const columns = data.data.results.columns || [];
        setTableData(results);
        setTotalItems(data.data.total || 0);
        setItemsPerPage(results.length > 0 ? itemsPerPage : 0);
        setTableHeader(sortData(columns));
      }
    };
    const mediatorObjectTypeId = getParam$1("mediatorObjectTypeId");
    const mediatorObjectRecordId = getParam$1("mediatorObjectRecordId");
    getParam$1("parentObjectTypeName");
    const objectTypeId = getParam$1("objectTypeId");
    const objectTypeName = getParam$1("objectTypeName");
    let portalId;
    if (env$1.VITE_DATA_SOURCE_SET != true) {
      portalId = (_a2 = getPortal()) == null ? void 0 : _a2.portalId;
    }
    const { mutate: getData, data: tableAPiData, isLoading } = useMutation({
      mutationKey: ["TableData"],
      mutationFn: async (props) => {
        const param = {
          limit: itemsPerPage || 10,
          page: currentPage,
          ...after && after.length > 0 && { after },
          sort: sortConfig,
          filterPropertyName: "hs_pipeline",
          filterOperator: "eq",
          filterValue: specPipeLine ? pipeLineId : "",
          cache: sync ? false : true,
          isPrimaryCompany: companyAsMediator ? companyAsMediator : false
        };
        setUrlParam(param);
        if (companyAsMediator) param.mediatorObjectTypeId = "0-2";
        return await Client.objects.all({
          API_ENDPOINT: apis.tableAPI,
          param: updateParamsFromUrl(apis.tableAPI, param)
        });
      },
      onSuccess: (data) => {
        setSync(false);
        if (data.statusCode === "200") {
          mapResponseData(data);
          setPermissions(data.configurations["object"]);
          setNumOfPages(Math.ceil(data.data.total / itemsPerPage));
        }
      },
      onError: (error) => {
        console.error("API Error:", error);
        setSync(false);
        setTableData([]);
        setPermissions(null);
      }
    });
    const handlePageChange = async (page) => {
      setCurrentPage(page);
      setAfter((page - 1) * itemsPerPage);
      await wait(100);
      getData();
    };
    reactExports.useEffect(() => {
      if (env$1.VITE_DATA_SOURCE_SET === true) {
        setTableData(currentTableData.slice(
          (currentPage - 1) * itemsPerPage,
          currentPage * itemsPerPage
        ));
      }
    }, [currentTableData, currentPage, itemsPerPage]);
    reactExports.useEffect(() => {
      if (sync) getData();
    }, [sync]);
    reactExports.useEffect(() => {
      getData();
    }, []);
    const toggleContent = () => {
      setIsExpanded((prev) => !prev);
    };
    const handleRowHover = (row) => {
      setHoverRow(row);
    };
    reactExports.useEffect(() => {
      setSingularModalTitle(
        title.endsWith("s") ? title.slice(0, -1) : title
      );
    }, [title]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-[var(--right-tables-background-color)] rounded-lg px-4 pt-2 w-full max-w-md dark:bg-dark-300", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between gap-x-2 text-sm font-medium pt-3 pb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: toggleContent, className: "cursor-pointer ", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { content: isExpanded ? "Shrink" : "Expand", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-secondary dark:text-white", children: isExpanded ? /* @__PURE__ */ jsxRuntimeExports.jsx(Chevron, { className: "rotate-[270deg] origin-center -webkit-transform" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Chevron, { className: "rotate-180 origin-center -webkit-transform" }) }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dark:text-white text-secondary font-bold text-xs", children: title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2 px-2 py-1 rounded-md bg-secondary dark:bg-white dark:text-dark-300 text-white text-xs", children: totalItems })
          ] })
        ] }),
        (permissions == null ? void 0 : permissions.create) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-end cursor-pointer ", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { className: "font-semibold text-xs", variant: "link", size: "link", onClick: () => setShowAddDialog(true), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mr-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconPlus, { className: "!w-3 !h-3" }) }),
          "Add"
        ] }) })
      ] }),
      isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: ``, children: /* @__PURE__ */ jsxRuntimeExports.jsx(HomeSidebarSkeleton, {}) }),
      !isLoading && tableData.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center p-5", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyMessageCard, { name: hubSpotUserDetails.sideMenu[0].tabName === title ? "item" : title, type: "col", className: "p-0" }),
        tableAPiData && tableAPiData.data && tableAPiData.data.configurations && tableAPiData.data.configurations.association && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-secondary text-base md:text-2xl dark:text-gray-300 mt-3", children: tableAPiData.data.configurations.associationMessage })
      ] }),
      !isLoading && tableData.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: `space-y-4 transition-all duration-300 ease-in-out ${isExpanded ? "max-h-auto" : "max-h-[270px] overflow-y-auto hide-scrollbar"}`, children: tableData.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx("table", { className: "flex items-start text-[var(--right-tables-text-color)] bg-[var(--right-tables-card-background-color)] dark:text-white dark:bg-dark-500 p-2 flex-col gap-1 border !border-transparent dark:!border-gray-600 rounded-md justify-between", children: tableHeader.map((column) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "tr",
          {
            className: "",
            onMouseEnter: () => handleRowHover(item),
            onMouseLeave: () => handleRowHover(null),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "pr-1 text-xs whitespace-wrap md:w-[120px] w-[100px] align-top dark:text-white text-[var(--right-tables-text-color)] !p-[3px]", children: [
                column.value,
                ": "
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "dark:text-white text-xs whitespace-wrap  text-[var(--right-tables-text-color)] break-all  !p-[3px]", children: renderCellContent(
                // companyAsMediator,
                // item[column.key],
                // column,
                // item.hs_object_id,
                // path == '/association' ? `/${getParam('objectTypeName')}` : item[column.key],
                // path == '/association' ? getParam('objectTypeId') : hubspotObjectTypeId,
                // 'homeList',
                // path == '/association' ? `/${objectTypeName}/${objectTypeId}/${item.hs_object_id}?mediatorObjectTypeId=${mediatorObjectTypeId}&mediatorObjectRecordId=${mediatorObjectRecordId}` : '',
                // detailsView,
                // hoverRow
                {
                  companyAsMediator,
                  value: item[column.key],
                  column,
                  itemId: item.hs_object_id,
                  path: path == "/association" ? `/${getParam$1("objectTypeName")}` : item[column.key],
                  hubspotObjectTypeId: path == "/association" ? getParam$1("objectTypeId") : hubspotObjectTypeId,
                  type: "homeList",
                  associationPath: path == "/association" ? `/${objectTypeName}/${objectTypeId}/${item.hs_object_id}?mediatorObjectTypeId=${mediatorObjectTypeId}&mediatorObjectRecordId=${mediatorObjectRecordId}` : "",
                  detailsView,
                  hoverRow,
                  item,
                  urlParam: null
                }
              ) })
            ]
          },
          column.value
        )) }, item.id)) }),
        tableData.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex lg:flex-row flex-col justify-between items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Pagination,
          {
            numOfPages: numOfPages || 0,
            currentPage,
            setCurrentPage: handlePageChange
          }
        ) })
      ] }),
      showAddDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(DashboardTableForm, { openModal: showAddDialog, setOpenModal: setShowAddDialog, title: singularModalTitle, path, portalId, hubspotObjectTypeId, apis, refetch: getData, urlParam })
    ] });
  };
  const Dashboard = () => {
    var _a2, _b2;
    const router2 = useRouter();
    const {
      pathname
    } = (_a2 = router2 == null ? void 0 : router2.state) == null ? void 0 : _a2.location;
    let {
      homeCardsView
    } = getRouteMenu(pathname);
    const param = getQueryParamsFromCurrentUrl();
    const [sidebarRightOpen, setSidebarRightOpen] = reactExports.useState(false);
    const {
      isLargeScreen,
      isMediumScreen,
      isSmallScreen
    } = useResponsive();
    const [userToggled, setUserToggled] = reactExports.useState(false);
    const [userData2, setUserData] = reactExports.useState();
    const [userId, setUserId] = reactExports.useState();
    const [userCompanyId, setUserCompanyId] = reactExports.useState();
    const [userObjectId, setUserObjectId] = reactExports.useState();
    const [cacheEnabled, setCacheEnabled] = reactExports.useState(true);
    const portalId = (_b2 = getPortal()) == null ? void 0 : _b2.portalId;
    const {
      sync,
      setSync
    } = useSync();
    const [isLoadedFirstTime, setIsLoadedFirstTime] = reactExports.useState(false);
    const fetchUserProfile = async ({
      portalId: portalId2,
      cache
    }) => {
      if (!portalId2) return null;
      const response = await Client.user.profile({
        portalId: portalId2,
        cache
      });
      return response == null ? void 0 : response.data;
    };
    const {
      data: userNewData,
      error,
      isLoading,
      refetch
    } = useQuery({
      queryKey: ["userProfilePage", portalId, cacheEnabled],
      queryFn: () => fetchUserProfile({
        portalId,
        cache: sync ? false : true
      }),
      onSuccess: (data) => {
        var _a3, _b3, _c2, _d2, _e2, _f2, _g2;
        if (data) {
          setUserData(data);
          setUserId((_b3 = (_a3 = data == null ? void 0 : data.response) == null ? void 0 : _a3.hs_object_id) == null ? void 0 : _b3.value);
          setUserObjectId((_c2 = data == null ? void 0 : data.info) == null ? void 0 : _c2.objectTypeId);
          setUserCompanyId((_g2 = (_f2 = (_e2 = (_d2 = data == null ? void 0 : data.response) == null ? void 0 : _d2.associations) == null ? void 0 : _e2.COMPANY) == null ? void 0 : _f2.hs_object_id) == null ? void 0 : _g2.value);
        }
        setSync(false);
        setIsLoadedFirstTime(true);
      },
      onError: (error2) => {
        console.error("Error fetching profile:", error2);
        setSync(false);
        setIsLoadedFirstTime(true);
      }
    });
    reactExports.useEffect(() => {
      if (sync) {
        refetch();
      }
    }, [sync]);
    const toggleSidebar = () => {
      setUserToggled(true);
      setSidebarRightOpen((prev) => !prev);
    };
    reactExports.useEffect(() => {
      if (!userToggled) {
        if (isLargeScreen) {
          setSidebarRightOpen(true);
        } else if (isMediumScreen || isSmallScreen) {
          setSidebarRightOpen(false);
        }
      }
    }, [isLargeScreen, isMediumScreen, isSmallScreen, userToggled]);
    reactExports.useEffect(() => {
      const resetOnResize = () => {
        setUserToggled(false);
      };
      window.addEventListener("resize", resetOnResize);
      return () => window.removeEventListener("resize", resetOnResize);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-[var(--sidebar-background-color)] h-[calc(100vh-var(--nav-height))] dark:bg-dark-300 ", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `dark:bg-dark-200 mt-[calc(var(--nav-height)-1px)] h-[calc(100vh-var(--nav-height))] bg-cleanWhite dark:text-white md:pl-4 
      ${isLargeScreen ? " " : `${!sidebarRightOpen ? "md:pr-4 pr-3  pl-3 " : "pl-3"}`}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4 w-full overflow-hidden relative", children: [
      showSidebarListDataOption && !isLargeScreen && !sidebarRightOpen ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-full dark:bg-dark-200 z-[52] absolute right-[10px] lg:top-[10px] md:top-[60px] top-[10px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "rounded-full p-2 dark:bg-cleanWhite bg-[var(--sidebar-background-color)] text-[var(--sidebar-text-color)] dark:text-dark-200 animate-pulseEffect dark:animate-pulseEffectDark", onClick: toggleSidebar, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DetailsIcon, {}) }) }) : "",
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: ` h-[calc(100vh-var(--nav-height))] hide-scrollbar overflow-y-auto ${enableDashboardCards ? " md:py-4 py-3" : " md:pb-4 pb-3"}
                ${showSidebarListDataOption && isLargeScreen ? "w-[calc(100%_-350px)]" : "w-full"} ${!showSidebarListDataOption && isLargeScreen ? "md:pr-4 pr-3 " : ""}`, children: [
        enableDashboardCards && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `grid grid-cols-12 md:gap-4 gap-3`, children: dashboardCards.map((card, index) => {
          const isLast = index === dashboardCards.length - 1;
          const isOdd = dashboardCards.length % 2 !== 0;
          const isOnly = dashboardCards.length === 1;
          const colSpan = isOnly || isLast && isOdd ? "col-span-12" : "md:col-span-6 col-span-12";
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${homeCardsView != "list" ? colSpan : "col-span-12"} grid border dark:border-none dark:border-gray-600 rounded-lg overflow-hidden shadow-[0px_4px_12px_0px_rgba(0,0,0,0.04)]
                      ${moduleStylesOptions.homeTabStyles.overlayer.color != "" ? `bg-[var(--home-tab-overlayer-color)]` : "bg-[var(--banner-overlayer-color)]"} dark:bg-dark-300 relative`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `absolute bottom-0 right-0 z-1 ${moduleStylesOptions.homeTabStyles.svgColor.color != "" ? `text-[var(--home-tab-svg-color)]` : "text-[var(--primary-color)]"} dark:text-gray-500`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "151", height: "125", viewBox: "0 0 151 125", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_7211_3894)", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "116", cy: "116", r: "116", fill: "currentColor", opacity: "0.1" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "116", cy: "116", r: "77", fill: "currentColor", opacity: "0.3" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "116", cy: "116", r: "35", fill: "currentColor", opacity: "0.5" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_7211_3894", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "151", height: "125", fill: "white" }) }) })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(HomeBanner, { moduleBannerDetailsOption: card, userData: userData2 }),
              (card == null ? void 0 : card.properties) && (card == null ? void 0 : card.properties.length) > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(HomeCompanyCard, { companyDetailsModalOption: card == null ? void 0 : card.add_details_modal, propertiesList: card == null ? void 0 : card.properties, userData: userData2 == null ? void 0 : userData2.response, isLoading, isLoadedFirstTime, iframePropertyName: card == null ? void 0 : card.properties, viewStyle: card == null ? void 0 : card.view })
            ] })
          ] }, index);
        }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(UserDetails, { userCompanyId, userPermissions: userData2 == null ? void 0 : userData2.configurations, objectId: userObjectId, id: userId, isLoading, isLoadedFirstTime })
      ] }),
      showSidebarListDataOption && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: ` bg-cleanWhite transition-transform duration-200 ease-in-out lg:h-[calc(100vh-var(--nav-height))] h-[100vh] hide-scrollbar overflow-visible max-lg:z-[52] lg:mt-[1px]
                ${isLargeScreen ? "w-[330px] right-0 static rounded-md dark:bg-dark-200 " : "fixed w-full inset-0 bg-gray-500 dark:bg-dark-300 bg-opacity-50 dark:bg-opacity-50 backdrop-blur-md backdrop-filter right-0 top-0 bottom-0 transform translate-x-full"} 
                ${!isLargeScreen && sidebarRightOpen ? "translate-x-0 mb-4" : ""}`, children: [
        !isLargeScreen && sidebarRightOpen && showSidebarListDataOption && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute z-[59] right-[9px] top-[60px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "rounded-full p-2 bg-[var(--sidebar-background-color)] dark:bg-cleanWhite text-[var(--sidebar-text-color)] dark:text-dark-200  animate-pulseEffect dark:animate-pulseEffectDark", onClick: toggleSidebar, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, {}) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-full md:!pt-4 hide-scrollbar ml-auto lg:max-w-auto lg:p-0 p-3 bg-cleanWhite dark:bg-dark-200 max-w-[350px] overflow-visible", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-col flex lg:gap-6 gap-3 lg:pb-4", children: sidebarListDataOption.map((option, index) => {
          const hubspotObjectTypeId = option.hubspotObjectTypeId;
          const sidebarDataApis = {
            tableAPI: `/api/${hubId}/${portalId}/hubspot-object-data/${hubspotObjectTypeId}${param}`,
            stagesAPI: `/api/${hubId}/${portalId}/hubspot-object-pipelines/${hubspotObjectTypeId}/`,
            // concat pipelineId
            formAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/${hubspotObjectTypeId}/fields${param}`,
            formDataAPI: `/api/:hubId/:portalId/hubspot-object-data/${hubspotObjectTypeId}/:objectId${param ? param + "&isForm=true" : "?isForm=true"}`,
            createAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/${hubspotObjectTypeId}/fields${param}`,
            createExistingAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/:fromObjectTypeId/:fromRecordId/associations/:toObjectTypeId${param}`,
            removeExistingAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/:fromObjectTypeId/:fromRecordId/disassociate/:toObjectTypeId${param}`,
            updateAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/${hubspotObjectTypeId}/fields/:formId${param}`
            // concat ticketId
          };
          return index === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarTable, { hubspotObjectTypeId, path: `/${formatPath(option.label)}`, title: option.label, apis: sidebarDataApis, companyAsMediator: option.companyAsMediator, pipeLineId: option.pipeLineId, specPipeLine: option.specPipeLine }, index) : /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarTable, { hubspotObjectTypeId, path: `/${formatPath(option.label)}`, title: option.label, apis: sidebarDataApis, companyAsMediator: option.companyAsMediator, pipeLineId: option.pipeLineId, specPipeLine: option.specPipeLine }, index);
        }) }) })
      ] })
    ] }) }) });
  };
  const App = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Dashboard, {});
  };
  const Route$b = createFileRoute("/")({
    component: App,
    beforeLoad: () => {
      return {
        layout: "MainLayout",
        requiresAuth: true
      };
    }
  });
  const ListComponent = () => {
    var _a2;
    const {
      listComponent: path
    } = Route$a.useParams();
    const router2 = useRouter();
    const {
      pathname
    } = router2.state.location;
    reactExports.useEffect(() => {
    }, [path, pathname]);
    const routeMenu = getRouteMenu(pathname);
    if (!routeMenu) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("h1", { className: "text-center", children: [
        pathname,
        " 404 Not Found"
      ] });
    }
    if (routeMenu == null ? void 0 : routeMenu.homeCardsView) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Dashboard, {});
    }
    let {
      hubspotObjectTypeId,
      title,
      pipeLineId,
      companyAsMediator,
      specPipeLine,
      objectDescription,
      objectUserProperties,
      objectUserPropertiesView
    } = routeMenu;
    let showIframe = "";
    let propertyName = "";
    const param = getQueryParamsFromCurrentUrl();
    let portalId;
    if (env$1.VITE_DATA_SOURCE_SET != true) {
      portalId = (_a2 = getPortal()) == null ? void 0 : _a2.portalId;
    }
    hubspotObjectTypeId = hubspotObjectTypeId || getParam$1("objectTypeId");
    const apis = {
      tableAPI: `/api/${hubId}/${portalId}/hubspot-object-data/${hubspotObjectTypeId}${param}`,
      stagesAPI: `/api/${hubId}/${portalId}/hubspot-object-pipelines/${hubspotObjectTypeId}/`,
      // concat pipelineId
      formAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/${hubspotObjectTypeId}/fields${param}`,
      formDataAPI: `/api/:hubId/:portalId/hubspot-object-data/${hubspotObjectTypeId}/:objectId${param ? param + "&isForm=true" : "?isForm=true"}`,
      createAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/${hubspotObjectTypeId}/fields${param}`,
      createExistingAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/:fromObjectTypeId/:fromRecordId/associations/:toObjectTypeId${param}`,
      removeExistingAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/:fromObjectTypeId/:fromRecordId/disassociate/:toObjectTypeId${param}`,
      updateAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/${hubspotObjectTypeId}/fields/:formId${param}`
      // concat ticketId
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicComponentView, { hubspotObjectTypeId, path, title, showIframe, propertyName, companyAsMediator, pipeLineId, specPipeLine, objectDescription, apis, objectUserProperties, objectUserPropertiesView }, path);
  };
  const Route$a = createFileRoute("/_dynamicPage/$listComponent")({
    component: ListComponent,
    beforeLoad: () => {
      return {
        layout: "MainLayout",
        requiresAuth: true
      };
    }
  });
  function VerifyEmail() {
    const [isVerifying, setIsVerifying] = reactExports.useState(true);
    const [isVerified, setIsVerified] = reactExports.useState(false);
    const {
      setToaster
    } = useToaster();
    const token = getParam("token");
    const {
      mutate: getVeifyEmail,
      isLoading
    } = useMutation({
      mutationKey: ["verifyEmail"],
      mutationFn: async () => {
        try {
          const response = await Client.authentication.verifyEmail({
            token
          });
          return response;
        } catch (error) {
          throw error;
        }
      },
      onSuccess: async () => {
        setIsVerified(true);
        setIsVerifying(false);
      },
      onError: (error) => {
        let errorMessage = "An unexpected error occurred.";
        if (error.response && error.response.data) {
          const errorData = error.response.data.detailedMessage;
          errorMessage = typeof errorData === "object" ? JSON.stringify(errorData) : errorData;
        }
        Ut.error(errorMessage);
      }
    });
    reactExports.useEffect(() => {
      getVeifyEmail();
    }, [token]);
    const handleRedirect = () => {
      window.location.hash = "/login";
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center min-h-screen", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-2xl font-bold mb-4 text-center", children: isVerified ? "Your Email Has Been Successfully Verified" : "Verify your email" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-lg text-gray-600 mb-8 text-center", children: isVerified ? "Your email is now verified. Enjoy full access to your account!" : "confirm verify" }),
      isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loader border-t-4 border-blue-500 rounded-full w-16 h-16 mb-6 animate-spin" }) : isVerified ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TickIcon, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: "my-4 ml-3 !bg-black", onClick: handleRedirect, children: "Okay" })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Session is expired" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: "my-4 ml-3 !bg-black", onClick: handleRedirect, children: "Back to login" })
      ] })
    ] });
  }
  const Route$9 = createFileRoute("/_auth/verify-email")({
    component: VerifyEmail,
    beforeLoad: () => {
      return {
        layout: "AuthLayout",
        requiresAuth: false
      };
    }
  });
  var define_process_default = { env: {} };
  var define_process_env_default = {};
  function err(message) {
    const error = new Error(message);
    if (error.stack === void 0) {
      try {
        throw error;
      } catch (_2) {
      }
    }
    return error;
  }
  var err_1 = err;
  var Recoil_err = err_1;
  function isPromise(p) {
    return !!p && typeof p.then === "function";
  }
  var Recoil_isPromise = isPromise;
  function nullthrows(x2, message) {
    if (x2 != null) {
      return x2;
    }
    throw Recoil_err(message !== null && message !== void 0 ? message : "Got unexpected null or undefined");
  }
  var Recoil_nullthrows = nullthrows;
  function _defineProperty(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  class BaseLoadable {
    getValue() {
      throw Recoil_err("BaseLoadable");
    }
    toPromise() {
      throw Recoil_err("BaseLoadable");
    }
    valueMaybe() {
      throw Recoil_err("BaseLoadable");
    }
    valueOrThrow() {
      throw Recoil_err(`Loadable expected value, but in "${this.state}" state`);
    }
    promiseMaybe() {
      throw Recoil_err("BaseLoadable");
    }
    promiseOrThrow() {
      throw Recoil_err(`Loadable expected promise, but in "${this.state}" state`);
    }
    errorMaybe() {
      throw Recoil_err("BaseLoadable");
    }
    errorOrThrow() {
      throw Recoil_err(`Loadable expected error, but in "${this.state}" state`);
    }
    is(other) {
      return other.state === this.state && other.contents === this.contents;
    }
    map(_map) {
      throw Recoil_err("BaseLoadable");
    }
  }
  class ValueLoadable extends BaseLoadable {
    constructor(value) {
      super();
      _defineProperty(this, "state", "hasValue");
      _defineProperty(this, "contents", void 0);
      this.contents = value;
    }
    getValue() {
      return this.contents;
    }
    toPromise() {
      return Promise.resolve(this.contents);
    }
    valueMaybe() {
      return this.contents;
    }
    valueOrThrow() {
      return this.contents;
    }
    promiseMaybe() {
      return void 0;
    }
    errorMaybe() {
      return void 0;
    }
    map(map) {
      try {
        const next = map(this.contents);
        return Recoil_isPromise(next) ? loadableWithPromise(next) : isLoadable(next) ? next : loadableWithValue(next);
      } catch (e) {
        return Recoil_isPromise(e) ? (
          // If we "suspended", then try again.
          // errors and subsequent retries will be handled in 'loading' case
          // $FlowFixMe[prop-missing]
          loadableWithPromise(e.next(() => this.map(map)))
        ) : loadableWithError(e);
      }
    }
  }
  class ErrorLoadable extends BaseLoadable {
    constructor(error) {
      super();
      _defineProperty(this, "state", "hasError");
      _defineProperty(this, "contents", void 0);
      this.contents = error;
    }
    getValue() {
      throw this.contents;
    }
    toPromise() {
      return Promise.reject(this.contents);
    }
    valueMaybe() {
      return void 0;
    }
    promiseMaybe() {
      return void 0;
    }
    errorMaybe() {
      return this.contents;
    }
    errorOrThrow() {
      return this.contents;
    }
    map(_map) {
      return this;
    }
  }
  class LoadingLoadable extends BaseLoadable {
    constructor(promise) {
      super();
      _defineProperty(this, "state", "loading");
      _defineProperty(this, "contents", void 0);
      this.contents = promise;
    }
    getValue() {
      throw this.contents;
    }
    toPromise() {
      return this.contents;
    }
    valueMaybe() {
      return void 0;
    }
    promiseMaybe() {
      return this.contents;
    }
    promiseOrThrow() {
      return this.contents;
    }
    errorMaybe() {
      return void 0;
    }
    map(map) {
      return loadableWithPromise(this.contents.then((value) => {
        const next = map(value);
        if (isLoadable(next)) {
          const nextLoadable = next;
          switch (nextLoadable.state) {
            case "hasValue":
              return nextLoadable.contents;
            case "hasError":
              throw nextLoadable.contents;
            case "loading":
              return nextLoadable.contents;
          }
        }
        return next;
      }).catch((e) => {
        if (Recoil_isPromise(e)) {
          return e.then(() => this.map(map).contents);
        }
        throw e;
      }));
    }
  }
  function loadableWithValue(value) {
    return Object.freeze(new ValueLoadable(value));
  }
  function loadableWithError(error) {
    return Object.freeze(new ErrorLoadable(error));
  }
  function loadableWithPromise(promise) {
    return Object.freeze(new LoadingLoadable(promise));
  }
  function loadableLoading() {
    return Object.freeze(new LoadingLoadable(new Promise(() => {
    })));
  }
  function loadableAllArray(inputs) {
    return inputs.every((i2) => i2.state === "hasValue") ? loadableWithValue(inputs.map((i2) => i2.contents)) : inputs.some((i2) => i2.state === "hasError") ? loadableWithError(Recoil_nullthrows(inputs.find((i2) => i2.state === "hasError"), "Invalid loadable passed to loadableAll").contents) : loadableWithPromise(Promise.all(inputs.map((i2) => i2.contents)));
  }
  function loadableAll(inputs) {
    const unwrapedInputs = Array.isArray(inputs) ? inputs : Object.getOwnPropertyNames(inputs).map((key2) => inputs[key2]);
    const normalizedInputs = unwrapedInputs.map((x2) => isLoadable(x2) ? x2 : Recoil_isPromise(x2) ? loadableWithPromise(x2) : loadableWithValue(x2));
    const output = loadableAllArray(normalizedInputs);
    return Array.isArray(inputs) ? (
      // $FlowIssue[incompatible-return]
      output
    ) : (
      // Object.getOwnPropertyNames() has consistent key ordering with ES6
      // $FlowIssue[incompatible-call]
      output.map((outputs) => Object.getOwnPropertyNames(inputs).reduce(
        // $FlowFixMe[invalid-computed-prop]
        (out, key2, idx) => ({
          ...out,
          [key2]: outputs[idx]
        }),
        {}
      ))
    );
  }
  function isLoadable(x2) {
    return x2 instanceof BaseLoadable;
  }
  const LoadableStaticInterface = {
    of: (value) => Recoil_isPromise(value) ? loadableWithPromise(value) : isLoadable(value) ? value : loadableWithValue(value),
    error: (error) => loadableWithError(error),
    // $FlowIssue[incompatible-return]
    loading: () => loadableLoading(),
    // $FlowIssue[unclear-type]
    all: loadableAll,
    isLoadable
  };
  var Recoil_Loadable = {
    loadableWithValue,
    loadableWithError,
    loadableWithPromise,
    loadableLoading,
    loadableAll,
    isLoadable,
    RecoilLoadable: LoadableStaticInterface
  };
  var Recoil_Loadable_1 = Recoil_Loadable.loadableWithValue;
  var Recoil_Loadable_2 = Recoil_Loadable.loadableWithError;
  var Recoil_Loadable_3 = Recoil_Loadable.loadableWithPromise;
  var Recoil_Loadable_4 = Recoil_Loadable.loadableLoading;
  var Recoil_Loadable_5 = Recoil_Loadable.loadableAll;
  var Recoil_Loadable_6 = Recoil_Loadable.isLoadable;
  var Recoil_Loadable_7 = Recoil_Loadable.RecoilLoadable;
  var Recoil_Loadable$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    loadableWithValue: Recoil_Loadable_1,
    loadableWithError: Recoil_Loadable_2,
    loadableWithPromise: Recoil_Loadable_3,
    loadableLoading: Recoil_Loadable_4,
    loadableAll: Recoil_Loadable_5,
    isLoadable: Recoil_Loadable_6,
    RecoilLoadable: Recoil_Loadable_7
  });
  const env = {
    RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED: true,
    // Note: RECOIL_GKS_ENABLED settings will only be honored in OSS builds of Recoil
    RECOIL_GKS_ENABLED: /* @__PURE__ */ new Set(["recoil_hamt_2020", "recoil_sync_external_store", "recoil_suppress_rerender_in_callback", "recoil_memory_managament_2020"])
  };
  function readProcessEnvBooleanFlag(name, set2) {
    var _process$env$name, _process$env$name$toL;
    const sanitizedValue = (_process$env$name = define_process_env_default[name]) === null || _process$env$name === void 0 ? void 0 : (_process$env$name$toL = _process$env$name.toLowerCase()) === null || _process$env$name$toL === void 0 ? void 0 : _process$env$name$toL.trim();
    if (sanitizedValue == null || sanitizedValue === "") {
      return;
    }
    const allowedValues = ["true", "false"];
    if (!allowedValues.includes(sanitizedValue)) {
      throw Recoil_err(`process.env.${name} value must be 'true', 'false', or empty: ${sanitizedValue}`);
    }
    set2(sanitizedValue === "true");
  }
  function readProcessEnvStringArrayFlag(name, set2) {
    var _process$env$name2;
    const sanitizedValue = (_process$env$name2 = define_process_env_default[name]) === null || _process$env$name2 === void 0 ? void 0 : _process$env$name2.trim();
    if (sanitizedValue == null || sanitizedValue === "") {
      return;
    }
    set2(sanitizedValue.split(/\s*,\s*|\s+/));
  }
  function applyProcessEnvFlagOverrides() {
    var _process;
    if (typeof define_process_default === "undefined") {
      return;
    }
    if (((_process = define_process_default) === null || _process === void 0 ? void 0 : _process.env) == null) {
      return;
    }
    readProcessEnvBooleanFlag("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED", (value) => {
      env.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED = value;
    });
    readProcessEnvStringArrayFlag("RECOIL_GKS_ENABLED", (value) => {
      value.forEach((gk) => {
        env.RECOIL_GKS_ENABLED.add(gk);
      });
    });
  }
  applyProcessEnvFlagOverrides();
  var Recoil_RecoilEnv = env;
  function Recoil_gkx_OSS(gk) {
    return Recoil_RecoilEnv.RECOIL_GKS_ENABLED.has(gk);
  }
  Recoil_gkx_OSS.setPass = (gk) => {
    Recoil_RecoilEnv.RECOIL_GKS_ENABLED.add(gk);
  };
  Recoil_gkx_OSS.setFail = (gk) => {
    Recoil_RecoilEnv.RECOIL_GKS_ENABLED.delete(gk);
  };
  Recoil_gkx_OSS.clear = () => {
    Recoil_RecoilEnv.RECOIL_GKS_ENABLED.clear();
  };
  var Recoil_gkx = Recoil_gkx_OSS;
  function recoverableViolation(message, _projectName, {
    error
  } = {}) {
    return null;
  }
  var recoverableViolation_1 = recoverableViolation;
  var Recoil_recoverableViolation = recoverableViolation_1;
  var _createMutableSource, _useMutableSource, _useSyncExternalStore;
  // flowlint-next-line unclear-type:off
  (_createMutableSource = React.createMutableSource) !== null && _createMutableSource !== void 0 ? _createMutableSource : React.unstable_createMutableSource;
  const useMutableSource = (
    // flowlint-next-line unclear-type:off
    (_useMutableSource = React.useMutableSource) !== null && _useMutableSource !== void 0 ? _useMutableSource : React.unstable_useMutableSource
  );
  const useSyncExternalStore = (
    // flowlint-next-line unclear-type:off
    (_useSyncExternalStore = React.useSyncExternalStore) !== null && _useSyncExternalStore !== void 0 ? _useSyncExternalStore : (
      // flowlint-next-line unclear-type:off
      React.unstable_useSyncExternalStore
    )
  );
  let ReactRendererVersionMismatchWarnOnce = false;
  function currentRendererSupportsUseSyncExternalStore() {
    var _ReactCurrentDispatch;
    const {
      ReactCurrentDispatcher,
      ReactCurrentOwner
    } = (
      /* $FlowFixMe[prop-missing] This workaround was approved as a safer mechanism
       * to detect if the current renderer supports useSyncExternalStore()
       * https://fb.workplace.com/groups/reactjs/posts/9558682330846963/ */
      React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
    );
    const dispatcher = (_ReactCurrentDispatch = ReactCurrentDispatcher === null || ReactCurrentDispatcher === void 0 ? void 0 : ReactCurrentDispatcher.current) !== null && _ReactCurrentDispatch !== void 0 ? _ReactCurrentDispatch : ReactCurrentOwner.currentDispatcher;
    const isUseSyncExternalStoreSupported = dispatcher.useSyncExternalStore != null;
    if (useSyncExternalStore && !isUseSyncExternalStoreSupported && !ReactRendererVersionMismatchWarnOnce) {
      ReactRendererVersionMismatchWarnOnce = true;
      Recoil_recoverableViolation();
    }
    return isUseSyncExternalStoreSupported;
  }
  function reactMode() {
    if (Recoil_gkx("recoil_transition_support")) {
      return {
        mode: "TRANSITION_SUPPORT",
        early: true,
        concurrent: true
      };
    }
    if (Recoil_gkx("recoil_sync_external_store") && useSyncExternalStore != null) {
      return {
        mode: "SYNC_EXTERNAL_STORE",
        early: true,
        concurrent: false
      };
    }
    if (Recoil_gkx("recoil_mutable_source") && useMutableSource != null && typeof window !== "undefined" && !window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE) {
      return Recoil_gkx("recoil_suppress_rerender_in_callback") ? {
        mode: "MUTABLE_SOURCE",
        early: true,
        concurrent: true
      } : {
        mode: "MUTABLE_SOURCE",
        early: false,
        concurrent: false
      };
    }
    return Recoil_gkx("recoil_suppress_rerender_in_callback") ? {
      mode: "LEGACY",
      early: true,
      concurrent: false
    } : {
      mode: "LEGACY",
      early: false,
      concurrent: false
    };
  }
  var Recoil_ReactMode = {
    useMutableSource,
    useSyncExternalStore,
    currentRendererSupportsUseSyncExternalStore,
    reactMode
  };
  class AbstractRecoilValue {
    constructor(newKey) {
      _defineProperty(this, "key", void 0);
      this.key = newKey;
    }
    toJSON() {
      return {
        key: this.key
      };
    }
  }
  class RecoilState extends AbstractRecoilValue {
  }
  class RecoilValueReadOnly extends AbstractRecoilValue {
  }
  function isRecoilValue(x2) {
    return x2 instanceof RecoilState || x2 instanceof RecoilValueReadOnly;
  }
  var Recoil_RecoilValue = {
    AbstractRecoilValue,
    RecoilState,
    RecoilValueReadOnly,
    isRecoilValue
  };
  var Recoil_RecoilValue_1 = Recoil_RecoilValue.AbstractRecoilValue;
  var Recoil_RecoilValue_2 = Recoil_RecoilValue.RecoilState;
  var Recoil_RecoilValue_3 = Recoil_RecoilValue.RecoilValueReadOnly;
  var Recoil_RecoilValue_4 = Recoil_RecoilValue.isRecoilValue;
  var Recoil_RecoilValue$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    AbstractRecoilValue: Recoil_RecoilValue_1,
    RecoilState: Recoil_RecoilValue_2,
    RecoilValueReadOnly: Recoil_RecoilValue_3,
    isRecoilValue: Recoil_RecoilValue_4
  });
  function expectationViolation(format, ...args) {
  }
  var expectationViolation_1 = expectationViolation;
  var Recoil_expectationViolation = expectationViolation_1;
  function mapIterable(iterable, callback) {
    return function* () {
      let index = 0;
      for (const value of iterable) {
        yield callback(value, index++);
      }
    }();
  }
  var Recoil_mapIterable = mapIterable;
  class DefaultValue {
  }
  const DEFAULT_VALUE = new DefaultValue();
  const nodes = /* @__PURE__ */ new Map();
  const recoilValues = /* @__PURE__ */ new Map();
  function recoilValuesForKeys(keys2) {
    return Recoil_mapIterable(keys2, (key2) => Recoil_nullthrows(recoilValues.get(key2)));
  }
  function checkForDuplicateAtomKey(key2) {
    if (nodes.has(key2)) {
      const message = `Duplicate atom key "${key2}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;
      {
        console.warn(message);
      }
    }
  }
  function registerNode(node) {
    if (Recoil_RecoilEnv.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED) {
      checkForDuplicateAtomKey(node.key);
    }
    nodes.set(node.key, node);
    const recoilValue = node.set == null ? new Recoil_RecoilValue$1.RecoilValueReadOnly(node.key) : new Recoil_RecoilValue$1.RecoilState(node.key);
    recoilValues.set(node.key, recoilValue);
    return recoilValue;
  }
  class NodeMissingError extends Error {
  }
  function getNode(key2) {
    const node = nodes.get(key2);
    if (node == null) {
      throw new NodeMissingError(`Missing definition for RecoilValue: "${key2}""`);
    }
    return node;
  }
  function getNodeMaybe(key2) {
    return nodes.get(key2);
  }
  const configDeletionHandlers = /* @__PURE__ */ new Map();
  function deleteNodeConfigIfPossible(key2) {
    var _node$shouldDeleteCon;
    if (!Recoil_gkx("recoil_memory_managament_2020")) {
      return;
    }
    const node = nodes.get(key2);
    if (node !== null && node !== void 0 && (_node$shouldDeleteCon = node.shouldDeleteConfigOnRelease) !== null && _node$shouldDeleteCon !== void 0 && _node$shouldDeleteCon.call(node)) {
      var _getConfigDeletionHan;
      nodes.delete(key2);
      (_getConfigDeletionHan = getConfigDeletionHandler(key2)) === null || _getConfigDeletionHan === void 0 ? void 0 : _getConfigDeletionHan();
      configDeletionHandlers.delete(key2);
    }
  }
  function setConfigDeletionHandler(key2, fn) {
    if (!Recoil_gkx("recoil_memory_managament_2020")) {
      return;
    }
    if (fn === void 0) {
      configDeletionHandlers.delete(key2);
    } else {
      configDeletionHandlers.set(key2, fn);
    }
  }
  function getConfigDeletionHandler(key2) {
    return configDeletionHandlers.get(key2);
  }
  var Recoil_Node = {
    recoilValues,
    registerNode,
    getNode,
    getNodeMaybe,
    deleteNodeConfigIfPossible,
    setConfigDeletionHandler,
    getConfigDeletionHandler,
    recoilValuesForKeys,
    DefaultValue,
    DEFAULT_VALUE
  };
  function createCommonjsModule(fn, module) {
    return module = { exports: {} }, fn(module, module.exports), module.exports;
  }
  var hamt_1 = createCommonjsModule(function(module) {
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var hamt = {};
    var SIZE = 5;
    var BUCKET_SIZE = Math.pow(2, SIZE);
    var MASK = BUCKET_SIZE - 1;
    var MAX_INDEX_NODE = BUCKET_SIZE / 2;
    var MIN_ARRAY_NODE = BUCKET_SIZE / 4;
    var nothing = {};
    var constant = function constant2(x2) {
      return function() {
        return x2;
      };
    };
    var hash = hamt.hash = function(str) {
      var type = typeof str === "undefined" ? "undefined" : _typeof(str);
      if (type === "number") return str;
      if (type !== "string") str += "";
      var hash2 = 0;
      for (var i2 = 0, len = str.length; i2 < len; ++i2) {
        var c = str.charCodeAt(i2);
        hash2 = (hash2 << 5) - hash2 + c | 0;
      }
      return hash2;
    };
    var popcount = function popcount2(x2) {
      x2 -= x2 >> 1 & 1431655765;
      x2 = (x2 & 858993459) + (x2 >> 2 & 858993459);
      x2 = x2 + (x2 >> 4) & 252645135;
      x2 += x2 >> 8;
      x2 += x2 >> 16;
      return x2 & 127;
    };
    var hashFragment = function hashFragment2(shift2, h2) {
      return h2 >>> shift2 & MASK;
    };
    var toBitmap = function toBitmap2(x2) {
      return 1 << x2;
    };
    var fromBitmap = function fromBitmap2(bitmap, bit) {
      return popcount(bitmap & bit - 1);
    };
    var arrayUpdate = function arrayUpdate2(mutate2, at, v, arr) {
      var out = arr;
      if (!mutate2) {
        var len = arr.length;
        out = new Array(len);
        for (var i2 = 0; i2 < len; ++i2) {
          out[i2] = arr[i2];
        }
      }
      out[at] = v;
      return out;
    };
    var arraySpliceOut = function arraySpliceOut2(mutate2, at, arr) {
      var newLen = arr.length - 1;
      var i2 = 0;
      var g = 0;
      var out = arr;
      if (mutate2) {
        i2 = g = at;
      } else {
        out = new Array(newLen);
        while (i2 < at) {
          out[g++] = arr[i2++];
        }
      }
      ++i2;
      while (i2 <= newLen) {
        out[g++] = arr[i2++];
      }
      if (mutate2) {
        out.length = newLen;
      }
      return out;
    };
    var arraySpliceIn = function arraySpliceIn2(mutate2, at, v, arr) {
      var len = arr.length;
      if (mutate2) {
        var _i2 = len;
        while (_i2 >= at) {
          arr[_i2--] = arr[_i2];
        }
        arr[at] = v;
        return arr;
      }
      var i2 = 0, g = 0;
      var out = new Array(len + 1);
      while (i2 < at) {
        out[g++] = arr[i2++];
      }
      out[at] = v;
      while (i2 < len) {
        out[++g] = arr[i2++];
      }
      return out;
    };
    var LEAF = 1;
    var COLLISION = 2;
    var INDEX = 3;
    var ARRAY = 4;
    var empty2 = {
      __hamt_isEmpty: true
    };
    var isEmptyNode = function isEmptyNode2(x2) {
      return x2 === empty2 || x2 && x2.__hamt_isEmpty;
    };
    var Leaf2 = function Leaf22(edit, hash2, key2, value) {
      return {
        type: LEAF,
        edit,
        hash: hash2,
        key: key2,
        value,
        _modify: Leaf__modify
      };
    };
    var Collision = function Collision2(edit, hash2, children) {
      return {
        type: COLLISION,
        edit,
        hash: hash2,
        children,
        _modify: Collision__modify
      };
    };
    var IndexedNode = function IndexedNode2(edit, mask, children) {
      return {
        type: INDEX,
        edit,
        mask,
        children,
        _modify: IndexedNode__modify
      };
    };
    var ArrayNode = function ArrayNode2(edit, size, children) {
      return {
        type: ARRAY,
        edit,
        size,
        children,
        _modify: ArrayNode__modify
      };
    };
    var isLeaf = function isLeaf2(node) {
      return node === empty2 || node.type === LEAF || node.type === COLLISION;
    };
    var expand = function expand2(edit, frag, child, bitmap, subNodes) {
      var arr = [];
      var bit = bitmap;
      var count2 = 0;
      for (var i2 = 0; bit; ++i2) {
        if (bit & 1) arr[i2] = subNodes[count2++];
        bit >>>= 1;
      }
      arr[frag] = child;
      return ArrayNode(edit, count2 + 1, arr);
    };
    var pack = function pack2(edit, count2, removed, elements) {
      var children = new Array(count2 - 1);
      var g = 0;
      var bitmap = 0;
      for (var i2 = 0, len = elements.length; i2 < len; ++i2) {
        if (i2 !== removed) {
          var elem = elements[i2];
          if (elem && !isEmptyNode(elem)) {
            children[g++] = elem;
            bitmap |= 1 << i2;
          }
        }
      }
      return IndexedNode(edit, bitmap, children);
    };
    var mergeLeaves = function mergeLeaves2(edit, shift2, h1, n1, h2, n2) {
      if (h1 === h2) return Collision(edit, h1, [n2, n1]);
      var subH1 = hashFragment(shift2, h1);
      var subH2 = hashFragment(shift2, h2);
      return IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), subH1 === subH2 ? [mergeLeaves2(edit, shift2 + SIZE, h1, n1, h2, n2)] : subH1 < subH2 ? [n1, n2] : [n2, n1]);
    };
    var updateCollisionList = function updateCollisionList2(mutate2, edit, keyEq, h2, list, f, k2, size) {
      var len = list.length;
      for (var i2 = 0; i2 < len; ++i2) {
        var child = list[i2];
        if (keyEq(k2, child.key)) {
          var value = child.value;
          var _newValue = f(value);
          if (_newValue === value) return list;
          if (_newValue === nothing) {
            --size.value;
            return arraySpliceOut(mutate2, i2, list);
          }
          return arrayUpdate(mutate2, i2, Leaf2(edit, h2, k2, _newValue), list);
        }
      }
      var newValue = f();
      if (newValue === nothing) return list;
      ++size.value;
      return arrayUpdate(mutate2, len, Leaf2(edit, h2, k2, newValue), list);
    };
    var canEditNode = function canEditNode2(edit, node) {
      return edit === node.edit;
    };
    var Leaf__modify = function Leaf__modify2(edit, keyEq, shift2, f, h2, k2, size) {
      if (keyEq(k2, this.key)) {
        var _v2 = f(this.value);
        if (_v2 === this.value) return this;
        else if (_v2 === nothing) {
          --size.value;
          return empty2;
        }
        if (canEditNode(edit, this)) {
          this.value = _v2;
          return this;
        }
        return Leaf2(edit, h2, k2, _v2);
      }
      var v = f();
      if (v === nothing) return this;
      ++size.value;
      return mergeLeaves(edit, shift2, this.hash, this, h2, Leaf2(edit, h2, k2, v));
    };
    var Collision__modify = function Collision__modify2(edit, keyEq, shift2, f, h2, k2, size) {
      if (h2 === this.hash) {
        var canEdit = canEditNode(edit, this);
        var list = updateCollisionList(canEdit, edit, keyEq, this.hash, this.children, f, k2, size);
        if (list === this.children) return this;
        return list.length > 1 ? Collision(edit, this.hash, list) : list[0];
      }
      var v = f();
      if (v === nothing) return this;
      ++size.value;
      return mergeLeaves(edit, shift2, this.hash, this, h2, Leaf2(edit, h2, k2, v));
    };
    var IndexedNode__modify = function IndexedNode__modify2(edit, keyEq, shift2, f, h2, k2, size) {
      var mask = this.mask;
      var children = this.children;
      var frag = hashFragment(shift2, h2);
      var bit = toBitmap(frag);
      var indx = fromBitmap(mask, bit);
      var exists = mask & bit;
      var current = exists ? children[indx] : empty2;
      var child = current._modify(edit, keyEq, shift2 + SIZE, f, h2, k2, size);
      if (current === child) return this;
      var canEdit = canEditNode(edit, this);
      var bitmap = mask;
      var newChildren = void 0;
      if (exists && isEmptyNode(child)) {
        bitmap &= ~bit;
        if (!bitmap) return empty2;
        if (children.length <= 2 && isLeaf(children[indx ^ 1])) return children[indx ^ 1];
        newChildren = arraySpliceOut(canEdit, indx, children);
      } else if (!exists && !isEmptyNode(child)) {
        if (children.length >= MAX_INDEX_NODE) return expand(edit, frag, child, mask, children);
        bitmap |= bit;
        newChildren = arraySpliceIn(canEdit, indx, child, children);
      } else {
        newChildren = arrayUpdate(canEdit, indx, child, children);
      }
      if (canEdit) {
        this.mask = bitmap;
        this.children = newChildren;
        return this;
      }
      return IndexedNode(edit, bitmap, newChildren);
    };
    var ArrayNode__modify = function ArrayNode__modify2(edit, keyEq, shift2, f, h2, k2, size) {
      var count2 = this.size;
      var children = this.children;
      var frag = hashFragment(shift2, h2);
      var child = children[frag];
      var newChild = (child || empty2)._modify(edit, keyEq, shift2 + SIZE, f, h2, k2, size);
      if (child === newChild) return this;
      var canEdit = canEditNode(edit, this);
      var newChildren = void 0;
      if (isEmptyNode(child) && !isEmptyNode(newChild)) {
        ++count2;
        newChildren = arrayUpdate(canEdit, frag, newChild, children);
      } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
        --count2;
        if (count2 <= MIN_ARRAY_NODE) return pack(edit, count2, frag, children);
        newChildren = arrayUpdate(canEdit, frag, empty2, children);
      } else {
        newChildren = arrayUpdate(canEdit, frag, newChild, children);
      }
      if (canEdit) {
        this.size = count2;
        this.children = newChildren;
        return this;
      }
      return ArrayNode(edit, count2, newChildren);
    };
    empty2._modify = function(edit, keyEq, shift2, f, h2, k2, size) {
      var v = f();
      if (v === nothing) return empty2;
      ++size.value;
      return Leaf2(edit, h2, k2, v);
    };
    function Map2(editable, edit, config, root, size) {
      this._editable = editable;
      this._edit = edit;
      this._config = config;
      this._root = root;
      this._size = size;
    }
    Map2.prototype.setTree = function(newRoot, newSize) {
      if (this._editable) {
        this._root = newRoot;
        this._size = newSize;
        return this;
      }
      return newRoot === this._root ? this : new Map2(this._editable, this._edit, this._config, newRoot, newSize);
    };
    var tryGetHash = hamt.tryGetHash = function(alt, hash2, key2, map) {
      var node = map._root;
      var shift2 = 0;
      var keyEq = map._config.keyEq;
      while (true) {
        switch (node.type) {
          case LEAF: {
            return keyEq(key2, node.key) ? node.value : alt;
          }
          case COLLISION: {
            if (hash2 === node.hash) {
              var children = node.children;
              for (var i2 = 0, len = children.length; i2 < len; ++i2) {
                var child = children[i2];
                if (keyEq(key2, child.key)) return child.value;
              }
            }
            return alt;
          }
          case INDEX: {
            var frag = hashFragment(shift2, hash2);
            var bit = toBitmap(frag);
            if (node.mask & bit) {
              node = node.children[fromBitmap(node.mask, bit)];
              shift2 += SIZE;
              break;
            }
            return alt;
          }
          case ARRAY: {
            node = node.children[hashFragment(shift2, hash2)];
            if (node) {
              shift2 += SIZE;
              break;
            }
            return alt;
          }
          default:
            return alt;
        }
      }
    };
    Map2.prototype.tryGetHash = function(alt, hash2, key2) {
      return tryGetHash(alt, hash2, key2, this);
    };
    var tryGet = hamt.tryGet = function(alt, key2, map) {
      return tryGetHash(alt, map._config.hash(key2), key2, map);
    };
    Map2.prototype.tryGet = function(alt, key2) {
      return tryGet(alt, key2, this);
    };
    var getHash = hamt.getHash = function(hash2, key2, map) {
      return tryGetHash(void 0, hash2, key2, map);
    };
    Map2.prototype.getHash = function(hash2, key2) {
      return getHash(hash2, key2, this);
    };
    hamt.get = function(key2, map) {
      return tryGetHash(void 0, map._config.hash(key2), key2, map);
    };
    Map2.prototype.get = function(key2, alt) {
      return tryGet(alt, key2, this);
    };
    var hasHash = hamt.has = function(hash2, key2, map) {
      return tryGetHash(nothing, hash2, key2, map) !== nothing;
    };
    Map2.prototype.hasHash = function(hash2, key2) {
      return hasHash(hash2, key2, this);
    };
    var has = hamt.has = function(key2, map) {
      return hasHash(map._config.hash(key2), key2, map);
    };
    Map2.prototype.has = function(key2) {
      return has(key2, this);
    };
    var defKeyCompare = function defKeyCompare2(x2, y) {
      return x2 === y;
    };
    hamt.make = function(config) {
      return new Map2(0, 0, {
        keyEq: config && config.keyEq || defKeyCompare,
        hash: config && config.hash || hash
      }, empty2, 0);
    };
    hamt.empty = hamt.make();
    var isEmpty = hamt.isEmpty = function(map) {
      return map && !!isEmptyNode(map._root);
    };
    Map2.prototype.isEmpty = function() {
      return isEmpty(this);
    };
    var modifyHash = hamt.modifyHash = function(f, hash2, key2, map) {
      var size = {
        value: map._size
      };
      var newRoot = map._root._modify(map._editable ? map._edit : NaN, map._config.keyEq, 0, f, hash2, key2, size);
      return map.setTree(newRoot, size.value);
    };
    Map2.prototype.modifyHash = function(hash2, key2, f) {
      return modifyHash(f, hash2, key2, this);
    };
    var modify = hamt.modify = function(f, key2, map) {
      return modifyHash(f, map._config.hash(key2), key2, map);
    };
    Map2.prototype.modify = function(key2, f) {
      return modify(f, key2, this);
    };
    var setHash = hamt.setHash = function(hash2, key2, value, map) {
      return modifyHash(constant(value), hash2, key2, map);
    };
    Map2.prototype.setHash = function(hash2, key2, value) {
      return setHash(hash2, key2, value, this);
    };
    var set2 = hamt.set = function(key2, value, map) {
      return setHash(map._config.hash(key2), key2, value, map);
    };
    Map2.prototype.set = function(key2, value) {
      return set2(key2, value, this);
    };
    var del2 = constant(nothing);
    var removeHash = hamt.removeHash = function(hash2, key2, map) {
      return modifyHash(del2, hash2, key2, map);
    };
    Map2.prototype.removeHash = Map2.prototype.deleteHash = function(hash2, key2) {
      return removeHash(hash2, key2, this);
    };
    var remove = hamt.remove = function(key2, map) {
      return removeHash(map._config.hash(key2), key2, map);
    };
    Map2.prototype.remove = Map2.prototype.delete = function(key2) {
      return remove(key2, this);
    };
    var beginMutation = hamt.beginMutation = function(map) {
      return new Map2(map._editable + 1, map._edit + 1, map._config, map._root, map._size);
    };
    Map2.prototype.beginMutation = function() {
      return beginMutation(this);
    };
    var endMutation = hamt.endMutation = function(map) {
      map._editable = map._editable && map._editable - 1;
      return map;
    };
    Map2.prototype.endMutation = function() {
      return endMutation(this);
    };
    var mutate = hamt.mutate = function(f, map) {
      var transient = beginMutation(map);
      f(transient);
      return endMutation(transient);
    };
    Map2.prototype.mutate = function(f) {
      return mutate(f, this);
    };
    var appk = function appk2(k2) {
      return k2 && lazyVisitChildren(k2[0], k2[1], k2[2], k2[3], k2[4]);
    };
    var lazyVisitChildren = function lazyVisitChildren2(len, children, i2, f, k2) {
      while (i2 < len) {
        var child = children[i2++];
        if (child && !isEmptyNode(child)) return lazyVisit(child, f, [len, children, i2, f, k2]);
      }
      return appk(k2);
    };
    var lazyVisit = function lazyVisit2(node, f, k2) {
      switch (node.type) {
        case LEAF:
          return {
            value: f(node),
            rest: k2
          };
        case COLLISION:
        case ARRAY:
        case INDEX:
          var children = node.children;
          return lazyVisitChildren(children.length, children, 0, f, k2);
        default:
          return appk(k2);
      }
    };
    var DONE = {
      done: true
    };
    function MapIterator(v) {
      this.v = v;
    }
    MapIterator.prototype.next = function() {
      if (!this.v) return DONE;
      var v0 = this.v;
      this.v = appk(v0.rest);
      return v0;
    };
    MapIterator.prototype[Symbol.iterator] = function() {
      return this;
    };
    var visit = function visit2(map, f) {
      return new MapIterator(lazyVisit(map._root, f));
    };
    var buildPairs = function buildPairs2(x2) {
      return [x2.key, x2.value];
    };
    var entries2 = hamt.entries = function(map) {
      return visit(map, buildPairs);
    };
    Map2.prototype.entries = Map2.prototype[Symbol.iterator] = function() {
      return entries2(this);
    };
    var buildKeys = function buildKeys2(x2) {
      return x2.key;
    };
    var keys2 = hamt.keys = function(map) {
      return visit(map, buildKeys);
    };
    Map2.prototype.keys = function() {
      return keys2(this);
    };
    var buildValues = function buildValues2(x2) {
      return x2.value;
    };
    var values = hamt.values = Map2.prototype.values = function(map) {
      return visit(map, buildValues);
    };
    Map2.prototype.values = function() {
      return values(this);
    };
    var fold = hamt.fold = function(f, z2, m) {
      var root = m._root;
      if (root.type === LEAF) return f(z2, root.value, root.key);
      var toVisit = [root.children];
      var children = void 0;
      while (children = toVisit.pop()) {
        for (var i2 = 0, len = children.length; i2 < len; ) {
          var child = children[i2++];
          if (child && child.type) {
            if (child.type === LEAF) z2 = f(z2, child.value, child.key);
            else toVisit.push(child.children);
          }
        }
      }
      return z2;
    };
    Map2.prototype.fold = function(f, z2) {
      return fold(f, z2, this);
    };
    var forEach2 = hamt.forEach = function(f, map) {
      return fold(function(_2, value, key2) {
        return f(value, key2, map);
      }, null, map);
    };
    Map2.prototype.forEach = function(f) {
      return forEach2(f, this);
    };
    var count = hamt.count = function(map) {
      return map._size;
    };
    Map2.prototype.count = function() {
      return count(this);
    };
    Object.defineProperty(Map2.prototype, "size", {
      get: Map2.prototype.count
    });
    if (module.exports) {
      module.exports = hamt;
    } else {
      (void 0).hamt = hamt;
    }
  });
  class BuiltInMap {
    constructor(existing) {
      _defineProperty(this, "_map", void 0);
      this._map = new Map(existing === null || existing === void 0 ? void 0 : existing.entries());
    }
    keys() {
      return this._map.keys();
    }
    entries() {
      return this._map.entries();
    }
    get(k2) {
      return this._map.get(k2);
    }
    has(k2) {
      return this._map.has(k2);
    }
    set(k2, v) {
      this._map.set(k2, v);
      return this;
    }
    delete(k2) {
      this._map.delete(k2);
      return this;
    }
    clone() {
      return persistentMap(this);
    }
    toMap() {
      return new Map(this._map);
    }
  }
  class HashArrayMappedTrieMap {
    // Because hamt.empty is not a function there is no way to introduce type
    // parameters on it, so empty is typed as HAMTPlusMap<string, mixed>.
    // $FlowIssue
    constructor(existing) {
      _defineProperty(this, "_hamt", hamt_1.empty.beginMutation());
      if (existing instanceof HashArrayMappedTrieMap) {
        const h2 = existing._hamt.endMutation();
        existing._hamt = h2.beginMutation();
        this._hamt = h2.beginMutation();
      } else if (existing) {
        for (const [k2, v] of existing.entries()) {
          this._hamt.set(k2, v);
        }
      }
    }
    keys() {
      return this._hamt.keys();
    }
    entries() {
      return this._hamt.entries();
    }
    get(k2) {
      return this._hamt.get(k2);
    }
    has(k2) {
      return this._hamt.has(k2);
    }
    set(k2, v) {
      this._hamt.set(k2, v);
      return this;
    }
    delete(k2) {
      this._hamt.delete(k2);
      return this;
    }
    clone() {
      return persistentMap(this);
    }
    toMap() {
      return new Map(this._hamt);
    }
  }
  function persistentMap(existing) {
    if (Recoil_gkx("recoil_hamt_2020")) {
      return new HashArrayMappedTrieMap(existing);
    } else {
      return new BuiltInMap(existing);
    }
  }
  var Recoil_PersistentMap = {
    persistentMap
  };
  var Recoil_PersistentMap_1 = Recoil_PersistentMap.persistentMap;
  var Recoil_PersistentMap$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    persistentMap: Recoil_PersistentMap_1
  });
  function differenceSets(set2, ...setsWithValuesToRemove) {
    const ret = /* @__PURE__ */ new Set();
    FIRST: for (const value of set2) {
      for (const otherSet of setsWithValuesToRemove) {
        if (otherSet.has(value)) {
          continue FIRST;
        }
      }
      ret.add(value);
    }
    return ret;
  }
  var Recoil_differenceSets = differenceSets;
  function makeGraph() {
    return {
      nodeDeps: /* @__PURE__ */ new Map(),
      nodeToNodeSubscriptions: /* @__PURE__ */ new Map()
    };
  }
  function mergeDepsIntoGraph(key2, newDeps, graph2, olderGraph) {
    const {
      nodeDeps,
      nodeToNodeSubscriptions
    } = graph2;
    const oldDeps = nodeDeps.get(key2);
    if (oldDeps && olderGraph && oldDeps !== olderGraph.nodeDeps.get(key2)) {
      return;
    }
    nodeDeps.set(key2, newDeps);
    const addedDeps = oldDeps == null ? newDeps : Recoil_differenceSets(newDeps, oldDeps);
    for (const dep of addedDeps) {
      if (!nodeToNodeSubscriptions.has(dep)) {
        nodeToNodeSubscriptions.set(dep, /* @__PURE__ */ new Set());
      }
      const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));
      existing.add(key2);
    }
    if (oldDeps) {
      const removedDeps = Recoil_differenceSets(oldDeps, newDeps);
      for (const dep of removedDeps) {
        if (!nodeToNodeSubscriptions.has(dep)) {
          return;
        }
        const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));
        existing.delete(key2);
        if (existing.size === 0) {
          nodeToNodeSubscriptions.delete(dep);
        }
      }
    }
  }
  function saveDepsToStore(key2, deps, store, version) {
    var _storeState$nextTree, _storeState$previousT, _storeState$previousT2, _storeState$previousT3;
    const storeState = store.getState();
    if (!(version === storeState.currentTree.version || version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {
      Recoil_recoverableViolation();
    }
    const graph2 = store.getGraph(version);
    mergeDepsIntoGraph(key2, deps, graph2);
    if (version === ((_storeState$previousT2 = storeState.previousTree) === null || _storeState$previousT2 === void 0 ? void 0 : _storeState$previousT2.version)) {
      const currentGraph = store.getGraph(storeState.currentTree.version);
      mergeDepsIntoGraph(key2, deps, currentGraph, graph2);
    }
    if (version === ((_storeState$previousT3 = storeState.previousTree) === null || _storeState$previousT3 === void 0 ? void 0 : _storeState$previousT3.version) || version === storeState.currentTree.version) {
      var _storeState$nextTree2;
      const nextVersion = (_storeState$nextTree2 = storeState.nextTree) === null || _storeState$nextTree2 === void 0 ? void 0 : _storeState$nextTree2.version;
      if (nextVersion !== void 0) {
        const nextGraph = store.getGraph(nextVersion);
        mergeDepsIntoGraph(key2, deps, nextGraph, graph2);
      }
    }
  }
  var Recoil_Graph = {
    graph: makeGraph,
    saveDepsToStore
  };
  let nextTreeStateVersion = 0;
  const getNextTreeStateVersion = () => nextTreeStateVersion++;
  let nextStoreID = 0;
  const getNextStoreID = () => nextStoreID++;
  let nextComponentID = 0;
  const getNextComponentID = () => nextComponentID++;
  var Recoil_Keys = {
    getNextTreeStateVersion,
    getNextStoreID,
    getNextComponentID
  };
  const {
    persistentMap: persistentMap$1
  } = Recoil_PersistentMap$1;
  const {
    graph
  } = Recoil_Graph;
  const {
    getNextTreeStateVersion: getNextTreeStateVersion$1
  } = Recoil_Keys;
  function makeEmptyTreeState() {
    const version = getNextTreeStateVersion$1();
    return {
      version,
      stateID: version,
      transactionMetadata: {},
      dirtyAtoms: /* @__PURE__ */ new Set(),
      atomValues: persistentMap$1(),
      nonvalidatedAtoms: persistentMap$1()
    };
  }
  function makeEmptyStoreState() {
    const currentTree = makeEmptyTreeState();
    return {
      currentTree,
      nextTree: null,
      previousTree: null,
      commitDepth: 0,
      knownAtoms: /* @__PURE__ */ new Set(),
      knownSelectors: /* @__PURE__ */ new Set(),
      transactionSubscriptions: /* @__PURE__ */ new Map(),
      nodeTransactionSubscriptions: /* @__PURE__ */ new Map(),
      nodeToComponentSubscriptions: /* @__PURE__ */ new Map(),
      queuedComponentCallbacks_DEPRECATED: [],
      suspendedComponentResolvers: /* @__PURE__ */ new Set(),
      graphsByVersion: (/* @__PURE__ */ new Map()).set(currentTree.version, graph()),
      retention: {
        referenceCounts: /* @__PURE__ */ new Map(),
        nodesRetainedByZone: /* @__PURE__ */ new Map(),
        retainablesToCheckForRelease: /* @__PURE__ */ new Set()
      },
      nodeCleanupFunctions: /* @__PURE__ */ new Map()
    };
  }
  var Recoil_State = {
    makeEmptyStoreState,
    getNextTreeStateVersion: getNextTreeStateVersion$1
  };
  class RetentionZone {
  }
  var Recoil_RetentionZone = {
    RetentionZone
  };
  function* filterIterable(iterable, predicate) {
    let index = 0;
    for (const value of iterable) {
      if (predicate(value, index++)) {
        yield value;
      }
    }
  }
  var Recoil_filterIterable = filterIterable;
  function lazyProxy(base2, factories) {
    const proxy = new Proxy(base2, {
      // Compute and cache lazy property if not already done.
      get: (target, prop) => {
        if (!(prop in target) && prop in factories) {
          target[prop] = factories[prop]();
        }
        return target[prop];
      },
      // This method allows user to iterate keys as normal
      ownKeys: (target) => {
        return Object.keys(target);
      }
    });
    return proxy;
  }
  var Recoil_lazyProxy = lazyProxy;
  const {
    getNode: getNode$1,
    recoilValuesForKeys: recoilValuesForKeys$1
  } = Recoil_Node;
  const {
    RetentionZone: RetentionZone$1
  } = Recoil_RetentionZone;
  const emptySet = Object.freeze(/* @__PURE__ */ new Set());
  class ReadOnlyRecoilValueError extends Error {
  }
  function initializeRetentionForNode(store, nodeKey, retainedBy) {
    if (!Recoil_gkx("recoil_memory_managament_2020")) {
      return () => void 0;
    }
    const {
      nodesRetainedByZone: nodesRetainedByZone2
    } = store.getState().retention;
    function addToZone(zone) {
      let set2 = nodesRetainedByZone2.get(zone);
      if (!set2) {
        nodesRetainedByZone2.set(zone, set2 = /* @__PURE__ */ new Set());
      }
      set2.add(nodeKey);
    }
    if (retainedBy instanceof RetentionZone$1) {
      addToZone(retainedBy);
    } else if (Array.isArray(retainedBy)) {
      for (const zone of retainedBy) {
        addToZone(zone);
      }
    }
    return () => {
      if (!Recoil_gkx("recoil_memory_managament_2020")) {
        return;
      }
      const {
        retention
      } = store.getState();
      function deleteFromZone(zone) {
        const set2 = retention.nodesRetainedByZone.get(zone);
        set2 === null || set2 === void 0 ? void 0 : set2.delete(nodeKey);
        if (set2 && set2.size === 0) {
          retention.nodesRetainedByZone.delete(zone);
        }
      }
      if (retainedBy instanceof RetentionZone$1) {
        deleteFromZone(retainedBy);
      } else if (Array.isArray(retainedBy)) {
        for (const zone of retainedBy) {
          deleteFromZone(zone);
        }
      }
    };
  }
  function initializeNodeIfNewToStore(store, treeState, key2, trigger) {
    const storeState = store.getState();
    if (storeState.nodeCleanupFunctions.has(key2)) {
      return;
    }
    const node = getNode$1(key2);
    const retentionCleanup = initializeRetentionForNode(store, key2, node.retainedBy);
    const nodeCleanup = node.init(store, treeState, trigger);
    storeState.nodeCleanupFunctions.set(key2, () => {
      nodeCleanup();
      retentionCleanup();
    });
  }
  function initializeNode(store, key2, trigger) {
    initializeNodeIfNewToStore(store, store.getState().currentTree, key2, trigger);
  }
  function cleanUpNode(store, key2) {
    var _state$nodeCleanupFun;
    const state = store.getState();
    (_state$nodeCleanupFun = state.nodeCleanupFunctions.get(key2)) === null || _state$nodeCleanupFun === void 0 ? void 0 : _state$nodeCleanupFun();
    state.nodeCleanupFunctions.delete(key2);
  }
  function getNodeLoadable(store, state, key2) {
    initializeNodeIfNewToStore(store, state, key2, "get");
    return getNode$1(key2).get(store, state);
  }
  function peekNodeLoadable(store, state, key2) {
    return getNode$1(key2).peek(store, state);
  }
  function setNodeValue(store, state, key2, newValue) {
    const node = getNode$1(key2);
    if (node.set == null) {
      throw new ReadOnlyRecoilValueError(`Attempt to set read-only RecoilValue: ${key2}`);
    }
    const set2 = node.set;
    initializeNodeIfNewToStore(store, state, key2, "set");
    return set2(store, state, newValue);
  }
  function peekNodeInfo(store, state, key2) {
    const storeState = store.getState();
    const graph2 = store.getGraph(state.version);
    const type = getNode$1(key2).nodeType;
    return Recoil_lazyProxy({
      type
    }, {
      // $FlowFixMe[underconstrained-implicit-instantiation]
      loadable: () => peekNodeLoadable(store, state, key2),
      isActive: () => storeState.knownAtoms.has(key2) || storeState.knownSelectors.has(key2),
      isSet: () => type === "selector" ? false : state.atomValues.has(key2),
      isModified: () => state.dirtyAtoms.has(key2),
      // Report current dependencies.  If the node hasn't been evaluated, then
      // dependencies may be missing based on the current state.
      deps: () => {
        var _graph$nodeDeps$get;
        return recoilValuesForKeys$1((_graph$nodeDeps$get = graph2.nodeDeps.get(key2)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : []);
      },
      // Reports all "current" subscribers.  Evaluating other nodes or
      // previous in-progress async evaluations may introduce new subscribers.
      subscribers: () => {
        var _storeState$nodeToCom, _storeState$nodeToCom2;
        return {
          nodes: recoilValuesForKeys$1(Recoil_filterIterable(getDownstreamNodes(store, state, /* @__PURE__ */ new Set([key2])), (nodeKey) => nodeKey !== key2)),
          components: Recoil_mapIterable((_storeState$nodeToCom = (_storeState$nodeToCom2 = storeState.nodeToComponentSubscriptions.get(key2)) === null || _storeState$nodeToCom2 === void 0 ? void 0 : _storeState$nodeToCom2.values()) !== null && _storeState$nodeToCom !== void 0 ? _storeState$nodeToCom : [], ([name]) => ({
            name
          }))
        };
      }
    });
  }
  function getDownstreamNodes(store, state, keys2) {
    const visitedNodes = /* @__PURE__ */ new Set();
    const visitingNodes = Array.from(keys2);
    const graph2 = store.getGraph(state.version);
    for (let key2 = visitingNodes.pop(); key2; key2 = visitingNodes.pop()) {
      var _graph$nodeToNodeSubs;
      visitedNodes.add(key2);
      const subscribedNodes = (_graph$nodeToNodeSubs = graph2.nodeToNodeSubscriptions.get(key2)) !== null && _graph$nodeToNodeSubs !== void 0 ? _graph$nodeToNodeSubs : emptySet;
      for (const downstreamNode of subscribedNodes) {
        if (!visitedNodes.has(downstreamNode)) {
          visitingNodes.push(downstreamNode);
        }
      }
    }
    return visitedNodes;
  }
  var Recoil_FunctionalCore = {
    getNodeLoadable,
    peekNodeLoadable,
    setNodeValue,
    initializeNode,
    cleanUpNode,
    peekNodeInfo,
    getDownstreamNodes
  };
  let _invalidateMemoizedSnapshot = null;
  function setInvalidateMemoizedSnapshot(invalidate) {
    _invalidateMemoizedSnapshot = invalidate;
  }
  function invalidateMemoizedSnapshot() {
    var _invalidateMemoizedSn;
    (_invalidateMemoizedSn = _invalidateMemoizedSnapshot) === null || _invalidateMemoizedSn === void 0 ? void 0 : _invalidateMemoizedSn();
  }
  var Recoil_SnapshotCache = {
    setInvalidateMemoizedSnapshot,
    invalidateMemoizedSnapshot
  };
  const {
    getDownstreamNodes: getDownstreamNodes$1,
    getNodeLoadable: getNodeLoadable$1,
    setNodeValue: setNodeValue$1
  } = Recoil_FunctionalCore;
  const {
    getNextComponentID: getNextComponentID$1
  } = Recoil_Keys;
  const {
    getNode: getNode$2,
    getNodeMaybe: getNodeMaybe$2
  } = Recoil_Node;
  const {
    DefaultValue: DefaultValue$1
  } = Recoil_Node;
  const {
    reactMode: reactMode$1
  } = Recoil_ReactMode;
  const {
    AbstractRecoilValue: AbstractRecoilValue$1,
    RecoilState: RecoilState$1,
    RecoilValueReadOnly: RecoilValueReadOnly$1,
    isRecoilValue: isRecoilValue$1
  } = Recoil_RecoilValue$1;
  const {
    invalidateMemoizedSnapshot: invalidateMemoizedSnapshot$1
  } = Recoil_SnapshotCache;
  function getRecoilValueAsLoadable(store, {
    key: key2
  }, treeState = store.getState().currentTree) {
    var _storeState$nextTree, _storeState$previousT;
    const storeState = store.getState();
    if (!(treeState.version === storeState.currentTree.version || treeState.version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || treeState.version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {
      Recoil_recoverableViolation();
    }
    const loadable = getNodeLoadable$1(store, treeState, key2);
    if (loadable.state === "loading") {
      loadable.contents.catch(() => {
        return;
      });
    }
    return loadable;
  }
  function valueFromValueOrUpdater(store, state, {
    key: key2
  }, valueOrUpdater) {
    if (typeof valueOrUpdater === "function") {
      const current = getNodeLoadable$1(store, state, key2);
      if (current.state === "loading") {
        const msg = `Tried to set atom or selector "${key2}" using an updater function while the current state is pending, this is not currently supported.`;
        Recoil_recoverableViolation();
        throw Recoil_err(msg);
      } else if (current.state === "hasError") {
        throw current.contents;
      }
      return valueOrUpdater(current.contents);
    } else {
      return valueOrUpdater;
    }
  }
  function applyAction(store, state, action) {
    if (action.type === "set") {
      const {
        recoilValue,
        valueOrUpdater
      } = action;
      const newValue = valueFromValueOrUpdater(store, state, recoilValue, valueOrUpdater);
      const writes = setNodeValue$1(store, state, recoilValue.key, newValue);
      for (const [key2, loadable] of writes.entries()) {
        writeLoadableToTreeState(state, key2, loadable);
      }
    } else if (action.type === "setLoadable") {
      const {
        recoilValue: {
          key: key2
        },
        loadable
      } = action;
      writeLoadableToTreeState(state, key2, loadable);
    } else if (action.type === "markModified") {
      const {
        recoilValue: {
          key: key2
        }
      } = action;
      state.dirtyAtoms.add(key2);
    } else if (action.type === "setUnvalidated") {
      var _node$invalidate;
      const {
        recoilValue: {
          key: key2
        },
        unvalidatedValue
      } = action;
      const node = getNodeMaybe$2(key2);
      node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);
      state.atomValues.delete(key2);
      state.nonvalidatedAtoms.set(key2, unvalidatedValue);
      state.dirtyAtoms.add(key2);
    } else {
      Recoil_recoverableViolation(`Unknown action ${action.type}`);
    }
  }
  function writeLoadableToTreeState(state, key2, loadable) {
    if (loadable.state === "hasValue" && loadable.contents instanceof DefaultValue$1) {
      state.atomValues.delete(key2);
    } else {
      state.atomValues.set(key2, loadable);
    }
    state.dirtyAtoms.add(key2);
    state.nonvalidatedAtoms.delete(key2);
  }
  function applyActionsToStore(store, actions) {
    store.replaceState((state) => {
      const newState = copyTreeState(state);
      for (const action of actions) {
        applyAction(store, newState, action);
      }
      invalidateDownstreams(store, newState);
      invalidateMemoizedSnapshot$1();
      return newState;
    });
  }
  function queueOrPerformStateUpdate(store, action) {
    if (batchStack.length) {
      const actionsByStore = batchStack[batchStack.length - 1];
      let actions = actionsByStore.get(store);
      if (!actions) {
        actionsByStore.set(store, actions = []);
      }
      actions.push(action);
    } else {
      applyActionsToStore(store, [action]);
    }
  }
  const batchStack = [];
  function batchStart() {
    const actionsByStore = /* @__PURE__ */ new Map();
    batchStack.push(actionsByStore);
    return () => {
      for (const [store, actions] of actionsByStore) {
        applyActionsToStore(store, actions);
      }
      const popped = batchStack.pop();
      if (popped !== actionsByStore) {
        Recoil_recoverableViolation();
      }
    };
  }
  function copyTreeState(state) {
    return {
      ...state,
      atomValues: state.atomValues.clone(),
      nonvalidatedAtoms: state.nonvalidatedAtoms.clone(),
      dirtyAtoms: new Set(state.dirtyAtoms)
    };
  }
  function invalidateDownstreams(store, state) {
    const downstreams = getDownstreamNodes$1(store, state, state.dirtyAtoms);
    for (const key2 of downstreams) {
      var _getNodeMaybe, _getNodeMaybe$invalid;
      (_getNodeMaybe = getNodeMaybe$2(key2)) === null || _getNodeMaybe === void 0 ? void 0 : (_getNodeMaybe$invalid = _getNodeMaybe.invalidate) === null || _getNodeMaybe$invalid === void 0 ? void 0 : _getNodeMaybe$invalid.call(_getNodeMaybe, state);
    }
  }
  function setRecoilValue(store, recoilValue, valueOrUpdater) {
    queueOrPerformStateUpdate(store, {
      type: "set",
      recoilValue,
      valueOrUpdater
    });
  }
  function setRecoilValueLoadable(store, recoilValue, loadable) {
    if (loadable instanceof DefaultValue$1) {
      return setRecoilValue(store, recoilValue, loadable);
    }
    queueOrPerformStateUpdate(store, {
      type: "setLoadable",
      recoilValue,
      loadable
    });
  }
  function markRecoilValueModified(store, recoilValue) {
    queueOrPerformStateUpdate(store, {
      type: "markModified",
      recoilValue
    });
  }
  function setUnvalidatedRecoilValue(store, recoilValue, unvalidatedValue) {
    queueOrPerformStateUpdate(store, {
      type: "setUnvalidated",
      recoilValue,
      unvalidatedValue
    });
  }
  function subscribeToRecoilValue(store, {
    key: key2
  }, callback, componentDebugName = null) {
    const subID = getNextComponentID$1();
    const storeState = store.getState();
    if (!storeState.nodeToComponentSubscriptions.has(key2)) {
      storeState.nodeToComponentSubscriptions.set(key2, /* @__PURE__ */ new Map());
    }
    Recoil_nullthrows(storeState.nodeToComponentSubscriptions.get(key2)).set(subID, [componentDebugName !== null && componentDebugName !== void 0 ? componentDebugName : "<not captured>", callback]);
    const mode = reactMode$1();
    if (mode.early && (mode.mode === "LEGACY" || mode.mode === "MUTABLE_SOURCE")) {
      const nextTree = store.getState().nextTree;
      if (nextTree && nextTree.dirtyAtoms.has(key2)) {
        callback(nextTree);
      }
    }
    return {
      release: () => {
        const releaseStoreState = store.getState();
        const subs = releaseStoreState.nodeToComponentSubscriptions.get(key2);
        if (subs === void 0 || !subs.has(subID)) {
          Recoil_recoverableViolation();
          return;
        }
        subs.delete(subID);
        if (subs.size === 0) {
          releaseStoreState.nodeToComponentSubscriptions.delete(key2);
        }
      }
    };
  }
  function refreshRecoilValue(store, recoilValue) {
    var _node$clearCache;
    const {
      currentTree
    } = store.getState();
    const node = getNode$2(recoilValue.key);
    (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, currentTree);
  }
  var Recoil_RecoilValueInterface = {
    AbstractRecoilValue: AbstractRecoilValue$1,
    getRecoilValueAsLoadable,
    setRecoilValue,
    setRecoilValueLoadable,
    markRecoilValueModified,
    setUnvalidatedRecoilValue,
    subscribeToRecoilValue,
    // TODO Remove export when deprecating initialStoreState_DEPRECATED in RecoilRoot
    batchStart,
    writeLoadableToTreeState,
    invalidateDownstreams,
    copyTreeState,
    refreshRecoilValue
  };
  function someSet(set2, callback, context) {
    const iterator2 = set2.entries();
    let current = iterator2.next();
    while (!current.done) {
      const entry = current.value;
      if (callback.call(context, entry[1], entry[0], set2)) {
        return true;
      }
      current = iterator2.next();
    }
    return false;
  }
  var Recoil_someSet = someSet;
  const {
    cleanUpNode: cleanUpNode$1
  } = Recoil_FunctionalCore;
  const {
    deleteNodeConfigIfPossible: deleteNodeConfigIfPossible$1,
    getNode: getNode$3
  } = Recoil_Node;
  const {
    RetentionZone: RetentionZone$2
  } = Recoil_RetentionZone;
  const SUSPENSE_TIMEOUT_MS = 12e4;
  const emptySet$1 = /* @__PURE__ */ new Set();
  function releaseRetainablesNowOnCurrentTree(store, retainables) {
    const storeState = store.getState();
    const treeState = storeState.currentTree;
    if (storeState.nextTree) {
      Recoil_recoverableViolation();
      return;
    }
    const nodes2 = /* @__PURE__ */ new Set();
    for (const r of retainables) {
      if (r instanceof RetentionZone$2) {
        for (const n of nodesRetainedByZone(storeState, r)) {
          nodes2.add(n);
        }
      } else {
        nodes2.add(r);
      }
    }
    const releasableNodes = findReleasableNodes(store, nodes2);
    for (const node of releasableNodes) {
      releaseNode(store, treeState, node);
    }
  }
  function findReleasableNodes(store, searchFromNodes) {
    const storeState = store.getState();
    const treeState = storeState.currentTree;
    const graph2 = store.getGraph(treeState.version);
    const releasableNodes = /* @__PURE__ */ new Set();
    const nonReleasableNodes = /* @__PURE__ */ new Set();
    findReleasableNodesInner(searchFromNodes);
    return releasableNodes;
    function findReleasableNodesInner(searchFromNodes2) {
      const releasableNodesFoundThisIteration = /* @__PURE__ */ new Set();
      const downstreams = getDownstreamNodesInTopologicalOrder(
        store,
        treeState,
        searchFromNodes2,
        releasableNodes,
        // don't descend into these
        nonReleasableNodes
        // don't descend into these
      );
      for (const node of downstreams) {
        var _storeState$retention;
        if (getNode$3(node).retainedBy === "recoilRoot") {
          nonReleasableNodes.add(node);
          continue;
        }
        if (((_storeState$retention = storeState.retention.referenceCounts.get(node)) !== null && _storeState$retention !== void 0 ? _storeState$retention : 0) > 0) {
          nonReleasableNodes.add(node);
          continue;
        }
        if (zonesThatCouldRetainNode(node).some((z2) => storeState.retention.referenceCounts.get(z2))) {
          nonReleasableNodes.add(node);
          continue;
        }
        const nodeChildren = graph2.nodeToNodeSubscriptions.get(node);
        if (nodeChildren && Recoil_someSet(nodeChildren, (child) => nonReleasableNodes.has(child))) {
          nonReleasableNodes.add(node);
          continue;
        }
        releasableNodes.add(node);
        releasableNodesFoundThisIteration.add(node);
      }
      const parents = /* @__PURE__ */ new Set();
      for (const node of releasableNodesFoundThisIteration) {
        for (const parent of (_graph$nodeDeps$get = graph2.nodeDeps.get(node)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : emptySet$1) {
          var _graph$nodeDeps$get;
          if (!releasableNodes.has(parent)) {
            parents.add(parent);
          }
        }
      }
      if (parents.size) {
        findReleasableNodesInner(parents);
      }
    }
  }
  function getDownstreamNodesInTopologicalOrder(store, treeState, nodes2, doNotDescendInto1, doNotDescendInto2) {
    const graph2 = store.getGraph(treeState.version);
    const answer = [];
    const visited = /* @__PURE__ */ new Set();
    while (nodes2.size > 0) {
      visit(Recoil_nullthrows(nodes2.values().next().value));
    }
    return answer;
    function visit(node) {
      if (doNotDescendInto1.has(node) || doNotDescendInto2.has(node)) {
        nodes2.delete(node);
        return;
      }
      if (visited.has(node)) {
        return;
      }
      const children = graph2.nodeToNodeSubscriptions.get(node);
      if (children) {
        for (const child of children) {
          visit(child);
        }
      }
      visited.add(node);
      nodes2.delete(node);
      answer.push(node);
    }
  }
  function releaseNode(store, treeState, node) {
    if (!Recoil_gkx("recoil_memory_managament_2020")) {
      return;
    }
    cleanUpNode$1(store, node);
    const storeState = store.getState();
    storeState.knownAtoms.delete(node);
    storeState.knownSelectors.delete(node);
    storeState.nodeTransactionSubscriptions.delete(node);
    storeState.retention.referenceCounts.delete(node);
    const zones = zonesThatCouldRetainNode(node);
    for (const zone of zones) {
      var _storeState$retention2;
      (_storeState$retention2 = storeState.retention.nodesRetainedByZone.get(zone)) === null || _storeState$retention2 === void 0 ? void 0 : _storeState$retention2.delete(node);
    }
    treeState.atomValues.delete(node);
    treeState.dirtyAtoms.delete(node);
    treeState.nonvalidatedAtoms.delete(node);
    const graph2 = storeState.graphsByVersion.get(treeState.version);
    if (graph2) {
      const deps = graph2.nodeDeps.get(node);
      if (deps !== void 0) {
        graph2.nodeDeps.delete(node);
        for (const dep of deps) {
          var _graph$nodeToNodeSubs;
          (_graph$nodeToNodeSubs = graph2.nodeToNodeSubscriptions.get(dep)) === null || _graph$nodeToNodeSubs === void 0 ? void 0 : _graph$nodeToNodeSubs.delete(node);
        }
      }
      graph2.nodeToNodeSubscriptions.delete(node);
    }
    deleteNodeConfigIfPossible$1(node);
  }
  function nodesRetainedByZone(storeState, zone) {
    var _storeState$retention3;
    return (_storeState$retention3 = storeState.retention.nodesRetainedByZone.get(zone)) !== null && _storeState$retention3 !== void 0 ? _storeState$retention3 : emptySet$1;
  }
  function zonesThatCouldRetainNode(node) {
    const retainedBy = getNode$3(node).retainedBy;
    if (retainedBy === void 0 || retainedBy === "components" || retainedBy === "recoilRoot") {
      return [];
    } else if (retainedBy instanceof RetentionZone$2) {
      return [retainedBy];
    } else {
      return retainedBy;
    }
  }
  function scheduleOrPerformPossibleReleaseOfRetainable(store, retainable) {
    const state = store.getState();
    if (state.nextTree) {
      state.retention.retainablesToCheckForRelease.add(retainable);
    } else {
      releaseRetainablesNowOnCurrentTree(store, /* @__PURE__ */ new Set([retainable]));
    }
  }
  function updateRetainCount(store, retainable, delta) {
    var _map$get;
    if (!Recoil_gkx("recoil_memory_managament_2020")) {
      return;
    }
    const map = store.getState().retention.referenceCounts;
    const newCount = ((_map$get = map.get(retainable)) !== null && _map$get !== void 0 ? _map$get : 0) + delta;
    if (newCount === 0) {
      updateRetainCountToZero(store, retainable);
    } else {
      map.set(retainable, newCount);
    }
  }
  function updateRetainCountToZero(store, retainable) {
    if (!Recoil_gkx("recoil_memory_managament_2020")) {
      return;
    }
    const map = store.getState().retention.referenceCounts;
    map.delete(retainable);
    scheduleOrPerformPossibleReleaseOfRetainable(store, retainable);
  }
  function retainedByOptionWithDefault(r) {
    return r === void 0 ? "recoilRoot" : r;
  }
  var Recoil_Retention = {
    SUSPENSE_TIMEOUT_MS,
    updateRetainCount,
    retainedByOptionWithDefault
  };
  const {
    unstable_batchedUpdates
  } = reactDom;
  var ReactBatchedUpdates = {
    unstable_batchedUpdates
  };
  const {
    unstable_batchedUpdates: unstable_batchedUpdates$1
  } = ReactBatchedUpdates;
  var Recoil_ReactBatchedUpdates = {
    unstable_batchedUpdates: unstable_batchedUpdates$1
  };
  const {
    batchStart: batchStart$1
  } = Recoil_RecoilValueInterface;
  const {
    unstable_batchedUpdates: unstable_batchedUpdates$2
  } = Recoil_ReactBatchedUpdates;
  let batcher = unstable_batchedUpdates$2 || ((batchFn) => batchFn());
  const batchUpdates = (callback) => {
    batcher(() => {
      let batchEnd = () => void 0;
      try {
        batchEnd = batchStart$1();
        callback();
      } finally {
        batchEnd();
      }
    });
  };
  var Recoil_Batching = {
    batchUpdates
  };
  function* concatIterables(iters) {
    for (const iter of iters) {
      for (const val of iter) {
        yield val;
      }
    }
  }
  var Recoil_concatIterables = concatIterables;
  const isSSR = (
    // $FlowFixMe(site=recoil) Window does not have a FlowType definition https://github.com/facebook/flow/issues/6709
    typeof Window === "undefined" || typeof window === "undefined"
  );
  var Recoil_Environment = {
    isSSR
  };
  function memoizeOneWithArgsHashAndInvalidation(fn, hashFunction) {
    let lastKey;
    let lastResult;
    const memoizedFn = (...args) => {
      const key2 = hashFunction(...args);
      if (lastKey === key2) {
        return lastResult;
      }
      lastKey = key2;
      lastResult = fn(...args);
      return lastResult;
    };
    const invalidate = () => {
      lastKey = null;
    };
    return [memoizedFn, invalidate];
  }
  var Recoil_Memoize = {
    memoizeOneWithArgsHashAndInvalidation
  };
  const {
    batchUpdates: batchUpdates$1
  } = Recoil_Batching;
  const {
    initializeNode: initializeNode$1,
    peekNodeInfo: peekNodeInfo$1
  } = Recoil_FunctionalCore;
  const {
    graph: graph$1
  } = Recoil_Graph;
  const {
    getNextStoreID: getNextStoreID$1
  } = Recoil_Keys;
  const {
    DEFAULT_VALUE: DEFAULT_VALUE$1,
    recoilValues: recoilValues$1,
    recoilValuesForKeys: recoilValuesForKeys$2
  } = Recoil_Node;
  const {
    AbstractRecoilValue: AbstractRecoilValue$2,
    getRecoilValueAsLoadable: getRecoilValueAsLoadable$1,
    setRecoilValue: setRecoilValue$1,
    setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$1
  } = Recoil_RecoilValueInterface;
  const {
    updateRetainCount: updateRetainCount$1
  } = Recoil_Retention;
  const {
    setInvalidateMemoizedSnapshot: setInvalidateMemoizedSnapshot$1
  } = Recoil_SnapshotCache;
  const {
    getNextTreeStateVersion: getNextTreeStateVersion$2,
    makeEmptyStoreState: makeEmptyStoreState$1
  } = Recoil_State;
  const {
    isSSR: isSSR$1
  } = Recoil_Environment;
  const {
    memoizeOneWithArgsHashAndInvalidation: memoizeOneWithArgsHashAndInvalidation$1
  } = Recoil_Memoize;
  class Snapshot {
    // eslint-disable-next-line fb-www/no-uninitialized-properties
    constructor(storeState, parentStoreID) {
      _defineProperty(this, "_store", void 0);
      _defineProperty(this, "_refCount", 1);
      _defineProperty(this, "getLoadable", (recoilValue) => {
        this.checkRefCount_INTERNAL();
        return getRecoilValueAsLoadable$1(this._store, recoilValue);
      });
      _defineProperty(this, "getPromise", (recoilValue) => {
        this.checkRefCount_INTERNAL();
        return this.getLoadable(recoilValue).toPromise();
      });
      _defineProperty(this, "getNodes_UNSTABLE", (opt) => {
        this.checkRefCount_INTERNAL();
        if ((opt === null || opt === void 0 ? void 0 : opt.isModified) === true) {
          if ((opt === null || opt === void 0 ? void 0 : opt.isInitialized) === false) {
            return [];
          }
          const state = this._store.getState().currentTree;
          return recoilValuesForKeys$2(state.dirtyAtoms);
        }
        const knownAtoms = this._store.getState().knownAtoms;
        const knownSelectors = this._store.getState().knownSelectors;
        return (opt === null || opt === void 0 ? void 0 : opt.isInitialized) == null ? recoilValues$1.values() : opt.isInitialized === true ? recoilValuesForKeys$2(Recoil_concatIterables([knownAtoms, knownSelectors])) : Recoil_filterIterable(recoilValues$1.values(), ({
          key: key2
        }) => !knownAtoms.has(key2) && !knownSelectors.has(key2));
      });
      _defineProperty(this, "getInfo_UNSTABLE", ({
        key: key2
      }) => {
        this.checkRefCount_INTERNAL();
        return peekNodeInfo$1(this._store, this._store.getState().currentTree, key2);
      });
      _defineProperty(this, "map", (mapper) => {
        this.checkRefCount_INTERNAL();
        const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);
        mapper(mutableSnapshot);
        return mutableSnapshot;
      });
      _defineProperty(this, "asyncMap", async (mapper) => {
        this.checkRefCount_INTERNAL();
        const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);
        mutableSnapshot.retain();
        await mapper(mutableSnapshot);
        mutableSnapshot.autoRelease_INTERNAL();
        return mutableSnapshot;
      });
      this._store = {
        storeID: getNextStoreID$1(),
        parentStoreID,
        getState: () => storeState,
        replaceState: (replacer) => {
          storeState.currentTree = replacer(storeState.currentTree);
        },
        getGraph: (version) => {
          const graphs = storeState.graphsByVersion;
          if (graphs.has(version)) {
            return Recoil_nullthrows(graphs.get(version));
          }
          const newGraph = graph$1();
          graphs.set(version, newGraph);
          return newGraph;
        },
        subscribeToTransactions: () => ({
          release: () => {
          }
        }),
        addTransactionMetadata: () => {
          throw Recoil_err("Cannot subscribe to Snapshots");
        }
      };
      for (const nodeKey of this._store.getState().knownAtoms) {
        initializeNode$1(this._store, nodeKey, "get");
        updateRetainCount$1(this._store, nodeKey, 1);
      }
      this.autoRelease_INTERNAL();
    }
    retain() {
      if (this._refCount <= 0) {
        {
          Recoil_recoverableViolation();
        }
      }
      this._refCount++;
      let released = false;
      return () => {
        if (!released) {
          released = true;
          this._release();
        }
      };
    }
    /**
     * Release the snapshot on the next tick.  This means the snapshot is retained
     * during the execution of the current function using it.
     */
    autoRelease_INTERNAL() {
      if (!isSSR$1) {
        window.setTimeout(() => this._release(), 10);
      }
    }
    _release() {
      this._refCount--;
      if (this._refCount === 0) {
        this._store.getState().nodeCleanupFunctions.forEach((cleanup) => cleanup());
        this._store.getState().nodeCleanupFunctions.clear();
        if (!Recoil_gkx("recoil_memory_managament_2020")) {
          return;
        }
      } else if (this._refCount < 0) ;
    }
    isRetained() {
      return this._refCount > 0;
    }
    checkRefCount_INTERNAL() {
      if (Recoil_gkx("recoil_memory_managament_2020") && this._refCount <= 0) ;
    }
    getStore_INTERNAL() {
      this.checkRefCount_INTERNAL();
      return this._store;
    }
    getID() {
      this.checkRefCount_INTERNAL();
      return this._store.getState().currentTree.stateID;
    }
    getStoreID() {
      this.checkRefCount_INTERNAL();
      return this._store.storeID;
    }
    // We want to allow the methods to be destructured and used as accessors
    /* eslint-disable fb-www/extra-arrow-initializer */
    /* eslint-enable fb-www/extra-arrow-initializer */
  }
  function cloneStoreState(store, treeState, bumpVersion = false) {
    const storeState = store.getState();
    const version = bumpVersion ? getNextTreeStateVersion$2() : treeState.version;
    return {
      // Always clone the TreeState to isolate stores from accidental mutations.
      // For example, reading a selector from a cloned snapshot shouldn't cache
      // in the original treestate which may cause the original to skip
      // initialization of upstream atoms.
      currentTree: {
        // TODO snapshots shouldn't really have versions because a new version number
        // is always assigned when the snapshot is gone to.
        version: bumpVersion ? version : treeState.version,
        stateID: bumpVersion ? version : treeState.stateID,
        transactionMetadata: {
          ...treeState.transactionMetadata
        },
        dirtyAtoms: new Set(treeState.dirtyAtoms),
        atomValues: treeState.atomValues.clone(),
        nonvalidatedAtoms: treeState.nonvalidatedAtoms.clone()
      },
      commitDepth: 0,
      nextTree: null,
      previousTree: null,
      knownAtoms: new Set(storeState.knownAtoms),
      // FIXME here's a copy
      knownSelectors: new Set(storeState.knownSelectors),
      // FIXME here's a copy
      transactionSubscriptions: /* @__PURE__ */ new Map(),
      nodeTransactionSubscriptions: /* @__PURE__ */ new Map(),
      nodeToComponentSubscriptions: /* @__PURE__ */ new Map(),
      queuedComponentCallbacks_DEPRECATED: [],
      suspendedComponentResolvers: /* @__PURE__ */ new Set(),
      graphsByVersion: (/* @__PURE__ */ new Map()).set(version, store.getGraph(treeState.version)),
      retention: {
        referenceCounts: /* @__PURE__ */ new Map(),
        nodesRetainedByZone: /* @__PURE__ */ new Map(),
        retainablesToCheckForRelease: /* @__PURE__ */ new Set()
      },
      // FIXME here's a copy
      // Create blank cleanup handlers for atoms so snapshots don't re-run
      // atom effects.
      nodeCleanupFunctions: new Map(Recoil_mapIterable(storeState.nodeCleanupFunctions.entries(), ([key2]) => [key2, () => {
      }]))
    };
  }
  function freshSnapshot(initializeState) {
    const snapshot = new Snapshot(makeEmptyStoreState$1());
    return initializeState != null ? snapshot.map(initializeState) : snapshot;
  }
  const [memoizedCloneSnapshot, invalidateMemoizedSnapshot$2] = memoizeOneWithArgsHashAndInvalidation$1(
    // $FlowFixMe[missing-local-annot]
    (store, version) => {
      var _storeState$nextTree;
      const storeState = store.getState();
      const treeState = version === "latest" ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : Recoil_nullthrows(storeState.previousTree);
      return new Snapshot(cloneStoreState(store, treeState), store.storeID);
    },
    (store, version) => {
      var _store$getState$nextT, _store$getState$previ;
      return String(version) + String(store.storeID) + String((_store$getState$nextT = store.getState().nextTree) === null || _store$getState$nextT === void 0 ? void 0 : _store$getState$nextT.version) + String(store.getState().currentTree.version) + String((_store$getState$previ = store.getState().previousTree) === null || _store$getState$previ === void 0 ? void 0 : _store$getState$previ.version);
    }
  );
  setInvalidateMemoizedSnapshot$1(invalidateMemoizedSnapshot$2);
  function cloneSnapshot(store, version = "latest") {
    const snapshot = memoizedCloneSnapshot(store, version);
    if (!snapshot.isRetained()) {
      invalidateMemoizedSnapshot$2();
      return memoizedCloneSnapshot(store, version);
    }
    return snapshot;
  }
  class MutableSnapshot extends Snapshot {
    constructor(snapshot, batch2) {
      super(cloneStoreState(snapshot.getStore_INTERNAL(), snapshot.getStore_INTERNAL().getState().currentTree, true), snapshot.getStoreID());
      _defineProperty(this, "_batch", void 0);
      _defineProperty(this, "set", (recoilState, newValueOrUpdater) => {
        this.checkRefCount_INTERNAL();
        const store = this.getStore_INTERNAL();
        this._batch(() => {
          updateRetainCount$1(store, recoilState.key, 1);
          setRecoilValue$1(this.getStore_INTERNAL(), recoilState, newValueOrUpdater);
        });
      });
      _defineProperty(this, "reset", (recoilState) => {
        this.checkRefCount_INTERNAL();
        const store = this.getStore_INTERNAL();
        this._batch(() => {
          updateRetainCount$1(store, recoilState.key, 1);
          setRecoilValue$1(this.getStore_INTERNAL(), recoilState, DEFAULT_VALUE$1);
        });
      });
      _defineProperty(this, "setUnvalidatedAtomValues_DEPRECATED", (values) => {
        this.checkRefCount_INTERNAL();
        const store = this.getStore_INTERNAL();
        batchUpdates$1(() => {
          for (const [k2, v] of values.entries()) {
            updateRetainCount$1(store, k2, 1);
            setUnvalidatedRecoilValue$1(store, new AbstractRecoilValue$2(k2), v);
          }
        });
      });
      this._batch = batch2;
    }
  }
  var Recoil_Snapshot = {
    Snapshot,
    MutableSnapshot,
    freshSnapshot,
    cloneSnapshot
  };
  var Recoil_Snapshot_1 = Recoil_Snapshot.Snapshot;
  var Recoil_Snapshot_2 = Recoil_Snapshot.MutableSnapshot;
  var Recoil_Snapshot_3 = Recoil_Snapshot.freshSnapshot;
  var Recoil_Snapshot_4 = Recoil_Snapshot.cloneSnapshot;
  var Recoil_Snapshot$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    Snapshot: Recoil_Snapshot_1,
    MutableSnapshot: Recoil_Snapshot_2,
    freshSnapshot: Recoil_Snapshot_3,
    cloneSnapshot: Recoil_Snapshot_4
  });
  const {
    useRef
  } = React;
  const {
    getNextStoreID: getNextStoreID$2
  } = Recoil_Keys;
  const {
    freshSnapshot: freshSnapshot$1
  } = Recoil_Snapshot$1;
  const {
    useCallback,
    useContext,
    useEffect,
    useMemo,
    useRef: useRef$1,
    useState
  } = React;
  function notInAContext() {
    throw Recoil_err("This component must be used inside a <RecoilRoot> component.");
  }
  const defaultStore = Object.freeze({
    storeID: getNextStoreID$2(),
    getState: notInAContext,
    replaceState: notInAContext,
    getGraph: notInAContext,
    subscribeToTransactions: notInAContext,
    addTransactionMetadata: notInAContext
  });
  const AppContext = React.createContext({
    current: defaultStore
  });
  const useStoreRef = () => useContext(AppContext);
  const MutableSourceContext = React.createContext(null);
  function useRecoilMutableSource() {
    const mutableSource = useContext(MutableSourceContext);
    if (mutableSource == null) {
      Recoil_expectationViolation();
    }
    return mutableSource;
  }
  var Recoil_RecoilRoot = {
    useStoreRef,
    useRecoilMutableSource
  };
  function shallowArrayEqual(a, b2) {
    if (a === b2) {
      return true;
    }
    if (a.length !== b2.length) {
      return false;
    }
    for (let i2 = 0, l = a.length; i2 < l; i2++) {
      if (a[i2] !== b2[i2]) {
        return false;
      }
    }
    return true;
  }
  var Recoil_shallowArrayEqual = shallowArrayEqual;
  const {
    useEffect: useEffect$1,
    useRef: useRef$2
  } = React;
  function usePrevious(value) {
    const ref = useRef$2();
    useEffect$1(() => {
      ref.current = value;
    });
    return ref.current;
  }
  var Recoil_usePrevious = usePrevious;
  const {
    useStoreRef: useStoreRef$1
  } = Recoil_RecoilRoot;
  const {
    SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$1
  } = Recoil_Retention;
  const {
    updateRetainCount: updateRetainCount$2
  } = Recoil_Retention;
  const {
    RetentionZone: RetentionZone$3
  } = Recoil_RetentionZone;
  const {
    useEffect: useEffect$2,
    useRef: useRef$3
  } = React;
  const {
    isSSR: isSSR$2
  } = Recoil_Environment;
  function useRetain(toRetain) {
    if (!Recoil_gkx("recoil_memory_managament_2020")) {
      return;
    }
    return useRetain_ACTUAL(toRetain);
  }
  function useRetain_ACTUAL(toRetain) {
    const array = Array.isArray(toRetain) ? toRetain : [toRetain];
    const retainables = array.map((a) => a instanceof RetentionZone$3 ? a : a.key);
    const storeRef = useStoreRef$1();
    useEffect$2(() => {
      if (!Recoil_gkx("recoil_memory_managament_2020")) {
        return;
      }
      const store = storeRef.current;
      if (timeoutID.current && !isSSR$2) {
        window.clearTimeout(timeoutID.current);
        timeoutID.current = null;
      } else {
        for (const r of retainables) {
          updateRetainCount$2(store, r, 1);
        }
      }
      return () => {
        for (const r of retainables) {
          updateRetainCount$2(store, r, -1);
        }
      };
    }, [storeRef, ...retainables]);
    const timeoutID = useRef$3();
    const previousRetainables = Recoil_usePrevious(retainables);
    if (!isSSR$2 && (previousRetainables === void 0 || !Recoil_shallowArrayEqual(previousRetainables, retainables))) {
      const store = storeRef.current;
      for (const r of retainables) {
        updateRetainCount$2(store, r, 1);
      }
      if (previousRetainables) {
        for (const r of previousRetainables) {
          updateRetainCount$2(store, r, -1);
        }
      }
      if (timeoutID.current) {
        window.clearTimeout(timeoutID.current);
      }
      timeoutID.current = window.setTimeout(() => {
        timeoutID.current = null;
        for (const r of retainables) {
          updateRetainCount$2(store, r, -1);
        }
      }, SUSPENSE_TIMEOUT_MS$1);
    }
  }
  var Recoil_useRetain = useRetain;
  function useComponentName() {
    return "<component name not available>";
  }
  var Recoil_useComponentName = useComponentName;
  const {
    currentRendererSupportsUseSyncExternalStore: currentRendererSupportsUseSyncExternalStore$1,
    reactMode: reactMode$3,
    useMutableSource: useMutableSource$1,
    useSyncExternalStore: useSyncExternalStore$1
  } = Recoil_ReactMode;
  const {
    useRecoilMutableSource: useRecoilMutableSource$1,
    useStoreRef: useStoreRef$2
  } = Recoil_RecoilRoot;
  const {
    isRecoilValue: isRecoilValue$2
  } = Recoil_RecoilValue$1;
  const {
    getRecoilValueAsLoadable: getRecoilValueAsLoadable$2,
    setRecoilValue: setRecoilValue$2,
    subscribeToRecoilValue: subscribeToRecoilValue$1
  } = Recoil_RecoilValueInterface;
  const {
    useCallback: useCallback$1,
    useEffect: useEffect$3,
    useMemo: useMemo$1,
    useRef: useRef$4,
    useState: useState$1
  } = React;
  const {
    isSSR: isSSR$3
  } = Recoil_Environment;
  function handleLoadable(loadable, recoilValue, storeRef) {
    if (loadable.state === "hasValue") {
      return loadable.contents;
    } else if (loadable.state === "loading") {
      const promise = new Promise((resolve) => {
        const suspendedComponentResolvers = storeRef.current.getState().suspendedComponentResolvers;
        suspendedComponentResolvers.add(resolve);
        if (isSSR$3 && Recoil_isPromise(loadable.contents)) {
          loadable.contents.finally(() => {
            suspendedComponentResolvers.delete(resolve);
          });
        }
      });
      throw promise;
    } else if (loadable.state === "hasError") {
      throw loadable.contents;
    } else {
      throw Recoil_err(`Invalid value of loadable atom "${recoilValue.key}"`);
    }
  }
  function useRecoilValueLoadable_SYNC_EXTERNAL_STORE(recoilValue) {
    const storeRef = useStoreRef$2();
    const componentName = Recoil_useComponentName();
    const getSnapshot = useCallback$1(() => {
      var _storeState$nextTree2;
      const store = storeRef.current;
      const storeState = store.getState();
      const treeState = reactMode$3().early ? (_storeState$nextTree2 = storeState.nextTree) !== null && _storeState$nextTree2 !== void 0 ? _storeState$nextTree2 : storeState.currentTree : storeState.currentTree;
      const loadable = getRecoilValueAsLoadable$2(store, recoilValue, treeState);
      return {
        loadable,
        key: recoilValue.key
      };
    }, [storeRef, recoilValue]);
    const memoizePreviousSnapshot = useCallback$1((getState) => {
      let prevState;
      return () => {
        var _prevState, _prevState2;
        const nextState = getState();
        if ((_prevState = prevState) !== null && _prevState !== void 0 && _prevState.loadable.is(nextState.loadable) && ((_prevState2 = prevState) === null || _prevState2 === void 0 ? void 0 : _prevState2.key) === nextState.key) {
          return prevState;
        }
        prevState = nextState;
        return nextState;
      };
    }, []);
    const getMemoizedSnapshot = useMemo$1(() => memoizePreviousSnapshot(getSnapshot), [getSnapshot, memoizePreviousSnapshot]);
    const subscribe2 = useCallback$1((notify) => {
      const store = storeRef.current;
      const subscription = subscribeToRecoilValue$1(store, recoilValue, notify, componentName);
      return subscription.release;
    }, [storeRef, recoilValue, componentName]);
    return useSyncExternalStore$1(
      subscribe2,
      getMemoizedSnapshot,
      // getSnapshot()
      getMemoizedSnapshot
      // getServerSnapshot() for SSR support
    ).loadable;
  }
  function useRecoilValueLoadable_MUTABLE_SOURCE(recoilValue) {
    const storeRef = useStoreRef$2();
    const getLoadable = useCallback$1(() => {
      var _storeState$nextTree3;
      const store = storeRef.current;
      const storeState = store.getState();
      const treeState = reactMode$3().early ? (_storeState$nextTree3 = storeState.nextTree) !== null && _storeState$nextTree3 !== void 0 ? _storeState$nextTree3 : storeState.currentTree : storeState.currentTree;
      return getRecoilValueAsLoadable$2(store, recoilValue, treeState);
    }, [storeRef, recoilValue]);
    const getLoadableWithTesting = useCallback$1(() => {
      return getLoadable();
    }, [getLoadable]);
    const componentName = Recoil_useComponentName();
    const subscribe2 = useCallback$1((_storeState, notify) => {
      const store = storeRef.current;
      const subscription = subscribeToRecoilValue$1(store, recoilValue, () => {
        if (!Recoil_gkx("recoil_suppress_rerender_in_callback")) {
          return notify();
        }
        const newLoadable = getLoadable();
        if (!prevLoadableRef.current.is(newLoadable)) {
          notify();
        }
        prevLoadableRef.current = newLoadable;
      }, componentName);
      return subscription.release;
    }, [storeRef, recoilValue, componentName, getLoadable]);
    const source = useRecoilMutableSource$1();
    if (source == null) {
      throw Recoil_err("Recoil hooks must be used in components contained within a <RecoilRoot> component.");
    }
    const loadable = useMutableSource$1(source, getLoadableWithTesting, subscribe2);
    const prevLoadableRef = useRef$4(loadable);
    useEffect$3(() => {
      prevLoadableRef.current = loadable;
    });
    return loadable;
  }
  function useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue) {
    const storeRef = useStoreRef$2();
    const componentName = Recoil_useComponentName();
    const getLoadable = useCallback$1(() => {
      var _storeState$nextTree4;
      const store = storeRef.current;
      const storeState = store.getState();
      const treeState = reactMode$3().early ? (_storeState$nextTree4 = storeState.nextTree) !== null && _storeState$nextTree4 !== void 0 ? _storeState$nextTree4 : storeState.currentTree : storeState.currentTree;
      return getRecoilValueAsLoadable$2(store, recoilValue, treeState);
    }, [storeRef, recoilValue]);
    const getState = useCallback$1(() => ({
      loadable: getLoadable(),
      key: recoilValue.key
    }), [getLoadable, recoilValue.key]);
    const updateState = useCallback$1((prevState) => {
      const nextState = getState();
      return prevState.loadable.is(nextState.loadable) && prevState.key === nextState.key ? prevState : nextState;
    }, [getState]);
    useEffect$3(() => {
      const subscription = subscribeToRecoilValue$1(storeRef.current, recoilValue, (_state) => {
        setState(updateState);
      }, componentName);
      setState(updateState);
      return subscription.release;
    }, [componentName, recoilValue, storeRef, updateState]);
    const [state, setState] = useState$1(getState);
    return state.key !== recoilValue.key ? getState().loadable : state.loadable;
  }
  function useRecoilValueLoadable_LEGACY(recoilValue) {
    const storeRef = useStoreRef$2();
    const [, forceUpdate] = useState$1([]);
    const componentName = Recoil_useComponentName();
    const getLoadable = useCallback$1(() => {
      var _storeState$nextTree5;
      const store = storeRef.current;
      const storeState = store.getState();
      const treeState = reactMode$3().early ? (_storeState$nextTree5 = storeState.nextTree) !== null && _storeState$nextTree5 !== void 0 ? _storeState$nextTree5 : storeState.currentTree : storeState.currentTree;
      return getRecoilValueAsLoadable$2(store, recoilValue, treeState);
    }, [storeRef, recoilValue]);
    const loadable = getLoadable();
    const prevLoadableRef = useRef$4(loadable);
    useEffect$3(() => {
      prevLoadableRef.current = loadable;
    });
    useEffect$3(() => {
      const store = storeRef.current;
      const storeState = store.getState();
      const subscription = subscribeToRecoilValue$1(store, recoilValue, (_state) => {
        var _prevLoadableRef$curr;
        if (!Recoil_gkx("recoil_suppress_rerender_in_callback")) {
          return forceUpdate([]);
        }
        const newLoadable = getLoadable();
        if (!((_prevLoadableRef$curr = prevLoadableRef.current) !== null && _prevLoadableRef$curr !== void 0 && _prevLoadableRef$curr.is(newLoadable))) {
          forceUpdate(newLoadable);
        }
        prevLoadableRef.current = newLoadable;
      }, componentName);
      if (storeState.nextTree) {
        store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {
          prevLoadableRef.current = null;
          forceUpdate([]);
        });
      } else {
        var _prevLoadableRef$curr2;
        if (!Recoil_gkx("recoil_suppress_rerender_in_callback")) {
          return forceUpdate([]);
        }
        const newLoadable = getLoadable();
        if (!((_prevLoadableRef$curr2 = prevLoadableRef.current) !== null && _prevLoadableRef$curr2 !== void 0 && _prevLoadableRef$curr2.is(newLoadable))) {
          forceUpdate(newLoadable);
        }
        prevLoadableRef.current = newLoadable;
      }
      return subscription.release;
    }, [componentName, getLoadable, recoilValue, storeRef]);
    return loadable;
  }
  function useRecoilValueLoadable(recoilValue) {
    if (Recoil_gkx("recoil_memory_managament_2020")) {
      Recoil_useRetain(recoilValue);
    }
    return {
      TRANSITION_SUPPORT: useRecoilValueLoadable_TRANSITION_SUPPORT,
      // Recoil will attemp to detect if `useSyncExternalStore()` is supported with
      // `reactMode()` before calling it.  However, sometimes the host React
      // environment supports it but uses additional React renderers (such as with
      // `react-three-fiber`) which do not.  While this is technically a user issue
      // by using a renderer with React 18+ that doesn't fully support React 18 we
      // don't want to break users if it can be avoided. As the current renderer can
      // change at runtime, we need to dynamically check and fallback if necessary.
      SYNC_EXTERNAL_STORE: currentRendererSupportsUseSyncExternalStore$1() ? useRecoilValueLoadable_SYNC_EXTERNAL_STORE : useRecoilValueLoadable_TRANSITION_SUPPORT,
      MUTABLE_SOURCE: useRecoilValueLoadable_MUTABLE_SOURCE,
      LEGACY: useRecoilValueLoadable_LEGACY
    }[reactMode$3().mode](recoilValue);
  }
  function useRecoilValue(recoilValue) {
    const storeRef = useStoreRef$2();
    const loadable = useRecoilValueLoadable(recoilValue);
    return handleLoadable(loadable, recoilValue, storeRef);
  }
  function useSetRecoilState(recoilState) {
    const storeRef = useStoreRef$2();
    return useCallback$1((newValueOrUpdater) => {
      setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);
    }, [storeRef, recoilState]);
  }
  var Recoil_Hooks = {
    useRecoilValue,
    useSetRecoilState
  };
  const {
    batchUpdates: batchUpdates$3
  } = Recoil_Batching;
  const {
    DEFAULT_VALUE: DEFAULT_VALUE$3,
    getNode: getNode$4
  } = Recoil_Node;
  const {
    AbstractRecoilValue: AbstractRecoilValue$4,
    setRecoilValueLoadable: setRecoilValueLoadable$1
  } = Recoil_RecoilValueInterface;
  const {
    cloneSnapshot: cloneSnapshot$1
  } = Recoil_Snapshot$1;
  const {
    useCallback: useCallback$2,
    useEffect: useEffect$4,
    useRef: useRef$5,
    useState: useState$2
  } = React;
  function gotoSnapshot(store, snapshot) {
    var _storeState$nextTree;
    const storeState = store.getState();
    const prev = (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree;
    const next = snapshot.getStore_INTERNAL().getState().currentTree;
    batchUpdates$3(() => {
      const keysToUpdate = /* @__PURE__ */ new Set();
      for (const keys2 of [prev.atomValues.keys(), next.atomValues.keys()]) {
        for (const key2 of keys2) {
          var _prev$atomValues$get, _next$atomValues$get;
          if (((_prev$atomValues$get = prev.atomValues.get(key2)) === null || _prev$atomValues$get === void 0 ? void 0 : _prev$atomValues$get.contents) !== ((_next$atomValues$get = next.atomValues.get(key2)) === null || _next$atomValues$get === void 0 ? void 0 : _next$atomValues$get.contents) && getNode$4(key2).shouldRestoreFromSnapshots) {
            keysToUpdate.add(key2);
          }
        }
      }
      keysToUpdate.forEach((key2) => {
        setRecoilValueLoadable$1(store, new AbstractRecoilValue$4(key2), next.atomValues.has(key2) ? Recoil_nullthrows(next.atomValues.get(key2)) : DEFAULT_VALUE$3);
      });
      store.replaceState((state) => ({
        ...state,
        stateID: snapshot.getID()
      }));
    });
  }
  var Recoil_SnapshotHooks = {
    gotoSnapshot
  };
  const {
    useMemo: useMemo$2
  } = React;
  const {
    loadableWithValue: loadableWithValue$1
  } = Recoil_Loadable$1;
  const {
    initializeNode: initializeNode$3
  } = Recoil_FunctionalCore;
  const {
    DEFAULT_VALUE: DEFAULT_VALUE$4,
    getNode: getNode$5
  } = Recoil_Node;
  const {
    copyTreeState: copyTreeState$1,
    getRecoilValueAsLoadable: getRecoilValueAsLoadable$3,
    invalidateDownstreams: invalidateDownstreams$1,
    writeLoadableToTreeState: writeLoadableToTreeState$1
  } = Recoil_RecoilValueInterface;
  function isAtom(recoilValue) {
    return getNode$5(recoilValue.key).nodeType === "atom";
  }
  class TransactionInterfaceImpl {
    constructor(store, treeState) {
      _defineProperty(this, "_store", void 0);
      _defineProperty(this, "_treeState", void 0);
      _defineProperty(this, "_changes", void 0);
      _defineProperty(this, "get", (recoilValue) => {
        if (this._changes.has(recoilValue.key)) {
          return this._changes.get(recoilValue.key);
        }
        if (!isAtom(recoilValue)) {
          throw Recoil_err("Reading selectors within atomicUpdate is not supported");
        }
        const loadable = getRecoilValueAsLoadable$3(this._store, recoilValue, this._treeState);
        if (loadable.state === "hasValue") {
          return loadable.contents;
        } else if (loadable.state === "hasError") {
          throw loadable.contents;
        } else {
          throw Recoil_err(`Expected Recoil atom ${recoilValue.key} to have a value, but it is in a loading state.`);
        }
      });
      _defineProperty(this, "set", (recoilState, valueOrUpdater) => {
        if (!isAtom(recoilState)) {
          throw Recoil_err("Setting selectors within atomicUpdate is not supported");
        }
        if (typeof valueOrUpdater === "function") {
          const current = this.get(recoilState);
          this._changes.set(recoilState.key, valueOrUpdater(current));
        } else {
          initializeNode$3(this._store, recoilState.key, "set");
          this._changes.set(recoilState.key, valueOrUpdater);
        }
      });
      _defineProperty(this, "reset", (recoilState) => {
        this.set(recoilState, DEFAULT_VALUE$4);
      });
      this._store = store;
      this._treeState = treeState;
      this._changes = /* @__PURE__ */ new Map();
    }
    // Allow destructing
    // eslint-disable-next-line fb-www/extra-arrow-initializer
    newTreeState_INTERNAL() {
      if (this._changes.size === 0) {
        return this._treeState;
      }
      const newState = copyTreeState$1(this._treeState);
      for (const [k2, v] of this._changes) {
        writeLoadableToTreeState$1(newState, k2, loadableWithValue$1(v));
      }
      invalidateDownstreams$1(this._store, newState);
      return newState;
    }
  }
  function atomicUpdater(store) {
    return (fn) => {
      store.replaceState((treeState) => {
        const changeset = new TransactionInterfaceImpl(store, treeState);
        fn(changeset);
        return changeset.newTreeState_INTERNAL();
      });
    };
  }
  var Recoil_AtomicUpdates = {
    atomicUpdater
  };
  var Recoil_AtomicUpdates_1 = Recoil_AtomicUpdates.atomicUpdater;
  var Recoil_AtomicUpdates$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    atomicUpdater: Recoil_AtomicUpdates_1
  });
  function invariant(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }
  var invariant_1 = invariant;
  var Recoil_invariant = invariant_1;
  const {
    atomicUpdater: atomicUpdater$1
  } = Recoil_AtomicUpdates$1;
  const {
    batchUpdates: batchUpdates$4
  } = Recoil_Batching;
  const {
    DEFAULT_VALUE: DEFAULT_VALUE$5
  } = Recoil_Node;
  const {
    refreshRecoilValue: refreshRecoilValue$1,
    setRecoilValue: setRecoilValue$3
  } = Recoil_RecoilValueInterface;
  const {
    cloneSnapshot: cloneSnapshot$2
  } = Recoil_Snapshot$1;
  const {
    gotoSnapshot: gotoSnapshot$1
  } = Recoil_SnapshotHooks;
  const {
    useCallback: useCallback$3
  } = React;
  class Sentinel {
  }
  const SENTINEL = new Sentinel();
  function recoilCallback(store, fn, args, extraInterface) {
    let ret = SENTINEL;
    let releaseSnapshot;
    batchUpdates$4(() => {
      const errMsg = "useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";
      if (typeof fn !== "function") {
        throw Recoil_err(errMsg);
      }
      const callbackInterface = Recoil_lazyProxy({
        ...extraInterface !== null && extraInterface !== void 0 ? extraInterface : {},
        // flowlint-line unclear-type:off
        // $FlowFixMe[missing-local-annot]
        set: (node, newValue) => setRecoilValue$3(store, node, newValue),
        // $FlowFixMe[missing-local-annot]
        reset: (node) => setRecoilValue$3(store, node, DEFAULT_VALUE$5),
        // $FlowFixMe[missing-local-annot]
        refresh: (node) => refreshRecoilValue$1(store, node),
        gotoSnapshot: (snapshot) => gotoSnapshot$1(store, snapshot),
        transact_UNSTABLE: (transaction) => atomicUpdater$1(store)(transaction)
      }, {
        snapshot: () => {
          const snapshot = cloneSnapshot$2(store);
          releaseSnapshot = snapshot.retain();
          return snapshot;
        }
      });
      const callback = fn(callbackInterface);
      if (typeof callback !== "function") {
        throw Recoil_err(errMsg);
      }
      ret = callback(...args);
    });
    !!(ret instanceof Sentinel) ? Recoil_invariant(false) : void 0;
    if (Recoil_isPromise(ret)) {
      ret = ret.finally(() => {
        var _releaseSnapshot;
        (_releaseSnapshot = releaseSnapshot) === null || _releaseSnapshot === void 0 ? void 0 : _releaseSnapshot();
      });
    } else {
      var _releaseSnapshot2;
      (_releaseSnapshot2 = releaseSnapshot) === null || _releaseSnapshot2 === void 0 ? void 0 : _releaseSnapshot2();
    }
    return ret;
  }
  var Recoil_useRecoilCallback = {
    recoilCallback
  };
  const {
    useCallback: useCallback$4
  } = React;
  const {
    atomicUpdater: atomicUpdater$2
  } = Recoil_AtomicUpdates$1;
  const {
    useMemo: useMemo$3
  } = React;
  class WrappedValue {
    constructor(value) {
      _defineProperty(this, "value", void 0);
      this.value = value;
    }
  }
  var Recoil_Wrapper = {
    WrappedValue
  };
  var Recoil_Wrapper_1 = Recoil_Wrapper.WrappedValue;
  var Recoil_Wrapper$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    WrappedValue: Recoil_Wrapper_1
  });
  class ChangedPathError extends Error {
  }
  class TreeCache {
    // $FlowIssue[unclear-type]
    constructor(options) {
      var _options$onHit, _options$onSet, _options$mapNodeValue;
      _defineProperty(this, "_name", void 0);
      _defineProperty(this, "_numLeafs", void 0);
      _defineProperty(this, "_root", void 0);
      _defineProperty(this, "_onHit", void 0);
      _defineProperty(this, "_onSet", void 0);
      _defineProperty(this, "_mapNodeValue", void 0);
      this._name = options === null || options === void 0 ? void 0 : options.name;
      this._numLeafs = 0;
      this._root = null;
      this._onHit = (_options$onHit = options === null || options === void 0 ? void 0 : options.onHit) !== null && _options$onHit !== void 0 ? _options$onHit : () => {
      };
      this._onSet = (_options$onSet = options === null || options === void 0 ? void 0 : options.onSet) !== null && _options$onSet !== void 0 ? _options$onSet : () => {
      };
      this._mapNodeValue = (_options$mapNodeValue = options === null || options === void 0 ? void 0 : options.mapNodeValue) !== null && _options$mapNodeValue !== void 0 ? _options$mapNodeValue : (val) => val;
    }
    size() {
      return this._numLeafs;
    }
    // $FlowIssue[unclear-type]
    root() {
      return this._root;
    }
    get(getNodeValue, handlers2) {
      var _this$getLeafNode;
      return (_this$getLeafNode = this.getLeafNode(getNodeValue, handlers2)) === null || _this$getLeafNode === void 0 ? void 0 : _this$getLeafNode.value;
    }
    getLeafNode(getNodeValue, handlers2) {
      if (this._root == null) {
        return void 0;
      }
      let node = this._root;
      while (node) {
        handlers2 === null || handlers2 === void 0 ? void 0 : handlers2.onNodeVisit(node);
        if (node.type === "leaf") {
          this._onHit(node);
          return node;
        }
        const nodeValue = this._mapNodeValue(getNodeValue(node.nodeKey));
        node = node.branches.get(nodeValue);
      }
      return void 0;
    }
    set(route, value, handlers2) {
      const addLeaf = () => {
        var _node2, _node3, _this$_root2, _handlers$onNodeVisit2;
        let node;
        let branchKey;
        for (const [nodeKey, nodeValue] of route) {
          var _node, _handlers$onNodeVisit, _this$_root;
          const root = this._root;
          if ((root === null || root === void 0 ? void 0 : root.type) === "leaf") {
            throw this.invalidCacheError();
          }
          const parent = node;
          node = parent ? parent.branches.get(branchKey) : root;
          node = (_node = node) !== null && _node !== void 0 ? _node : {
            type: "branch",
            nodeKey,
            parent,
            branches: /* @__PURE__ */ new Map(),
            branchKey
          };
          if (node.type !== "branch" || node.nodeKey !== nodeKey) {
            throw this.invalidCacheError();
          }
          parent === null || parent === void 0 ? void 0 : parent.branches.set(branchKey, node);
          handlers2 === null || handlers2 === void 0 ? void 0 : (_handlers$onNodeVisit = handlers2.onNodeVisit) === null || _handlers$onNodeVisit === void 0 ? void 0 : _handlers$onNodeVisit.call(handlers2, node);
          branchKey = this._mapNodeValue(nodeValue);
          this._root = (_this$_root = this._root) !== null && _this$_root !== void 0 ? _this$_root : node;
        }
        const oldLeaf = node ? (_node2 = node) === null || _node2 === void 0 ? void 0 : _node2.branches.get(branchKey) : this._root;
        if (oldLeaf != null && (oldLeaf.type !== "leaf" || oldLeaf.branchKey !== branchKey)) {
          throw this.invalidCacheError();
        }
        const leafNode = {
          type: "leaf",
          value,
          parent: node,
          branchKey
        };
        (_node3 = node) === null || _node3 === void 0 ? void 0 : _node3.branches.set(branchKey, leafNode);
        this._root = (_this$_root2 = this._root) !== null && _this$_root2 !== void 0 ? _this$_root2 : leafNode;
        this._numLeafs++;
        this._onSet(leafNode);
        handlers2 === null || handlers2 === void 0 ? void 0 : (_handlers$onNodeVisit2 = handlers2.onNodeVisit) === null || _handlers$onNodeVisit2 === void 0 ? void 0 : _handlers$onNodeVisit2.call(handlers2, leafNode);
      };
      try {
        addLeaf();
      } catch (error) {
        if (error instanceof ChangedPathError) {
          this.clear();
          addLeaf();
        } else {
          throw error;
        }
      }
    }
    // Returns true if leaf was actually deleted from the tree
    delete(leaf) {
      const root = this.root();
      if (!root) {
        return false;
      }
      if (leaf === root) {
        this._root = null;
        this._numLeafs = 0;
        return true;
      }
      let node = leaf.parent;
      let branchKey = leaf.branchKey;
      while (node) {
        var _node4;
        node.branches.delete(branchKey);
        if (node === root) {
          if (node.branches.size === 0) {
            this._root = null;
            this._numLeafs = 0;
          } else {
            this._numLeafs--;
          }
          return true;
        }
        if (node.branches.size > 0) {
          break;
        }
        branchKey = (_node4 = node) === null || _node4 === void 0 ? void 0 : _node4.branchKey;
        node = node.parent;
      }
      for (; node !== root; node = node.parent) {
        if (node == null) {
          return false;
        }
      }
      this._numLeafs--;
      return true;
    }
    clear() {
      this._numLeafs = 0;
      this._root = null;
    }
    invalidCacheError() {
      const CHANGED_PATH_ERROR_MESSAGE = "Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.";
      Recoil_recoverableViolation(CHANGED_PATH_ERROR_MESSAGE + (this._name != null ? ` - ${this._name}` : ""));
      throw new ChangedPathError();
    }
  }
  var Recoil_TreeCache = {
    TreeCache
  };
  var Recoil_TreeCache_1 = Recoil_TreeCache.TreeCache;
  var Recoil_TreeCache$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    TreeCache: Recoil_TreeCache_1
  });
  class LRUCache {
    constructor(options) {
      var _options$mapKey;
      _defineProperty(this, "_maxSize", void 0);
      _defineProperty(this, "_size", void 0);
      _defineProperty(this, "_head", void 0);
      _defineProperty(this, "_tail", void 0);
      _defineProperty(this, "_map", void 0);
      _defineProperty(this, "_keyMapper", void 0);
      this._maxSize = options.maxSize;
      this._size = 0;
      this._head = null;
      this._tail = null;
      this._map = /* @__PURE__ */ new Map();
      this._keyMapper = (_options$mapKey = options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : (v) => v;
    }
    head() {
      return this._head;
    }
    tail() {
      return this._tail;
    }
    size() {
      return this._size;
    }
    maxSize() {
      return this._maxSize;
    }
    has(key2) {
      return this._map.has(this._keyMapper(key2));
    }
    get(key2) {
      const mappedKey = this._keyMapper(key2);
      const node = this._map.get(mappedKey);
      if (!node) {
        return void 0;
      }
      this.set(key2, node.value);
      return node.value;
    }
    set(key2, val) {
      const mappedKey = this._keyMapper(key2);
      const existingNode = this._map.get(mappedKey);
      if (existingNode) {
        this.delete(key2);
      }
      const head = this.head();
      const node = {
        key: key2,
        right: head,
        left: null,
        value: val
      };
      if (head) {
        head.left = node;
      } else {
        this._tail = node;
      }
      this._map.set(mappedKey, node);
      this._head = node;
      this._size++;
      this._maybeDeleteLRU();
    }
    _maybeDeleteLRU() {
      if (this.size() > this.maxSize()) {
        this.deleteLru();
      }
    }
    deleteLru() {
      const tail = this.tail();
      if (tail) {
        this.delete(tail.key);
      }
    }
    delete(key2) {
      const mappedKey = this._keyMapper(key2);
      if (!this._size || !this._map.has(mappedKey)) {
        return;
      }
      const node = Recoil_nullthrows(this._map.get(mappedKey));
      const right = node.right;
      const left = node.left;
      if (right) {
        right.left = node.left;
      }
      if (left) {
        left.right = node.right;
      }
      if (node === this.head()) {
        this._head = right;
      }
      if (node === this.tail()) {
        this._tail = left;
      }
      this._map.delete(mappedKey);
      this._size--;
    }
    clear() {
      this._size = 0;
      this._head = null;
      this._tail = null;
      this._map = /* @__PURE__ */ new Map();
    }
  }
  var Recoil_LRUCache = {
    LRUCache
  };
  var Recoil_LRUCache_1 = Recoil_LRUCache.LRUCache;
  var Recoil_LRUCache$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    LRUCache: Recoil_LRUCache_1
  });
  const {
    LRUCache: LRUCache$1
  } = Recoil_LRUCache$1;
  const {
    TreeCache: TreeCache$1
  } = Recoil_TreeCache$1;
  function treeCacheLRU({
    name,
    maxSize,
    mapNodeValue = (v) => v
  }) {
    const lruCache = new LRUCache$1({
      maxSize
    });
    const cache = new TreeCache$1({
      name,
      mapNodeValue,
      onHit: (node) => {
        lruCache.set(node, true);
      },
      onSet: (node) => {
        const lruNode = lruCache.tail();
        lruCache.set(node, true);
        if (lruNode && cache.size() > maxSize) {
          cache.delete(lruNode.key);
        }
      }
    });
    return cache;
  }
  var Recoil_treeCacheLRU = treeCacheLRU;
  function stringify(x2, opt, key2) {
    if (typeof x2 === "string" && !x2.includes('"') && !x2.includes("\\")) {
      return `"${x2}"`;
    }
    switch (typeof x2) {
      case "undefined":
        return "";
      // JSON.stringify(undefined) returns undefined, but we always want to return a string
      case "boolean":
        return x2 ? "true" : "false";
      case "number":
      case "symbol":
        return String(x2);
      case "string":
        return JSON.stringify(x2);
      case "function":
        if ((opt === null || opt === void 0 ? void 0 : opt.allowFunctions) !== true) {
          throw Recoil_err("Attempt to serialize function in a Recoil cache key");
        }
        return `__FUNCTION(${x2.name})__`;
    }
    if (x2 === null) {
      return "null";
    }
    if (typeof x2 !== "object") {
      var _JSON$stringify;
      return (_JSON$stringify = JSON.stringify(x2)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : "";
    }
    if (Recoil_isPromise(x2)) {
      return "__PROMISE__";
    }
    if (Array.isArray(x2)) {
      return `[${x2.map((v, i2) => stringify(v, opt, i2.toString()))}]`;
    }
    if (typeof x2.toJSON === "function") {
      return stringify(x2.toJSON(key2), opt, key2);
    }
    if (x2 instanceof Map) {
      const obj = {};
      for (const [k2, v] of x2) {
        obj[typeof k2 === "string" ? k2 : stringify(k2, opt)] = v;
      }
      return stringify(obj, opt, key2);
    }
    if (x2 instanceof Set) {
      return stringify(
        // $FlowFixMe[missing-local-annot]
        Array.from(x2).sort((a, b2) => stringify(a, opt).localeCompare(stringify(b2, opt))),
        opt,
        key2
      );
    }
    if (Symbol !== void 0 && x2[Symbol.iterator] != null && typeof x2[Symbol.iterator] === "function") {
      return stringify(Array.from(x2), opt, key2);
    }
    return `{${Object.keys(x2).filter((k2) => x2[k2] !== void 0).sort().map((k2) => `${stringify(k2, opt)}:${stringify(x2[k2], opt, k2)}`).join(",")}}`;
  }
  function stableStringify(x2, opt = {
    allowFunctions: false
  }) {
    return stringify(x2, opt);
  }
  var Recoil_stableStringify = stableStringify;
  const {
    TreeCache: TreeCache$2
  } = Recoil_TreeCache$1;
  const defaultPolicy = {
    equality: "reference",
    eviction: "keep-all",
    maxSize: Infinity
  };
  function treeCacheFromPolicy({
    equality = defaultPolicy.equality,
    eviction = defaultPolicy.eviction,
    maxSize = defaultPolicy.maxSize
  } = defaultPolicy, name) {
    const valueMapper = getValueMapper(equality);
    return getTreeCache(eviction, maxSize, valueMapper, name);
  }
  function getValueMapper(equality) {
    switch (equality) {
      case "reference":
        return (val) => val;
      case "value":
        return (val) => Recoil_stableStringify(val);
    }
    throw Recoil_err(`Unrecognized equality policy ${equality}`);
  }
  function getTreeCache(eviction, maxSize, mapNodeValue, name) {
    switch (eviction) {
      case "keep-all":
        return new TreeCache$2({
          name,
          mapNodeValue
        });
      case "lru":
        return Recoil_treeCacheLRU({
          name,
          maxSize: Recoil_nullthrows(maxSize),
          mapNodeValue
        });
      case "most-recent":
        return Recoil_treeCacheLRU({
          name,
          maxSize: 1,
          mapNodeValue
        });
    }
    throw Recoil_err(`Unrecognized eviction policy ${eviction}`);
  }
  var Recoil_treeCacheFromPolicy = treeCacheFromPolicy;
  const {
    isLoadable: isLoadable$1,
    loadableWithError: loadableWithError$1,
    loadableWithPromise: loadableWithPromise$1,
    loadableWithValue: loadableWithValue$2
  } = Recoil_Loadable$1;
  const {
    WrappedValue: WrappedValue$1
  } = Recoil_Wrapper$1;
  const {
    getNodeLoadable: getNodeLoadable$2,
    peekNodeLoadable: peekNodeLoadable$1,
    setNodeValue: setNodeValue$3
  } = Recoil_FunctionalCore;
  const {
    saveDepsToStore: saveDepsToStore$1
  } = Recoil_Graph;
  const {
    DEFAULT_VALUE: DEFAULT_VALUE$6,
    getConfigDeletionHandler: getConfigDeletionHandler$1,
    getNode: getNode$6,
    registerNode: registerNode$1
  } = Recoil_Node;
  const {
    isRecoilValue: isRecoilValue$3
  } = Recoil_RecoilValue$1;
  const {
    markRecoilValueModified: markRecoilValueModified$1
  } = Recoil_RecoilValueInterface;
  const {
    retainedByOptionWithDefault: retainedByOptionWithDefault$1
  } = Recoil_Retention;
  const {
    recoilCallback: recoilCallback$1
  } = Recoil_useRecoilCallback;
  class Canceled {
  }
  const CANCELED = new Canceled();
  const dependencyStack = [];
  const waitingStores = /* @__PURE__ */ new Map();
  const getNewExecutionID = /* @__PURE__ */ (() => {
    let executionID = 0;
    return () => executionID++;
  })();
  function selector(options) {
    let recoilValue = null;
    const {
      key: key2,
      get: get2,
      cachePolicy_UNSTABLE: cachePolicy
    } = options;
    const set2 = options.set != null ? options.set : void 0;
    const discoveredDependencyNodeKeys = /* @__PURE__ */ new Set();
    const cache = Recoil_treeCacheFromPolicy(cachePolicy !== null && cachePolicy !== void 0 ? cachePolicy : {
      equality: "reference",
      eviction: "keep-all"
    }, key2);
    const retainedBy = retainedByOptionWithDefault$1(options.retainedBy_UNSTABLE);
    const executionInfoMap = /* @__PURE__ */ new Map();
    let liveStoresCount = 0;
    function selectorIsLive() {
      return !Recoil_gkx("recoil_memory_managament_2020") || liveStoresCount > 0;
    }
    function selectorInit(store) {
      store.getState().knownSelectors.add(key2);
      liveStoresCount++;
      return () => {
        liveStoresCount--;
      };
    }
    function selectorShouldDeleteConfigOnRelease() {
      return getConfigDeletionHandler$1(key2) !== void 0 && !selectorIsLive();
    }
    function resolveAsync(store, state, executionID, loadable, depValues) {
      setCache(state, loadable, depValues);
      notifyStoresOfResolvedAsync(store, executionID);
    }
    function notifyStoresOfResolvedAsync(store, executionID) {
      if (isLatestExecution(store, executionID)) {
        clearExecutionInfo(store);
      }
      notifyWaitingStores(executionID, true);
    }
    function notifyStoresOfNewAsyncDep(store, executionID) {
      if (isLatestExecution(store, executionID)) {
        const executionInfo = Recoil_nullthrows(getExecutionInfo(store));
        executionInfo.stateVersions.clear();
        notifyWaitingStores(executionID, false);
      }
    }
    function notifyWaitingStores(executionID, clearWaitlist) {
      const stores = waitingStores.get(executionID);
      if (stores != null) {
        for (const waitingStore of stores) {
          markRecoilValueModified$1(waitingStore, Recoil_nullthrows(recoilValue));
        }
        if (clearWaitlist) {
          waitingStores.delete(executionID);
        }
      }
    }
    function markStoreWaitingForResolvedAsync(store, executionID) {
      let stores = waitingStores.get(executionID);
      if (stores == null) {
        waitingStores.set(executionID, stores = /* @__PURE__ */ new Set());
      }
      stores.add(store);
    }
    function wrapResultPromise(store, promise, state, depValues, executionID, loadingDepsState) {
      return promise.then((value) => {
        if (!selectorIsLive()) {
          clearExecutionInfo(store);
          throw CANCELED;
        }
        const loadable = loadableWithValue$2(value);
        resolveAsync(store, state, executionID, loadable, depValues);
        return value;
      }).catch((errorOrPromise) => {
        if (!selectorIsLive()) {
          clearExecutionInfo(store);
          throw CANCELED;
        }
        if (Recoil_isPromise(errorOrPromise)) {
          return wrapPendingDependencyPromise(store, errorOrPromise, state, depValues, executionID, loadingDepsState);
        }
        const loadable = loadableWithError$1(errorOrPromise);
        resolveAsync(store, state, executionID, loadable, depValues);
        throw errorOrPromise;
      });
    }
    function wrapPendingDependencyPromise(store, promise, state, existingDeps, executionID, loadingDepsState) {
      return promise.then((resolvedDep) => {
        if (!selectorIsLive()) {
          clearExecutionInfo(store);
          throw CANCELED;
        }
        if (loadingDepsState.loadingDepKey != null && loadingDepsState.loadingDepPromise === promise) {
          state.atomValues.set(loadingDepsState.loadingDepKey, loadableWithValue$2(resolvedDep));
        } else {
          store.getState().knownSelectors.forEach((nodeKey) => {
            state.atomValues.delete(nodeKey);
          });
        }
        const cachedLoadable = getLoadableFromCacheAndUpdateDeps(store, state);
        if (cachedLoadable && cachedLoadable.state !== "loading") {
          if (isLatestExecution(store, executionID) || getExecutionInfo(store) == null) {
            notifyStoresOfResolvedAsync(store, executionID);
          }
          if (cachedLoadable.state === "hasValue") {
            return cachedLoadable.contents;
          } else {
            throw cachedLoadable.contents;
          }
        }
        if (!isLatestExecution(store, executionID)) {
          const executionInfo = getInProgressExecutionInfo(store, state);
          if (executionInfo != null) {
            return executionInfo.loadingLoadable.contents;
          }
        }
        const [loadable, depValues] = evaluateSelectorGetter(store, state, executionID);
        if (loadable.state !== "loading") {
          resolveAsync(store, state, executionID, loadable, depValues);
        }
        if (loadable.state === "hasError") {
          throw loadable.contents;
        }
        return loadable.contents;
      }).catch((error) => {
        if (error instanceof Canceled) {
          throw CANCELED;
        }
        if (!selectorIsLive()) {
          clearExecutionInfo(store);
          throw CANCELED;
        }
        const loadable = loadableWithError$1(error);
        resolveAsync(store, state, executionID, loadable, existingDeps);
        throw error;
      });
    }
    function updateDeps(store, state, deps, executionID) {
      var _store$getState, _store$getState$curre, _store$getState2, _store$getState2$next;
      if (isLatestExecution(store, executionID) || state.version === ((_store$getState = store.getState()) === null || _store$getState === void 0 ? void 0 : (_store$getState$curre = _store$getState.currentTree) === null || _store$getState$curre === void 0 ? void 0 : _store$getState$curre.version) || state.version === ((_store$getState2 = store.getState()) === null || _store$getState2 === void 0 ? void 0 : (_store$getState2$next = _store$getState2.nextTree) === null || _store$getState2$next === void 0 ? void 0 : _store$getState2$next.version)) {
        var _store$getState$nextT, _store$getState3, _store$getState3$next;
        saveDepsToStore$1(key2, deps, store, (_store$getState$nextT = (_store$getState3 = store.getState()) === null || _store$getState3 === void 0 ? void 0 : (_store$getState3$next = _store$getState3.nextTree) === null || _store$getState3$next === void 0 ? void 0 : _store$getState3$next.version) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree.version);
      }
      for (const nodeKey of deps) {
        discoveredDependencyNodeKeys.add(nodeKey);
      }
    }
    function evaluateSelectorGetter(store, state, executionID) {
      let duringSynchronousExecution = true;
      let duringAsynchronousExecution = true;
      const finishEvaluation = () => {
        duringAsynchronousExecution = false;
      };
      let result;
      let resultIsError = false;
      let loadable;
      const loadingDepsState = {
        loadingDepKey: null,
        loadingDepPromise: null
      };
      const depValues = /* @__PURE__ */ new Map();
      function getRecoilValue({
        key: depKey
      }) {
        const depLoadable = getNodeLoadable$2(store, state, depKey);
        depValues.set(depKey, depLoadable);
        if (!duringSynchronousExecution) {
          updateDeps(store, state, new Set(depValues.keys()), executionID);
          notifyStoresOfNewAsyncDep(store, executionID);
        }
        switch (depLoadable.state) {
          case "hasValue":
            return depLoadable.contents;
          case "hasError":
            throw depLoadable.contents;
          case "loading":
            loadingDepsState.loadingDepKey = depKey;
            loadingDepsState.loadingDepPromise = depLoadable.contents;
            throw depLoadable.contents;
        }
        throw Recoil_err("Invalid Loadable state");
      }
      const getCallback = (fn) => {
        return (...args) => {
          if (duringAsynchronousExecution) {
            throw Recoil_err("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");
          }
          !(recoilValue != null) ? Recoil_invariant(false) : void 0;
          return recoilCallback$1(
            store,
            fn,
            args,
            {
              node: recoilValue
            }
            // flowlint-line unclear-type:off
          );
        };
      };
      try {
        result = get2({
          get: getRecoilValue,
          getCallback
        });
        result = isRecoilValue$3(result) ? getRecoilValue(result) : result;
        if (isLoadable$1(result)) {
          if (result.state === "hasError") {
            resultIsError = true;
          }
          result = result.contents;
        }
        if (Recoil_isPromise(result)) {
          result = wrapResultPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);
        } else {
          finishEvaluation();
        }
        result = result instanceof WrappedValue$1 ? result.value : result;
      } catch (errorOrDepPromise) {
        result = errorOrDepPromise;
        if (Recoil_isPromise(result)) {
          result = wrapPendingDependencyPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);
        } else {
          resultIsError = true;
          finishEvaluation();
        }
      }
      if (resultIsError) {
        loadable = loadableWithError$1(result);
      } else if (Recoil_isPromise(result)) {
        loadable = loadableWithPromise$1(result);
      } else {
        loadable = loadableWithValue$2(result);
      }
      duringSynchronousExecution = false;
      updateExecutionInfoDepValues(store, executionID, depValues);
      updateDeps(store, state, new Set(depValues.keys()), executionID);
      return [loadable, depValues];
    }
    function getLoadableFromCacheAndUpdateDeps(store, state) {
      let cachedLoadable = state.atomValues.get(key2);
      if (cachedLoadable != null) {
        return cachedLoadable;
      }
      const depsAfterCacheLookup = /* @__PURE__ */ new Set();
      try {
        cachedLoadable = cache.get((nodeKey) => {
          !(typeof nodeKey === "string") ? false ? Recoil_invariant(false, "Cache nodeKey is type string") : Recoil_invariant(false) : void 0;
          return getNodeLoadable$2(store, state, nodeKey).contents;
        }, {
          onNodeVisit: (node) => {
            if (node.type === "branch" && node.nodeKey !== key2) {
              depsAfterCacheLookup.add(node.nodeKey);
            }
          }
        });
      } catch (error) {
        throw Recoil_err(`Problem with cache lookup for selector "${key2}": ${error.message}`);
      }
      if (cachedLoadable) {
        var _getExecutionInfo;
        state.atomValues.set(key2, cachedLoadable);
        updateDeps(store, state, depsAfterCacheLookup, (_getExecutionInfo = getExecutionInfo(store)) === null || _getExecutionInfo === void 0 ? void 0 : _getExecutionInfo.executionID);
      }
      return cachedLoadable;
    }
    function getSelectorLoadableAndUpdateDeps(store, state) {
      const cachedVal = getLoadableFromCacheAndUpdateDeps(store, state);
      if (cachedVal != null) {
        clearExecutionInfo(store);
        return cachedVal;
      }
      const inProgressExecutionInfo = getInProgressExecutionInfo(store, state);
      if (inProgressExecutionInfo != null) {
        var _inProgressExecutionI;
        if (((_inProgressExecutionI = inProgressExecutionInfo.loadingLoadable) === null || _inProgressExecutionI === void 0 ? void 0 : _inProgressExecutionI.state) === "loading") {
          markStoreWaitingForResolvedAsync(store, inProgressExecutionInfo.executionID);
        }
        return inProgressExecutionInfo.loadingLoadable;
      }
      const newExecutionID = getNewExecutionID();
      const [loadable, newDepValues] = evaluateSelectorGetter(store, state, newExecutionID);
      if (loadable.state === "loading") {
        setExecutionInfo(store, newExecutionID, loadable, newDepValues, state);
        markStoreWaitingForResolvedAsync(store, newExecutionID);
      } else {
        clearExecutionInfo(store);
        setCache(state, loadable, newDepValues);
      }
      return loadable;
    }
    function getInProgressExecutionInfo(store, state) {
      const pendingExecutions = Recoil_concatIterables([executionInfoMap.has(store) ? [Recoil_nullthrows(executionInfoMap.get(store))] : [], Recoil_mapIterable(Recoil_filterIterable(executionInfoMap, ([s]) => s !== store), ([, execInfo]) => execInfo)]);
      function anyDepChanged(execDepValues) {
        for (const [depKey, execLoadable] of execDepValues) {
          if (!getNodeLoadable$2(store, state, depKey).is(execLoadable)) {
            return true;
          }
        }
        return false;
      }
      for (const execInfo of pendingExecutions) {
        if (
          // If this execution was already checked to be valid with this version
          // of state, then let's use it!
          execInfo.stateVersions.get(state.version) || // If the deps for the execution match our current state, then it's valid
          !anyDepChanged(execInfo.depValuesDiscoveredSoFarDuringAsyncWork)
        ) {
          execInfo.stateVersions.set(state.version, true);
          return execInfo;
        } else {
          execInfo.stateVersions.set(state.version, false);
        }
      }
      return void 0;
    }
    function getExecutionInfo(store) {
      return executionInfoMap.get(store);
    }
    function setExecutionInfo(store, newExecutionID, loadable, depValues, state) {
      executionInfoMap.set(store, {
        depValuesDiscoveredSoFarDuringAsyncWork: depValues,
        executionID: newExecutionID,
        loadingLoadable: loadable,
        stateVersions: /* @__PURE__ */ new Map([[state.version, true]])
      });
    }
    function updateExecutionInfoDepValues(store, executionID, depValues) {
      if (isLatestExecution(store, executionID)) {
        const executionInfo = getExecutionInfo(store);
        if (executionInfo != null) {
          executionInfo.depValuesDiscoveredSoFarDuringAsyncWork = depValues;
        }
      }
    }
    function clearExecutionInfo(store) {
      executionInfoMap.delete(store);
    }
    function isLatestExecution(store, executionID) {
      var _getExecutionInfo2;
      return executionID === ((_getExecutionInfo2 = getExecutionInfo(store)) === null || _getExecutionInfo2 === void 0 ? void 0 : _getExecutionInfo2.executionID);
    }
    function depValuesToDepRoute(depValues) {
      return Array.from(depValues.entries()).map(([depKey, valLoadable]) => [depKey, valLoadable.contents]);
    }
    function setCache(state, loadable, depValues) {
      state.atomValues.set(key2, loadable);
      try {
        cache.set(depValuesToDepRoute(depValues), loadable);
      } catch (error) {
        throw Recoil_err(`Problem with setting cache for selector "${key2}": ${error.message}`);
      }
    }
    function detectCircularDependencies(fn) {
      if (dependencyStack.includes(key2)) {
        const message = `Recoil selector has circular dependencies: ${dependencyStack.slice(dependencyStack.indexOf(key2)).join("  ")}`;
        return loadableWithError$1(Recoil_err(message));
      }
      dependencyStack.push(key2);
      try {
        return fn();
      } finally {
        dependencyStack.pop();
      }
    }
    function selectorPeek(store, state) {
      const cachedLoadable = state.atomValues.get(key2);
      if (cachedLoadable != null) {
        return cachedLoadable;
      }
      return cache.get((nodeKey) => {
        var _peekNodeLoadable;
        !(typeof nodeKey === "string") ? Recoil_invariant(false) : void 0;
        return (_peekNodeLoadable = peekNodeLoadable$1(store, state, nodeKey)) === null || _peekNodeLoadable === void 0 ? void 0 : _peekNodeLoadable.contents;
      });
    }
    function selectorGet(store, state) {
      return detectCircularDependencies(() => getSelectorLoadableAndUpdateDeps(store, state));
    }
    function invalidateSelector(state) {
      state.atomValues.delete(key2);
    }
    function clearSelectorCache(store, treeState) {
      !(recoilValue != null) ? Recoil_invariant(false) : void 0;
      for (const nodeKey of discoveredDependencyNodeKeys) {
        var _node$clearCache;
        const node = getNode$6(nodeKey);
        (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, treeState);
      }
      discoveredDependencyNodeKeys.clear();
      invalidateSelector(treeState);
      cache.clear();
      markRecoilValueModified$1(store, recoilValue);
    }
    if (set2 != null) {
      const selectorSet = (store, state, newValue) => {
        let syncSelectorSetFinished = false;
        const writes = /* @__PURE__ */ new Map();
        function getRecoilValue({
          key: depKey
        }) {
          if (syncSelectorSetFinished) {
            throw Recoil_err("Recoil: Async selector sets are not currently supported.");
          }
          const loadable = getNodeLoadable$2(store, state, depKey);
          if (loadable.state === "hasValue") {
            return loadable.contents;
          } else if (loadable.state === "loading") {
            const msg = `Getting value of asynchronous atom or selector "${depKey}" in a pending state while setting selector "${key2}" is not yet supported.`;
            Recoil_recoverableViolation();
            throw Recoil_err(msg);
          } else {
            throw loadable.contents;
          }
        }
        function setRecoilState(recoilState, valueOrUpdater) {
          if (syncSelectorSetFinished) {
            const msg = "Recoil: Async selector sets are not currently supported.";
            Recoil_recoverableViolation();
            throw Recoil_err(msg);
          }
          const setValue = typeof valueOrUpdater === "function" ? (
            // cast to any because we can't restrict type S from being a function itself without losing support for opaque types
            // flowlint-next-line unclear-type:off
            valueOrUpdater(getRecoilValue(recoilState))
          ) : valueOrUpdater;
          const upstreamWrites = setNodeValue$3(store, state, recoilState.key, setValue);
          upstreamWrites.forEach((v, k2) => writes.set(k2, v));
        }
        function resetRecoilState(recoilState) {
          setRecoilState(recoilState, DEFAULT_VALUE$6);
        }
        const ret = set2({
          set: setRecoilState,
          get: getRecoilValue,
          reset: resetRecoilState
        }, newValue);
        if (ret !== void 0) {
          throw Recoil_isPromise(ret) ? Recoil_err("Recoil: Async selector sets are not currently supported.") : Recoil_err("Recoil: selector set should be a void function.");
        }
        syncSelectorSetFinished = true;
        return writes;
      };
      return recoilValue = registerNode$1({
        key: key2,
        nodeType: "selector",
        peek: selectorPeek,
        get: selectorGet,
        set: selectorSet,
        init: selectorInit,
        invalidate: invalidateSelector,
        clearCache: clearSelectorCache,
        shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,
        dangerouslyAllowMutability: options.dangerouslyAllowMutability,
        shouldRestoreFromSnapshots: false,
        retainedBy
      });
    } else {
      return recoilValue = registerNode$1({
        key: key2,
        nodeType: "selector",
        peek: selectorPeek,
        get: selectorGet,
        init: selectorInit,
        invalidate: invalidateSelector,
        clearCache: clearSelectorCache,
        shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,
        dangerouslyAllowMutability: options.dangerouslyAllowMutability,
        shouldRestoreFromSnapshots: false,
        retainedBy
      });
    }
  }
  selector.value = (value) => new WrappedValue$1(value);
  var Recoil_selector = selector;
  const {
    isLoadable: isLoadable$2,
    loadableWithError: loadableWithError$2,
    loadableWithPromise: loadableWithPromise$2,
    loadableWithValue: loadableWithValue$3
  } = Recoil_Loadable$1;
  const {
    WrappedValue: WrappedValue$2
  } = Recoil_Wrapper$1;
  const {
    isRecoilValue: isRecoilValue$4
  } = Recoil_RecoilValue$1;
  class MapCache {
    constructor(options) {
      var _options$mapKey;
      _defineProperty(this, "_map", void 0);
      _defineProperty(this, "_keyMapper", void 0);
      this._map = /* @__PURE__ */ new Map();
      this._keyMapper = (_options$mapKey = options === null || options === void 0 ? void 0 : options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : (v) => v;
    }
    size() {
      return this._map.size;
    }
    has(key2) {
      return this._map.has(this._keyMapper(key2));
    }
    get(key2) {
      return this._map.get(this._keyMapper(key2));
    }
    set(key2, val) {
      this._map.set(this._keyMapper(key2), val);
    }
    delete(key2) {
      this._map.delete(this._keyMapper(key2));
    }
    clear() {
      this._map.clear();
    }
  }
  var Recoil_MapCache = {
    MapCache
  };
  var Recoil_MapCache_1 = Recoil_MapCache.MapCache;
  var Recoil_MapCache$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    MapCache: Recoil_MapCache_1
  });
  const {
    LRUCache: LRUCache$2
  } = Recoil_LRUCache$1;
  const {
    MapCache: MapCache$1
  } = Recoil_MapCache$1;
  const defaultPolicy$1 = {
    equality: "reference",
    eviction: "none",
    maxSize: Infinity
  };
  function cacheFromPolicy({
    equality = defaultPolicy$1.equality,
    eviction = defaultPolicy$1.eviction,
    maxSize = defaultPolicy$1.maxSize
  } = defaultPolicy$1) {
    const valueMapper = getValueMapper$1(equality);
    const cache = getCache(eviction, maxSize, valueMapper);
    return cache;
  }
  function getValueMapper$1(equality) {
    switch (equality) {
      case "reference":
        return (val) => val;
      case "value":
        return (val) => Recoil_stableStringify(val);
    }
    throw Recoil_err(`Unrecognized equality policy ${equality}`);
  }
  function getCache(eviction, maxSize, mapKey) {
    switch (eviction) {
      case "keep-all":
        return new MapCache$1({
          mapKey
        });
      case "lru":
        return new LRUCache$2({
          mapKey,
          maxSize: Recoil_nullthrows(maxSize)
        });
      case "most-recent":
        return new LRUCache$2({
          mapKey,
          maxSize: 1
        });
    }
    throw Recoil_err(`Unrecognized eviction policy ${eviction}`);
  }
  var Recoil_cacheFromPolicy = cacheFromPolicy;
  const {
    setConfigDeletionHandler: setConfigDeletionHandler$3
  } = Recoil_Node;
  let nextIndex = 0;
  function selectorFamily(options) {
    var _options$cachePolicyF, _options$cachePolicyF2;
    const selectorCache = Recoil_cacheFromPolicy({
      equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : "value",
      eviction: "keep-all"
    });
    return (params) => {
      var _stableStringify;
      let cachedSelector;
      try {
        cachedSelector = selectorCache.get(params);
      } catch (error) {
        throw Recoil_err(`Problem with cache lookup for selector ${options.key}: ${error.message}`);
      }
      if (cachedSelector != null) {
        return cachedSelector;
      }
      const myKey = `${options.key}__selectorFamily/${(_stableStringify = Recoil_stableStringify(params, {
        // It is possible to use functions in parameters if the user uses
        // a cache with reference equality thanks to the incrementing index.
        allowFunctions: true
      })) !== null && _stableStringify !== void 0 ? _stableStringify : "void"}/${nextIndex++}`;
      const myGet = (callbacks) => options.get(params)(callbacks);
      const myCachePolicy = options.cachePolicy_UNSTABLE;
      const retainedBy = typeof options.retainedBy_UNSTABLE === "function" ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE;
      let newSelector;
      if (options.set != null) {
        const set2 = options.set;
        const mySet = (callbacks, newValue) => set2(params)(callbacks, newValue);
        newSelector = Recoil_selector({
          key: myKey,
          get: myGet,
          set: mySet,
          cachePolicy_UNSTABLE: myCachePolicy,
          dangerouslyAllowMutability: options.dangerouslyAllowMutability,
          retainedBy_UNSTABLE: retainedBy
        });
      } else {
        newSelector = Recoil_selector({
          key: myKey,
          get: myGet,
          cachePolicy_UNSTABLE: myCachePolicy,
          dangerouslyAllowMutability: options.dangerouslyAllowMutability,
          retainedBy_UNSTABLE: retainedBy
        });
      }
      selectorCache.set(params, newSelector);
      setConfigDeletionHandler$3(newSelector.key, () => {
        selectorCache.delete(params);
      });
      return newSelector;
    };
  }
  var Recoil_selectorFamily = selectorFamily;
  Recoil_selectorFamily({
    key: "__constant",
    get: (constant) => () => constant,
    cachePolicyForParams_UNSTABLE: {
      equality: "reference"
    }
  });
  Recoil_selectorFamily({
    key: "__error",
    get: (message) => () => {
      throw Recoil_err(message);
    },
    // TODO Why?
    cachePolicyForParams_UNSTABLE: {
      equality: "reference"
    }
  });
  const {
    loadableWithError: loadableWithError$3,
    loadableWithPromise: loadableWithPromise$3,
    loadableWithValue: loadableWithValue$4
  } = Recoil_Loadable$1;
  function concurrentRequests(getRecoilValue, deps) {
    const results = Array(deps.length).fill(void 0);
    const exceptions = Array(deps.length).fill(void 0);
    for (const [i2, dep] of deps.entries()) {
      try {
        results[i2] = getRecoilValue(dep);
      } catch (e) {
        exceptions[i2] = e;
      }
    }
    return [results, exceptions];
  }
  function isError(exp) {
    return exp != null && !Recoil_isPromise(exp);
  }
  function unwrapDependencies(dependencies) {
    return Array.isArray(dependencies) ? dependencies : Object.getOwnPropertyNames(dependencies).map((key2) => dependencies[key2]);
  }
  function wrapResults(dependencies, results) {
    return Array.isArray(dependencies) ? results : (
      // Object.getOwnPropertyNames() has consistent key ordering with ES6
      Object.getOwnPropertyNames(dependencies).reduce((out, key2, idx) => ({
        ...out,
        [key2]: results[idx]
      }), {})
    );
  }
  function wrapLoadables(dependencies, results, exceptions) {
    const output = exceptions.map((exception, idx) => exception == null ? loadableWithValue$4(results[idx]) : Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));
    return wrapResults(dependencies, output);
  }
  function combineAsyncResultsWithSyncResults(syncResults, asyncResults) {
    return asyncResults.map((result, idx) => (
      /**
       * it's important we use === undefined as opposed to == null, because the
       * resolved value of the async promise could be `null`, in which case we
       * don't want to use syncResults[idx], which would be undefined. If async
       * promise resolves to `undefined`, that's ok because `syncResults[idx]`
       * will also be `undefined`. That's a little hacky, but it works.
       */
      result === void 0 ? syncResults[idx] : result
    ));
  }
  Recoil_selectorFamily({
    key: "__waitForNone",
    get: (dependencies) => ({
      get: get2
    }) => {
      const deps = unwrapDependencies(dependencies);
      const [results, exceptions] = concurrentRequests(get2, deps);
      return wrapLoadables(dependencies, results, exceptions);
    },
    dangerouslyAllowMutability: true
  });
  Recoil_selectorFamily({
    key: "__waitForAny",
    get: (dependencies) => ({
      get: get2
    }) => {
      const deps = unwrapDependencies(dependencies);
      const [results, exceptions] = concurrentRequests(get2, deps);
      if (exceptions.some((exp) => !Recoil_isPromise(exp))) {
        return wrapLoadables(dependencies, results, exceptions);
      }
      return new Promise((resolve) => {
        for (const [i2, exp] of exceptions.entries()) {
          if (Recoil_isPromise(exp)) {
            exp.then((result) => {
              results[i2] = result;
              exceptions[i2] = void 0;
              resolve(wrapLoadables(dependencies, results, exceptions));
            }).catch((error) => {
              exceptions[i2] = error;
              resolve(wrapLoadables(dependencies, results, exceptions));
            });
          }
        }
      });
    },
    dangerouslyAllowMutability: true
  });
  Recoil_selectorFamily({
    key: "__waitForAll",
    get: (dependencies) => ({
      get: get2
    }) => {
      const deps = unwrapDependencies(dependencies);
      const [results, exceptions] = concurrentRequests(get2, deps);
      if (exceptions.every((exp) => exp == null)) {
        return wrapResults(dependencies, results);
      }
      const error = exceptions.find(isError);
      if (error != null) {
        throw error;
      }
      return Promise.all(exceptions).then((exceptionResults) => wrapResults(dependencies, combineAsyncResultsWithSyncResults(results, exceptionResults)));
    },
    dangerouslyAllowMutability: true
  });
  Recoil_selectorFamily({
    key: "__waitForAllSettled",
    get: (dependencies) => ({
      get: get2
    }) => {
      const deps = unwrapDependencies(dependencies);
      const [results, exceptions] = concurrentRequests(get2, deps);
      if (exceptions.every((exp) => !Recoil_isPromise(exp))) {
        return wrapLoadables(dependencies, results, exceptions);
      }
      return Promise.all(exceptions.map((exp, i2) => Recoil_isPromise(exp) ? exp.then((result) => {
        results[i2] = result;
        exceptions[i2] = void 0;
      }).catch((error) => {
        results[i2] = void 0;
        exceptions[i2] = error;
      }) : null)).then(() => wrapLoadables(dependencies, results, exceptions));
    },
    dangerouslyAllowMutability: true
  });
  Recoil_selectorFamily({
    key: "__noWait",
    get: (dependency) => ({
      get: get2
    }) => {
      try {
        return Recoil_selector.value(loadableWithValue$4(get2(dependency)));
      } catch (exception) {
        return Recoil_selector.value(Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));
      }
    },
    dangerouslyAllowMutability: true
  });
  const {
    RecoilLoadable
  } = Recoil_Loadable$1;
  const {
    isRecoilValue: isRecoilValue$5
  } = Recoil_RecoilValue$1;
  const {
    freshSnapshot: freshSnapshot$2
  } = Recoil_Snapshot$1;
  const {
    useRecoilValue: useRecoilValue$1,
    useSetRecoilState: useSetRecoilState$1
  } = Recoil_Hooks;
  var Recoil_index = {
    // Hooks for Atoms/Selectors
    useRecoilValue: useRecoilValue$1,
    useSetRecoilState: useSetRecoilState$1
  };
  var Recoil_index_20 = Recoil_index.useRecoilValue;
  var Recoil_index_24 = Recoil_index.useSetRecoilState;
  const PasswordIcon = ({
    width = "20px",
    height = "20px",
    color = "#e8eaed",
    ...props
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width,
        height,
        fill: color,
        ...props,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        className: "dark:fill-white",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M288.33-136q-23.56 0-39.95-16.53Q232-169.07 232-192.62v-334.76q0-23.55 16.53-40.09Q265.07-584 288.62-584H328v-96q0-63.53 44.3-107.76Q416.61-832 480.23-832q63.62 0 107.69 44.24Q632-743.53 632-680v96h39.38q23.55 0 40.09 16.53Q728-550.93 728-527.38v334.76q0 23.55-16.55 40.09Q694.91-136 671.34-136H288.33Zm.29-32h382.76q10.77 0 17.7-6.92 6.92-6.93 6.92-17.7v-334.76q0-10.77-6.92-17.7-6.93-6.92-17.7-6.92H288.62q-10.77 0-17.7 6.92-6.92 6.93-6.92 17.7v334.76q0 10.77 6.92 17.7 6.93 6.92 17.7 6.92Zm191.59-140q22.1 0 36.94-15.06Q532-338.12 532-360.21q0-22.1-15.06-36.94Q501.88-412 479.79-412q-22.1 0-36.94 15.06Q428-381.88 428-359.79q0 22.1 15.06 36.94Q458.12-308 480.21-308ZM360-584h240v-96q0-50-35-85t-85-35q-50 0-85 35t-35 85v96Zm-96 416v-384 384Z" })
      }
    );
  };
  const TwoFa = () => {
    const [serverError, setServerError] = reactExports.useState(null);
    const {
      setToaster
    } = useToaster();
    const {
      routes
    } = useRoute();
    const loginUserValidationSchema = z.object({
      otp: z.string().nonempty({
        message: "OTP is required."
      })
    });
    const {
      tokenData
    } = getLoggedInDetails();
    const setUserDetails = Recoil_index_24(userDetailsAtom);
    const setItemAsync = async (key2, value) => {
      return new Promise((resolve) => {
        setCookie(key2, value);
        resolve();
      });
    };
    const {
      mutate: login,
      isLoading
    } = useMutation({
      mutationKey: ["loginUser"],
      mutationFn: async (input) => {
        try {
          const response = await Client.authentication.verifyOtp({
            otp: input.otp,
            token: tokenData.token
          });
          return response;
        } catch (error) {
          throw error;
        }
      },
      onSuccess: async (data) => {
        if (!data.data.tokenData.token) {
          setToaster({
            message: "Wrong email or password",
            type: "error"
          });
          return;
        }
        await setItemAsync(env$1.VITE_AUTH_TOKEN_KEY, data.data.tokenData.token);
        setUserDetails(data.data.loggedInDetails);
        setToaster({
          message: "Login successful",
          type: "success"
        });
        if (routes && routes.length > 0) {
          const firstRoute = routes[0].path;
          window.location.hash = firstRoute;
        } else {
          window.location.hash = "/no-routes";
        }
      },
      onError: (error) => {
        let errorMessage = "An unexpected error occurred.";
        if (error.response && error.response.data) {
          const errorData = error.response.data.detailedMessage;
          setServerError(errorData);
          errorMessage = typeof errorData === "object" ? JSON.stringify(errorData) : errorData;
        }
        setToaster({
          message: errorMessage,
          type: "error"
        });
      }
    });
    const onSubmit = (data) => {
      login(data);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center bg-flatGray dark:bg-gray-800 justify-center h-screen", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dark:bg-dark-200 bg-cleanWhite py-8 gap-4 px-4 flex flex-col items-center justify-center rounded-lg w-[30%]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-[200px]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: hubSpotUserDetails.hubspotPortals.portalSettings.authPopupFormLogo, alt: "Light Mode Logo", className: "h-auto dark:hidden" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: hubSpotUserDetails.hubspotPortals.portalSettings.logo, alt: "Dark Mode Logo", className: "h-auto hidden dark:block" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { onSubmit, validationSchema: loginUserValidationSchema, serverError, className: "dark:bg-dark-200", children: ({
        register,
        formState: {
          errors
        }
      }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-gray-800 dark:text-gray-200", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { className: "text-xs font-semibold text-gray-800 dark:text-gray-300 focus:text-blue-600", children: "OTP" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { height: "medium", icon: PasswordIcon, placeholder: "OTP", className: "", ...register("otp") }) }) }),
          errors.otp && /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, { className: "text-red-600 dark:text-red-400", children: errors.otp.message })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-end items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/login", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-black text-xs dark:text-gray-300", children: "Back to Login" }) }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4 flex flex-col justify-center items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: "w-full  ", isLoading, children: "Login" }) })
      ] }) }) })
    ] }) });
  };
  const Route$8 = createFileRoute("/_auth/two-fa")({
    component: TwoFa,
    beforeLoad: () => {
      return {
        layout: "AuthLayout",
        requiresAuth: false
      };
    }
  });
  const EyeIcon = ({
    width = "15px",
    height = "15px",
    color = "#e8eaed",
    ...props
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width,
        height,
        fill: color,
        ...props,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        className: "fill-black dark:fill-white",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M480.18-353.85q60.97 0 103.47-42.68t42.5-103.65q0-60.97-42.68-103.47t-103.65-42.5q-60.97 0-103.47 42.68t-42.5 103.65q0 60.97 42.68 103.47t103.65 42.5ZM480-392q-45 0-76.5-31.5T372-500q0-45 31.5-76.5T480-608q45 0 76.5 31.5T588-500q0 45-31.5 76.5T480-392Zm.11 152q-129.96 0-236.88-70.73Q136.31-381.46 83.08-500q53.23-118.54 160.04-189.27T479.89-760q129.96 0 236.88 70.73Q823.69-618.54 876.92-500q-53.23 118.54-160.04 189.27T480.11-240ZM480-500Zm0 220q113 0 207.5-59.5T832-500q-50-101-144.5-160.5T480-720q-113 0-207.5 59.5T128-500q50 101 144.5 160.5T480-280Z" })
      }
    );
  };
  const EyeOffIcon = ({
    width = "15px",
    height = "15px",
    color = "#e8eaed",
    ...props
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width,
        height,
        fill: color,
        ...props,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        className: "fill-black dark:fill-white",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M617.85-454.15 586-486q9-52.38-29.69-90.69Q517.62-615 466-606l-31.85-31.85q10.08-4.15 21.04-6.23 10.96-2.07 24.81-2.07 61.15 0 103.65 42.5 42.5 42.5 42.5 103.65 0 13.85-2.07 25.58-2.08 11.73-6.23 20.27Zm126.46 122.92L714-358q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-31.23-31.23q34.85-13.15 70.92-18.96Q443.77-760 480-760q130.23 0 238.23 71.58 108 71.57 158.69 188.42-21.46 48.23-54.34 90.65-32.89 42.43-78.27 78.12Zm44.61 216.77L633.23-269.69q-26.54 11.77-65.88 20.73Q528-240 480-240q-131 0-238.23-71.58Q134.54-383.15 83.08-500q23.3-53 61.46-99.27 38.15-46.27 81.46-77.65l-111.54-112 28.31-28.31 674.46 674.46-28.31 28.31ZM254.31-648.62q-34.39 24.47-70.31 64.31-35.92 39.85-56 84.31 50 101 143.5 160.5T480-280q34.62 0 69.77-6.73t52.85-13.58L537.38-366q-9.46 5.31-26.38 8.73-16.92 3.42-31 3.42-61.15 0-103.65-42.5-42.5-42.5-42.5-103.65 0-13.31 3.42-29.85 3.42-16.53 8.73-27.53l-91.69-91.24ZM541-531Zm-112.54 56.54Z" })
      }
    );
  };
  const ResetPassword = () => {
    const [serverError, setServerError] = reactExports.useState(null);
    const {
      setToaster
    } = useToaster();
    const [showPassword, setShowPassword] = reactExports.useState(false);
    const [showConfirmPassword, setShowConfirmPassword] = reactExports.useState(false);
    const resetPasswordValidationSchema = objectType({
      newPassword: stringType().min(6, {
        message: "It should be 6 characters long"
      }).regex(/[A-Z]/, {
        message: "Must contain at least one uppercase letter"
      }).regex(/\d/, {
        message: "Must contain at least one number"
      }).regex(/[!@#$%^&*(),.?":{}|<>]/, {
        message: "Must contain at least one special character"
      }),
      confirmPassword: stringType().min(6, {
        message: "Please confirm your new password"
      })
    }).refine((data) => data.newPassword === data.confirmPassword, {
      message: "New passwords don't match",
      path: ["confirmPassword"]
    });
    const togglePasswordVisibility = () => {
      setShowPassword((prevState) => !prevState);
    };
    const toggleConfirmPasswordVisibility = () => {
      setShowConfirmPassword((prevState) => !prevState);
    };
    const getTokenFromParams = () => {
      const hash = window.location.hash;
      const params = new URLSearchParams(hash.split("?")[1]);
      let token = params.get("token");
      if (token) {
        token = token && typeof token === "string" ? token.replace(/ /g, "+") : "";
        return decodeURIComponent(token);
      }
      return null;
    };
    const {
      mutate: resetNewPassword,
      isLoading
    } = useMutation({
      mutationKey: ["resetNewPassword"],
      mutationFn: async (input) => {
        const token = getTokenFromParams();
        if (!token) {
          throw new Error("Token not found");
        }
        try {
          const response = await Client.authentication.resetPassword({
            newPassword: input.newPassword,
            confirmPassword: input.confirmPassword,
            token
          });
          return response;
        } catch (error) {
          throw error;
        }
      },
      onSuccess: (data) => {
        setToaster({
          message: "Password reset successful",
          type: "success"
        });
        window.location.hash = "/login";
      },
      onError: (error) => {
        console.error("Error:", error);
        setToaster({
          message: "Failed to reset password",
          type: "error"
        });
      }
    });
    reactExports.useEffect(() => {
      const token = getTokenFromParams();
      if (!token) {
        window.location.hash = "/login";
      }
    }, []);
    const onSubmit = (data) => {
      resetNewPassword(data);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center bg-flatGray dark:bg-gray-800 justify-center h-screen", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dark:bg-dark-200 bg-cleanWhite py-8 gap-4 px-4 flex flex-col items-center justify-center rounded-lg w-[30%]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-[200px]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: hubSpotUserDetails.hubspotPortals.portalSettings.authPopupFormLogo, alt: "Light Mode Logo", className: "h-auto dark:hidden" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: hubSpotUserDetails.hubspotPortals.portalSettings.logo, alt: "Dark Mode Logo", className: "h-auto hidden dark:block" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { onSubmit, validationSchema: resetPasswordValidationSchema, serverError, className: "dark:bg-dark-200", children: ({
        register,
        formState: {
          errors
        }
      }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-gray-800 dark:text-gray-200", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { className: "text-xs font-semibold text-gray-800 dark:text-gray-300 focus:text-blue-600", children: "New Password" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { placeholder: "New Password", icon: PasswordIcon, type: showPassword ? "text" : "password", className: " ", ...register("newPassword") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute right-2 top-2 cursor-pointer", onClick: togglePasswordVisibility, children: showPassword ? /* @__PURE__ */ jsxRuntimeExports.jsx(EyeIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOffIcon, {}) })
          ] }) }),
          errors.newPassword && /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, { className: "text-red-600 dark:text-red-400", children: errors.newPassword.message })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { className: "text-xs font-semibold text-gray-800 dark:text-gray-300 focus:text-blue-600", children: "Confirm Password" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { placeholder: "Confirm Password", icon: PasswordIcon, type: showConfirmPassword ? "text" : "password", className: " ", ...register("confirmPassword") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute right-2 top-2 cursor-pointer", onClick: toggleConfirmPasswordVisibility, children: showConfirmPassword ? /* @__PURE__ */ jsxRuntimeExports.jsx(EyeIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOffIcon, {}) })
          ] }) }),
          errors.confirmPassword && /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, { className: "text-red-600 dark:text-red-400", children: errors.confirmPassword.message })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4 flex flex-col justify-center items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: "w-full  ", isLoading, children: "Reset Password" }) })
      ] }) }) })
    ] }) });
  };
  const Route$7 = createFileRoute("/_auth/reset-password")({
    component: ResetPassword,
    beforeLoad: () => {
      return {
        layout: "AuthLayout",
        requiresAuth: false
      };
    }
  });
  const NotVerifiedEmail = () => {
    const {
      me
    } = useMe();
    const loggedInDetails = Recoil_index_20(userDetailsAtom);
    const {
      setToaster
    } = useToaster();
    const [serverError, setServerError] = reactExports.useState(null);
    let email = "no-email@example.com";
    if (loggedInDetails && loggedInDetails.email) {
      email = loggedInDetails.email;
    } else if (me && me.email) {
      email = me.email;
    }
    const {
      mutate: resetPassword,
      isLoading
    } = useMutation({
      mutationKey: ["resetPassword"],
      mutationFn: async () => {
        try {
          const response = await Client.authentication.resendEmail({
            email
          });
          return response;
        } catch (error) {
          throw error;
        }
      },
      onSuccess: (data) => {
        setToaster({
          message: data.statusMsg,
          type: "success"
        });
      },
      onError: (error) => {
        let errorMessage = "An unexpected error occurred.";
        if (error.response && error.response.data) {
          const errorData = error.response.data.detailedMessage;
          setServerError(errorData);
          errorMessage = typeof errorData === "object" ? JSON.stringify(errorData) : errorData;
        }
        setToaster({
          message: errorMessage,
          type: "error"
        });
      }
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col items-center justify-center h-screen text-center px-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full max-w-md", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "w-24 h-24 mb-6 mx-auto", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M16 12l-4-4-4 4m8-4l-4 4m-4 4v1a1 1 0 001 1h10a1 1 0 001-1v-1M5 11V5a2 2 0 012-2h10a2 2 0 012 2v6" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-2xl font-bold mb-4", children: "Please Verify Your Email" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-base mb-6", children: [
        "Click ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold cursor-pointer", children: "Resend" }),
        " to send the link to your email:",
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold ml-1", children: email })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between space-x-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: "w-full !bg-white !text-black", children: "Cancel" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: "w-full", onClick: () => resetPassword(), disabled: isLoading, children: isLoading ? "Sending..." : "Resend" })
      ] })
    ] }) });
  };
  const Route$6 = createFileRoute("/_auth/not-verified-email")({
    component: NotVerifiedEmail,
    beforeLoad: () => {
      return {
        layout: "AuthLayout",
        requiresAuth: false
      };
    }
  });
  const EmailIcon = ({
    width = "20px",
    height = "20px",
    color = "#e8eaed",
    ...props
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width,
        height,
        fill: color,
        ...props,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        className: "fill-black dark:fill-white",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M180.31-212q-27.01 0-45.66-18.66Q116-249.32 116-276.35v-407.62q0-27.03 18.65-45.53t45.66-18.5h599.38q27.01 0 45.66 18.66Q844-710.68 844-683.65v407.62q0 27.03-18.65 45.53T779.69-212H180.31ZM480-449.69 168-633.31v357q0 5.39 3.46 8.85t8.85 3.46h599.38q5.39 0 8.85-3.46t3.46-8.85v-357L480-449.69Zm0-67.31 305.85-179h-611.7L480-517ZM168-633.31V-696v419.69q0 5.39 3.46 8.85t8.85 3.46H168v-369.31Z" })
      }
    );
  };
  const PreLogin = ({ setActiveState, entredEmail, setEntredEmail, setloginData }) => {
    const [serverError, setServerError] = reactExports.useState(null);
    const enterEmailValidationSchema = objectType({
      email: stringType().email().nonempty({
        message: "Email is required."
      })
    });
    const { mutate: login, isLoading } = useMutation({
      mutationKey: ["enterEmailUser"],
      mutationFn: async (input) => {
        try {
          const response = await Client.authentication.preLogin({
            email: input.email
          });
          return response;
        } catch (error) {
          throw error;
        }
      },
      onSuccess: async (data) => {
        setEntredEmail(data.data.email);
        setloginData(data == null ? void 0 : data.data);
        if (data.data.activeStatus === "ACTIVE" && data.data.emailVerified === true) {
          setActiveState("final-login");
        } else {
          setActiveState("existing-user-register");
        }
      },
      onError: (error) => {
        let errorMessage = "An unexpected error occurred.";
        if (error.response && error.response.data) {
          const errorData = error.response.data.detailedMessage;
          const errors = error.response.data.validationErrors;
          setServerError(errors);
          errorMessage = typeof errorData === "object" ? JSON.stringify(errorData) : errorData;
        }
        Ut.error(errorMessage);
      }
    });
    const onSubmit = (data) => {
      login(data);
    };
    const { isLargeScreen, isMediumScreen, isSmallScreen } = useResponsive();
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center bg-flatGray dark:bg-gray-800 justify-center h-screen", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `dark:bg-dark-200 gap-4 bg-cleanWhite py-8 px-4 flex flex-col items-center justify-center rounded-lg ${isLargeScreen && "w-[30%]"}  ${isMediumScreen && "w-[45%]"}  ${isSmallScreen && "w-[85%]"} `, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-[200px]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: hubSpotUserDetails.hubspotPortals.portalSettings.authPopupFormLogo,
            alt: "Light Mode Logo",
            className: "h-auto dark:hidden"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: hubSpotUserDetails.hubspotPortals.portalSettings.logo,
            alt: "Dark Mode Logo",
            className: "h-auto hidden dark:block"
          }
        )
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-center dark:text-white", children: baseCompanyOptions.welcomeMessage || "" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Form,
          {
            onSubmit,
            validationSchema: enterEmailValidationSchema,
            serverError,
            className: "dark:bg-dark-200",
            formName: `login-form-submited`,
            children: ({ register, setValue, watch, formState: { errors } }) => {
              watch("email");
              reactExports.useEffect(() => {
                if (developerMode) {
                  setValue("email", "krishna@digitalwoods.net");
                }
              }, [developerMode, setValue]);
              return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-gray-800 dark:text-gray-200", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { className: "text-xs font-semibold text-gray-800 dark:text-gray-300 focus:text-blue-600", children: "Enter Email" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      autoFocus: true,
                      height: "medium",
                      icon: EmailIcon,
                      placeholder: "Email",
                      defaultValue: entredEmail,
                      disabled: developerMode,
                      ...register("email", {
                        onChange: (e) => setValue("email", e.target.value.toLowerCase())
                      })
                    }
                  ) }) }),
                  errors.email && /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, { className: "text-red-600 dark:text-red-400", children: errors.email.message })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4 flex flex-col justify-center items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    className: "w-full",
                    isLoading,
                    children: "Continue"
                  }
                ) })
              ] });
            }
          }
        ),
        (baseCompanyOptions == null ? void 0 : baseCompanyOptions.createAccountBool) && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "mt-6 mb-0 text-xs dark:text-white flex gap-1 relative items-center justify-center flex-wrap", children: [
          "Don't have an Account?",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-secondary hover:underline", children: /* @__PURE__ */ jsxRuntimeExports.jsx(HtmlParser, { html: baseCompanyOptions == null ? void 0 : baseCompanyOptions.createAccountLink }) })
        ] })
      ] })
    ] }) });
  };
  const EditIcon2 = ({
    width = "15px",
    height = "15px",
    color = "#e8eaed",
    ...props
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width,
        height,
        fill: color,
        ...props,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M200-200h57l391-391-57-57-391 391v57Zm-80 80v-170l528-527q12-11 26.5-17t30.5-6q16 0 31 6t26 18l55 56q12 11 17.5 26t5.5 30q0 16-5.5 30.5T817-647L290-120H120Zm640-584-56-56 56 56Zm-141 85-28-29 57 57-29-28Z" })
      }
    );
  };
  const FinalLogin = ({ setActiveState, entredEmail, loginData, clientSiteUrl }) => {
    var _a2, _b2, _c2;
    const router2 = useRouter();
    const [serverError, setServerError] = reactExports.useState(null);
    const [showPassword, setShowPassword] = reactExports.useState(false);
    const hasUserData = (loginData == null ? void 0 : loginData.firstName) || (loginData == null ? void 0 : loginData.email);
    const userPortals = (loginData == null ? void 0 : loginData.portals) || [];
    const matchingPortal = userPortals.find((portal) => portal.portalUrl === clientSiteUrl);
    const portalUrl = ((_a2 = matchingPortal == null ? void 0 : matchingPortal.portalUrl) == null ? void 0 : _a2.replace("https://", "")) || (userPortals.leggth > 0 ? (_c2 = (_b2 = userPortals[0]) == null ? void 0 : _b2.portalUrl) == null ? void 0 : _c2.replace("https://", "") : "");
    const developerModeOn = developerMode;
    const loginUserValidationSchema = objectType({
      // email: z.string().email(),
      password: stringType().nonempty({
        message: "Password is required."
      })
    });
    const setItemAsync = async (key2, value) => {
      return new Promise((resolve) => {
        setCookie(key2, value);
        resolve();
      });
    };
    const { mutate: login, isLoading } = useMutation({
      mutationKey: ["loginUser"],
      mutationFn: async (input) => {
        try {
          const response = await Client.authentication.login({
            username: entredEmail,
            password: input.password
          }, hubId);
          return response;
        } catch (error) {
          throw error;
        }
      },
      onSuccess: async (data) => {
        var _a3, _b3, _c3, _d2, _e2;
        if (!data.data.tokenData.token) {
          Ut.error("Wrong email or password");
          return;
        }
        const currentDomain = env$1.VITE_NODE_ENV === "development" ? env$1.VITE_PORTAL_URL : window.location.origin;
        const portal = data.data.loggedInDetails.portals.find(
          (item) => item.portalUrl === currentDomain
        );
        console.log("portal", portal);
        setPortal(portal);
        if (data.data.loggedInDetails && data.data.loggedInDetails.hubspot && data.data.loggedInDetails.hubspot.twoFa) {
          setLoggedInDetails(data.data);
          const SubscriptionType = ((_b3 = (_a3 = data == null ? void 0 : data.data) == null ? void 0 : _a3.loggedInDetails) == null ? void 0 : _b3.subscriptionType) || "FREE";
          setSubscriptionType(SubscriptionType);
          setTwoFa({ twoFa: data.data.loggedInDetails.hubspot.twoFa });
          window.location.hash = "/login/tow-fa";
        } else {
          await setItemAsync(env$1.VITE_AUTH_USER_KEY, JSON.stringify(data.data));
          await setItemAsync(env$1.VITE_AUTH_TOKEN_KEY, data.data.tokenData.token);
          const path = formatPath(((_c3 = hubSpotUserDetails == null ? void 0 : hubSpotUserDetails.sideMenu[0]) == null ? void 0 : _c3.label) && !addHomeTabOption ? (_d2 = hubSpotUserDetails == null ? void 0 : hubSpotUserDetails.sideMenu[0]) == null ? void 0 : _d2.label : (_e2 = hubSpotUserDetails == null ? void 0 : hubSpotUserDetails.sideMenu[0]) == null ? void 0 : _e2.tabName);
          router2.navigate({ to: `/${path}` });
        }
        Ut.error(data.statusMsg);
      },
      onError: (error) => {
        let errorMessage = "An unexpected error occurred.";
        if (error.response && error.response.data) {
          const errorData = error.response.data.detailedMessage;
          const errors = error.response.data.validationErrors;
          setServerError(errors);
          errorMessage = typeof errorData === "object" ? JSON.stringify(errorData) : errorData;
        }
        Ut.error(errorMessage);
      }
    });
    const onSubmit = (data) => {
      login(data);
    };
    const togglePasswordVisibility = () => {
      setShowPassword((prevState) => !prevState);
    };
    const { isLargeScreen, isMediumScreen, isSmallScreen } = useResponsive();
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center bg-flatGray dark:bg-gray-800 justify-center h-screen", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `dark:bg-dark-200 gap-4 bg-cleanWhite py-8 px-4 flex flex-col items-center justify-center rounded-lg ${isLargeScreen && "w-[30%]"}  ${isMediumScreen && "w-[45%]"}  ${isSmallScreen && "w-[85%]"} `,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-[200px]", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: hubSpotUserDetails.hubspotPortals.portalSettings.authPopupFormLogo,
                alt: "Light Mode Logo",
                className: "h-auto dark:hidden"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: hubSpotUserDetails.hubspotPortals.portalSettings.logo,
                alt: "Dark Mode Logo",
                className: "h-auto hidden dark:block"
              }
            )
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-center dark:text-white", children: baseCompanyOptions.welcomeMessage || "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Form,
            {
              onSubmit,
              validationSchema: loginUserValidationSchema,
              serverError,
              formName: hasUserData && userPortals.length > 0 ? `${portalUrl}-LoginUser-Verification` : "Existing-user-logged-in-form-submitted",
              className: "dark:bg-dark-200",
              children: ({ register, setValue, formState: { errors } }) => {
                reactExports.useEffect(() => {
                  if (developerModeOn) {
                    setValue("password", "Krish@12345");
                  }
                }, [developerModeOn, setValue]);
                return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-gray-800 dark:text-gray-200", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { className: "text-xs font-semibold text-gray-800 dark:text-gray-300 focus:text-blue-600", children: "Email" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Input,
                        {
                          height: "medium",
                          icon: EmailIcon,
                          placeholder: "Email",
                          ...register("email"),
                          defaultValue: entredEmail,
                          disabled: true,
                          readOnly: true
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "span",
                        {
                          className: "absolute right-2 top-3 text-secondary cursor-pointer",
                          onClick: () => setActiveState("pre-login"),
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(EditIcon2, {})
                        }
                      )
                    ] }) }) }),
                    errors.username && /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, { className: "text-red-600 dark:text-red-400", children: errors.username.message })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { className: "text-xs font-semibold text-gray-800 dark:text-gray-300 focus:text-blue-600", children: "Password" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Input,
                        {
                          autoFocus: true,
                          placeholder: "Password",
                          icon: PasswordIcon,
                          type: showPassword ? "text" : "password",
                          ...register("password"),
                          disabled: developerModeOn
                        }
                      ),
                      !developerModeOn && /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "span",
                        {
                          className: "absolute right-2 top-3 cursor-pointer",
                          onClick: togglePasswordVisibility,
                          children: showPassword ? /* @__PURE__ */ jsxRuntimeExports.jsx(EyeIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOffIcon, {})
                        }
                      )
                    ] }) }),
                    errors.password && /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, { className: "text-red-600 dark:text-red-400", children: errors.password.message })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/forget-password", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 mb-0 text-xs dark:text-white text-secondary hover:underline text-end", children: "Forgot password?" }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4 flex flex-col justify-center items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: "w-full", isLoading, children: "Login" }) })
                ] });
              }
            }
          ) })
        ]
      }
    ) });
  };
  const ExistingUserRegister = ({ setActiveState, entredEmail, loginData, clientSiteUrl }) => {
    var _a2, _b2, _c2;
    const [resend, setIsResend] = reactExports.useState(true);
    const [serverError, setServerError] = reactExports.useState(null);
    const [showPassword, setShowPassword] = reactExports.useState(false);
    const [showPassword2, setShowPassword2] = reactExports.useState(false);
    const hasUserData = (loginData == null ? void 0 : loginData.firstName) || (loginData == null ? void 0 : loginData.email);
    const userPortals = (loginData == null ? void 0 : loginData.portals) || [];
    const matchingPortal = userPortals.find((portal) => portal.portalUrl === clientSiteUrl);
    const portalUrl = ((_a2 = matchingPortal == null ? void 0 : matchingPortal.portalUrl) == null ? void 0 : _a2.replace("https://", "")) || ((_c2 = (_b2 = userPortals[0]) == null ? void 0 : _b2.portalUrl) == null ? void 0 : _c2.replace("https://", ""));
    const enterEmailValidationSchema = objectType({
      // email: z.string().email().nonempty({
      //   message: "Email is required.",
      // }),
      newPassword: stringType().nonempty({
        message: "New password is required."
      }),
      confirmPassword: stringType().nonempty({
        message: "Confirm password is required."
      })
    }).refine((data) => data.newPassword === data.confirmPassword, {
      message: "Passwords do not match.",
      path: ["confirmPassword"]
    });
    const { mutate: login, isLoading } = useMutation({
      mutationKey: ["enterEmailUser"],
      mutationFn: async (input) => {
        try {
          const response = await Client.authentication.existingUserRegister({
            email: entredEmail,
            newPassword: input.newPassword,
            confirmPassword: input.confirmPassword
          });
          return response;
        } catch (error) {
          throw error;
        }
      },
      onSuccess: async (data) => {
        Ut.error(data.statusMsg);
        setTimeout(() => {
          setIsResend(false);
        }, 1e3);
      },
      onError: (error) => {
        let errorMessage = "An unexpected error occurred.";
        if (error.response && error.response.data) {
          const errorData = error.response.data.detailedMessage;
          const errors = error.response.data.validationErrors;
          setServerError(errors);
          errorMessage = typeof errorData === "object" ? JSON.stringify(errorData) : errorData;
        }
        Ut.error(errorMessage);
      }
    });
    const onSubmit = (data) => {
      login(data);
    };
    const { mutate: resendEmail, isLoading: isLoadingResend } = useMutation({
      mutationKey: ["enterEmailUser"],
      mutationFn: async () => {
        try {
          const response = await Client.authentication.verifyEmailResend({
            email: entredEmail
          });
          return response;
        } catch (error) {
          throw error;
        }
      },
      onSuccess: async (data) => {
        Ut.error(data.statusMsg);
      },
      onError: (error) => {
        let errorMessage = "An unexpected error occurred.";
        if (error.response && error.response.data) {
          const errorData = error.response.data.detailedMessage;
          const errors = error.response.data.validationErrors;
          setServerError(errors);
          errorMessage = typeof errorData === "object" ? JSON.stringify(errorData) : errorData;
        }
        Ut.error(errorMessage);
      }
    });
    const togglePasswordVisibility = () => {
      setShowPassword((prevState) => !prevState);
    };
    const togglePassword2Visibility = () => {
      setShowPassword2((prevState) => !prevState);
    };
    const { isLargeScreen, isMediumScreen, isSmallScreen } = useResponsive();
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center bg-flatGray dark:bg-gray-800 justify-center h-screen", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `dark:bg-dark-200 gap-4 bg-cleanWhite py-8 px-4 flex flex-col items-center justify-center rounded-lg ${isLargeScreen && "w-[30%]"}  ${isMediumScreen && "w-[50%]"}  ${isSmallScreen && "w-[80%]"} `,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-[200px]", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: hubSpotUserDetails.hubspotPortals.portalSettings.authPopupFormLogo,
                alt: "Light Mode Logo",
                className: "h-auto dark:hidden"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: hubSpotUserDetails.hubspotPortals.portalSettings.logo,
                alt: "Dark Mode Logo",
                className: "h-auto hidden dark:block"
              }
            )
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-center dark:text-white", children: baseCompanyOptions.welcomeMessage || "" }),
          resend ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col items-center justify-center w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Form,
            {
              onSubmit,
              validationSchema: enterEmailValidationSchema,
              serverError,
              formName: hasUserData && userPortals.length > 0 ? `${portalUrl}-Login-Credential-Approval` : "Existing-user-registered-form-submitted",
              className: "dark:bg-dark-200",
              children: ({ register, formState: { errors } }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-gray-800 dark:text-gray-200", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { className: "text-xs font-semibold text-gray-800 dark:text-gray-300 focus:text-blue-600", children: "Enter Email" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      height: "medium",
                      icon: EmailIcon,
                      placeholder: "Email",
                      className: "",
                      ...register("email"),
                      defaultValue: entredEmail,
                      disabled: true,
                      readonly: true
                    }
                  ) }) }),
                  errors.email && /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, { className: "text-red-600 dark:text-red-400", children: errors.email.message })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { className: "text-xs font-semibold text-gray-800 dark:text-gray-300 focus:text-blue-600", children: "New Password" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Input,
                      {
                        placeholder: "New Password",
                        icon: PasswordIcon,
                        type: showPassword ? "text" : "password",
                        className: " ",
                        ...register("newPassword")
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "span",
                      {
                        className: "absolute right-2 top-2 cursor-pointer",
                        onClick: togglePasswordVisibility,
                        children: showPassword ? /* @__PURE__ */ jsxRuntimeExports.jsx(EyeIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOffIcon, {})
                      }
                    )
                  ] }) }),
                  errors.newPassword && /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, { className: "text-red-600 dark:text-red-400", children: errors.newPassword.message })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { className: "text-xs font-semibold text-gray-800 dark:text-gray-300 focus:text-blue-600", children: "Confirm Password" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Input,
                      {
                        placeholder: "Confirm Password",
                        icon: PasswordIcon,
                        type: showPassword2 ? "text" : "password",
                        className: " ",
                        ...register("confirmPassword")
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "span",
                      {
                        className: "absolute right-2 top-2 cursor-pointer",
                        onClick: togglePassword2Visibility,
                        children: showPassword2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(EyeIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOffIcon, {})
                      }
                    )
                  ] }) }),
                  errors.confirmPassword && /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, { className: "text-red-600 dark:text-red-400", children: errors.confirmPassword.message })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-end items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Link,
                  {
                    to: "/login",
                    onClick: () => setActiveState("pre-login"),
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-black text-xs dark:text-gray-300", children: "Back to enter email" })
                  }
                ) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4 flex flex-col justify-center items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: "w-full", isLoading, children: "Change Password" }) })
              ] })
            }
          ) }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center w-full", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-xl font-bold mb-4", children: "Verify your email address" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: " text-sm text-muted-gray ", children: "A verification link has been sent to" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "ml-1 text-base", children: entredEmail }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-gray my-6", children: "Check your inbox to verify your account" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "w-full" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-gray my-6", children: "Didnt receive your email?" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between space-x-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outline",
                  onClick: () => setActiveState("pre-login"),
                  children: "Cancel"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { isLoading: isLoadingResend, onClick: () => resendEmail(), children: "Resend" })
            ] })
          ] })
        ]
      }
    ) });
  };
  const Login = () => {
    const [activeState, setActiveState] = reactExports.useState("pre-login");
    const [entredEmail, setEntredEmail] = reactExports.useState("");
    const [loginData, setloginData] = reactExports.useState([]);
    const clientSiteUrl = window.location.origin;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: activeState === "pre-login" ? /* @__PURE__ */ jsxRuntimeExports.jsx(PreLogin, { setActiveState, entredEmail, setEntredEmail, setloginData }) : activeState === "final-login" ? /* @__PURE__ */ jsxRuntimeExports.jsx(FinalLogin, { setActiveState, entredEmail, loginData, clientSiteUrl }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ExistingUserRegister, { setActiveState, entredEmail, loginData, clientSiteUrl }) });
  };
  const Route$5 = createFileRoute("/_auth/login")({
    component: Login,
    beforeLoad: () => {
      return {
        layout: "AuthLayout",
        requiresAuth: false
      };
    }
  });
  const ForgetPassword = () => {
    const [serverError, setServerError] = reactExports.useState(null);
    const {
      setToaster
    } = useToaster();
    const resetPasswordValidationSchema = objectType({
      email: stringType().email()
    });
    const {
      mutate: resetPassword,
      isLoading
    } = useMutation({
      mutationKey: ["resetPassword"],
      mutationFn: async (input) => {
        try {
          const response = await Client.authentication.forgetPassword({
            email: input.email
          });
          return response;
        } catch (error) {
          throw error;
        }
      },
      onSuccess: (data) => {
        setToaster({
          message: data.statusMsg,
          type: "success"
        });
      },
      onError: (error) => {
        let errorMessage = "An unexpected error occurred.";
        if (error.response && error.response.data) {
          const errorData = error.response.data.detailedMessage;
          setServerError(errorData);
          errorMessage = typeof errorData === "object" ? JSON.stringify(errorData) : errorData;
        }
        setToaster({
          message: errorMessage,
          type: "error"
        });
      }
    });
    const onSubmit = (data) => {
      resetPassword(data);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center bg-flatGray dark:bg-gray-900 justify-center h-screen", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dark:bg-dark-200 bg-cleanWhite py-8 px-4 flex flex-col items-center justify-center rounded-lg w-[30%]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-[200px]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: hubSpotUserDetails.hubspotPortals.portalSettings.authPopupFormLogo, alt: "Light Mode Logo", className: "h-auto dark:hidden" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: hubSpotUserDetails.hubspotPortals.portalSettings.logo, alt: "Dark Mode Logo", className: "h-auto hidden dark:block" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Form,
        {
          onSubmit,
          validationSchema: resetPasswordValidationSchema,
          className: "dark:bg-dark-200",
          children: ({
            register,
            formState: {
              errors
            }
          }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-gray-800 dark:text-gray-200", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { className: "text-xs font-semibold text-gray-800 dark:text-gray-300 focus:text-blue-600", children: "Email" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { height: "medium", icon: EmailIcon, placeholder: "Email", className: "", ...register("email") }) }) }),
              errors.email && /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, { className: "text-red-600 dark:text-red-400", children: errors.email.message })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-end items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/login", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-black text-xs dark:text-gray-300", children: "Back to Login?" }) }) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4 flex flex-col justify-center items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { disabled: isLoading, className: "w-full  ", children: isLoading ? "Sending..." : "Send Link" }) })
          ] })
        }
      ) })
    ] }) });
  };
  const Route$4 = createFileRoute("/_auth/forget-password")({
    component: ForgetPassword,
    beforeLoad: () => {
      return {
        layout: "AuthLayout",
        requiresAuth: false
      };
    }
  });
  const registerUserValidationSchema = objectType({
    name: stringType().min(4, {
      message: "Name must be at least 4 characters."
    }),
    email: stringType().email(),
    password: stringType().min(4, {
      message: "Password must be at least 4 characters."
    })
  });
  const Register = () => {
    let [serverError, setServerError] = reactExports.useState(null);
    const {
      mutate: addUser,
      isLoading
    } = useMutation({
      mutationKey: ["registerUser"],
      mutationFn: async (input) => await Client.authentication.register(input),
      onSuccess: (_data) => {
      },
      onError: (error) => {
        setServerError(error.response.data);
      }
    });
    const onSubmit = (data) => {
      addUser(data);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-light-100 dark:bg-dark-200 p-5", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { onSubmit, validationSchema: registerUserValidationSchema, serverError, className: "bg-light-100 dark:bg-dark-200", children: ({
      register,
      formState: {
        errors
      }
    }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-dark dark:text-white", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-base font-semibold leading-7 text-gray-900 dark:text-white", children: "Register" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1 text-sm leading-6 text-gray-600  dark:text-white", children: "Use a permanent address where you can receive mail." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Name" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { placeholder: "Name", ...register("name") }) }),
          errors.name && /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, { className: "text-red-600", children: errors.name.message })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Email" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { placeholder: "Email", ...register("email") }) }),
          errors.email && /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, { className: "text-red-600", children: errors.email.message })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Password" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { placeholder: "Password", ...register("password") }) }),
          errors.password && /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, { className: "text-red-600", children: errors.password.message })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-6 flex items-center justify-end gap-x-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { href: "/home", children: "Home" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", isLoading, children: "Submit" })
      ] })
    ] }) }) });
  };
  const Route$3 = createFileRoute("/_auth/Register")({
    component: Register,
    beforeLoad: () => {
      return {
        layout: "AuthLayout",
        requiresAuth: false
      };
    }
  });
  const CurrentpassIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      height: "20px",
      viewBox: "0 -960 960 960",
      width: "20px",
      className: "fill-black dark:fill-white",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M288-399.39q-33.85 0-57.23-23.38-23.38-23.38-23.38-57.23 0-33.85 23.38-57.23 23.38-23.38 57.23-23.38 33.85 0 57.23 23.38 23.38 23.38 23.38 57.23 0 33.85-23.38 57.23-23.38 23.38-57.23 23.38ZM288-260q-91.54 0-155.77-64.23T68-480q0-91.54 64.23-155.77T288-700q62.31 0 114.81 32.69 52.5 32.7 80.88 87.31h352.08l100 100-153.85 141.07-78.23-55.76-68.15 56.53L546.46-404h-50.77q-19.38 67.23-78.38 105.61Q358.31-260 288-260Zm0-52q64.54 0 112.15-41.27 47.62-41.27 53.47-102.73h110.69l69.61 50.85 67.16-55.16L779-405.38 860.62-481l-46-47h-366q-17.85-51.46-60.97-85.73Q344.54-648 288-648q-70 0-119 49t-49 119q0 70 49 119t119 49Z" })
    }
  );
  const ConfirmandCurrentPassIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      height: "20px",
      viewBox: "0 -960 960 960",
      width: "20px",
      className: "fill-black dark:fill-white",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M276.03-116q-26.64 0-45.34-18.84Q212-153.69 212-180.31v-359.38q0-26.62 18.84-45.47Q249.69-604 276.31-604H308v-96q0-71.6 50.27-121.8Q408.53-872 480.23-872q71.69 0 121.73 50.2Q652-771.6 652-700v96h31.69q26.62 0 45.47 18.84Q748-566.31 748-539.69v359.38q0 26.62-18.86 45.47Q710.29-116 683.65-116H276.03Zm.28-52h407.38q5.39 0 8.85-3.46t3.46-8.85v-359.38q0-5.39-3.46-8.85t-8.85-3.46H276.31q-5.39 0-8.85 3.46t-3.46 8.85v359.38q0 5.39 3.46 8.85t8.85 3.46Zm203.9-130q25.94 0 43.87-18.14Q542-334.27 542-360.21t-18.14-43.87Q505.73-422 479.79-422t-43.87 18.14Q418-385.73 418-359.79t18.14 43.87Q454.27-298 480.21-298ZM360-604h240v-96q0-50-35-85t-85-35q-50 0-85 35t-35 85v96Zm-96 436v-384 384Z" })
    }
  );
  const ChangePassword = () => {
    const { setToaster } = useToaster$1();
    const [currentPassword, setCurrentPassword] = reactExports.useState("");
    const [newPassword, setNewPassword] = reactExports.useState("");
    const [confirmPassword, setConfirmPassword] = reactExports.useState("");
    const [showCurrentPassword, setShowCurrentPassword] = reactExports.useState(false);
    const [showNewPassword, setShowNewPassword] = reactExports.useState(false);
    const [showConfirmPassword, setShowConfirmPassword] = reactExports.useState(false);
    const passwordValidationSchema = z$2.object({
      currentPassword: z$2.string().min(6, { message: "Current password is required" }),
      newPassword: z$2.string().min(6, { message: "It should be 6 characters long" }).regex(/[A-Z]/, {
        message: "Must contain at least one uppercase letter"
      }).regex(/\d/, { message: "Must contain at least one number" }).regex(/[!@#$%^&*(),.?":{}|<>]/, {
        message: "Must contain at least one special character"
      }),
      confirmPassword: z$2.string().min(6, { message: "Please confirm your new password" })
    }).refine((data) => data.newPassword === data.confirmPassword, {
      message: "New passwords don't match",
      path: ["confirmPassword"]
    });
    const {
      mutate: changePassword,
      isLoading,
      isError: isError2,
      isSuccess,
      error
    } = useMutation({
      mutationFn: (data) => Client.authentication.changePassword(data),
      onSuccess: (response) => {
        setToaster({ message: response.statusMsg || "Password updated successfully", type: "success" });
        setCurrentPassword("");
        setNewPassword("");
        setConfirmPassword("");
      },
      onError: (error2) => {
        let errorMessage = "Error updating password";
        if (error2.response && error2.response.data && error2.response.data.errorMessage) {
          errorMessage = error2.response.data.errorMessage;
        } else if (error2.message) {
          errorMessage = error2.message;
        }
        setToaster({ message: errorMessage, type: "error" });
      }
    });
    const handleSubmit = () => {
      const payload = {
        currentPassword: String(currentPassword),
        newPassword: String(newPassword),
        confirmPassword: String(confirmPassword)
      };
      changePassword(payload);
    };
    const toggleCurrentPasswordVisibility = () => {
      setShowCurrentPassword((prevState) => !prevState);
    };
    const toggleNewPasswordVisibility = () => {
      setShowNewPassword((prevState) => !prevState);
    };
    const toggleConfirmPasswordVisibility = () => {
      setShowConfirmPassword((prevState) => !prevState);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { onSubmit: handleSubmit, validationSchema: passwordValidationSchema, children: ({ register, formState: { errors } }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 max-sm:p-2 dark:bg-dark-300 bg-cleanWhite rounded-md border dark:border-none dark:text-white", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "text-xl max-sm:text-lg font-semibold dark:text-white", children: "Change Password" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: !recorBtnCustom ? "default" : "create",
            disabled: isLoading,
            children: isLoading ? "Saving..." : "Save"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { className: "!mb-0 py-2 flex flex-col", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { className: "text-xs font-semibold w-[200px]", children: "Current Password" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { className: "flex flex-col items-center w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-full", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                type: showCurrentPassword ? "text" : "password",
                placeholder: "Current Password",
                ...register("currentPassword"),
                className: "text-xs text-gray-500 w-full !px-10",
                icon: CurrentpassIcon,
                value: currentPassword,
                onChange: (e) => setCurrentPassword(e.target.value)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "absolute right-3 top-2 cursor-pointer",
                onClick: toggleCurrentPasswordVisibility,
                children: showCurrentPassword ? /* @__PURE__ */ jsxRuntimeExports.jsx(EyeIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOffIcon, {})
              }
            ),
            errors.currentPassword && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-600 text-[12px] px-2 mt-1 max-w-[calc(100%-16px)]", children: errors.currentPassword.message })
          ] }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { className: "!mb-0 py-2 flex flex-col", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { className: "text-xs font-semibold w-[200px]", children: "New Password" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { className: "flex flex-col items-center w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-full", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                type: showNewPassword ? "text" : "password",
                placeholder: "New password",
                ...register("newPassword"),
                className: "text-xs text-gray-500 !px-10 w-full",
                icon: ConfirmandCurrentPassIcon,
                value: newPassword,
                onChange: (e) => setNewPassword(e.target.value)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "absolute right-2 top-2 cursor-pointer",
                onClick: toggleNewPasswordVisibility,
                children: showNewPassword ? /* @__PURE__ */ jsxRuntimeExports.jsx(EyeIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOffIcon, {})
              }
            ),
            errors.newPassword && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-600 text-[12px] px-2  mt-1 max-w-[calc(100%-16px)]", children: errors.newPassword.message })
          ] }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { className: "!mb-0 py-2 flex flex-col", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { className: "text-xs font-semibold w-[200px]", children: "Confirm New Password" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { className: "flex flex-col items-center w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-full", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                type: showConfirmPassword ? "text" : "password",
                placeholder: "Confirm new password",
                ...register("confirmPassword"),
                className: "text-xs text-gray-500 !px-10 w-full",
                icon: ConfirmandCurrentPassIcon,
                value: confirmPassword,
                onChange: (e) => setConfirmPassword(e.target.value)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "absolute right-2 top-2 cursor-pointer",
                onClick: toggleConfirmPasswordVisibility,
                children: showConfirmPassword ? /* @__PURE__ */ jsxRuntimeExports.jsx(EyeIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOffIcon, {})
              }
            ),
            errors.confirmPassword && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-600 text-[12px] px-2 mt-1 max-w-[calc(100%-16px)]", children: errors.confirmPassword.message })
          ] }) })
        ] })
      ] })
    ] }) }) });
  };
  const SkeletonLoader = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "animate-pulse flex max-sm:flex-col items-start gap-8 w-full mx-auto p-6 rounded-lg shadow-md border dark:border-none dark:bg-dark-300 relative overflow-hidden", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `bg-[${moduleStylesOptions.homeTabStyles.overlayer.color || "#E5F5F8"}]/${moduleStylesOptions.homeTabStyles.overlayer.opacity || "100"} dark:bg-gray-600/10 absolute top-0 right-0 left-0 h-[90px]` }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center relative z-50", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-full h-[80px] w-[80px] max-sm:w-[50px] max-sm:h-[50px] flex items-center justify-center bg-gray-400 text-white text-2xl font-medium", children: "U" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-full z-50 mt-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col md:flex-row gap-4 pb-4 mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: " flex items-center flex-wrap gap-2 text-xl font-semibold dark:text-secondary text-secondary mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "h-3 bg-gray-300 dark:bg-dark-white rounded-sm w-[150px] inline-block " }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs flex items-center flex-wrap gap-1 dark:text-white", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "h-3 bg-gray-300 dark:bg-dark-white rounded-sm w-[100px] inline-block" }),
            "",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "h-3 bg-gray-300 dark:bg-dark-white rounded-sm w-[100px] inline-block " })
          ] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 md:grid-cols-3 lg:grid-cols-3 xl:grid-cols-4 gap-2 text-xs dark:text-white transition-all duration-500", children: Array.from({ length: 4 }).map((_2, i2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-start gap-1 text-xs", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold", children: /* @__PURE__ */ jsxRuntimeExports.jsx("sapn", { className: "h-3 bg-gray-300 dark:bg-dark-white rounded-sm w-[120px] inline-block" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "h-3 bg-gray-300 dark:bg-dark-white rounded-sm w-[100px] inline-block" })
        ] }, i2)) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-6 pt-4 border-t dark:border-gray-600", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold dark:text-white mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "h-6 bg-gray-300 dark:bg-dark-white rounded-sm w-[100px] inline-block" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 md:grid-cols-3 lg:grid-cols-3 xl:grid-cols-4 gap-2 text-xs dark:text-white transition-all mt-2 duration-500", children: Array.from({ length: 4 }).map((_2, i2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-start gap-1 text-xs", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "h-3 bg-gray-300 dark:bg-dark-white rounded-sm w-[120px] inline-block" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "h-3 bg-gray-300 dark:bg-dark-white rounded-sm w-[100px] inline-block" })
          ] }, i2)) }) })
        ] })
      ] })
    ] });
  };
  const sortProperties = (data) => {
    return Object.entries(data).filter(([key2, value]) => value == null ? void 0 : value.label).sort(([, a], [, b2]) => {
      if (a.isPrimaryDisplayProperty && !b2.isPrimaryDisplayProperty) return -1;
      if (!a.isPrimaryDisplayProperty && b2.isPrimaryDisplayProperty) return 1;
      if (a.isSecondaryDisplayProperty && !b2.isSecondaryDisplayProperty) return -1;
      if (!a.isSecondaryDisplayProperty && b2.isSecondaryDisplayProperty) return 1;
      return 0;
    });
  };
  const UserProfileCard = ({ userData: userData2, isLoading }) => {
    var _a2, _b2, _c2;
    const [userDetails, setUserDetails] = reactExports.useState({});
    const [userAssociatedDetails, setUserAssociatedDetails] = reactExports.useState({});
    const [showMoreDetails, setShowMoreDetails] = reactExports.useState(false);
    const [showMoreAssociated, setShowMoreAssociated] = reactExports.useState(false);
    const { me } = useMe$1();
    const { profileDetails: loggedInDetails } = useAuth();
    reactExports.useEffect(() => {
      var _a3, _b3;
      if (userData2 == null ? void 0 : userData2.response) {
        setUserDetails(userData2.response);
        setUserAssociatedDetails(((_b3 = (_a3 = userData2.response) == null ? void 0 : _a3.associations) == null ? void 0 : _b3.COMPANY) || {});
      }
    }, [userData2]);
    if (isLoading) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SkeletonLoader, {});
    }
    const firstName = getFirstName2(loggedInDetails, me);
    const lastName = getLastName2(loggedInDetails, me);
    const email = getEmail2(loggedInDetails, me);
    function getFirstName2(loggedInDetails2, me2) {
      if (loggedInDetails2 && loggedInDetails2.firstName) {
        return loggedInDetails2.firstName;
      } else if (me2 && me2.firstName) {
        return me2.firstName;
      } else {
        return "";
      }
    }
    function getLastName2(loggedInDetails2, me2) {
      if (loggedInDetails2 && loggedInDetails2.lastName) {
        return loggedInDetails2.lastName;
      } else if (me2 && me2.lastName) {
        return me2.lastName;
      } else {
        return "";
      }
    }
    function getEmail2(loggedInDetails2, me2) {
      if (loggedInDetails2 && loggedInDetails2.email) {
        return loggedInDetails2.email;
      } else if (me2 && me2.email) {
        return me2.email;
      } else {
        return "";
      }
    }
    const initials = profileInitial(firstName, lastName);
    const filteredDetails = Object.entries(userDetails).filter(
      ([key2, value]) => (value == null ? void 0 : value.label) && !["firstname", "lastname", "email", "company", "phone", "associations", "hs_object_id"].includes(key2)
    );
    const sortedDetails = sortProperties(Object.fromEntries(filteredDetails));
    showMoreDetails ? sortedDetails : sortedDetails.slice(0, 4);
    const filteredAssociatedDetails = Object.entries(userAssociatedDetails).filter(
      ([key2, value]) => (value == null ? void 0 : value.label) && !["configurations", "objectTypeId", "labels", "name", "hs_object_id"].includes(key2)
    );
    const sortedAssociatedDetails = sortProperties(Object.fromEntries(filteredAssociatedDetails));
    const visibleAssociatedDetails = showMoreAssociated ? sortedAssociatedDetails : sortedAssociatedDetails.slice(0, 4);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex max-sm:flex-col items-start gap-8 w-full mx-auto p-6 rounded-lg border dark:border-none dark:bg-dark-300 relative overflow-hidden", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: ` bg-[${moduleStylesOptions.homeTabStyles.overlayer.color || "#E5F5F8"}]/${moduleStylesOptions.homeTabStyles.overlayer.opacity || "100"}  dark:bg-gray-600/10 absolute top-0 right-0 left-0 h-[80px]` }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center relative z-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-full h-[80px] w-[80px] max-sm:w-[50px] max-sm:h-[50px] flex items-center justify-center bg-gray-400 text-white text-2xl font-medium", children: initials }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-full z-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col md:flex-row gap-2 pb-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-xl font-semibold  dark:text-white dark:opacity-70 text-secondary mb-1", children: [
            firstName,
            " ",
            lastName
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs dark:text-white", children: [
            email,
            ((_a2 = userDetails == null ? void 0 : userDetails.phone) == null ? void 0 : _a2.value) ? `  ${(_b2 = userDetails == null ? void 0 : userDetails.phone) == null ? void 0 : _b2.value}` : ""
          ] })
        ] }) }),
        visibleAssociatedDetails && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold  dark:text-white dark:opacity-70 mb-0", children: ((_c2 = userAssociatedDetails == null ? void 0 : userAssociatedDetails.name) == null ? void 0 : _c2.value) || "--" }) })
      ] })
    ] }) });
  };
  const Profile = () => {
    var _a2;
    useAuth();
    const [userData2, setUserData] = reactExports.useState();
    const [userId, setUserId] = reactExports.useState();
    const [userObjectId, setUserObjectId] = reactExports.useState();
    const [cacheEnabled, setCacheEnabled] = reactExports.useState(true);
    const portalId = (_a2 = getPortal()) == null ? void 0 : _a2.portalId;
    const {
      sync,
      setSync
    } = useSync();
    const [activeTab, setActiveTab] = reactExports.useState("password");
    const fetchUserProfile = async ({
      portalId: portalId2,
      cache
    }) => {
      if (!portalId2) return null;
      const response = await Client.user.profile({
        portalId: portalId2,
        cache
      });
      return response == null ? void 0 : response.data;
    };
    const {
      data: userNewData,
      error,
      isLoading,
      refetch
    } = useQuery({
      queryKey: ["userProfilePage", portalId, cacheEnabled],
      queryFn: () => fetchUserProfile({
        portalId,
        cache: sync ? false : true
      }),
      onSuccess: (data) => {
        var _a3, _b2, _c2;
        if (data) {
          setUserData(data);
          setUserId((_b2 = (_a3 = data == null ? void 0 : data.response) == null ? void 0 : _a3.hs_object_id) == null ? void 0 : _b2.value);
          setUserObjectId((_c2 = data == null ? void 0 : data.info) == null ? void 0 : _c2.objectTypeId);
        }
        setSync(false);
      },
      onError: (error2) => {
        console.error("Error fetching profile:", error2);
        setSync(false);
      }
    });
    reactExports.useEffect(() => {
      if (sync) {
        refetch();
      }
    }, [sync]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-[var(--sidebar-background-color)] mt-[calc(var(--nav-height)-1px)] h-[calc(100vh-var(--nav-height))] dark:bg-dark-300", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `dark:bg-dark-200 hide-scrollbar overflow-y-auto  h-[calc(100vh-var(--nav-height))] bg-cleanWhite dark:text-white md:px-4 px-3 `, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: ` md:pt-4 pt-3`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(UserProfileCard, { userData: userData2, isLoading }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `w-full hide-scrollbar overflow-y-auto overflow-x-hidden md:my-4 my-3`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: ``, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChangePassword, {}) }) })
    ] }) }) });
  };
  const Route$2 = createFileRoute("/_auth/Profile")({
    component: Profile,
    beforeLoad: () => {
      return {
        layout: "MainLayout",
        requiresAuth: true
      };
    }
  });
  const AssociationComponent = () => {
    var _a2;
    const router2 = useRouter();
    const {
      search
    } = router2.state.location;
    const {
      name: path
    } = Route$1.useParams();
    const routeMenu = getRouteMenuByObjectTypeId(search == null ? void 0 : search.parentObjectTypeId);
    if (!routeMenu) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("h1", { className: "text-center", children: [
        search == null ? void 0 : search.parentObjectTypeId,
        " 404 Not Found"
      ] });
    }
    let {
      hubspotObjectTypeId,
      title,
      pipeLineId,
      companyAsMediator,
      specPipeLine,
      objectDescription,
      objectUserProperties,
      objectUserPropertiesView
    } = routeMenu;
    let showIframe = "";
    let propertyName = "";
    const param = getQueryParamsFromCurrentUrl();
    let portalId;
    if (env$1.VITE_DATA_SOURCE_SET != true) {
      portalId = (_a2 = getPortal()) == null ? void 0 : _a2.portalId;
    }
    hubspotObjectTypeId = hubspotObjectTypeId || getParam$1("objectTypeId");
    const apis = {
      tableAPI: `/api/${hubId}/${portalId}/hubspot-object-data/${hubspotObjectTypeId}${param}`,
      stagesAPI: `/api/${hubId}/${portalId}/hubspot-object-pipelines/${hubspotObjectTypeId}/`,
      // concat pipelineId
      formAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/${hubspotObjectTypeId}/fields${param}`,
      formDataAPI: `/api/:hubId/:portalId/hubspot-object-data/${hubspotObjectTypeId}/:objectId${param ? param + "&isForm=true" : "?isForm=true"}`,
      createAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/${hubspotObjectTypeId}/fields${param}`,
      createExistingAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/:fromObjectTypeId/:fromRecordId/associations/:toObjectTypeId${param}`,
      removeExistingAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/:fromObjectTypeId/:fromRecordId/disassociate/:toObjectTypeId${param}`,
      updateAPI: `/api/${hubId}/${portalId}/hubspot-object-forms/${hubspotObjectTypeId}/fields/:formId${param}`
      // concat ticketId
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicComponentView, { hubspotObjectTypeId, path, title, showIframe, propertyName, companyAsMediator, pipeLineId, specPipeLine, objectDescription, apis, objectUserProperties, objectUserPropertiesView });
  };
  const Route$1 = createFileRoute("/_dynamicPage/association/$name")({
    component: AssociationComponent,
    beforeLoad: () => {
      return {
        layout: "MainLayout",
        requiresAuth: true
      };
    }
  });
  const ModuleFileTable = ({ files }) => {
    const [selectedFile, setSelectedFile] = reactExports.useState(null);
    const [activeDropdown, setActiveDropdown] = reactExports.useState(null);
    const handleRowClick = (file) => {
      let data = { data: {} };
      data.data = file;
      setSelectedFile(data);
    };
    const closeModal = () => {
      setSelectedFile(null);
    };
    const handleDownload = (file, e) => {
      e.stopPropagation();
      window.open(file.url, "_blank");
    };
    const toggleDropdown = (index) => {
      setActiveDropdown(activeDropdown === index ? null : index);
    };
    const renderFiles = (files2) => {
      if (!files2 || files2.length === 0) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(TableRow, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { colSpan: 5, className: "text-center text-gray-500", children: "No files available" }) });
      }
      return files2.map((file, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        TableRow,
        {
          className: `border-t relative cursor-pointer hover:bg-gray-200 dark:hover:bg-dark-300`,
          onClick: () => handleRowClick(file),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "px-4 py-2 text-xs", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: getIconType(file.type) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "px-4 py-2 text-xs", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dark:text-white", children: file.name }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "px-4 py-2 text-left dark:text-white text-xs w-[100px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: file.type }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "px-4 py-2 text-left dark:text-white text-xs w-[100px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: file.size }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { className: "px-4 py-2 text-right relative", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "border border-gray-300 dark:text-white text-xs px-3 py-1 rounded",
                  onClick: (e) => {
                    e.stopPropagation();
                    toggleDropdown(index);
                  },
                  children: "Actions"
                }
              ),
              activeDropdown === index && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute right-0 mt-2 w-32 bg-white dark:bg-dark-200 border rounded-lg shadow-lg z-50", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "block w-full text-left px-4 py-2 text-sm text-black dark:text-white hover:bg-gray-100 dark:hover:bg-dark-300",
                    onClick: (e) => {
                      e.stopPropagation();
                      handleRowClick(file);
                      toggleDropdown(index);
                    },
                    children: "Details"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "block w-full text-left px-4 py-2 text-sm text-black dark:text-white hover:bg-gray-100 dark:hover:bg-dark-300",
                    onClick: (e) => handleDownload(file, e),
                    children: "Download"
                  }
                )
              ] })
            ] }) })
          ]
        }
      ) }, file.url));
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "table-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: " dark:bg-[#2a2a2a]  table-auto w-full mb-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "bg-gray-100 text-left dark:bg-dark-200", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-4 py-2 text-xs dark:text-white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-4 py-2 text-xs dark:text-white", children: "Name" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-4 py-2 text-xs dark:text-white text-left w-[100px]", children: "File Type" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-4 py-2 text-xs dark:text-white text-left w-[100px]", children: "Size" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-4 py-2 text-xs dark:text-white" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: renderFiles(files) })
      ] }),
      selectedFile && /* @__PURE__ */ jsxRuntimeExports.jsx(FileDetailsModal, { file: selectedFile, onClose: closeModal })
    ] });
  };
  const DetailsMapsCard = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative bg-[url('https://lh3.googleusercontent.com/KIy0SU9X2AU03o4zutzTZqDb9nvxhKfY6MBpCX-te4wgyjOmc3yGxzVl_bmGg54jEJoWKzhpL6Sh4sKm2Li5x5dfi0Qb5xu753OiwAn9=rw-e365-w1375')] bg-cover bg-center h-64 rounded-lg w-full mt-5 flex items-center justify-between overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "absolute bottom-4 flex gap-x-4 right-4 bg-cleanWhite text-gray-400 rounded-md px-4 py-2 font-medium text-sm", children: [
      "Get Directions",
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "svg",
        {
          xmlns: "http://www.w3.org/2000/svg",
          height: "20px",
          viewBox: "0 -960 960 960",
          width: "20px",
          fill: "#000000",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m600-165.54-240-72-139.15 45.61q-20.69 6.85-38.77-5.42Q164-209.62 164-233.31v-462.61q0-14.85 8.35-26.77 8.34-11.92 20.81-16.15L360-794.46l240 72 139.15-45.61q20.69-8.85 38.77 3.84 18.08 12.69 18.08 36v465.69q0 15.23-8.42 27.46-8.43 12.23-22.27 15.46L600-165.54Zm-26-61.38v-450l-188-56.93v450l188 56.93Zm52-2L744-268v-448l-118 39.08v448ZM216-244l118-39.85v-448L216-692v448Zm410-432.92v448-448Zm-292-54.93v448-448Z" })
        }
      ) })
    ] }) });
  };
  const DetailsTable = ({ item, path }) => {
    const tableHeaders = path === "/jobs" ? ["stage_name", "status", "start_date", "end_date"] : Object.keys(item || {}).filter(
      (key2) => ![
        "id",
        "createdAt",
        "archived",
        "updatedAt",
        "hs_lastmodifieddate",
        "hs_createdate",
        "hs_object_id"
      ].includes(key2)
    );
    const tableRows = item && tableHeaders.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { children: item[tableHeaders[0]] ? /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
      tableHeaders.map((header) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        TableCell,
        {
          className: "px-4 py-2 text-gray-900 dark:text-gray-100",
          children: renderCellContent(
            // false,item[header]
            {
              companyAsMediator: false,
              value: item[header]
            }
          )
        },
        header
      )),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-black w-fit p-1 rounded-md", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "svg",
        {
          xmlns: "http://www.w3.org/2000/svg",
          height: "20px",
          viewBox: "0 -960 960 960",
          width: "20px",
          fill: "#EFEFEF",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M320-240h320v-80H320v80Zm0-160h320v-80H320v80ZM240-80q-33 0-56.5-23.5T160-160v-640q0-33 23.5-56.5T240-880h320l240 240v480q0 33-23.5 56.5T720-80H240Zm280-520v-200H240v640h480v-440H520ZM240-800v200-200 640-640Z" })
        }
      ) }) })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TableRow, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      TableCell,
      {
        colSpan: tableHeaders.length + 1 || 1,
        className: "text-center py-4 text-gray-500 dark:text-gray-400",
        children: "No data found"
      }
    ) }) }) : null;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { className: "w-full dark:bg-dark-300 my-8 bg-cleanWhite rounded-md", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableHeader, { children: tableHeaders.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
        tableHeaders.map((header) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          TableHead,
          {
            className: "px-4 py-2 font-semibold text-xs text-gray-700 dark:text-gray-300 whitespace-nowrap",
            children: formatKey(header)
          },
          header
        )),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { className: "text-xs text-gray-700 dark:text-gray-300 whitespace-nowrap font-semibold", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Report" }) })
      ] }) }),
      tableRows
    ] });
  };
  const ModuleDetails = ({ path, id }) => {
    const [item, setItems] = reactExports.useState(null);
    const [images, setImages] = reactExports.useState([]);
    const [files, setFiles] = reactExports.useState([]);
    const [filesUrl, setFilesUrl] = reactExports.useState([]);
    const [sortItems, setSortItems] = reactExports.useState([]);
    const [activeTab, setActiveTab] = reactExports.useState("overview");
    const [galleryDialog, setGalleryDialog] = reactExports.useState(false);
    const [isLoading, setIsLoading] = reactExports.useState(true);
    let objList = hubSpotTableData.data.results || [];
    const headerPath = path && typeof path === "string" ? path.replace(/\//g, "") : "";
    const result = objList.find((item2) => item2.name === headerPath);
    let listData = result ? result.results.rows : [];
    reactExports.useEffect(() => {
      if (Array.isArray(objList) && objList.length > 0) {
        const idStr = String(id);
        let data = listData.find((item2) => String(item2.id) === idStr);
        if (data) {
          data = { data, statusCode: 200 };
          const structuredData = Object.keys(data.data).reduce((acc, key2) => {
            if (key2 === "files" || key2 === "images") {
              return acc;
            }
            acc[key2] = {
              isSecondaryDisplayProperty: false,
              label: formatLabel(key2),
              value: data.data[key2],
              isPrimaryDisplayProperty: false
            };
            return acc;
          }, {});
          const finalData = JSON.parse(
            JSON.stringify(sortData(structuredData, "details"))
          );
          setSortItems(finalData);
          setItems(finalData);
          getImages(data.data);
          getFilesUrl(data.data);
        } else {
          console.error("No data found with matching ID");
        }
      } else {
        console.error("Error: objList is not a valid array");
      }
      setIsLoading(false);
    }, [objList, id]);
    const formatLabel = (key2) => {
      return key2 && typeof key2 === "string" ? key2.replace(/_/g, " ").replace(/\b\w/g, (l) => l.toUpperCase()) : "";
    };
    const getImages = (data) => {
      if (data && data.images) {
        let urlArray = data.images.split(",");
        setImages(urlArray);
      } else {
        setImages([]);
      }
    };
    const getFilesUrl = (data) => {
      if (data && data.files) {
        let urlArray = data.files.split(",");
        setFilesUrl(urlArray);
      } else {
        setFilesUrl([]);
      }
    };
    reactExports.useEffect(() => {
      if (filesUrl.length > 0) {
        const fetchFileDetails = async () => {
          const fileDetails = await getFileDetails(filesUrl);
          setFiles(fileDetails);
        };
        fetchFileDetails();
      }
    }, [filesUrl]);
    const goBack = () => {
      window.history.back();
    };
    if (!item) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-[calc(100vh_-110px)] flex flex-col items-center justify-center dark:text-white text-dark-300 bg-cleanWhite dark:bg-dark-200 md:text-2xl text-base font-semibold", children: "Error fetching data" });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "h-full dark:bg-dark-200 w-[100%] p-6", children: [
      isLoading && !item && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loader-line" }),
      item && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: " flex flex-col gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: goBack, className: "text-secondary dark:text-white flex items-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "svg",
            {
              viewBox: "0 0 1024 1024",
              fill: "currentColor",
              height: "1rem",
              width: "1rem",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M793 242H366v-74c0-6.7-7.7-10.4-12.9-6.3l-142 112a8 8 0 000 12.6l142 112c5.2 4.1 12.9.4 12.9-6.3v-74h415v470H175c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h618c35.3 0 64-28.7 64-64V306c0-35.3-28.7-64-64-64z" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-semibold", children: "Go Back" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full pr-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border rounded-lg  bg-graySecondary dark:bg-dark-300 border-flatGray w-fit dark:border-gray-700 my-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Tabs,
            {
              activeTab,
              setActiveTab,
              className: "rounded-md ",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { className: "rounded-md", value: "overview", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-black dark:text-white", children: "Overview" }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { className: "rounded-md", value: "files", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-black dark:text-white", children: "Files" }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { className: "rounded-md", value: "photos", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-black dark:text-white", children: "Photos" }) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "overview" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "files" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "photos" })
              ]
            }
          ) }),
          (path === "/sites" || path === "/assets") && /* @__PURE__ */ jsxRuntimeExports.jsx(DetailsMapsCard, {}),
          path === "/jobs" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DetailsTable, { item, path }) }),
          sortItems && activeTab === "overview" && /* @__PURE__ */ jsxRuntimeExports.jsx(DetailsView, { item, sortItems }),
          activeTab === "files" ? env$1.VITE_DATA_SOURCE_SET !== true ? /* @__PURE__ */ jsxRuntimeExports.jsx(Files, { fileId: id, path }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ModuleFileTable, { files }) : null,
          activeTab === "photos" ? images.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            DetailsGallery,
            {
              images,
              setGalleryDialog
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dark:text-white h-[60vh] flex items-center justify-center", children: "No Photos Found" }) : null
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Dialog,
          {
            open: galleryDialog,
            onClose: setGalleryDialog,
            className: "w-[50%]",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: " bg-cleanWhite dark:bg-dark-100 dark:text-white rounded-md flex-col justify-start items-center gap-6 inline-flex", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-2 gap-4", children: images.map((url, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: url,
                alt: `Image ${index + 1}`,
                className: "w-full h-auto"
              },
              index
            )) }) })
          }
        )
      ] })
    ] });
  };
  const Details = () => {
    var _a2, _b2;
    const {
      objectName: path,
      object_id: objectId,
      id
    } = Route.useParams();
    const {
      breadcrumbs
    } = useBreadcrumb();
    const decodeToBase64 = (base64) => {
      const decodedStr = atob(base64);
      return decodedStr;
    };
    let breadcrumb = getParam$1("b");
    let breadcrumbItems = breadcrumb ? JSON.parse(decodeToBase64(breadcrumb)) : breadcrumbs;
    let tabName = breadcrumbItems.length > 0 ? breadcrumbItems.length > 1 ? (_a2 = breadcrumbItems[breadcrumbItems.length - 2]) == null ? void 0 : _a2.name : (_b2 = breadcrumbItems[0]) == null ? void 0 : _b2.name : "";
    const normalizedTabName = (tabName || "").toLowerCase().replace(/\s+/g, "-");
    const matchedObject = moduleIframeListOptions.find((item) => {
      return item.hubspotObjectTypeId === objectId && ((item.label || "").toLowerCase().replace(/\s+/g, "-") === normalizedTabName || (item.tabName || "").toLowerCase().replace(/\s+/g, "-") === normalizedTabName);
    }) || {};
    const propertyName = matchedObject.iframeProperties ? matchedObject.iframeProperties : [];
    const showIframe = matchedObject.showIframe || false;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-[var(--sidebar-background-color)] mt-[calc(var(--nav-height)-1px)] dark:bg-dark-300", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `bg-cleanWhite dark:bg-dark-200`, children: env$1.VITE_DATA_SOURCE_SET !== true ? /* @__PURE__ */ jsxRuntimeExports.jsx(ApiDetails, { objectId, path, id, propertyName, showIframe }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ModuleDetails, { objectId, path, id, propertyName, showIframe }) }) });
  };
  const Route = createFileRoute("/_dynamicPage/$objectName/$object_id/$id/")({
    component: Details,
    beforeLoad: () => {
      return {
        layout: "MainLayout",
        requiresAuth: true
      };
    }
  });
  const ClientSessionRoute = Route$c.update({
    id: "/client-session",
    path: "/client-session",
    getParentRoute: () => Route$d
  });
  const IndexRoute = Route$b.update({
    id: "/",
    path: "/",
    getParentRoute: () => Route$d
  });
  const DynamicPageListComponentRoute = Route$a.update({
    id: "/_dynamicPage/$listComponent",
    path: "/$listComponent",
    getParentRoute: () => Route$d
  });
  const AuthVerifyEmailRoute = Route$9.update({
    id: "/_auth/verify-email",
    path: "/verify-email",
    getParentRoute: () => Route$d
  });
  const AuthTwoFaRoute = Route$8.update({
    id: "/_auth/two-fa",
    path: "/two-fa",
    getParentRoute: () => Route$d
  });
  const AuthResetPasswordRoute = Route$7.update({
    id: "/_auth/reset-password",
    path: "/reset-password",
    getParentRoute: () => Route$d
  });
  const AuthNotVerifiedEmailRoute = Route$6.update({
    id: "/_auth/not-verified-email",
    path: "/not-verified-email",
    getParentRoute: () => Route$d
  });
  const AuthLoginRoute = Route$5.update({
    id: "/_auth/login",
    path: "/login",
    getParentRoute: () => Route$d
  });
  const AuthForgetPasswordRoute = Route$4.update({
    id: "/_auth/forget-password",
    path: "/forget-password",
    getParentRoute: () => Route$d
  });
  const AuthRegisterRoute = Route$3.update({
    id: "/_auth/Register",
    path: "/Register",
    getParentRoute: () => Route$d
  });
  const AuthProfileRoute = Route$2.update({
    id: "/_auth/Profile",
    path: "/Profile",
    getParentRoute: () => Route$d
  });
  const DynamicPageAssociationNameRoute = Route$1.update({
    id: "/_dynamicPage/association/$name",
    path: "/association/$name",
    getParentRoute: () => Route$d
  });
  const DynamicPageObjectNameObject_idIdIndexRoute = Route.update({
    id: "/_dynamicPage/$objectName/$object_id/$id/",
    path: "/$objectName/$object_id/$id/",
    getParentRoute: () => Route$d
  });
  const rootRouteChildren = {
    IndexRoute,
    ClientSessionRoute,
    AuthProfileRoute,
    AuthRegisterRoute,
    AuthForgetPasswordRoute,
    AuthLoginRoute,
    AuthNotVerifiedEmailRoute,
    AuthResetPasswordRoute,
    AuthTwoFaRoute,
    AuthVerifyEmailRoute,
    DynamicPageListComponentRoute,
    DynamicPageAssociationNameRoute,
    DynamicPageObjectNameObject_idIdIndexRoute
  };
  const routeTree = Route$d._addFileChildren(rootRouteChildren)._addFileTypes();
  const router = createRouter({
    routeTree,
    context: {
      ...getContext()
    },
    history: createHashHistory(),
    defaultPreload: "intent",
    scrollRestoration: true,
    defaultStructuralSharing: true,
    defaultPreloadStaleTime: 0
  });
  const rootElement = document.getElementById("app");
  if (rootElement && !rootElement.innerHTML) {
    const root = ReactDOM.createRoot(rootElement);
    root.render(
      /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Provider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(RouterProvider, { router }) }) })
    );
  }
})();
